var as = Object.defineProperty
var ss = (o, a, s) =>
  a in o
    ? as(o, a, { enumerable: !0, configurable: !0, writable: !0, value: s })
    : (o[a] = s)
var Wr = (o, a, s) => ss(o, typeof a != 'symbol' ? a + '' : a, s)
function _mergeNamespaces(o, a) {
  for (var s = 0; s < a.length; s++) {
    const $ = a[s]
    if (typeof $ != 'string' && !Array.isArray($)) {
      for (const j in $)
        if (j !== 'default' && !(j in o)) {
          const _e = Object.getOwnPropertyDescriptor($, j)
          _e &&
            Object.defineProperty(
              o,
              j,
              _e.get ? _e : { enumerable: !0, get: () => $[j] }
            )
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(o, Symbol.toStringTag, { value: 'Module' })
  )
}
;(function() {
  const a = document.createElement('link').relList
  if (a && a.supports && a.supports('modulepreload')) return
  for (const j of document.querySelectorAll('link[rel="modulepreload"]')) $(j)
  new MutationObserver(j => {
    for (const _e of j)
      if (_e.type === 'childList')
        for (const et of _e.addedNodes)
          et.tagName === 'LINK' && et.rel === 'modulepreload' && $(et)
  }).observe(document, { childList: !0, subtree: !0 })
  function s(j) {
    const _e = {}
    return (
      j.integrity && (_e.integrity = j.integrity),
      j.referrerPolicy && (_e.referrerPolicy = j.referrerPolicy),
      j.crossOrigin === 'use-credentials'
        ? (_e.credentials = 'include')
        : j.crossOrigin === 'anonymous'
        ? (_e.credentials = 'omit')
        : (_e.credentials = 'same-origin'),
      _e
    )
  }
  function $(j) {
    if (j.ep) return
    j.ep = !0
    const _e = s(j)
    fetch(j.href, _e)
  }
})()
var define_global_default$a = {},
  commonjsGlobal$1 =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
      ? window
      : typeof define_global_default$a < 'u'
      ? define_global_default$a
      : typeof self < 'u'
      ? self
      : {}
function getDefaultExportFromCjs(o) {
  return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, 'default')
    ? o.default
    : o
}
function getAugmentedNamespace(o) {
  if (o.__esModule) return o
  var a = o.default
  if (typeof a == 'function') {
    var s = function $() {
      return this instanceof $
        ? Reflect.construct(a, arguments, this.constructor)
        : a.apply(this, arguments)
    }
    s.prototype = a.prototype
  } else s = {}
  return (
    Object.defineProperty(s, '__esModule', { value: !0 }),
    Object.keys(o).forEach(function($) {
      var j = Object.getOwnPropertyDescriptor(o, $)
      Object.defineProperty(
        s,
        $,
        j.get
          ? j
          : {
              enumerable: !0,
              get: function() {
                return o[$]
              },
            }
      )
    }),
    s
  )
}
var jsxRuntime = { exports: {} },
  reactJsxRuntime_production_min = {}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var getOwnPropertySymbols$1 =
    Object.getOwnPropertySymbols,
  hasOwnProperty$4 = Object.prototype.hasOwnProperty,
  propIsEnumerable = Object.prototype.propertyIsEnumerable
function toObject(o) {
  if (o == null)
    throw new TypeError('Object.assign cannot be called with null or undefined')
  return Object(o)
}
function shouldUseNative() {
  try {
    if (!Object.assign) return !1
    var o = new String('abc')
    if (((o[5] = 'de'), Object.getOwnPropertyNames(o)[0] === '5')) return !1
    for (var a = {}, s = 0; s < 10; s++) a['_' + String.fromCharCode(s)] = s
    var $ = Object.getOwnPropertyNames(a).map(function(_e) {
      return a[_e]
    })
    if ($.join('') !== '0123456789') return !1
    var j = {}
    return (
      'abcdefghijklmnopqrst'.split('').forEach(function(_e) {
        j[_e] = _e
      }),
      Object.keys(Object.assign({}, j)).join('') === 'abcdefghijklmnopqrst'
    )
  } catch {
    return !1
  }
}
var objectAssign = shouldUseNative()
  ? Object.assign
  : function(o, a) {
      for (var s, $ = toObject(o), j, _e = 1; _e < arguments.length; _e++) {
        s = Object(arguments[_e])
        for (var et in s) hasOwnProperty$4.call(s, et) && ($[et] = s[et])
        if (getOwnPropertySymbols$1) {
          j = getOwnPropertySymbols$1(s)
          for (var tt = 0; tt < j.length; tt++)
            propIsEnumerable.call(s, j[tt]) && ($[j[tt]] = s[j[tt]])
        }
      }
      return $
    }
const objectAssign$1 = getDefaultExportFromCjs(objectAssign)
var react = { exports: {} },
  react_production_min = {}
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var l$4 = objectAssign,
  n$5 = 60103,
  p$5 = 60106
react_production_min.Fragment = 60107
react_production_min.StrictMode = 60108
react_production_min.Profiler = 60114
var q$5 = 60109,
  r$6 = 60110,
  t$4 = 60112
react_production_min.Suspense = 60113
var u$1 = 60115,
  v$4 = 60116
if (typeof Symbol == 'function' && Symbol.for) {
  var w$4 = Symbol.for
  ;(n$5 = w$4('react.element')),
    (p$5 = w$4('react.portal')),
    (react_production_min.Fragment = w$4('react.fragment')),
    (react_production_min.StrictMode = w$4('react.strict_mode')),
    (react_production_min.Profiler = w$4('react.profiler')),
    (q$5 = w$4('react.provider')),
    (r$6 = w$4('react.context')),
    (t$4 = w$4('react.forward_ref')),
    (react_production_min.Suspense = w$4('react.suspense')),
    (u$1 = w$4('react.memo')),
    (v$4 = w$4('react.lazy'))
}
var x$3 = typeof Symbol == 'function' && Symbol.iterator
function y$4(o) {
  return o === null || typeof o != 'object'
    ? null
    : ((o = (x$3 && o[x$3]) || o['@@iterator']),
      typeof o == 'function' ? o : null)
}
function z$3(o) {
  for (
    var a = 'https://reactjs.org/docs/error-decoder.html?invariant=' + o, s = 1;
    s < arguments.length;
    s++
  )
    a += '&args[]=' + encodeURIComponent(arguments[s])
  return (
    'Minified React error #' +
    o +
    '; visit ' +
    a +
    ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
  )
}
var A$3 = {
    isMounted: function() {
      return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {},
  },
  B$2 = {}
function C(o, a, s) {
  ;(this.props = o),
    (this.context = a),
    (this.refs = B$2),
    (this.updater = s || A$3)
}
C.prototype.isReactComponent = {}
C.prototype.setState = function(o, a) {
  if (typeof o != 'object' && typeof o != 'function' && o != null)
    throw Error(z$3(85))
  this.updater.enqueueSetState(this, o, a, 'setState')
}
C.prototype.forceUpdate = function(o) {
  this.updater.enqueueForceUpdate(this, o, 'forceUpdate')
}
function D$1() {}
D$1.prototype = C.prototype
function E$1(o, a, s) {
  ;(this.props = o),
    (this.context = a),
    (this.refs = B$2),
    (this.updater = s || A$3)
}
var F$1 = (E$1.prototype = new D$1())
F$1.constructor = E$1
l$4(F$1, C.prototype)
F$1.isPureReactComponent = !0
var G$1 = { current: null },
  H$1 = Object.prototype.hasOwnProperty,
  I$1 = { key: !0, ref: !0, __self: !0, __source: !0 }
function J(o, a, s) {
  var $,
    j = {},
    _e = null,
    et = null
  if (a != null)
    for ($ in (a.ref !== void 0 && (et = a.ref),
    a.key !== void 0 && (_e = '' + a.key),
    a))
      H$1.call(a, $) && !I$1.hasOwnProperty($) && (j[$] = a[$])
  var tt = arguments.length - 2
  if (tt === 1) j.children = s
  else if (1 < tt) {
    for (var rt = Array(tt), nt = 0; nt < tt; nt++) rt[nt] = arguments[nt + 2]
    j.children = rt
  }
  if (o && o.defaultProps)
    for ($ in ((tt = o.defaultProps), tt)) j[$] === void 0 && (j[$] = tt[$])
  return {
    $$typeof: n$5,
    type: o,
    key: _e,
    ref: et,
    props: j,
    _owner: G$1.current,
  }
}
function K(o, a) {
  return {
    $$typeof: n$5,
    type: o.type,
    key: a,
    ref: o.ref,
    props: o.props,
    _owner: o._owner,
  }
}
function L(o) {
  return typeof o == 'object' && o !== null && o.$$typeof === n$5
}
function escape(o) {
  var a = { '=': '=0', ':': '=2' }
  return (
    '$' +
    o.replace(/[=:]/g, function(s) {
      return a[s]
    })
  )
}
var M$1 = /\/+/g
function N$1(o, a) {
  return typeof o == 'object' && o !== null && o.key != null
    ? escape('' + o.key)
    : a.toString(36)
}
function O$1(o, a, s, $, j) {
  var _e = typeof o
  ;(_e === 'undefined' || _e === 'boolean') && (o = null)
  var et = !1
  if (o === null) et = !0
  else
    switch (_e) {
      case 'string':
      case 'number':
        et = !0
        break
      case 'object':
        switch (o.$$typeof) {
          case n$5:
          case p$5:
            et = !0
        }
    }
  if (et)
    return (
      (et = o),
      (j = j(et)),
      (o = $ === '' ? '.' + N$1(et, 0) : $),
      Array.isArray(j)
        ? ((s = ''),
          o != null && (s = o.replace(M$1, '$&/') + '/'),
          O$1(j, a, s, '', function(nt) {
            return nt
          }))
        : j != null &&
          (L(j) &&
            (j = K(
              j,
              s +
                (!j.key || (et && et.key === j.key)
                  ? ''
                  : ('' + j.key).replace(M$1, '$&/') + '/') +
                o
            )),
          a.push(j)),
      1
    )
  if (((et = 0), ($ = $ === '' ? '.' : $ + ':'), Array.isArray(o)))
    for (var tt = 0; tt < o.length; tt++) {
      _e = o[tt]
      var rt = $ + N$1(_e, tt)
      et += O$1(_e, a, s, rt, j)
    }
  else if (((rt = y$4(o)), typeof rt == 'function'))
    for (o = rt.call(o), tt = 0; !(_e = o.next()).done; )
      (_e = _e.value), (rt = $ + N$1(_e, tt++)), (et += O$1(_e, a, s, rt, j))
  else if (_e === 'object')
    throw ((a = '' + o),
    Error(
      z$3(
        31,
        a === '[object Object]'
          ? 'object with keys {' + Object.keys(o).join(', ') + '}'
          : a
      )
    ))
  return et
}
function P$2(o, a, s) {
  if (o == null) return o
  var $ = [],
    j = 0
  return (
    O$1(o, $, '', '', function(_e) {
      return a.call(s, _e, j++)
    }),
    $
  )
}
function Q(o) {
  if (o._status === -1) {
    var a = o._result
    ;(a = a()),
      (o._status = 0),
      (o._result = a),
      a.then(
        function(s) {
          o._status === 0 && ((s = s.default), (o._status = 1), (o._result = s))
        },
        function(s) {
          o._status === 0 && ((o._status = 2), (o._result = s))
        }
      )
  }
  if (o._status === 1) return o._result
  throw o._result
}
var R$2 = { current: null }
function S$1() {
  var o = R$2.current
  if (o === null) throw Error(z$3(321))
  return o
}
var T$1 = {
  ReactCurrentDispatcher: R$2,
  ReactCurrentBatchConfig: { transition: 0 },
  ReactCurrentOwner: G$1,
  IsSomeRendererActing: { current: !1 },
  assign: l$4,
}
react_production_min.Children = {
  map: P$2,
  forEach: function(o, a, s) {
    P$2(
      o,
      function() {
        a.apply(this, arguments)
      },
      s
    )
  },
  count: function(o) {
    var a = 0
    return (
      P$2(o, function() {
        a++
      }),
      a
    )
  },
  toArray: function(o) {
    return (
      P$2(o, function(a) {
        return a
      }) || []
    )
  },
  only: function(o) {
    if (!L(o)) throw Error(z$3(143))
    return o
  },
}
react_production_min.Component = C
react_production_min.PureComponent = E$1
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1
react_production_min.cloneElement = function(o, a, s) {
  if (o == null) throw Error(z$3(267, o))
  var $ = l$4({}, o.props),
    j = o.key,
    _e = o.ref,
    et = o._owner
  if (a != null) {
    if (
      (a.ref !== void 0 && ((_e = a.ref), (et = G$1.current)),
      a.key !== void 0 && (j = '' + a.key),
      o.type && o.type.defaultProps)
    )
      var tt = o.type.defaultProps
    for (rt in a)
      H$1.call(a, rt) &&
        !I$1.hasOwnProperty(rt) &&
        ($[rt] = a[rt] === void 0 && tt !== void 0 ? tt[rt] : a[rt])
  }
  var rt = arguments.length - 2
  if (rt === 1) $.children = s
  else if (1 < rt) {
    tt = Array(rt)
    for (var nt = 0; nt < rt; nt++) tt[nt] = arguments[nt + 2]
    $.children = tt
  }
  return { $$typeof: n$5, type: o.type, key: j, ref: _e, props: $, _owner: et }
}
react_production_min.createContext = function(o, a) {
  return (
    a === void 0 && (a = null),
    (o = {
      $$typeof: r$6,
      _calculateChangedBits: a,
      _currentValue: o,
      _currentValue2: o,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
    }),
    (o.Provider = { $$typeof: q$5, _context: o }),
    (o.Consumer = o)
  )
}
react_production_min.createElement = J
react_production_min.createFactory = function(o) {
  var a = J.bind(null, o)
  return (a.type = o), a
}
react_production_min.createRef = function() {
  return { current: null }
}
react_production_min.forwardRef = function(o) {
  return { $$typeof: t$4, render: o }
}
react_production_min.isValidElement = L
react_production_min.lazy = function(o) {
  return { $$typeof: v$4, _payload: { _status: -1, _result: o }, _init: Q }
}
react_production_min.memo = function(o, a) {
  return { $$typeof: u$1, type: o, compare: a === void 0 ? null : a }
}
react_production_min.useCallback = function(o, a) {
  return S$1().useCallback(o, a)
}
react_production_min.useContext = function(o, a) {
  return S$1().useContext(o, a)
}
react_production_min.useDebugValue = function() {}
react_production_min.useEffect = function(o, a) {
  return S$1().useEffect(o, a)
}
react_production_min.useImperativeHandle = function(o, a, s) {
  return S$1().useImperativeHandle(o, a, s)
}
react_production_min.useLayoutEffect = function(o, a) {
  return S$1().useLayoutEffect(o, a)
}
react_production_min.useMemo = function(o, a) {
  return S$1().useMemo(o, a)
}
react_production_min.useReducer = function(o, a, s) {
  return S$1().useReducer(o, a, s)
}
react_production_min.useRef = function(o) {
  return S$1().useRef(o)
}
react_production_min.useState = function(o) {
  return S$1().useState(o)
}
react_production_min.version = '17.0.2'
react.exports = react_production_min
var reactExports = react.exports
const React$5 = getDefaultExportFromCjs(reactExports),
  React$6 = _mergeNamespaces({ __proto__: null, default: React$5 }, [
    reactExports,
  ])
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var f$4 = reactExports,
  g$7 = 60103
reactJsxRuntime_production_min.Fragment = 60107
if (typeof Symbol == 'function' && Symbol.for) {
  var h$4 = Symbol.for
  ;(g$7 = h$4('react.element')),
    (reactJsxRuntime_production_min.Fragment = h$4('react.fragment'))
}
var m$5 =
    f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  n$4 = Object.prototype.hasOwnProperty,
  p$4 = { key: !0, ref: !0, __self: !0, __source: !0 }
function q$4(o, a, s) {
  var $,
    j = {},
    _e = null,
    et = null
  s !== void 0 && (_e = '' + s),
    a.key !== void 0 && (_e = '' + a.key),
    a.ref !== void 0 && (et = a.ref)
  for ($ in a) n$4.call(a, $) && !p$4.hasOwnProperty($) && (j[$] = a[$])
  if (o && o.defaultProps)
    for ($ in ((a = o.defaultProps), a)) j[$] === void 0 && (j[$] = a[$])
  return {
    $$typeof: g$7,
    type: o,
    key: _e,
    ref: et,
    props: j,
    _owner: m$5.current,
  }
}
reactJsxRuntime_production_min.jsx = q$4
reactJsxRuntime_production_min.jsxs = q$4
jsxRuntime.exports = reactJsxRuntime_production_min
var jsxRuntimeExports = jsxRuntime.exports,
  buffer$1 = {},
  base64Js = {}
base64Js.byteLength = byteLength
base64Js.toByteArray = toByteArray
base64Js.fromByteArray = fromByteArray
var lookup$1 = [],
  revLookup = [],
  Arr = typeof Uint8Array < 'u' ? Uint8Array : Array,
  code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i$3 = 0, len = code.length; i$3 < len; ++i$3)
  (lookup$1[i$3] = code[i$3]), (revLookup[code.charCodeAt(i$3)] = i$3)
revLookup[45] = 62
revLookup[95] = 63
function getLens(o) {
  var a = o.length
  if (a % 4 > 0)
    throw new Error('Invalid string. Length must be a multiple of 4')
  var s = o.indexOf('=')
  s === -1 && (s = a)
  var $ = s === a ? 0 : 4 - (s % 4)
  return [s, $]
}
function byteLength(o) {
  var a = getLens(o),
    s = a[0],
    $ = a[1]
  return ((s + $) * 3) / 4 - $
}
function _byteLength(o, a, s) {
  return ((a + s) * 3) / 4 - s
}
function toByteArray(o) {
  var a,
    s = getLens(o),
    $ = s[0],
    j = s[1],
    _e = new Arr(_byteLength(o, $, j)),
    et = 0,
    tt = j > 0 ? $ - 4 : $,
    rt
  for (rt = 0; rt < tt; rt += 4)
    (a =
      (revLookup[o.charCodeAt(rt)] << 18) |
      (revLookup[o.charCodeAt(rt + 1)] << 12) |
      (revLookup[o.charCodeAt(rt + 2)] << 6) |
      revLookup[o.charCodeAt(rt + 3)]),
      (_e[et++] = (a >> 16) & 255),
      (_e[et++] = (a >> 8) & 255),
      (_e[et++] = a & 255)
  return (
    j === 2 &&
      ((a =
        (revLookup[o.charCodeAt(rt)] << 2) |
        (revLookup[o.charCodeAt(rt + 1)] >> 4)),
      (_e[et++] = a & 255)),
    j === 1 &&
      ((a =
        (revLookup[o.charCodeAt(rt)] << 10) |
        (revLookup[o.charCodeAt(rt + 1)] << 4) |
        (revLookup[o.charCodeAt(rt + 2)] >> 2)),
      (_e[et++] = (a >> 8) & 255),
      (_e[et++] = a & 255)),
    _e
  )
}
function tripletToBase64(o) {
  return (
    lookup$1[(o >> 18) & 63] +
    lookup$1[(o >> 12) & 63] +
    lookup$1[(o >> 6) & 63] +
    lookup$1[o & 63]
  )
}
function encodeChunk(o, a, s) {
  for (var $, j = [], _e = a; _e < s; _e += 3)
    ($ =
      ((o[_e] << 16) & 16711680) +
      ((o[_e + 1] << 8) & 65280) +
      (o[_e + 2] & 255)),
      j.push(tripletToBase64($))
  return j.join('')
}
function fromByteArray(o) {
  for (
    var a, s = o.length, $ = s % 3, j = [], _e = 16383, et = 0, tt = s - $;
    et < tt;
    et += _e
  )
    j.push(encodeChunk(o, et, et + _e > tt ? tt : et + _e))
  return (
    $ === 1
      ? ((a = o[s - 1]),
        j.push(lookup$1[a >> 2] + lookup$1[(a << 4) & 63] + '=='))
      : $ === 2 &&
        ((a = (o[s - 2] << 8) + o[s - 1]),
        j.push(
          lookup$1[a >> 10] +
            lookup$1[(a >> 4) & 63] +
            lookup$1[(a << 2) & 63] +
            '='
        )),
    j.join('')
  )
}
var ieee754 = {}
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ ieee754.read = function(
  o,
  a,
  s,
  $,
  j
) {
  var _e,
    et,
    tt = j * 8 - $ - 1,
    rt = (1 << tt) - 1,
    nt = rt >> 1,
    it = -7,
    ot = s ? j - 1 : 0,
    at = s ? -1 : 1,
    st = o[a + ot]
  for (
    ot += at, _e = st & ((1 << -it) - 1), st >>= -it, it += tt;
    it > 0;
    _e = _e * 256 + o[a + ot], ot += at, it -= 8
  );
  for (
    et = _e & ((1 << -it) - 1), _e >>= -it, it += $;
    it > 0;
    et = et * 256 + o[a + ot], ot += at, it -= 8
  );
  if (_e === 0) _e = 1 - nt
  else {
    if (_e === rt) return et ? NaN : (st ? -1 : 1) * (1 / 0)
    ;(et = et + Math.pow(2, $)), (_e = _e - nt)
  }
  return (st ? -1 : 1) * et * Math.pow(2, _e - $)
}
ieee754.write = function(o, a, s, $, j, _e) {
  var et,
    tt,
    rt,
    nt = _e * 8 - j - 1,
    it = (1 << nt) - 1,
    ot = it >> 1,
    at = j === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    st = $ ? 0 : _e - 1,
    ut = $ ? 1 : -1,
    ct = a < 0 || (a === 0 && 1 / a < 0) ? 1 : 0
  for (
    a = Math.abs(a),
      isNaN(a) || a === 1 / 0
        ? ((tt = isNaN(a) ? 1 : 0), (et = it))
        : ((et = Math.floor(Math.log(a) / Math.LN2)),
          a * (rt = Math.pow(2, -et)) < 1 && (et--, (rt *= 2)),
          et + ot >= 1 ? (a += at / rt) : (a += at * Math.pow(2, 1 - ot)),
          a * rt >= 2 && (et++, (rt /= 2)),
          et + ot >= it
            ? ((tt = 0), (et = it))
            : et + ot >= 1
            ? ((tt = (a * rt - 1) * Math.pow(2, j)), (et = et + ot))
            : ((tt = a * Math.pow(2, ot - 1) * Math.pow(2, j)), (et = 0)));
    j >= 8;
    o[s + st] = tt & 255, st += ut, tt /= 256, j -= 8
  );
  for (
    et = (et << j) | tt, nt += j;
    nt > 0;
    o[s + st] = et & 255, st += ut, et /= 256, nt -= 8
  );
  o[s + st - ut] |= ct * 128
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
;(function(o) {
  const a = base64Js,
    s = ieee754,
    $ =
      typeof Symbol == 'function' && typeof Symbol.for == 'function'
        ? Symbol.for('nodejs.util.inspect.custom')
        : null
  ;(o.Buffer = tt), (o.SlowBuffer = mt), (o.INSPECT_MAX_BYTES = 50)
  const j = 2147483647
  ;(o.kMaxLength = j),
    (tt.TYPED_ARRAY_SUPPORT = _e()),
    !tt.TYPED_ARRAY_SUPPORT &&
      typeof console < 'u' &&
      typeof console.error == 'function' &&
      console.error(
        'This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
      )
  function _e() {
    try {
      const zt = new Uint8Array(1),
        bt = {
          foo: function() {
            return 42
          },
        }
      return (
        Object.setPrototypeOf(bt, Uint8Array.prototype),
        Object.setPrototypeOf(zt, bt),
        zt.foo() === 42
      )
    } catch {
      return !1
    }
  }
  Object.defineProperty(tt.prototype, 'parent', {
    enumerable: !0,
    get: function() {
      if (tt.isBuffer(this)) return this.buffer
    },
  }),
    Object.defineProperty(tt.prototype, 'offset', {
      enumerable: !0,
      get: function() {
        if (tt.isBuffer(this)) return this.byteOffset
      },
    })
  function et(zt) {
    if (zt > j)
      throw new RangeError(
        'The value "' + zt + '" is invalid for option "size"'
      )
    const bt = new Uint8Array(zt)
    return Object.setPrototypeOf(bt, tt.prototype), bt
  }
  function tt(zt, bt, Rt) {
    if (typeof zt == 'number') {
      if (typeof bt == 'string')
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        )
      return ot(zt)
    }
    return rt(zt, bt, Rt)
  }
  tt.poolSize = 8192
  function rt(zt, bt, Rt) {
    if (typeof zt == 'string') return at(zt, bt)
    if (ArrayBuffer.isView(zt)) return ut(zt)
    if (zt == null)
      throw new TypeError(
        'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
          typeof zt
      )
    if (
      nr(zt, ArrayBuffer) ||
      (zt && nr(zt.buffer, ArrayBuffer)) ||
      (typeof SharedArrayBuffer < 'u' &&
        (nr(zt, SharedArrayBuffer) || (zt && nr(zt.buffer, SharedArrayBuffer))))
    )
      return ct(zt, bt, Rt)
    if (typeof zt == 'number')
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      )
    const qt = zt.valueOf && zt.valueOf()
    if (qt != null && qt !== zt) return tt.from(qt, bt, Rt)
    const rr = dt(zt)
    if (rr) return rr
    if (
      typeof Symbol < 'u' &&
      Symbol.toPrimitive != null &&
      typeof zt[Symbol.toPrimitive] == 'function'
    )
      return tt.from(zt[Symbol.toPrimitive]('string'), bt, Rt)
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' +
        typeof zt
    )
  }
  ;(tt.from = function(zt, bt, Rt) {
    return rt(zt, bt, Rt)
  }),
    Object.setPrototypeOf(tt.prototype, Uint8Array.prototype),
    Object.setPrototypeOf(tt, Uint8Array)
  function nt(zt) {
    if (typeof zt != 'number')
      throw new TypeError('"size" argument must be of type number')
    if (zt < 0)
      throw new RangeError(
        'The value "' + zt + '" is invalid for option "size"'
      )
  }
  function it(zt, bt, Rt) {
    return (
      nt(zt),
      zt <= 0
        ? et(zt)
        : bt !== void 0
        ? typeof Rt == 'string'
          ? et(zt).fill(bt, Rt)
          : et(zt).fill(bt)
        : et(zt)
    )
  }
  tt.alloc = function(zt, bt, Rt) {
    return it(zt, bt, Rt)
  }
  function ot(zt) {
    return nt(zt), et(zt < 0 ? 0 : ft(zt) | 0)
  }
  ;(tt.allocUnsafe = function(zt) {
    return ot(zt)
  }),
    (tt.allocUnsafeSlow = function(zt) {
      return ot(zt)
    })
  function at(zt, bt) {
    if (
      ((typeof bt != 'string' || bt === '') && (bt = 'utf8'),
      !tt.isEncoding(bt))
    )
      throw new TypeError('Unknown encoding: ' + bt)
    const Rt = vt(zt, bt) | 0
    let qt = et(Rt)
    const rr = qt.write(zt, bt)
    return rr !== Rt && (qt = qt.slice(0, rr)), qt
  }
  function st(zt) {
    const bt = zt.length < 0 ? 0 : ft(zt.length) | 0,
      Rt = et(bt)
    for (let qt = 0; qt < bt; qt += 1) Rt[qt] = zt[qt] & 255
    return Rt
  }
  function ut(zt) {
    if (nr(zt, Uint8Array)) {
      const bt = new Uint8Array(zt)
      return ct(bt.buffer, bt.byteOffset, bt.byteLength)
    }
    return st(zt)
  }
  function ct(zt, bt, Rt) {
    if (bt < 0 || zt.byteLength < bt)
      throw new RangeError('"offset" is outside of buffer bounds')
    if (zt.byteLength < bt + (Rt || 0))
      throw new RangeError('"length" is outside of buffer bounds')
    let qt
    return (
      bt === void 0 && Rt === void 0
        ? (qt = new Uint8Array(zt))
        : Rt === void 0
        ? (qt = new Uint8Array(zt, bt))
        : (qt = new Uint8Array(zt, bt, Rt)),
      Object.setPrototypeOf(qt, tt.prototype),
      qt
    )
  }
  function dt(zt) {
    if (tt.isBuffer(zt)) {
      const bt = ft(zt.length) | 0,
        Rt = et(bt)
      return Rt.length === 0 || zt.copy(Rt, 0, 0, bt), Rt
    }
    if (zt.length !== void 0)
      return typeof zt.length != 'number' || fr(zt.length) ? et(0) : st(zt)
    if (zt.type === 'Buffer' && Array.isArray(zt.data)) return st(zt.data)
  }
  function ft(zt) {
    if (zt >= j)
      throw new RangeError(
        'Attempt to allocate Buffer larger than maximum size: 0x' +
          j.toString(16) +
          ' bytes'
      )
    return zt | 0
  }
  function mt(zt) {
    return +zt != zt && (zt = 0), tt.alloc(+zt)
  }
  ;(tt.isBuffer = function(bt) {
    return bt != null && bt._isBuffer === !0 && bt !== tt.prototype
  }),
    (tt.compare = function(bt, Rt) {
      if (
        (nr(bt, Uint8Array) && (bt = tt.from(bt, bt.offset, bt.byteLength)),
        nr(Rt, Uint8Array) && (Rt = tt.from(Rt, Rt.offset, Rt.byteLength)),
        !tt.isBuffer(bt) || !tt.isBuffer(Rt))
      )
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        )
      if (bt === Rt) return 0
      let qt = bt.length,
        rr = Rt.length
      for (let ar = 0, ir = Math.min(qt, rr); ar < ir; ++ar)
        if (bt[ar] !== Rt[ar]) {
          ;(qt = bt[ar]), (rr = Rt[ar])
          break
        }
      return qt < rr ? -1 : rr < qt ? 1 : 0
    }),
    (tt.isEncoding = function(bt) {
      switch (String(bt).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return !0
        default:
          return !1
      }
    }),
    (tt.concat = function(bt, Rt) {
      if (!Array.isArray(bt))
        throw new TypeError('"list" argument must be an Array of Buffers')
      if (bt.length === 0) return tt.alloc(0)
      let qt
      if (Rt === void 0)
        for (Rt = 0, qt = 0; qt < bt.length; ++qt) Rt += bt[qt].length
      const rr = tt.allocUnsafe(Rt)
      let ar = 0
      for (qt = 0; qt < bt.length; ++qt) {
        let ir = bt[qt]
        if (nr(ir, Uint8Array))
          ar + ir.length > rr.length
            ? (tt.isBuffer(ir) || (ir = tt.from(ir)), ir.copy(rr, ar))
            : Uint8Array.prototype.set.call(rr, ir, ar)
        else if (tt.isBuffer(ir)) ir.copy(rr, ar)
        else throw new TypeError('"list" argument must be an Array of Buffers')
        ar += ir.length
      }
      return rr
    })
  function vt(zt, bt) {
    if (tt.isBuffer(zt)) return zt.length
    if (ArrayBuffer.isView(zt) || nr(zt, ArrayBuffer)) return zt.byteLength
    if (typeof zt != 'string')
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' +
          typeof zt
      )
    const Rt = zt.length,
      qt = arguments.length > 2 && arguments[2] === !0
    if (!qt && Rt === 0) return 0
    let rr = !1
    for (;;)
      switch (bt) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return Rt
        case 'utf8':
        case 'utf-8':
          return mr(zt).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return Rt * 2
        case 'hex':
          return Rt >>> 1
        case 'base64':
          return _r(zt).length
        default:
          if (rr) return qt ? -1 : mr(zt).length
          ;(bt = ('' + bt).toLowerCase()), (rr = !0)
      }
  }
  tt.byteLength = vt
  function yt(zt, bt, Rt) {
    let qt = !1
    if (
      ((bt === void 0 || bt < 0) && (bt = 0),
      bt > this.length ||
        ((Rt === void 0 || Rt > this.length) && (Rt = this.length), Rt <= 0) ||
        ((Rt >>>= 0), (bt >>>= 0), Rt <= bt))
    )
      return ''
    for (zt || (zt = 'utf8'); ; )
      switch (zt) {
        case 'hex':
          return kt(this, bt, Rt)
        case 'utf8':
        case 'utf-8':
          return Bt(this, bt, Rt)
        case 'ascii':
          return Wt(this, bt, Rt)
        case 'latin1':
        case 'binary':
          return Tt(this, bt, Rt)
        case 'base64':
          return St(this, bt, Rt)
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return Ot(this, bt, Rt)
        default:
          if (qt) throw new TypeError('Unknown encoding: ' + zt)
          ;(zt = (zt + '').toLowerCase()), (qt = !0)
      }
  }
  tt.prototype._isBuffer = !0
  function pt(zt, bt, Rt) {
    const qt = zt[bt]
    ;(zt[bt] = zt[Rt]), (zt[Rt] = qt)
  }
  ;(tt.prototype.swap16 = function() {
    const bt = this.length
    if (bt % 2 !== 0)
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    for (let Rt = 0; Rt < bt; Rt += 2) pt(this, Rt, Rt + 1)
    return this
  }),
    (tt.prototype.swap32 = function() {
      const bt = this.length
      if (bt % 4 !== 0)
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      for (let Rt = 0; Rt < bt; Rt += 4)
        pt(this, Rt, Rt + 3), pt(this, Rt + 1, Rt + 2)
      return this
    }),
    (tt.prototype.swap64 = function() {
      const bt = this.length
      if (bt % 8 !== 0)
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      for (let Rt = 0; Rt < bt; Rt += 8)
        pt(this, Rt, Rt + 7),
          pt(this, Rt + 1, Rt + 6),
          pt(this, Rt + 2, Rt + 5),
          pt(this, Rt + 3, Rt + 4)
      return this
    }),
    (tt.prototype.toString = function() {
      const bt = this.length
      return bt === 0
        ? ''
        : arguments.length === 0
        ? Bt(this, 0, bt)
        : yt.apply(this, arguments)
    }),
    (tt.prototype.toLocaleString = tt.prototype.toString),
    (tt.prototype.equals = function(bt) {
      if (!tt.isBuffer(bt)) throw new TypeError('Argument must be a Buffer')
      return this === bt ? !0 : tt.compare(this, bt) === 0
    }),
    (tt.prototype.inspect = function() {
      let bt = ''
      const Rt = o.INSPECT_MAX_BYTES
      return (
        (bt = this.toString('hex', 0, Rt)
          .replace(/(.{2})/g, '$1 ')
          .trim()),
        this.length > Rt && (bt += ' ... '),
        '<Buffer ' + bt + '>'
      )
    }),
    $ && (tt.prototype[$] = tt.prototype.inspect),
    (tt.prototype.compare = function(bt, Rt, qt, rr, ar) {
      if (
        (nr(bt, Uint8Array) && (bt = tt.from(bt, bt.offset, bt.byteLength)),
        !tt.isBuffer(bt))
      )
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' +
            typeof bt
        )
      if (
        (Rt === void 0 && (Rt = 0),
        qt === void 0 && (qt = bt ? bt.length : 0),
        rr === void 0 && (rr = 0),
        ar === void 0 && (ar = this.length),
        Rt < 0 || qt > bt.length || rr < 0 || ar > this.length)
      )
        throw new RangeError('out of range index')
      if (rr >= ar && Rt >= qt) return 0
      if (rr >= ar) return -1
      if (Rt >= qt) return 1
      if (((Rt >>>= 0), (qt >>>= 0), (rr >>>= 0), (ar >>>= 0), this === bt))
        return 0
      let ir = ar - rr,
        Tr = qt - Rt
      const vr = Math.min(ir, Tr),
        Ar = this.slice(rr, ar),
        Nr = bt.slice(Rt, qt)
      for (let Or = 0; Or < vr; ++Or)
        if (Ar[Or] !== Nr[Or]) {
          ;(ir = Ar[Or]), (Tr = Nr[Or])
          break
        }
      return ir < Tr ? -1 : Tr < ir ? 1 : 0
    })
  function ht(zt, bt, Rt, qt, rr) {
    if (zt.length === 0) return -1
    if (
      (typeof Rt == 'string'
        ? ((qt = Rt), (Rt = 0))
        : Rt > 2147483647
        ? (Rt = 2147483647)
        : Rt < -2147483648 && (Rt = -2147483648),
      (Rt = +Rt),
      fr(Rt) && (Rt = rr ? 0 : zt.length - 1),
      Rt < 0 && (Rt = zt.length + Rt),
      Rt >= zt.length)
    ) {
      if (rr) return -1
      Rt = zt.length - 1
    } else if (Rt < 0)
      if (rr) Rt = 0
      else return -1
    if ((typeof bt == 'string' && (bt = tt.from(bt, qt)), tt.isBuffer(bt)))
      return bt.length === 0 ? -1 : At(zt, bt, Rt, qt, rr)
    if (typeof bt == 'number')
      return (
        (bt = bt & 255),
        typeof Uint8Array.prototype.indexOf == 'function'
          ? rr
            ? Uint8Array.prototype.indexOf.call(zt, bt, Rt)
            : Uint8Array.prototype.lastIndexOf.call(zt, bt, Rt)
          : At(zt, [bt], Rt, qt, rr)
      )
    throw new TypeError('val must be string, number or Buffer')
  }
  function At(zt, bt, Rt, qt, rr) {
    let ar = 1,
      ir = zt.length,
      Tr = bt.length
    if (
      qt !== void 0 &&
      ((qt = String(qt).toLowerCase()),
      qt === 'ucs2' || qt === 'ucs-2' || qt === 'utf16le' || qt === 'utf-16le')
    ) {
      if (zt.length < 2 || bt.length < 2) return -1
      ;(ar = 2), (ir /= 2), (Tr /= 2), (Rt /= 2)
    }
    function vr(Nr, Or) {
      return ar === 1 ? Nr[Or] : Nr.readUInt16BE(Or * ar)
    }
    let Ar
    if (rr) {
      let Nr = -1
      for (Ar = Rt; Ar < ir; Ar++)
        if (vr(zt, Ar) === vr(bt, Nr === -1 ? 0 : Ar - Nr)) {
          if ((Nr === -1 && (Nr = Ar), Ar - Nr + 1 === Tr)) return Nr * ar
        } else Nr !== -1 && (Ar -= Ar - Nr), (Nr = -1)
    } else
      for (Rt + Tr > ir && (Rt = ir - Tr), Ar = Rt; Ar >= 0; Ar--) {
        let Nr = !0
        for (let Or = 0; Or < Tr; Or++)
          if (vr(zt, Ar + Or) !== vr(bt, Or)) {
            Nr = !1
            break
          }
        if (Nr) return Ar
      }
    return -1
  }
  ;(tt.prototype.includes = function(bt, Rt, qt) {
    return this.indexOf(bt, Rt, qt) !== -1
  }),
    (tt.prototype.indexOf = function(bt, Rt, qt) {
      return ht(this, bt, Rt, qt, !0)
    }),
    (tt.prototype.lastIndexOf = function(bt, Rt, qt) {
      return ht(this, bt, Rt, qt, !1)
    })
  function wt(zt, bt, Rt, qt) {
    Rt = Number(Rt) || 0
    const rr = zt.length - Rt
    qt ? ((qt = Number(qt)), qt > rr && (qt = rr)) : (qt = rr)
    const ar = bt.length
    qt > ar / 2 && (qt = ar / 2)
    let ir
    for (ir = 0; ir < qt; ++ir) {
      const Tr = parseInt(bt.substr(ir * 2, 2), 16)
      if (fr(Tr)) return ir
      zt[Rt + ir] = Tr
    }
    return ir
  }
  function Ct(zt, bt, Rt, qt) {
    return Rr(mr(bt, zt.length - Rt), zt, Rt, qt)
  }
  function Dt(zt, bt, Rt, qt) {
    return Rr(Er(bt), zt, Rt, qt)
  }
  function jt(zt, bt, Rt, qt) {
    return Rr(_r(bt), zt, Rt, qt)
  }
  function Et(zt, bt, Rt, qt) {
    return Rr(ur(bt, zt.length - Rt), zt, Rt, qt)
  }
  ;(tt.prototype.write = function(bt, Rt, qt, rr) {
    if (Rt === void 0) (rr = 'utf8'), (qt = this.length), (Rt = 0)
    else if (qt === void 0 && typeof Rt == 'string')
      (rr = Rt), (qt = this.length), (Rt = 0)
    else if (isFinite(Rt))
      (Rt = Rt >>> 0),
        isFinite(qt)
          ? ((qt = qt >>> 0), rr === void 0 && (rr = 'utf8'))
          : ((rr = qt), (qt = void 0))
    else
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    const ar = this.length - Rt
    if (
      ((qt === void 0 || qt > ar) && (qt = ar),
      (bt.length > 0 && (qt < 0 || Rt < 0)) || Rt > this.length)
    )
      throw new RangeError('Attempt to write outside buffer bounds')
    rr || (rr = 'utf8')
    let ir = !1
    for (;;)
      switch (rr) {
        case 'hex':
          return wt(this, bt, Rt, qt)
        case 'utf8':
        case 'utf-8':
          return Ct(this, bt, Rt, qt)
        case 'ascii':
        case 'latin1':
        case 'binary':
          return Dt(this, bt, Rt, qt)
        case 'base64':
          return jt(this, bt, Rt, qt)
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return Et(this, bt, Rt, qt)
        default:
          if (ir) throw new TypeError('Unknown encoding: ' + rr)
          ;(rr = ('' + rr).toLowerCase()), (ir = !0)
      }
  }),
    (tt.prototype.toJSON = function() {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0),
      }
    })
  function St(zt, bt, Rt) {
    return bt === 0 && Rt === zt.length
      ? a.fromByteArray(zt)
      : a.fromByteArray(zt.slice(bt, Rt))
  }
  function Bt(zt, bt, Rt) {
    Rt = Math.min(zt.length, Rt)
    const qt = []
    let rr = bt
    for (; rr < Rt; ) {
      const ar = zt[rr]
      let ir = null,
        Tr = ar > 239 ? 4 : ar > 223 ? 3 : ar > 191 ? 2 : 1
      if (rr + Tr <= Rt) {
        let vr, Ar, Nr, Or
        switch (Tr) {
          case 1:
            ar < 128 && (ir = ar)
            break
          case 2:
            ;(vr = zt[rr + 1]),
              (vr & 192) === 128 &&
                ((Or = ((ar & 31) << 6) | (vr & 63)), Or > 127 && (ir = Or))
            break
          case 3:
            ;(vr = zt[rr + 1]),
              (Ar = zt[rr + 2]),
              (vr & 192) === 128 &&
                (Ar & 192) === 128 &&
                ((Or = ((ar & 15) << 12) | ((vr & 63) << 6) | (Ar & 63)),
                Or > 2047 && (Or < 55296 || Or > 57343) && (ir = Or))
            break
          case 4:
            ;(vr = zt[rr + 1]),
              (Ar = zt[rr + 2]),
              (Nr = zt[rr + 3]),
              (vr & 192) === 128 &&
                (Ar & 192) === 128 &&
                (Nr & 192) === 128 &&
                ((Or =
                  ((ar & 15) << 18) |
                  ((vr & 63) << 12) |
                  ((Ar & 63) << 6) |
                  (Nr & 63)),
                Or > 65535 && Or < 1114112 && (ir = Or))
        }
      }
      ir === null
        ? ((ir = 65533), (Tr = 1))
        : ir > 65535 &&
          ((ir -= 65536),
          qt.push(((ir >>> 10) & 1023) | 55296),
          (ir = 56320 | (ir & 1023))),
        qt.push(ir),
        (rr += Tr)
    }
    return Ut(qt)
  }
  const Mt = 4096
  function Ut(zt) {
    const bt = zt.length
    if (bt <= Mt) return String.fromCharCode.apply(String, zt)
    let Rt = '',
      qt = 0
    for (; qt < bt; )
      Rt += String.fromCharCode.apply(String, zt.slice(qt, (qt += Mt)))
    return Rt
  }
  function Wt(zt, bt, Rt) {
    let qt = ''
    Rt = Math.min(zt.length, Rt)
    for (let rr = bt; rr < Rt; ++rr) qt += String.fromCharCode(zt[rr] & 127)
    return qt
  }
  function Tt(zt, bt, Rt) {
    let qt = ''
    Rt = Math.min(zt.length, Rt)
    for (let rr = bt; rr < Rt; ++rr) qt += String.fromCharCode(zt[rr])
    return qt
  }
  function kt(zt, bt, Rt) {
    const qt = zt.length
    ;(!bt || bt < 0) && (bt = 0), (!Rt || Rt < 0 || Rt > qt) && (Rt = qt)
    let rr = ''
    for (let ar = bt; ar < Rt; ++ar) rr += gr[zt[ar]]
    return rr
  }
  function Ot(zt, bt, Rt) {
    const qt = zt.slice(bt, Rt)
    let rr = ''
    for (let ar = 0; ar < qt.length - 1; ar += 2)
      rr += String.fromCharCode(qt[ar] + qt[ar + 1] * 256)
    return rr
  }
  tt.prototype.slice = function(bt, Rt) {
    const qt = this.length
    ;(bt = ~~bt),
      (Rt = Rt === void 0 ? qt : ~~Rt),
      bt < 0 ? ((bt += qt), bt < 0 && (bt = 0)) : bt > qt && (bt = qt),
      Rt < 0 ? ((Rt += qt), Rt < 0 && (Rt = 0)) : Rt > qt && (Rt = qt),
      Rt < bt && (Rt = bt)
    const rr = this.subarray(bt, Rt)
    return Object.setPrototypeOf(rr, tt.prototype), rr
  }
  function Nt(zt, bt, Rt) {
    if (zt % 1 !== 0 || zt < 0) throw new RangeError('offset is not uint')
    if (zt + bt > Rt)
      throw new RangeError('Trying to access beyond buffer length')
  }
  ;(tt.prototype.readUintLE = tt.prototype.readUIntLE = function(bt, Rt, qt) {
    ;(bt = bt >>> 0), (Rt = Rt >>> 0), qt || Nt(bt, Rt, this.length)
    let rr = this[bt],
      ar = 1,
      ir = 0
    for (; ++ir < Rt && (ar *= 256); ) rr += this[bt + ir] * ar
    return rr
  }),
    (tt.prototype.readUintBE = tt.prototype.readUIntBE = function(bt, Rt, qt) {
      ;(bt = bt >>> 0), (Rt = Rt >>> 0), qt || Nt(bt, Rt, this.length)
      let rr = this[bt + --Rt],
        ar = 1
      for (; Rt > 0 && (ar *= 256); ) rr += this[bt + --Rt] * ar
      return rr
    }),
    (tt.prototype.readUint8 = tt.prototype.readUInt8 = function(bt, Rt) {
      return (bt = bt >>> 0), Rt || Nt(bt, 1, this.length), this[bt]
    }),
    (tt.prototype.readUint16LE = tt.prototype.readUInt16LE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 2, this.length),
        this[bt] | (this[bt + 1] << 8)
      )
    }),
    (tt.prototype.readUint16BE = tt.prototype.readUInt16BE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 2, this.length),
        (this[bt] << 8) | this[bt + 1]
      )
    }),
    (tt.prototype.readUint32LE = tt.prototype.readUInt32LE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 4, this.length),
        (this[bt] | (this[bt + 1] << 8) | (this[bt + 2] << 16)) +
          this[bt + 3] * 16777216
      )
    }),
    (tt.prototype.readUint32BE = tt.prototype.readUInt32BE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 4, this.length),
        this[bt] * 16777216 +
          ((this[bt + 1] << 16) | (this[bt + 2] << 8) | this[bt + 3])
      )
    }),
    (tt.prototype.readBigUInt64LE = br(function(bt) {
      ;(bt = bt >>> 0), Lt(bt, 'offset')
      const Rt = this[bt],
        qt = this[bt + 7]
      ;(Rt === void 0 || qt === void 0) && tr(bt, this.length - 8)
      const rr =
          Rt +
          this[++bt] * 2 ** 8 +
          this[++bt] * 2 ** 16 +
          this[++bt] * 2 ** 24,
        ar =
          this[++bt] + this[++bt] * 2 ** 8 + this[++bt] * 2 ** 16 + qt * 2 ** 24
      return BigInt(rr) + (BigInt(ar) << BigInt(32))
    })),
    (tt.prototype.readBigUInt64BE = br(function(bt) {
      ;(bt = bt >>> 0), Lt(bt, 'offset')
      const Rt = this[bt],
        qt = this[bt + 7]
      ;(Rt === void 0 || qt === void 0) && tr(bt, this.length - 8)
      const rr =
          Rt * 2 ** 24 +
          this[++bt] * 2 ** 16 +
          this[++bt] * 2 ** 8 +
          this[++bt],
        ar =
          this[++bt] * 2 ** 24 + this[++bt] * 2 ** 16 + this[++bt] * 2 ** 8 + qt
      return (BigInt(rr) << BigInt(32)) + BigInt(ar)
    })),
    (tt.prototype.readIntLE = function(bt, Rt, qt) {
      ;(bt = bt >>> 0), (Rt = Rt >>> 0), qt || Nt(bt, Rt, this.length)
      let rr = this[bt],
        ar = 1,
        ir = 0
      for (; ++ir < Rt && (ar *= 256); ) rr += this[bt + ir] * ar
      return (ar *= 128), rr >= ar && (rr -= Math.pow(2, 8 * Rt)), rr
    }),
    (tt.prototype.readIntBE = function(bt, Rt, qt) {
      ;(bt = bt >>> 0), (Rt = Rt >>> 0), qt || Nt(bt, Rt, this.length)
      let rr = Rt,
        ar = 1,
        ir = this[bt + --rr]
      for (; rr > 0 && (ar *= 256); ) ir += this[bt + --rr] * ar
      return (ar *= 128), ir >= ar && (ir -= Math.pow(2, 8 * Rt)), ir
    }),
    (tt.prototype.readInt8 = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 1, this.length),
        this[bt] & 128 ? (255 - this[bt] + 1) * -1 : this[bt]
      )
    }),
    (tt.prototype.readInt16LE = function(bt, Rt) {
      ;(bt = bt >>> 0), Rt || Nt(bt, 2, this.length)
      const qt = this[bt] | (this[bt + 1] << 8)
      return qt & 32768 ? qt | 4294901760 : qt
    }),
    (tt.prototype.readInt16BE = function(bt, Rt) {
      ;(bt = bt >>> 0), Rt || Nt(bt, 2, this.length)
      const qt = this[bt + 1] | (this[bt] << 8)
      return qt & 32768 ? qt | 4294901760 : qt
    }),
    (tt.prototype.readInt32LE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 4, this.length),
        this[bt] |
          (this[bt + 1] << 8) |
          (this[bt + 2] << 16) |
          (this[bt + 3] << 24)
      )
    }),
    (tt.prototype.readInt32BE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 4, this.length),
        (this[bt] << 24) |
          (this[bt + 1] << 16) |
          (this[bt + 2] << 8) |
          this[bt + 3]
      )
    }),
    (tt.prototype.readBigInt64LE = br(function(bt) {
      ;(bt = bt >>> 0), Lt(bt, 'offset')
      const Rt = this[bt],
        qt = this[bt + 7]
      ;(Rt === void 0 || qt === void 0) && tr(bt, this.length - 8)
      const rr =
        this[bt + 4] +
        this[bt + 5] * 2 ** 8 +
        this[bt + 6] * 2 ** 16 +
        (qt << 24)
      return (
        (BigInt(rr) << BigInt(32)) +
        BigInt(
          Rt + this[++bt] * 2 ** 8 + this[++bt] * 2 ** 16 + this[++bt] * 2 ** 24
        )
      )
    })),
    (tt.prototype.readBigInt64BE = br(function(bt) {
      ;(bt = bt >>> 0), Lt(bt, 'offset')
      const Rt = this[bt],
        qt = this[bt + 7]
      ;(Rt === void 0 || qt === void 0) && tr(bt, this.length - 8)
      const rr =
        (Rt << 24) + this[++bt] * 2 ** 16 + this[++bt] * 2 ** 8 + this[++bt]
      return (
        (BigInt(rr) << BigInt(32)) +
        BigInt(
          this[++bt] * 2 ** 24 + this[++bt] * 2 ** 16 + this[++bt] * 2 ** 8 + qt
        )
      )
    })),
    (tt.prototype.readFloatLE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 4, this.length),
        s.read(this, bt, !0, 23, 4)
      )
    }),
    (tt.prototype.readFloatBE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 4, this.length),
        s.read(this, bt, !1, 23, 4)
      )
    }),
    (tt.prototype.readDoubleLE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 8, this.length),
        s.read(this, bt, !0, 52, 8)
      )
    }),
    (tt.prototype.readDoubleBE = function(bt, Rt) {
      return (
        (bt = bt >>> 0),
        Rt || Nt(bt, 8, this.length),
        s.read(this, bt, !1, 52, 8)
      )
    })
  function $t(zt, bt, Rt, qt, rr, ar) {
    if (!tt.isBuffer(zt))
      throw new TypeError('"buffer" argument must be a Buffer instance')
    if (bt > rr || bt < ar)
      throw new RangeError('"value" argument is out of bounds')
    if (Rt + qt > zt.length) throw new RangeError('Index out of range')
  }
  ;(tt.prototype.writeUintLE = tt.prototype.writeUIntLE = function(
    bt,
    Rt,
    qt,
    rr
  ) {
    if (((bt = +bt), (Rt = Rt >>> 0), (qt = qt >>> 0), !rr)) {
      const Tr = Math.pow(2, 8 * qt) - 1
      $t(this, bt, Rt, qt, Tr, 0)
    }
    let ar = 1,
      ir = 0
    for (this[Rt] = bt & 255; ++ir < qt && (ar *= 256); )
      this[Rt + ir] = (bt / ar) & 255
    return Rt + qt
  }),
    (tt.prototype.writeUintBE = tt.prototype.writeUIntBE = function(
      bt,
      Rt,
      qt,
      rr
    ) {
      if (((bt = +bt), (Rt = Rt >>> 0), (qt = qt >>> 0), !rr)) {
        const Tr = Math.pow(2, 8 * qt) - 1
        $t(this, bt, Rt, qt, Tr, 0)
      }
      let ar = qt - 1,
        ir = 1
      for (this[Rt + ar] = bt & 255; --ar >= 0 && (ir *= 256); )
        this[Rt + ar] = (bt / ir) & 255
      return Rt + qt
    }),
    (tt.prototype.writeUint8 = tt.prototype.writeUInt8 = function(bt, Rt, qt) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 1, 255, 0),
        (this[Rt] = bt & 255),
        Rt + 1
      )
    }),
    (tt.prototype.writeUint16LE = tt.prototype.writeUInt16LE = function(
      bt,
      Rt,
      qt
    ) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 2, 65535, 0),
        (this[Rt] = bt & 255),
        (this[Rt + 1] = bt >>> 8),
        Rt + 2
      )
    }),
    (tt.prototype.writeUint16BE = tt.prototype.writeUInt16BE = function(
      bt,
      Rt,
      qt
    ) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 2, 65535, 0),
        (this[Rt] = bt >>> 8),
        (this[Rt + 1] = bt & 255),
        Rt + 2
      )
    }),
    (tt.prototype.writeUint32LE = tt.prototype.writeUInt32LE = function(
      bt,
      Rt,
      qt
    ) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 4, 4294967295, 0),
        (this[Rt + 3] = bt >>> 24),
        (this[Rt + 2] = bt >>> 16),
        (this[Rt + 1] = bt >>> 8),
        (this[Rt] = bt & 255),
        Rt + 4
      )
    }),
    (tt.prototype.writeUint32BE = tt.prototype.writeUInt32BE = function(
      bt,
      Rt,
      qt
    ) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 4, 4294967295, 0),
        (this[Rt] = bt >>> 24),
        (this[Rt + 1] = bt >>> 16),
        (this[Rt + 2] = bt >>> 8),
        (this[Rt + 3] = bt & 255),
        Rt + 4
      )
    })
  function Pt(zt, bt, Rt, qt, rr) {
    Ht(bt, qt, rr, zt, Rt, 7)
    let ar = Number(bt & BigInt(4294967295))
    ;(zt[Rt++] = ar),
      (ar = ar >> 8),
      (zt[Rt++] = ar),
      (ar = ar >> 8),
      (zt[Rt++] = ar),
      (ar = ar >> 8),
      (zt[Rt++] = ar)
    let ir = Number((bt >> BigInt(32)) & BigInt(4294967295))
    return (
      (zt[Rt++] = ir),
      (ir = ir >> 8),
      (zt[Rt++] = ir),
      (ir = ir >> 8),
      (zt[Rt++] = ir),
      (ir = ir >> 8),
      (zt[Rt++] = ir),
      Rt
    )
  }
  function Ft(zt, bt, Rt, qt, rr) {
    Ht(bt, qt, rr, zt, Rt, 7)
    let ar = Number(bt & BigInt(4294967295))
    ;(zt[Rt + 7] = ar),
      (ar = ar >> 8),
      (zt[Rt + 6] = ar),
      (ar = ar >> 8),
      (zt[Rt + 5] = ar),
      (ar = ar >> 8),
      (zt[Rt + 4] = ar)
    let ir = Number((bt >> BigInt(32)) & BigInt(4294967295))
    return (
      (zt[Rt + 3] = ir),
      (ir = ir >> 8),
      (zt[Rt + 2] = ir),
      (ir = ir >> 8),
      (zt[Rt + 1] = ir),
      (ir = ir >> 8),
      (zt[Rt] = ir),
      Rt + 8
    )
  }
  ;(tt.prototype.writeBigUInt64LE = br(function(bt, Rt = 0) {
    return Pt(this, bt, Rt, BigInt(0), BigInt('0xffffffffffffffff'))
  })),
    (tt.prototype.writeBigUInt64BE = br(function(bt, Rt = 0) {
      return Ft(this, bt, Rt, BigInt(0), BigInt('0xffffffffffffffff'))
    })),
    (tt.prototype.writeIntLE = function(bt, Rt, qt, rr) {
      if (((bt = +bt), (Rt = Rt >>> 0), !rr)) {
        const vr = Math.pow(2, 8 * qt - 1)
        $t(this, bt, Rt, qt, vr - 1, -vr)
      }
      let ar = 0,
        ir = 1,
        Tr = 0
      for (this[Rt] = bt & 255; ++ar < qt && (ir *= 256); )
        bt < 0 && Tr === 0 && this[Rt + ar - 1] !== 0 && (Tr = 1),
          (this[Rt + ar] = (((bt / ir) >> 0) - Tr) & 255)
      return Rt + qt
    }),
    (tt.prototype.writeIntBE = function(bt, Rt, qt, rr) {
      if (((bt = +bt), (Rt = Rt >>> 0), !rr)) {
        const vr = Math.pow(2, 8 * qt - 1)
        $t(this, bt, Rt, qt, vr - 1, -vr)
      }
      let ar = qt - 1,
        ir = 1,
        Tr = 0
      for (this[Rt + ar] = bt & 255; --ar >= 0 && (ir *= 256); )
        bt < 0 && Tr === 0 && this[Rt + ar + 1] !== 0 && (Tr = 1),
          (this[Rt + ar] = (((bt / ir) >> 0) - Tr) & 255)
      return Rt + qt
    }),
    (tt.prototype.writeInt8 = function(bt, Rt, qt) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 1, 127, -128),
        bt < 0 && (bt = 255 + bt + 1),
        (this[Rt] = bt & 255),
        Rt + 1
      )
    }),
    (tt.prototype.writeInt16LE = function(bt, Rt, qt) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 2, 32767, -32768),
        (this[Rt] = bt & 255),
        (this[Rt + 1] = bt >>> 8),
        Rt + 2
      )
    }),
    (tt.prototype.writeInt16BE = function(bt, Rt, qt) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 2, 32767, -32768),
        (this[Rt] = bt >>> 8),
        (this[Rt + 1] = bt & 255),
        Rt + 2
      )
    }),
    (tt.prototype.writeInt32LE = function(bt, Rt, qt) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 4, 2147483647, -2147483648),
        (this[Rt] = bt & 255),
        (this[Rt + 1] = bt >>> 8),
        (this[Rt + 2] = bt >>> 16),
        (this[Rt + 3] = bt >>> 24),
        Rt + 4
      )
    }),
    (tt.prototype.writeInt32BE = function(bt, Rt, qt) {
      return (
        (bt = +bt),
        (Rt = Rt >>> 0),
        qt || $t(this, bt, Rt, 4, 2147483647, -2147483648),
        bt < 0 && (bt = 4294967295 + bt + 1),
        (this[Rt] = bt >>> 24),
        (this[Rt + 1] = bt >>> 16),
        (this[Rt + 2] = bt >>> 8),
        (this[Rt + 3] = bt & 255),
        Rt + 4
      )
    }),
    (tt.prototype.writeBigInt64LE = br(function(bt, Rt = 0) {
      return Pt(
        this,
        bt,
        Rt,
        -BigInt('0x8000000000000000'),
        BigInt('0x7fffffffffffffff')
      )
    })),
    (tt.prototype.writeBigInt64BE = br(function(bt, Rt = 0) {
      return Ft(
        this,
        bt,
        Rt,
        -BigInt('0x8000000000000000'),
        BigInt('0x7fffffffffffffff')
      )
    }))
  function Vt(zt, bt, Rt, qt, rr, ar) {
    if (Rt + qt > zt.length) throw new RangeError('Index out of range')
    if (Rt < 0) throw new RangeError('Index out of range')
  }
  function Xt(zt, bt, Rt, qt, rr) {
    return (
      (bt = +bt),
      (Rt = Rt >>> 0),
      rr || Vt(zt, bt, Rt, 4),
      s.write(zt, bt, Rt, qt, 23, 4),
      Rt + 4
    )
  }
  ;(tt.prototype.writeFloatLE = function(bt, Rt, qt) {
    return Xt(this, bt, Rt, !0, qt)
  }),
    (tt.prototype.writeFloatBE = function(bt, Rt, qt) {
      return Xt(this, bt, Rt, !1, qt)
    })
  function Yt(zt, bt, Rt, qt, rr) {
    return (
      (bt = +bt),
      (Rt = Rt >>> 0),
      rr || Vt(zt, bt, Rt, 8),
      s.write(zt, bt, Rt, qt, 52, 8),
      Rt + 8
    )
  }
  ;(tt.prototype.writeDoubleLE = function(bt, Rt, qt) {
    return Yt(this, bt, Rt, !0, qt)
  }),
    (tt.prototype.writeDoubleBE = function(bt, Rt, qt) {
      return Yt(this, bt, Rt, !1, qt)
    }),
    (tt.prototype.copy = function(bt, Rt, qt, rr) {
      if (!tt.isBuffer(bt)) throw new TypeError('argument should be a Buffer')
      if (
        (qt || (qt = 0),
        !rr && rr !== 0 && (rr = this.length),
        Rt >= bt.length && (Rt = bt.length),
        Rt || (Rt = 0),
        rr > 0 && rr < qt && (rr = qt),
        rr === qt || bt.length === 0 || this.length === 0)
      )
        return 0
      if (Rt < 0) throw new RangeError('targetStart out of bounds')
      if (qt < 0 || qt >= this.length)
        throw new RangeError('Index out of range')
      if (rr < 0) throw new RangeError('sourceEnd out of bounds')
      rr > this.length && (rr = this.length),
        bt.length - Rt < rr - qt && (rr = bt.length - Rt + qt)
      const ar = rr - qt
      return (
        this === bt && typeof Uint8Array.prototype.copyWithin == 'function'
          ? this.copyWithin(Rt, qt, rr)
          : Uint8Array.prototype.set.call(bt, this.subarray(qt, rr), Rt),
        ar
      )
    }),
    (tt.prototype.fill = function(bt, Rt, qt, rr) {
      if (typeof bt == 'string') {
        if (
          (typeof Rt == 'string'
            ? ((rr = Rt), (Rt = 0), (qt = this.length))
            : typeof qt == 'string' && ((rr = qt), (qt = this.length)),
          rr !== void 0 && typeof rr != 'string')
        )
          throw new TypeError('encoding must be a string')
        if (typeof rr == 'string' && !tt.isEncoding(rr))
          throw new TypeError('Unknown encoding: ' + rr)
        if (bt.length === 1) {
          const ir = bt.charCodeAt(0)
          ;((rr === 'utf8' && ir < 128) || rr === 'latin1') && (bt = ir)
        }
      } else
        typeof bt == 'number'
          ? (bt = bt & 255)
          : typeof bt == 'boolean' && (bt = Number(bt))
      if (Rt < 0 || this.length < Rt || this.length < qt)
        throw new RangeError('Out of range index')
      if (qt <= Rt) return this
      ;(Rt = Rt >>> 0),
        (qt = qt === void 0 ? this.length : qt >>> 0),
        bt || (bt = 0)
      let ar
      if (typeof bt == 'number') for (ar = Rt; ar < qt; ++ar) this[ar] = bt
      else {
        const ir = tt.isBuffer(bt) ? bt : tt.from(bt, rr),
          Tr = ir.length
        if (Tr === 0)
          throw new TypeError(
            'The value "' + bt + '" is invalid for argument "value"'
          )
        for (ar = 0; ar < qt - Rt; ++ar) this[ar + Rt] = ir[ar % Tr]
      }
      return this
    })
  const xt = {}
  function It(zt, bt, Rt) {
    xt[zt] = class extends Rt {
      constructor() {
        super(),
          Object.defineProperty(this, 'message', {
            value: bt.apply(this, arguments),
            writable: !0,
            configurable: !0,
          }),
          (this.name = `${this.name} [${zt}]`),
          this.stack,
          delete this.name
      }
      get code() {
        return zt
      }
      set code(rr) {
        Object.defineProperty(this, 'code', {
          configurable: !0,
          enumerable: !0,
          value: rr,
          writable: !0,
        })
      }
      toString() {
        return `${this.name} [${zt}]: ${this.message}`
      }
    }
  }
  It(
    'ERR_BUFFER_OUT_OF_BOUNDS',
    function(zt) {
      return zt
        ? `${zt} is outside of buffer bounds`
        : 'Attempt to access memory outside buffer bounds'
    },
    RangeError
  ),
    It(
      'ERR_INVALID_ARG_TYPE',
      function(zt, bt) {
        return `The "${zt}" argument must be of type number. Received type ${typeof bt}`
      },
      TypeError
    ),
    It(
      'ERR_OUT_OF_RANGE',
      function(zt, bt, Rt) {
        let qt = `The value of "${zt}" is out of range.`,
          rr = Rt
        return (
          Number.isInteger(Rt) && Math.abs(Rt) > 2 ** 32
            ? (rr = Kt(String(Rt)))
            : typeof Rt == 'bigint' &&
              ((rr = String(Rt)),
              (Rt > BigInt(2) ** BigInt(32) ||
                Rt < -(BigInt(2) ** BigInt(32))) &&
                (rr = Kt(rr)),
              (rr += 'n')),
          (qt += ` It must be ${bt}. Received ${rr}`),
          qt
        )
      },
      RangeError
    )
  function Kt(zt) {
    let bt = '',
      Rt = zt.length
    const qt = zt[0] === '-' ? 1 : 0
    for (; Rt >= qt + 4; Rt -= 3) bt = `_${zt.slice(Rt - 3, Rt)}${bt}`
    return `${zt.slice(0, Rt)}${bt}`
  }
  function Qt(zt, bt, Rt) {
    Lt(bt, 'offset'),
      (zt[bt] === void 0 || zt[bt + Rt] === void 0) &&
        tr(bt, zt.length - (Rt + 1))
  }
  function Ht(zt, bt, Rt, qt, rr, ar) {
    if (zt > Rt || zt < bt) {
      const ir = typeof bt == 'bigint' ? 'n' : ''
      let Tr
      throw (bt === 0 || bt === BigInt(0)
        ? (Tr = `>= 0${ir} and < 2${ir} ** ${(ar + 1) * 8}${ir}`)
        : (Tr = `>= -(2${ir} ** ${(ar + 1) * 8 - 1}${ir}) and < 2 ** ${(ar +
            1) *
            8 -
            1}${ir}`),
      new xt.ERR_OUT_OF_RANGE('value', Tr, zt))
    }
    Qt(qt, rr, ar)
  }
  function Lt(zt, bt) {
    if (typeof zt != 'number')
      throw new xt.ERR_INVALID_ARG_TYPE(bt, 'number', zt)
  }
  function tr(zt, bt, Rt) {
    throw Math.floor(zt) !== zt
      ? (Lt(zt, Rt), new xt.ERR_OUT_OF_RANGE('offset', 'an integer', zt))
      : bt < 0
      ? new xt.ERR_BUFFER_OUT_OF_BOUNDS()
      : new xt.ERR_OUT_OF_RANGE('offset', `>= 0 and <= ${bt}`, zt)
  }
  const lr = /[^+/0-9A-Za-z-_]/g
  function yr(zt) {
    if (
      ((zt = zt.split('=')[0]), (zt = zt.trim().replace(lr, '')), zt.length < 2)
    )
      return ''
    for (; zt.length % 4 !== 0; ) zt = zt + '='
    return zt
  }
  function mr(zt, bt) {
    bt = bt || 1 / 0
    let Rt
    const qt = zt.length
    let rr = null
    const ar = []
    for (let ir = 0; ir < qt; ++ir) {
      if (((Rt = zt.charCodeAt(ir)), Rt > 55295 && Rt < 57344)) {
        if (!rr) {
          if (Rt > 56319) {
            ;(bt -= 3) > -1 && ar.push(239, 191, 189)
            continue
          } else if (ir + 1 === qt) {
            ;(bt -= 3) > -1 && ar.push(239, 191, 189)
            continue
          }
          rr = Rt
          continue
        }
        if (Rt < 56320) {
          ;(bt -= 3) > -1 && ar.push(239, 191, 189), (rr = Rt)
          continue
        }
        Rt = (((rr - 55296) << 10) | (Rt - 56320)) + 65536
      } else rr && (bt -= 3) > -1 && ar.push(239, 191, 189)
      if (((rr = null), Rt < 128)) {
        if ((bt -= 1) < 0) break
        ar.push(Rt)
      } else if (Rt < 2048) {
        if ((bt -= 2) < 0) break
        ar.push((Rt >> 6) | 192, (Rt & 63) | 128)
      } else if (Rt < 65536) {
        if ((bt -= 3) < 0) break
        ar.push((Rt >> 12) | 224, ((Rt >> 6) & 63) | 128, (Rt & 63) | 128)
      } else if (Rt < 1114112) {
        if ((bt -= 4) < 0) break
        ar.push(
          (Rt >> 18) | 240,
          ((Rt >> 12) & 63) | 128,
          ((Rt >> 6) & 63) | 128,
          (Rt & 63) | 128
        )
      } else throw new Error('Invalid code point')
    }
    return ar
  }
  function Er(zt) {
    const bt = []
    for (let Rt = 0; Rt < zt.length; ++Rt) bt.push(zt.charCodeAt(Rt) & 255)
    return bt
  }
  function ur(zt, bt) {
    let Rt, qt, rr
    const ar = []
    for (let ir = 0; ir < zt.length && !((bt -= 2) < 0); ++ir)
      (Rt = zt.charCodeAt(ir)),
        (qt = Rt >> 8),
        (rr = Rt % 256),
        ar.push(rr),
        ar.push(qt)
    return ar
  }
  function _r(zt) {
    return a.toByteArray(yr(zt))
  }
  function Rr(zt, bt, Rt, qt) {
    let rr
    for (rr = 0; rr < qt && !(rr + Rt >= bt.length || rr >= zt.length); ++rr)
      bt[rr + Rt] = zt[rr]
    return rr
  }
  function nr(zt, bt) {
    return (
      zt instanceof bt ||
      (zt != null &&
        zt.constructor != null &&
        zt.constructor.name != null &&
        zt.constructor.name === bt.name)
    )
  }
  function fr(zt) {
    return zt !== zt
  }
  const gr = (function() {
    const zt = '0123456789abcdef',
      bt = new Array(256)
    for (let Rt = 0; Rt < 16; ++Rt) {
      const qt = Rt * 16
      for (let rr = 0; rr < 16; ++rr) bt[qt + rr] = zt[Rt] + zt[rr]
    }
    return bt
  })()
  function br(zt) {
    return typeof BigInt > 'u' ? Sr : zt
  }
  function Sr() {
    throw new Error('BigInt not supported')
  }
})(buffer$1)
var browser$3 = { exports: {} },
  process$1 = (browser$3.exports = {}),
  cachedSetTimeout,
  cachedClearTimeout
function defaultSetTimout() {
  throw new Error('setTimeout has not been defined')
}
function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined')
}
;(function() {
  try {
    typeof setTimeout == 'function'
      ? (cachedSetTimeout = setTimeout)
      : (cachedSetTimeout = defaultSetTimout)
  } catch {
    cachedSetTimeout = defaultSetTimout
  }
  try {
    typeof clearTimeout == 'function'
      ? (cachedClearTimeout = clearTimeout)
      : (cachedClearTimeout = defaultClearTimeout)
  } catch {
    cachedClearTimeout = defaultClearTimeout
  }
})()
function runTimeout(o) {
  if (cachedSetTimeout === setTimeout) return setTimeout(o, 0)
  if (
    (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
    setTimeout
  )
    return (cachedSetTimeout = setTimeout), setTimeout(o, 0)
  try {
    return cachedSetTimeout(o, 0)
  } catch {
    try {
      return cachedSetTimeout.call(null, o, 0)
    } catch {
      return cachedSetTimeout.call(this, o, 0)
    }
  }
}
function runClearTimeout(o) {
  if (cachedClearTimeout === clearTimeout) return clearTimeout(o)
  if (
    (cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &&
    clearTimeout
  )
    return (cachedClearTimeout = clearTimeout), clearTimeout(o)
  try {
    return cachedClearTimeout(o)
  } catch {
    try {
      return cachedClearTimeout.call(null, o)
    } catch {
      return cachedClearTimeout.call(this, o)
    }
  }
}
var queue = [],
  draining = !1,
  currentQueue,
  queueIndex = -1
function cleanUpNextTick() {
  !draining ||
    !currentQueue ||
    ((draining = !1),
    currentQueue.length
      ? (queue = currentQueue.concat(queue))
      : (queueIndex = -1),
    queue.length && drainQueue())
}
function drainQueue() {
  if (!draining) {
    var o = runTimeout(cleanUpNextTick)
    draining = !0
    for (var a = queue.length; a; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < a; )
        currentQueue && currentQueue[queueIndex].run()
      ;(queueIndex = -1), (a = queue.length)
    }
    ;(currentQueue = null), (draining = !1), runClearTimeout(o)
  }
}
process$1.nextTick = function(o) {
  var a = new Array(arguments.length - 1)
  if (arguments.length > 1)
    for (var s = 1; s < arguments.length; s++) a[s - 1] = arguments[s]
  queue.push(new Item$1(o, a)),
    queue.length === 1 && !draining && runTimeout(drainQueue)
}
function Item$1(o, a) {
  ;(this.fun = o), (this.array = a)
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array)
}
process$1.title = 'browser'
process$1.browser = !0
process$1.env = {}
process$1.argv = []
process$1.version = ''
process$1.versions = {}
function noop$b() {}
process$1.on = noop$b
process$1.addListener = noop$b
process$1.once = noop$b
process$1.off = noop$b
process$1.removeListener = noop$b
process$1.removeAllListeners = noop$b
process$1.emit = noop$b
process$1.prependListener = noop$b
process$1.prependOnceListener = noop$b
process$1.listeners = function(o) {
  return []
}
process$1.binding = function(o) {
  throw new Error('process.binding is not supported')
}
process$1.cwd = function() {
  return '/'
}
process$1.chdir = function(o) {
  throw new Error('process.chdir is not supported')
}
process$1.umask = function() {
  return 0
}
var browserExports$1 = browser$3.exports
const process$2 = getDefaultExportFromCjs(browserExports$1)
window.Buffer = buffer$1.Buffer
window.process = process$2
var reactDom = { exports: {} },
  reactDom_production_min = {},
  scheduler = { exports: {} },
  scheduler_production_min = {}
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ;(function(o) {
  var a, s, $, j
  if (typeof performance == 'object' && typeof performance.now == 'function') {
    var _e = performance
    o.unstable_now = function() {
      return _e.now()
    }
  } else {
    var et = Date,
      tt = et.now()
    o.unstable_now = function() {
      return et.now() - tt
    }
  }
  if (typeof window > 'u' || typeof MessageChannel != 'function') {
    var rt = null,
      nt = null,
      it = function() {
        if (rt !== null)
          try {
            var Nt = o.unstable_now()
            rt(!0, Nt), (rt = null)
          } catch ($t) {
            throw (setTimeout(it, 0), $t)
          }
      }
    ;(a = function(Nt) {
      rt !== null ? setTimeout(a, 0, Nt) : ((rt = Nt), setTimeout(it, 0))
    }),
      (s = function(Nt, $t) {
        nt = setTimeout(Nt, $t)
      }),
      ($ = function() {
        clearTimeout(nt)
      }),
      (o.unstable_shouldYield = function() {
        return !1
      }),
      (j = o.unstable_forceFrameRate = function() {})
  } else {
    var ot = window.setTimeout,
      at = window.clearTimeout
    if (typeof console < 'u') {
      var st = window.cancelAnimationFrame
      typeof window.requestAnimationFrame != 'function' &&
        console.error(
          "This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
        ),
        typeof st != 'function' &&
          console.error(
            "This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
          )
    }
    var ut = !1,
      ct = null,
      dt = -1,
      ft = 5,
      mt = 0
    ;(o.unstable_shouldYield = function() {
      return o.unstable_now() >= mt
    }),
      (j = function() {}),
      (o.unstable_forceFrameRate = function(Nt) {
        0 > Nt || 125 < Nt
          ? console.error(
              'forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported'
            )
          : (ft = 0 < Nt ? Math.floor(1e3 / Nt) : 5)
      })
    var vt = new MessageChannel(),
      yt = vt.port2
    ;(vt.port1.onmessage = function() {
      if (ct !== null) {
        var Nt = o.unstable_now()
        mt = Nt + ft
        try {
          ct(!0, Nt) ? yt.postMessage(null) : ((ut = !1), (ct = null))
        } catch ($t) {
          throw (yt.postMessage(null), $t)
        }
      } else ut = !1
    }),
      (a = function(Nt) {
        ;(ct = Nt), ut || ((ut = !0), yt.postMessage(null))
      }),
      (s = function(Nt, $t) {
        dt = ot(function() {
          Nt(o.unstable_now())
        }, $t)
      }),
      ($ = function() {
        at(dt), (dt = -1)
      })
  }
  function pt(Nt, $t) {
    var Pt = Nt.length
    Nt.push($t)
    e: for (;;) {
      var Ft = (Pt - 1) >>> 1,
        Vt = Nt[Ft]
      if (Vt !== void 0 && 0 < wt(Vt, $t))
        (Nt[Ft] = $t), (Nt[Pt] = Vt), (Pt = Ft)
      else break e
    }
  }
  function ht(Nt) {
    return (Nt = Nt[0]), Nt === void 0 ? null : Nt
  }
  function At(Nt) {
    var $t = Nt[0]
    if ($t !== void 0) {
      var Pt = Nt.pop()
      if (Pt !== $t) {
        Nt[0] = Pt
        e: for (var Ft = 0, Vt = Nt.length; Ft < Vt; ) {
          var Xt = 2 * (Ft + 1) - 1,
            Yt = Nt[Xt],
            xt = Xt + 1,
            It = Nt[xt]
          if (Yt !== void 0 && 0 > wt(Yt, Pt))
            It !== void 0 && 0 > wt(It, Yt)
              ? ((Nt[Ft] = It), (Nt[xt] = Pt), (Ft = xt))
              : ((Nt[Ft] = Yt), (Nt[Xt] = Pt), (Ft = Xt))
          else if (It !== void 0 && 0 > wt(It, Pt))
            (Nt[Ft] = It), (Nt[xt] = Pt), (Ft = xt)
          else break e
        }
      }
      return $t
    }
    return null
  }
  function wt(Nt, $t) {
    var Pt = Nt.sortIndex - $t.sortIndex
    return Pt !== 0 ? Pt : Nt.id - $t.id
  }
  var Ct = [],
    Dt = [],
    jt = 1,
    Et = null,
    St = 3,
    Bt = !1,
    Mt = !1,
    Ut = !1
  function Wt(Nt) {
    for (var $t = ht(Dt); $t !== null; ) {
      if ($t.callback === null) At(Dt)
      else if ($t.startTime <= Nt)
        At(Dt), ($t.sortIndex = $t.expirationTime), pt(Ct, $t)
      else break
      $t = ht(Dt)
    }
  }
  function Tt(Nt) {
    if (((Ut = !1), Wt(Nt), !Mt))
      if (ht(Ct) !== null) (Mt = !0), a(kt)
      else {
        var $t = ht(Dt)
        $t !== null && s(Tt, $t.startTime - Nt)
      }
  }
  function kt(Nt, $t) {
    ;(Mt = !1), Ut && ((Ut = !1), $()), (Bt = !0)
    var Pt = St
    try {
      for (
        Wt($t), Et = ht(Ct);
        Et !== null &&
        (!(Et.expirationTime > $t) || (Nt && !o.unstable_shouldYield()));

      ) {
        var Ft = Et.callback
        if (typeof Ft == 'function') {
          ;(Et.callback = null), (St = Et.priorityLevel)
          var Vt = Ft(Et.expirationTime <= $t)
          ;($t = o.unstable_now()),
            typeof Vt == 'function'
              ? (Et.callback = Vt)
              : Et === ht(Ct) && At(Ct),
            Wt($t)
        } else At(Ct)
        Et = ht(Ct)
      }
      if (Et !== null) var Xt = !0
      else {
        var Yt = ht(Dt)
        Yt !== null && s(Tt, Yt.startTime - $t), (Xt = !1)
      }
      return Xt
    } finally {
      ;(Et = null), (St = Pt), (Bt = !1)
    }
  }
  var Ot = j
  ;(o.unstable_IdlePriority = 5),
    (o.unstable_ImmediatePriority = 1),
    (o.unstable_LowPriority = 4),
    (o.unstable_NormalPriority = 3),
    (o.unstable_Profiling = null),
    (o.unstable_UserBlockingPriority = 2),
    (o.unstable_cancelCallback = function(Nt) {
      Nt.callback = null
    }),
    (o.unstable_continueExecution = function() {
      Mt || Bt || ((Mt = !0), a(kt))
    }),
    (o.unstable_getCurrentPriorityLevel = function() {
      return St
    }),
    (o.unstable_getFirstCallbackNode = function() {
      return ht(Ct)
    }),
    (o.unstable_next = function(Nt) {
      switch (St) {
        case 1:
        case 2:
        case 3:
          var $t = 3
          break
        default:
          $t = St
      }
      var Pt = St
      St = $t
      try {
        return Nt()
      } finally {
        St = Pt
      }
    }),
    (o.unstable_pauseExecution = function() {}),
    (o.unstable_requestPaint = Ot),
    (o.unstable_runWithPriority = function(Nt, $t) {
      switch (Nt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break
        default:
          Nt = 3
      }
      var Pt = St
      St = Nt
      try {
        return $t()
      } finally {
        St = Pt
      }
    }),
    (o.unstable_scheduleCallback = function(Nt, $t, Pt) {
      var Ft = o.unstable_now()
      switch (
        (typeof Pt == 'object' && Pt !== null
          ? ((Pt = Pt.delay),
            (Pt = typeof Pt == 'number' && 0 < Pt ? Ft + Pt : Ft))
          : (Pt = Ft),
        Nt)
      ) {
        case 1:
          var Vt = -1
          break
        case 2:
          Vt = 250
          break
        case 5:
          Vt = 1073741823
          break
        case 4:
          Vt = 1e4
          break
        default:
          Vt = 5e3
      }
      return (
        (Vt = Pt + Vt),
        (Nt = {
          id: jt++,
          callback: $t,
          priorityLevel: Nt,
          startTime: Pt,
          expirationTime: Vt,
          sortIndex: -1,
        }),
        Pt > Ft
          ? ((Nt.sortIndex = Pt),
            pt(Dt, Nt),
            ht(Ct) === null &&
              Nt === ht(Dt) &&
              (Ut ? $() : (Ut = !0), s(Tt, Pt - Ft)))
          : ((Nt.sortIndex = Vt), pt(Ct, Nt), Mt || Bt || ((Mt = !0), a(kt))),
        Nt
      )
    }),
    (o.unstable_wrapCallback = function(Nt) {
      var $t = St
      return function() {
        var Pt = St
        St = $t
        try {
          return Nt.apply(this, arguments)
        } finally {
          St = Pt
        }
      }
    })
})(scheduler_production_min)
scheduler.exports = scheduler_production_min
var schedulerExports = scheduler.exports
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var aa = reactExports,
  m$4 = objectAssign,
  r$5 = schedulerExports
function y$3(o) {
  for (
    var a = 'https://reactjs.org/docs/error-decoder.html?invariant=' + o, s = 1;
    s < arguments.length;
    s++
  )
    a += '&args[]=' + encodeURIComponent(arguments[s])
  return (
    'Minified React error #' +
    o +
    '; visit ' +
    a +
    ' for the full message or use the non-minified dev environment for full errors and additional helpful warnings.'
  )
}
if (!aa) throw Error(y$3(227))
var ba = new Set(),
  ca = {}
function da(o, a) {
  ea(o, a), ea(o + 'Capture', a)
}
function ea(o, a) {
  for (ca[o] = a, o = 0; o < a.length; o++) ba.add(a[o])
}
var fa = !(
    typeof window > 'u' ||
    typeof window.document > 'u' ||
    typeof window.document.createElement > 'u'
  ),
  ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  ia = Object.prototype.hasOwnProperty,
  ja = {},
  ka = {}
function la(o) {
  return ia.call(ka, o)
    ? !0
    : ia.call(ja, o)
    ? !1
    : ha.test(o)
    ? (ka[o] = !0)
    : ((ja[o] = !0), !1)
}
function ma(o, a, s, $) {
  if (s !== null && s.type === 0) return !1
  switch (typeof a) {
    case 'function':
    case 'symbol':
      return !0
    case 'boolean':
      return $
        ? !1
        : s !== null
        ? !s.acceptsBooleans
        : ((o = o.toLowerCase().slice(0, 5)), o !== 'data-' && o !== 'aria-')
    default:
      return !1
  }
}
function na(o, a, s, $) {
  if (a === null || typeof a > 'u' || ma(o, a, s, $)) return !0
  if ($) return !1
  if (s !== null)
    switch (s.type) {
      case 3:
        return !a
      case 4:
        return a === !1
      case 5:
        return isNaN(a)
      case 6:
        return isNaN(a) || 1 > a
    }
  return !1
}
function B$1(o, a, s, $, j, _e, et) {
  ;(this.acceptsBooleans = a === 2 || a === 3 || a === 4),
    (this.attributeName = $),
    (this.attributeNamespace = j),
    (this.mustUseProperty = s),
    (this.propertyName = o),
    (this.type = a),
    (this.sanitizeURL = _e),
    (this.removeEmptyString = et)
}
var D = {}
'children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style'
  .split(' ')
  .forEach(function(o) {
    D[o] = new B$1(o, 0, !1, o, null, !1, !1)
  })
;[
  ['acceptCharset', 'accept-charset'],
  ['className', 'class'],
  ['htmlFor', 'for'],
  ['httpEquiv', 'http-equiv'],
].forEach(function(o) {
  var a = o[0]
  D[a] = new B$1(a, 1, !1, o[1], null, !1, !1)
})
;['contentEditable', 'draggable', 'spellCheck', 'value'].forEach(function(o) {
  D[o] = new B$1(o, 2, !1, o.toLowerCase(), null, !1, !1)
})
;[
  'autoReverse',
  'externalResourcesRequired',
  'focusable',
  'preserveAlpha',
].forEach(function(o) {
  D[o] = new B$1(o, 2, !1, o, null, !1, !1)
})
'allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope'
  .split(' ')
  .forEach(function(o) {
    D[o] = new B$1(o, 3, !1, o.toLowerCase(), null, !1, !1)
  })
;['checked', 'multiple', 'muted', 'selected'].forEach(function(o) {
  D[o] = new B$1(o, 3, !0, o, null, !1, !1)
})
;['capture', 'download'].forEach(function(o) {
  D[o] = new B$1(o, 4, !1, o, null, !1, !1)
})
;['cols', 'rows', 'size', 'span'].forEach(function(o) {
  D[o] = new B$1(o, 6, !1, o, null, !1, !1)
})
;['rowSpan', 'start'].forEach(function(o) {
  D[o] = new B$1(o, 5, !1, o.toLowerCase(), null, !1, !1)
})
var oa = /[\-:]([a-z])/g
function pa(o) {
  return o[1].toUpperCase()
}
'accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height'
  .split(' ')
  .forEach(function(o) {
    var a = o.replace(oa, pa)
    D[a] = new B$1(a, 1, !1, o, null, !1, !1)
  })
'xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type'
  .split(' ')
  .forEach(function(o) {
    var a = o.replace(oa, pa)
    D[a] = new B$1(a, 1, !1, o, 'http://www.w3.org/1999/xlink', !1, !1)
  })
;['xml:base', 'xml:lang', 'xml:space'].forEach(function(o) {
  var a = o.replace(oa, pa)
  D[a] = new B$1(a, 1, !1, o, 'http://www.w3.org/XML/1998/namespace', !1, !1)
})
;['tabIndex', 'crossOrigin'].forEach(function(o) {
  D[o] = new B$1(o, 1, !1, o.toLowerCase(), null, !1, !1)
})
D.xlinkHref = new B$1(
  'xlinkHref',
  1,
  !1,
  'xlink:href',
  'http://www.w3.org/1999/xlink',
  !0,
  !1
)
;['src', 'href', 'action', 'formAction'].forEach(function(o) {
  D[o] = new B$1(o, 1, !1, o.toLowerCase(), null, !0, !0)
})
function qa(o, a, s, $) {
  var j = D.hasOwnProperty(a) ? D[a] : null,
    _e =
      j !== null
        ? j.type === 0
        : $
        ? !1
        : !(
            !(2 < a.length) ||
            (a[0] !== 'o' && a[0] !== 'O') ||
            (a[1] !== 'n' && a[1] !== 'N')
          )
  _e ||
    (na(a, s, j, $) && (s = null),
    $ || j === null
      ? la(a) && (s === null ? o.removeAttribute(a) : o.setAttribute(a, '' + s))
      : j.mustUseProperty
      ? (o[j.propertyName] = s === null ? (j.type === 3 ? !1 : '') : s)
      : ((a = j.attributeName),
        ($ = j.attributeNamespace),
        s === null
          ? o.removeAttribute(a)
          : ((j = j.type),
            (s = j === 3 || (j === 4 && s === !0) ? '' : '' + s),
            $ ? o.setAttributeNS($, a, s) : o.setAttribute(a, s))))
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  sa = 60103,
  ta = 60106,
  ua = 60107,
  wa = 60108,
  xa = 60114,
  ya = 60109,
  za = 60110,
  Aa = 60112,
  Ba = 60113,
  Ca = 60120,
  Da = 60115,
  Ea = 60116,
  Fa = 60121,
  Ga = 60128,
  Ha = 60129,
  Ia = 60130,
  Ja = 60131
if (typeof Symbol == 'function' && Symbol.for) {
  var E = Symbol.for
  ;(sa = E('react.element')),
    (ta = E('react.portal')),
    (ua = E('react.fragment')),
    (wa = E('react.strict_mode')),
    (xa = E('react.profiler')),
    (ya = E('react.provider')),
    (za = E('react.context')),
    (Aa = E('react.forward_ref')),
    (Ba = E('react.suspense')),
    (Ca = E('react.suspense_list')),
    (Da = E('react.memo')),
    (Ea = E('react.lazy')),
    (Fa = E('react.block')),
    E('react.scope'),
    (Ga = E('react.opaque.id')),
    (Ha = E('react.debug_trace_mode')),
    (Ia = E('react.offscreen')),
    (Ja = E('react.legacy_hidden'))
}
var Ka = typeof Symbol == 'function' && Symbol.iterator
function La(o) {
  return o === null || typeof o != 'object'
    ? null
    : ((o = (Ka && o[Ka]) || o['@@iterator']),
      typeof o == 'function' ? o : null)
}
var Ma
function Na(o) {
  if (Ma === void 0)
    try {
      throw Error()
    } catch (s) {
      var a = s.stack.trim().match(/\n( *(at )?)/)
      Ma = (a && a[1]) || ''
    }
  return (
    `
` +
    Ma +
    o
  )
}
var Oa = !1
function Pa(o, a) {
  if (!o || Oa) return ''
  Oa = !0
  var s = Error.prepareStackTrace
  Error.prepareStackTrace = void 0
  try {
    if (a)
      if (
        ((a = function() {
          throw Error()
        }),
        Object.defineProperty(a.prototype, 'props', {
          set: function() {
            throw Error()
          },
        }),
        typeof Reflect == 'object' && Reflect.construct)
      ) {
        try {
          Reflect.construct(a, [])
        } catch (rt) {
          var $ = rt
        }
        Reflect.construct(o, [], a)
      } else {
        try {
          a.call()
        } catch (rt) {
          $ = rt
        }
        o.call(a.prototype)
      }
    else {
      try {
        throw Error()
      } catch (rt) {
        $ = rt
      }
      o()
    }
  } catch (rt) {
    if (rt && $ && typeof rt.stack == 'string') {
      for (
        var j = rt.stack.split(`
`),
          _e = $.stack.split(`
`),
          et = j.length - 1,
          tt = _e.length - 1;
        1 <= et && 0 <= tt && j[et] !== _e[tt];

      )
        tt--
      for (; 1 <= et && 0 <= tt; et--, tt--)
        if (j[et] !== _e[tt]) {
          if (et !== 1 || tt !== 1)
            do
              if ((et--, tt--, 0 > tt || j[et] !== _e[tt]))
                return (
                  `
` + j[et].replace(' at new ', ' at ')
                )
            while (1 <= et && 0 <= tt)
          break
        }
    }
  } finally {
    ;(Oa = !1), (Error.prepareStackTrace = s)
  }
  return (o = o ? o.displayName || o.name : '') ? Na(o) : ''
}
function Qa(o) {
  switch (o.tag) {
    case 5:
      return Na(o.type)
    case 16:
      return Na('Lazy')
    case 13:
      return Na('Suspense')
    case 19:
      return Na('SuspenseList')
    case 0:
    case 2:
    case 15:
      return (o = Pa(o.type, !1)), o
    case 11:
      return (o = Pa(o.type.render, !1)), o
    case 22:
      return (o = Pa(o.type._render, !1)), o
    case 1:
      return (o = Pa(o.type, !0)), o
    default:
      return ''
  }
}
function Ra(o) {
  if (o == null) return null
  if (typeof o == 'function') return o.displayName || o.name || null
  if (typeof o == 'string') return o
  switch (o) {
    case ua:
      return 'Fragment'
    case ta:
      return 'Portal'
    case xa:
      return 'Profiler'
    case wa:
      return 'StrictMode'
    case Ba:
      return 'Suspense'
    case Ca:
      return 'SuspenseList'
  }
  if (typeof o == 'object')
    switch (o.$$typeof) {
      case za:
        return (o.displayName || 'Context') + '.Consumer'
      case ya:
        return (o._context.displayName || 'Context') + '.Provider'
      case Aa:
        var a = o.render
        return (
          (a = a.displayName || a.name || ''),
          o.displayName || (a !== '' ? 'ForwardRef(' + a + ')' : 'ForwardRef')
        )
      case Da:
        return Ra(o.type)
      case Fa:
        return Ra(o._render)
      case Ea:
        ;(a = o._payload), (o = o._init)
        try {
          return Ra(o(a))
        } catch {}
    }
  return null
}
function Sa(o) {
  switch (typeof o) {
    case 'boolean':
    case 'number':
    case 'object':
    case 'string':
    case 'undefined':
      return o
    default:
      return ''
  }
}
function Ta(o) {
  var a = o.type
  return (
    (o = o.nodeName) &&
    o.toLowerCase() === 'input' &&
    (a === 'checkbox' || a === 'radio')
  )
}
function Ua(o) {
  var a = Ta(o) ? 'checked' : 'value',
    s = Object.getOwnPropertyDescriptor(o.constructor.prototype, a),
    $ = '' + o[a]
  if (
    !o.hasOwnProperty(a) &&
    typeof s < 'u' &&
    typeof s.get == 'function' &&
    typeof s.set == 'function'
  ) {
    var j = s.get,
      _e = s.set
    return (
      Object.defineProperty(o, a, {
        configurable: !0,
        get: function() {
          return j.call(this)
        },
        set: function(et) {
          ;($ = '' + et), _e.call(this, et)
        },
      }),
      Object.defineProperty(o, a, { enumerable: s.enumerable }),
      {
        getValue: function() {
          return $
        },
        setValue: function(et) {
          $ = '' + et
        },
        stopTracking: function() {
          ;(o._valueTracker = null), delete o[a]
        },
      }
    )
  }
}
function Va(o) {
  o._valueTracker || (o._valueTracker = Ua(o))
}
function Wa(o) {
  if (!o) return !1
  var a = o._valueTracker
  if (!a) return !0
  var s = a.getValue(),
    $ = ''
  return (
    o && ($ = Ta(o) ? (o.checked ? 'true' : 'false') : o.value),
    (o = $),
    o !== s ? (a.setValue(o), !0) : !1
  )
}
function Xa(o) {
  if (((o = o || (typeof document < 'u' ? document : void 0)), typeof o > 'u'))
    return null
  try {
    return o.activeElement || o.body
  } catch {
    return o.body
  }
}
function Ya(o, a) {
  var s = a.checked
  return m$4({}, a, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: s ?? o._wrapperState.initialChecked,
  })
}
function Za(o, a) {
  var s = a.defaultValue == null ? '' : a.defaultValue,
    $ = a.checked != null ? a.checked : a.defaultChecked
  ;(s = Sa(a.value != null ? a.value : s)),
    (o._wrapperState = {
      initialChecked: $,
      initialValue: s,
      controlled:
        a.type === 'checkbox' || a.type === 'radio'
          ? a.checked != null
          : a.value != null,
    })
}
function $a(o, a) {
  ;(a = a.checked), a != null && qa(o, 'checked', a, !1)
}
function ab(o, a) {
  $a(o, a)
  var s = Sa(a.value),
    $ = a.type
  if (s != null)
    $ === 'number'
      ? ((s === 0 && o.value === '') || o.value != s) && (o.value = '' + s)
      : o.value !== '' + s && (o.value = '' + s)
  else if ($ === 'submit' || $ === 'reset') {
    o.removeAttribute('value')
    return
  }
  a.hasOwnProperty('value')
    ? bb(o, a.type, s)
    : a.hasOwnProperty('defaultValue') && bb(o, a.type, Sa(a.defaultValue)),
    a.checked == null &&
      a.defaultChecked != null &&
      (o.defaultChecked = !!a.defaultChecked)
}
function cb(o, a, s) {
  if (a.hasOwnProperty('value') || a.hasOwnProperty('defaultValue')) {
    var $ = a.type
    if (
      !(
        ($ !== 'submit' && $ !== 'reset') ||
        (a.value !== void 0 && a.value !== null)
      )
    )
      return
    ;(a = '' + o._wrapperState.initialValue),
      s || a === o.value || (o.value = a),
      (o.defaultValue = a)
  }
  ;(s = o.name),
    s !== '' && (o.name = ''),
    (o.defaultChecked = !!o._wrapperState.initialChecked),
    s !== '' && (o.name = s)
}
function bb(o, a, s) {
  ;(a !== 'number' || Xa(o.ownerDocument) !== o) &&
    (s == null
      ? (o.defaultValue = '' + o._wrapperState.initialValue)
      : o.defaultValue !== '' + s && (o.defaultValue = '' + s))
}
function db$2(o) {
  var a = ''
  return (
    aa.Children.forEach(o, function(s) {
      s != null && (a += s)
    }),
    a
  )
}
function eb(o, a) {
  return (
    (o = m$4({ children: void 0 }, a)),
    (a = db$2(a.children)) && (o.children = a),
    o
  )
}
function fb(o, a, s, $) {
  if (((o = o.options), a)) {
    a = {}
    for (var j = 0; j < s.length; j++) a['$' + s[j]] = !0
    for (s = 0; s < o.length; s++)
      (j = a.hasOwnProperty('$' + o[s].value)),
        o[s].selected !== j && (o[s].selected = j),
        j && $ && (o[s].defaultSelected = !0)
  } else {
    for (s = '' + Sa(s), a = null, j = 0; j < o.length; j++) {
      if (o[j].value === s) {
        ;(o[j].selected = !0), $ && (o[j].defaultSelected = !0)
        return
      }
      a !== null || o[j].disabled || (a = o[j])
    }
    a !== null && (a.selected = !0)
  }
}
function gb(o, a) {
  if (a.dangerouslySetInnerHTML != null) throw Error(y$3(91))
  return m$4({}, a, {
    value: void 0,
    defaultValue: void 0,
    children: '' + o._wrapperState.initialValue,
  })
}
function hb(o, a) {
  var s = a.value
  if (s == null) {
    if (((s = a.children), (a = a.defaultValue), s != null)) {
      if (a != null) throw Error(y$3(92))
      if (Array.isArray(s)) {
        if (!(1 >= s.length)) throw Error(y$3(93))
        s = s[0]
      }
      a = s
    }
    a == null && (a = ''), (s = a)
  }
  o._wrapperState = { initialValue: Sa(s) }
}
function ib(o, a) {
  var s = Sa(a.value),
    $ = Sa(a.defaultValue)
  s != null &&
    ((s = '' + s),
    s !== o.value && (o.value = s),
    a.defaultValue == null && o.defaultValue !== s && (o.defaultValue = s)),
    $ != null && (o.defaultValue = '' + $)
}
function jb(o) {
  var a = o.textContent
  a === o._wrapperState.initialValue && a !== '' && a !== null && (o.value = a)
}
var kb = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg',
}
function lb(o) {
  switch (o) {
    case 'svg':
      return 'http://www.w3.org/2000/svg'
    case 'math':
      return 'http://www.w3.org/1998/Math/MathML'
    default:
      return 'http://www.w3.org/1999/xhtml'
  }
}
function mb(o, a) {
  return o == null || o === 'http://www.w3.org/1999/xhtml'
    ? lb(a)
    : o === 'http://www.w3.org/2000/svg' && a === 'foreignObject'
    ? 'http://www.w3.org/1999/xhtml'
    : o
}
var nb,
  ob = (function(o) {
    return typeof MSApp < 'u' && MSApp.execUnsafeLocalFunction
      ? function(a, s, $, j) {
          MSApp.execUnsafeLocalFunction(function() {
            return o(a, s, $, j)
          })
        }
      : o
  })(function(o, a) {
    if (o.namespaceURI !== kb.svg || 'innerHTML' in o) o.innerHTML = a
    else {
      for (
        nb = nb || document.createElement('div'),
          nb.innerHTML = '<svg>' + a.valueOf().toString() + '</svg>',
          a = nb.firstChild;
        o.firstChild;

      )
        o.removeChild(o.firstChild)
      for (; a.firstChild; ) o.appendChild(a.firstChild)
    }
  })
function pb(o, a) {
  if (a) {
    var s = o.firstChild
    if (s && s === o.lastChild && s.nodeType === 3) {
      s.nodeValue = a
      return
    }
  }
  o.textContent = a
}
var qb = {
    animationIterationCount: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  rb = ['Webkit', 'ms', 'Moz', 'O']
Object.keys(qb).forEach(function(o) {
  rb.forEach(function(a) {
    ;(a = a + o.charAt(0).toUpperCase() + o.substring(1)), (qb[a] = qb[o])
  })
})
function sb(o, a, s) {
  return a == null || typeof a == 'boolean' || a === ''
    ? ''
    : s || typeof a != 'number' || a === 0 || (qb.hasOwnProperty(o) && qb[o])
    ? ('' + a).trim()
    : a + 'px'
}
function tb(o, a) {
  o = o.style
  for (var s in a)
    if (a.hasOwnProperty(s)) {
      var $ = s.indexOf('--') === 0,
        j = sb(s, a[s], $)
      s === 'float' && (s = 'cssFloat'), $ ? o.setProperty(s, j) : (o[s] = j)
    }
}
var ub = m$4(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
)
function vb(o, a) {
  if (a) {
    if (ub[o] && (a.children != null || a.dangerouslySetInnerHTML != null))
      throw Error(y$3(137, o))
    if (a.dangerouslySetInnerHTML != null) {
      if (a.children != null) throw Error(y$3(60))
      if (
        !(
          typeof a.dangerouslySetInnerHTML == 'object' &&
          '__html' in a.dangerouslySetInnerHTML
        )
      )
        throw Error(y$3(61))
    }
    if (a.style != null && typeof a.style != 'object') throw Error(y$3(62))
  }
}
function wb(o, a) {
  if (o.indexOf('-') === -1) return typeof a.is == 'string'
  switch (o) {
    case 'annotation-xml':
    case 'color-profile':
    case 'font-face':
    case 'font-face-src':
    case 'font-face-uri':
    case 'font-face-format':
    case 'font-face-name':
    case 'missing-glyph':
      return !1
    default:
      return !0
  }
}
function xb(o) {
  return (
    (o = o.target || o.srcElement || window),
    o.correspondingUseElement && (o = o.correspondingUseElement),
    o.nodeType === 3 ? o.parentNode : o
  )
}
var yb = null,
  zb = null,
  Ab = null
function Bb(o) {
  if ((o = Cb(o))) {
    if (typeof yb != 'function') throw Error(y$3(280))
    var a = o.stateNode
    a && ((a = Db(a)), yb(o.stateNode, o.type, a))
  }
}
function Eb(o) {
  zb ? (Ab ? Ab.push(o) : (Ab = [o])) : (zb = o)
}
function Fb() {
  if (zb) {
    var o = zb,
      a = Ab
    if (((Ab = zb = null), Bb(o), a)) for (o = 0; o < a.length; o++) Bb(a[o])
  }
}
function Gb(o, a) {
  return o(a)
}
function Hb(o, a, s, $, j) {
  return o(a, s, $, j)
}
function Ib() {}
var Jb = Gb,
  Kb = !1,
  Lb = !1
function Mb() {
  ;(zb !== null || Ab !== null) && (Ib(), Fb())
}
function Nb(o, a, s) {
  if (Lb) return o(a, s)
  Lb = !0
  try {
    return Jb(o, a, s)
  } finally {
    ;(Lb = !1), Mb()
  }
}
function Ob(o, a) {
  var s = o.stateNode
  if (s === null) return null
  var $ = Db(s)
  if ($ === null) return null
  s = $[a]
  e: switch (a) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
    case 'onMouseEnter':
      ;($ = !$.disabled) ||
        ((o = o.type),
        ($ = !(
          o === 'button' ||
          o === 'input' ||
          o === 'select' ||
          o === 'textarea'
        ))),
        (o = !$)
      break e
    default:
      o = !1
  }
  if (o) return null
  if (s && typeof s != 'function') throw Error(y$3(231, a, typeof s))
  return s
}
var Pb = !1
if (fa)
  try {
    var Qb = {}
    Object.defineProperty(Qb, 'passive', {
      get: function() {
        Pb = !0
      },
    }),
      window.addEventListener('test', Qb, Qb),
      window.removeEventListener('test', Qb, Qb)
  } catch {
    Pb = !1
  }
function Rb(o, a, s, $, j, _e, et, tt, rt) {
  var nt = Array.prototype.slice.call(arguments, 3)
  try {
    a.apply(s, nt)
  } catch (it) {
    this.onError(it)
  }
}
var Sb = !1,
  Tb = null,
  Ub = !1,
  Vb = null,
  Wb = {
    onError: function(o) {
      ;(Sb = !0), (Tb = o)
    },
  }
function Xb(o, a, s, $, j, _e, et, tt, rt) {
  ;(Sb = !1), (Tb = null), Rb.apply(Wb, arguments)
}
function Yb(o, a, s, $, j, _e, et, tt, rt) {
  if ((Xb.apply(this, arguments), Sb)) {
    if (Sb) {
      var nt = Tb
      ;(Sb = !1), (Tb = null)
    } else throw Error(y$3(198))
    Ub || ((Ub = !0), (Vb = nt))
  }
}
function Zb(o) {
  var a = o,
    s = o
  if (o.alternate) for (; a.return; ) a = a.return
  else {
    o = a
    do (a = o), a.flags & 1026 && (s = a.return), (o = a.return)
    while (o)
  }
  return a.tag === 3 ? s : null
}
function $b(o) {
  if (o.tag === 13) {
    var a = o.memoizedState
    if (
      (a === null && ((o = o.alternate), o !== null && (a = o.memoizedState)),
      a !== null)
    )
      return a.dehydrated
  }
  return null
}
function ac(o) {
  if (Zb(o) !== o) throw Error(y$3(188))
}
function bc(o) {
  var a = o.alternate
  if (!a) {
    if (((a = Zb(o)), a === null)) throw Error(y$3(188))
    return a !== o ? null : o
  }
  for (var s = o, $ = a; ; ) {
    var j = s.return
    if (j === null) break
    var _e = j.alternate
    if (_e === null) {
      if ((($ = j.return), $ !== null)) {
        s = $
        continue
      }
      break
    }
    if (j.child === _e.child) {
      for (_e = j.child; _e; ) {
        if (_e === s) return ac(j), o
        if (_e === $) return ac(j), a
        _e = _e.sibling
      }
      throw Error(y$3(188))
    }
    if (s.return !== $.return) (s = j), ($ = _e)
    else {
      for (var et = !1, tt = j.child; tt; ) {
        if (tt === s) {
          ;(et = !0), (s = j), ($ = _e)
          break
        }
        if (tt === $) {
          ;(et = !0), ($ = j), (s = _e)
          break
        }
        tt = tt.sibling
      }
      if (!et) {
        for (tt = _e.child; tt; ) {
          if (tt === s) {
            ;(et = !0), (s = _e), ($ = j)
            break
          }
          if (tt === $) {
            ;(et = !0), ($ = _e), (s = j)
            break
          }
          tt = tt.sibling
        }
        if (!et) throw Error(y$3(189))
      }
    }
    if (s.alternate !== $) throw Error(y$3(190))
  }
  if (s.tag !== 3) throw Error(y$3(188))
  return s.stateNode.current === s ? o : a
}
function cc(o) {
  if (((o = bc(o)), !o)) return null
  for (var a = o; ; ) {
    if (a.tag === 5 || a.tag === 6) return a
    if (a.child) (a.child.return = a), (a = a.child)
    else {
      if (a === o) break
      for (; !a.sibling; ) {
        if (!a.return || a.return === o) return null
        a = a.return
      }
      ;(a.sibling.return = a.return), (a = a.sibling)
    }
  }
  return null
}
function dc(o, a) {
  for (var s = o.alternate; a !== null; ) {
    if (a === o || a === s) return !0
    a = a.return
  }
  return !1
}
var ec,
  fc,
  gc,
  hc,
  ic = !1,
  jc = [],
  kc = null,
  lc = null,
  mc = null,
  nc = new Map(),
  oc = new Map(),
  pc = [],
  qc = 'mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit'.split(
    ' '
  )
function rc(o, a, s, $, j) {
  return {
    blockedOn: o,
    domEventName: a,
    eventSystemFlags: s | 16,
    nativeEvent: j,
    targetContainers: [$],
  }
}
function sc(o, a) {
  switch (o) {
    case 'focusin':
    case 'focusout':
      kc = null
      break
    case 'dragenter':
    case 'dragleave':
      lc = null
      break
    case 'mouseover':
    case 'mouseout':
      mc = null
      break
    case 'pointerover':
    case 'pointerout':
      nc.delete(a.pointerId)
      break
    case 'gotpointercapture':
    case 'lostpointercapture':
      oc.delete(a.pointerId)
  }
}
function tc(o, a, s, $, j, _e) {
  return o === null || o.nativeEvent !== _e
    ? ((o = rc(a, s, $, j, _e)),
      a !== null && ((a = Cb(a)), a !== null && fc(a)),
      o)
    : ((o.eventSystemFlags |= $),
      (a = o.targetContainers),
      j !== null && a.indexOf(j) === -1 && a.push(j),
      o)
}
function uc(o, a, s, $, j) {
  switch (a) {
    case 'focusin':
      return (kc = tc(kc, o, a, s, $, j)), !0
    case 'dragenter':
      return (lc = tc(lc, o, a, s, $, j)), !0
    case 'mouseover':
      return (mc = tc(mc, o, a, s, $, j)), !0
    case 'pointerover':
      var _e = j.pointerId
      return nc.set(_e, tc(nc.get(_e) || null, o, a, s, $, j)), !0
    case 'gotpointercapture':
      return (
        (_e = j.pointerId),
        oc.set(_e, tc(oc.get(_e) || null, o, a, s, $, j)),
        !0
      )
  }
  return !1
}
function vc(o) {
  var a = wc(o.target)
  if (a !== null) {
    var s = Zb(a)
    if (s !== null) {
      if (((a = s.tag), a === 13)) {
        if (((a = $b(s)), a !== null)) {
          ;(o.blockedOn = a),
            hc(o.lanePriority, function() {
              r$5.unstable_runWithPriority(o.priority, function() {
                gc(s)
              })
            })
          return
        }
      } else if (a === 3 && s.stateNode.hydrate) {
        o.blockedOn = s.tag === 3 ? s.stateNode.containerInfo : null
        return
      }
    }
  }
  o.blockedOn = null
}
function xc(o) {
  if (o.blockedOn !== null) return !1
  for (var a = o.targetContainers; 0 < a.length; ) {
    var s = yc(o.domEventName, o.eventSystemFlags, a[0], o.nativeEvent)
    if (s !== null)
      return (a = Cb(s)), a !== null && fc(a), (o.blockedOn = s), !1
    a.shift()
  }
  return !0
}
function zc(o, a, s) {
  xc(o) && s.delete(a)
}
function Ac() {
  for (ic = !1; 0 < jc.length; ) {
    var o = jc[0]
    if (o.blockedOn !== null) {
      ;(o = Cb(o.blockedOn)), o !== null && ec(o)
      break
    }
    for (var a = o.targetContainers; 0 < a.length; ) {
      var s = yc(o.domEventName, o.eventSystemFlags, a[0], o.nativeEvent)
      if (s !== null) {
        o.blockedOn = s
        break
      }
      a.shift()
    }
    o.blockedOn === null && jc.shift()
  }
  kc !== null && xc(kc) && (kc = null),
    lc !== null && xc(lc) && (lc = null),
    mc !== null && xc(mc) && (mc = null),
    nc.forEach(zc),
    oc.forEach(zc)
}
function Bc(o, a) {
  o.blockedOn === a &&
    ((o.blockedOn = null),
    ic ||
      ((ic = !0),
      r$5.unstable_scheduleCallback(r$5.unstable_NormalPriority, Ac)))
}
function Cc(o) {
  function a(j) {
    return Bc(j, o)
  }
  if (0 < jc.length) {
    Bc(jc[0], o)
    for (var s = 1; s < jc.length; s++) {
      var $ = jc[s]
      $.blockedOn === o && ($.blockedOn = null)
    }
  }
  for (
    kc !== null && Bc(kc, o),
      lc !== null && Bc(lc, o),
      mc !== null && Bc(mc, o),
      nc.forEach(a),
      oc.forEach(a),
      s = 0;
    s < pc.length;
    s++
  )
    ($ = pc[s]), $.blockedOn === o && ($.blockedOn = null)
  for (; 0 < pc.length && ((s = pc[0]), s.blockedOn === null); )
    vc(s), s.blockedOn === null && pc.shift()
}
function Dc(o, a) {
  var s = {}
  return (
    (s[o.toLowerCase()] = a.toLowerCase()),
    (s['Webkit' + o] = 'webkit' + a),
    (s['Moz' + o] = 'moz' + a),
    s
  )
}
var Ec = {
    animationend: Dc('Animation', 'AnimationEnd'),
    animationiteration: Dc('Animation', 'AnimationIteration'),
    animationstart: Dc('Animation', 'AnimationStart'),
    transitionend: Dc('Transition', 'TransitionEnd'),
  },
  Fc = {},
  Gc = {}
fa &&
  ((Gc = document.createElement('div').style),
  'AnimationEvent' in window ||
    (delete Ec.animationend.animation,
    delete Ec.animationiteration.animation,
    delete Ec.animationstart.animation),
  'TransitionEvent' in window || delete Ec.transitionend.transition)
function Hc(o) {
  if (Fc[o]) return Fc[o]
  if (!Ec[o]) return o
  var a = Ec[o],
    s
  for (s in a) if (a.hasOwnProperty(s) && s in Gc) return (Fc[o] = a[s])
  return o
}
var Ic = Hc('animationend'),
  Jc = Hc('animationiteration'),
  Kc = Hc('animationstart'),
  Lc = Hc('transitionend'),
  Mc = new Map(),
  Nc = new Map(),
  Oc = [
    'abort',
    'abort',
    Ic,
    'animationEnd',
    Jc,
    'animationIteration',
    Kc,
    'animationStart',
    'canplay',
    'canPlay',
    'canplaythrough',
    'canPlayThrough',
    'durationchange',
    'durationChange',
    'emptied',
    'emptied',
    'encrypted',
    'encrypted',
    'ended',
    'ended',
    'error',
    'error',
    'gotpointercapture',
    'gotPointerCapture',
    'load',
    'load',
    'loadeddata',
    'loadedData',
    'loadedmetadata',
    'loadedMetadata',
    'loadstart',
    'loadStart',
    'lostpointercapture',
    'lostPointerCapture',
    'playing',
    'playing',
    'progress',
    'progress',
    'seeking',
    'seeking',
    'stalled',
    'stalled',
    'suspend',
    'suspend',
    'timeupdate',
    'timeUpdate',
    Lc,
    'transitionEnd',
    'waiting',
    'waiting',
  ]
function Pc(o, a) {
  for (var s = 0; s < o.length; s += 2) {
    var $ = o[s],
      j = o[s + 1]
    ;(j = 'on' + (j[0].toUpperCase() + j.slice(1))),
      Nc.set($, a),
      Mc.set($, j),
      da(j, [$])
  }
}
var Qc = r$5.unstable_now
Qc()
var F = 8
function Rc(o) {
  if (1 & o) return (F = 15), 1
  if (2 & o) return (F = 14), 2
  if (4 & o) return (F = 13), 4
  var a = 24 & o
  return a !== 0
    ? ((F = 12), a)
    : o & 32
    ? ((F = 11), 32)
    : ((a = 192 & o),
      a !== 0
        ? ((F = 10), a)
        : o & 256
        ? ((F = 9), 256)
        : ((a = 3584 & o),
          a !== 0
            ? ((F = 8), a)
            : o & 4096
            ? ((F = 7), 4096)
            : ((a = 4186112 & o),
              a !== 0
                ? ((F = 6), a)
                : ((a = 62914560 & o),
                  a !== 0
                    ? ((F = 5), a)
                    : o & 67108864
                    ? ((F = 4), 67108864)
                    : o & 134217728
                    ? ((F = 3), 134217728)
                    : ((a = 805306368 & o),
                      a !== 0
                        ? ((F = 2), a)
                        : 1073741824 & o
                        ? ((F = 1), 1073741824)
                        : ((F = 8), o))))))
}
function Sc(o) {
  switch (o) {
    case 99:
      return 15
    case 98:
      return 10
    case 97:
    case 96:
      return 8
    case 95:
      return 2
    default:
      return 0
  }
}
function Tc(o) {
  switch (o) {
    case 15:
    case 14:
      return 99
    case 13:
    case 12:
    case 11:
    case 10:
      return 98
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97
    case 3:
    case 2:
    case 1:
      return 95
    case 0:
      return 90
    default:
      throw Error(y$3(358, o))
  }
}
function Uc(o, a) {
  var s = o.pendingLanes
  if (s === 0) return (F = 0)
  var $ = 0,
    j = 0,
    _e = o.expiredLanes,
    et = o.suspendedLanes,
    tt = o.pingedLanes
  if (_e !== 0) ($ = _e), (j = F = 15)
  else if (((_e = s & 134217727), _e !== 0)) {
    var rt = _e & ~et
    rt !== 0
      ? (($ = Rc(rt)), (j = F))
      : ((tt &= _e), tt !== 0 && (($ = Rc(tt)), (j = F)))
  } else
    (_e = s & ~et),
      _e !== 0 ? (($ = Rc(_e)), (j = F)) : tt !== 0 && (($ = Rc(tt)), (j = F))
  if ($ === 0) return 0
  if (
    (($ = 31 - Vc($)),
    ($ = s & (((0 > $ ? 0 : 1 << $) << 1) - 1)),
    a !== 0 && a !== $ && !(a & et))
  ) {
    if ((Rc(a), j <= F)) return a
    F = j
  }
  if (((a = o.entangledLanes), a !== 0))
    for (o = o.entanglements, a &= $; 0 < a; )
      (s = 31 - Vc(a)), (j = 1 << s), ($ |= o[s]), (a &= ~j)
  return $
}
function Wc(o) {
  return (
    (o = o.pendingLanes & -1073741825),
    o !== 0 ? o : o & 1073741824 ? 1073741824 : 0
  )
}
function Xc(o, a) {
  switch (o) {
    case 15:
      return 1
    case 14:
      return 2
    case 12:
      return (o = Yc(24 & ~a)), o === 0 ? Xc(10, a) : o
    case 10:
      return (o = Yc(192 & ~a)), o === 0 ? Xc(8, a) : o
    case 8:
      return (
        (o = Yc(3584 & ~a)),
        o === 0 && ((o = Yc(4186112 & ~a)), o === 0 && (o = 512)),
        o
      )
    case 2:
      return (a = Yc(805306368 & ~a)), a === 0 && (a = 268435456), a
  }
  throw Error(y$3(358, o))
}
function Yc(o) {
  return o & -o
}
function Zc(o) {
  for (var a = [], s = 0; 31 > s; s++) a.push(o)
  return a
}
function $c(o, a, s) {
  o.pendingLanes |= a
  var $ = a - 1
  ;(o.suspendedLanes &= $),
    (o.pingedLanes &= $),
    (o = o.eventTimes),
    (a = 31 - Vc(a)),
    (o[a] = s)
}
var Vc = Math.clz32 ? Math.clz32 : ad,
  bd = Math.log,
  cd = Math.LN2
function ad(o) {
  return o === 0 ? 32 : (31 - ((bd(o) / cd) | 0)) | 0
}
var dd = r$5.unstable_UserBlockingPriority,
  ed = r$5.unstable_runWithPriority,
  fd = !0
function gd(o, a, s, $) {
  Kb || Ib()
  var j = hd,
    _e = Kb
  Kb = !0
  try {
    Hb(j, o, a, s, $)
  } finally {
    ;(Kb = _e) || Mb()
  }
}
function id(o, a, s, $) {
  ed(dd, hd.bind(null, o, a, s, $))
}
function hd(o, a, s, $) {
  if (fd) {
    var j
    if ((j = (a & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(o))
      (o = rc(null, o, a, s, $)), jc.push(o)
    else {
      var _e = yc(o, a, s, $)
      if (_e === null) j && sc(o, $)
      else {
        if (j) {
          if (-1 < qc.indexOf(o)) {
            ;(o = rc(_e, o, a, s, $)), jc.push(o)
            return
          }
          if (uc(_e, o, a, s, $)) return
          sc(o, $)
        }
        jd(o, a, $, null, s)
      }
    }
  }
}
function yc(o, a, s, $) {
  var j = xb($)
  if (((j = wc(j)), j !== null)) {
    var _e = Zb(j)
    if (_e === null) j = null
    else {
      var et = _e.tag
      if (et === 13) {
        if (((j = $b(_e)), j !== null)) return j
        j = null
      } else if (et === 3) {
        if (_e.stateNode.hydrate)
          return _e.tag === 3 ? _e.stateNode.containerInfo : null
        j = null
      } else _e !== j && (j = null)
    }
  }
  return jd(o, a, $, j, s), null
}
var kd = null,
  ld = null,
  md = null
function nd() {
  if (md) return md
  var o,
    a = ld,
    s = a.length,
    $,
    j = 'value' in kd ? kd.value : kd.textContent,
    _e = j.length
  for (o = 0; o < s && a[o] === j[o]; o++);
  var et = s - o
  for ($ = 1; $ <= et && a[s - $] === j[_e - $]; $++);
  return (md = j.slice(o, 1 < $ ? 1 - $ : void 0))
}
function od(o) {
  var a = o.keyCode
  return (
    'charCode' in o
      ? ((o = o.charCode), o === 0 && a === 13 && (o = 13))
      : (o = a),
    o === 10 && (o = 13),
    32 <= o || o === 13 ? o : 0
  )
}
function pd() {
  return !0
}
function qd() {
  return !1
}
function rd(o) {
  function a(s, $, j, _e, et) {
    ;(this._reactName = s),
      (this._targetInst = j),
      (this.type = $),
      (this.nativeEvent = _e),
      (this.target = et),
      (this.currentTarget = null)
    for (var tt in o)
      o.hasOwnProperty(tt) && ((s = o[tt]), (this[tt] = s ? s(_e) : _e[tt]))
    return (
      (this.isDefaultPrevented = (_e.defaultPrevented != null
      ? _e.defaultPrevented
      : _e.returnValue === !1)
        ? pd
        : qd),
      (this.isPropagationStopped = qd),
      this
    )
  }
  return (
    m$4(a.prototype, {
      preventDefault: function() {
        this.defaultPrevented = !0
        var s = this.nativeEvent
        s &&
          (s.preventDefault
            ? s.preventDefault()
            : typeof s.returnValue != 'unknown' && (s.returnValue = !1),
          (this.isDefaultPrevented = pd))
      },
      stopPropagation: function() {
        var s = this.nativeEvent
        s &&
          (s.stopPropagation
            ? s.stopPropagation()
            : typeof s.cancelBubble != 'unknown' && (s.cancelBubble = !0),
          (this.isPropagationStopped = pd))
      },
      persist: function() {},
      isPersistent: pd,
    }),
    a
  )
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
      return o.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  td = rd(sd),
  ud = m$4({}, sd, { view: 0, detail: 0 }),
  vd = rd(ud),
  wd,
  xd,
  yd,
  Ad = m$4({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
      return o.relatedTarget === void 0
        ? o.fromElement === o.srcElement
          ? o.toElement
          : o.fromElement
        : o.relatedTarget
    },
    movementX: function(o) {
      return 'movementX' in o
        ? o.movementX
        : (o !== yd &&
            (yd && o.type === 'mousemove'
              ? ((wd = o.screenX - yd.screenX), (xd = o.screenY - yd.screenY))
              : (xd = wd = 0),
            (yd = o)),
          wd)
    },
    movementY: function(o) {
      return 'movementY' in o ? o.movementY : xd
    },
  }),
  Bd = rd(Ad),
  Cd = m$4({}, Ad, { dataTransfer: 0 }),
  Dd = rd(Cd),
  Ed = m$4({}, ud, { relatedTarget: 0 }),
  Fd = rd(Ed),
  Gd = m$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Hd = rd(Gd),
  Id = m$4({}, sd, {
    clipboardData: function(o) {
      return 'clipboardData' in o ? o.clipboardData : window.clipboardData
    },
  }),
  Jd = rd(Id),
  Kd = m$4({}, sd, { data: 0 }),
  Ld = rd(Kd),
  Md = {
    Esc: 'Escape',
    Spacebar: ' ',
    Left: 'ArrowLeft',
    Up: 'ArrowUp',
    Right: 'ArrowRight',
    Down: 'ArrowDown',
    Del: 'Delete',
    Win: 'OS',
    Menu: 'ContextMenu',
    Apps: 'ContextMenu',
    Scroll: 'ScrollLock',
    MozPrintableKey: 'Unidentified',
  },
  Nd = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta',
  },
  Od = { Alt: 'altKey', Control: 'ctrlKey', Meta: 'metaKey', Shift: 'shiftKey' }
function Pd(o) {
  var a = this.nativeEvent
  return a.getModifierState ? a.getModifierState(o) : (o = Od[o]) ? !!a[o] : !1
}
function zd() {
  return Pd
}
var Qd = m$4({}, ud, {
    key: function(o) {
      if (o.key) {
        var a = Md[o.key] || o.key
        if (a !== 'Unidentified') return a
      }
      return o.type === 'keypress'
        ? ((o = od(o)), o === 13 ? 'Enter' : String.fromCharCode(o))
        : o.type === 'keydown' || o.type === 'keyup'
        ? Nd[o.keyCode] || 'Unidentified'
        : ''
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(o) {
      return o.type === 'keypress' ? od(o) : 0
    },
    keyCode: function(o) {
      return o.type === 'keydown' || o.type === 'keyup' ? o.keyCode : 0
    },
    which: function(o) {
      return o.type === 'keypress'
        ? od(o)
        : o.type === 'keydown' || o.type === 'keyup'
        ? o.keyCode
        : 0
    },
  }),
  Rd = rd(Qd),
  Sd = m$4({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  Td = rd(Sd),
  Ud = m$4({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd,
  }),
  Vd = rd(Ud),
  Wd = m$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  Xd = rd(Wd),
  Yd = m$4({}, Ad, {
    deltaX: function(o) {
      return 'deltaX' in o ? o.deltaX : 'wheelDeltaX' in o ? -o.wheelDeltaX : 0
    },
    deltaY: function(o) {
      return 'deltaY' in o
        ? o.deltaY
        : 'wheelDeltaY' in o
        ? -o.wheelDeltaY
        : 'wheelDelta' in o
        ? -o.wheelDelta
        : 0
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  Zd = rd(Yd),
  $d = [9, 13, 27, 32],
  ae = fa && 'CompositionEvent' in window,
  be = null
fa && 'documentMode' in document && (be = document.documentMode)
var ce = fa && 'TextEvent' in window && !be,
  de = fa && (!ae || (be && 8 < be && 11 >= be)),
  ee = ' ',
  fe = !1
function ge(o, a) {
  switch (o) {
    case 'keyup':
      return $d.indexOf(a.keyCode) !== -1
    case 'keydown':
      return a.keyCode !== 229
    case 'keypress':
    case 'mousedown':
    case 'focusout':
      return !0
    default:
      return !1
  }
}
function he(o) {
  return (o = o.detail), typeof o == 'object' && 'data' in o ? o.data : null
}
var ie = !1
function je(o, a) {
  switch (o) {
    case 'compositionend':
      return he(a)
    case 'keypress':
      return a.which !== 32 ? null : ((fe = !0), ee)
    case 'textInput':
      return (o = a.data), o === ee && fe ? null : o
    default:
      return null
  }
}
function ke(o, a) {
  if (ie)
    return o === 'compositionend' || (!ae && ge(o, a))
      ? ((o = nd()), (md = ld = kd = null), (ie = !1), o)
      : null
  switch (o) {
    case 'paste':
      return null
    case 'keypress':
      if (!(a.ctrlKey || a.altKey || a.metaKey) || (a.ctrlKey && a.altKey)) {
        if (a.char && 1 < a.char.length) return a.char
        if (a.which) return String.fromCharCode(a.which)
      }
      return null
    case 'compositionend':
      return de && a.locale !== 'ko' ? null : a.data
    default:
      return null
  }
}
var le = {
  color: !0,
  date: !0,
  datetime: !0,
  'datetime-local': !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
}
function me(o) {
  var a = o && o.nodeName && o.nodeName.toLowerCase()
  return a === 'input' ? !!le[o.type] : a === 'textarea'
}
function ne(o, a, s, $) {
  Eb($),
    (a = oe(a, 'onChange')),
    0 < a.length &&
      ((s = new td('onChange', 'change', null, s, $)),
      o.push({ event: s, listeners: a }))
}
var pe = null,
  qe = null
function re(o) {
  se(o, 0)
}
function te(o) {
  var a = ue(o)
  if (Wa(a)) return o
}
function ve(o, a) {
  if (o === 'change') return a
}
var we = !1
if (fa) {
  var xe
  if (fa) {
    var ye = 'oninput' in document
    if (!ye) {
      var ze = document.createElement('div')
      ze.setAttribute('oninput', 'return;'),
        (ye = typeof ze.oninput == 'function')
    }
    xe = ye
  } else xe = !1
  we = xe && (!document.documentMode || 9 < document.documentMode)
}
function Ae() {
  pe && (pe.detachEvent('onpropertychange', Be), (qe = pe = null))
}
function Be(o) {
  if (o.propertyName === 'value' && te(qe)) {
    var a = []
    if ((ne(a, qe, o, xb(o)), (o = re), Kb)) o(a)
    else {
      Kb = !0
      try {
        Gb(o, a)
      } finally {
        ;(Kb = !1), Mb()
      }
    }
  }
}
function Ce(o, a, s) {
  o === 'focusin'
    ? (Ae(), (pe = a), (qe = s), pe.attachEvent('onpropertychange', Be))
    : o === 'focusout' && Ae()
}
function De(o) {
  if (o === 'selectionchange' || o === 'keyup' || o === 'keydown') return te(qe)
}
function Ee(o, a) {
  if (o === 'click') return te(a)
}
function Fe(o, a) {
  if (o === 'input' || o === 'change') return te(a)
}
function Ge(o, a) {
  return (o === a && (o !== 0 || 1 / o === 1 / a)) || (o !== o && a !== a)
}
var He = typeof Object.is == 'function' ? Object.is : Ge,
  Ie = Object.prototype.hasOwnProperty
function Je(o, a) {
  if (He(o, a)) return !0
  if (typeof o != 'object' || o === null || typeof a != 'object' || a === null)
    return !1
  var s = Object.keys(o),
    $ = Object.keys(a)
  if (s.length !== $.length) return !1
  for ($ = 0; $ < s.length; $++)
    if (!Ie.call(a, s[$]) || !He(o[s[$]], a[s[$]])) return !1
  return !0
}
function Ke(o) {
  for (; o && o.firstChild; ) o = o.firstChild
  return o
}
function Le(o, a) {
  var s = Ke(o)
  o = 0
  for (var $; s; ) {
    if (s.nodeType === 3) {
      if ((($ = o + s.textContent.length), o <= a && $ >= a))
        return { node: s, offset: a - o }
      o = $
    }
    e: {
      for (; s; ) {
        if (s.nextSibling) {
          s = s.nextSibling
          break e
        }
        s = s.parentNode
      }
      s = void 0
    }
    s = Ke(s)
  }
}
function Me(o, a) {
  return o && a
    ? o === a
      ? !0
      : o && o.nodeType === 3
      ? !1
      : a && a.nodeType === 3
      ? Me(o, a.parentNode)
      : 'contains' in o
      ? o.contains(a)
      : o.compareDocumentPosition
      ? !!(o.compareDocumentPosition(a) & 16)
      : !1
    : !1
}
function Ne() {
  for (var o = window, a = Xa(); a instanceof o.HTMLIFrameElement; ) {
    try {
      var s = typeof a.contentWindow.location.href == 'string'
    } catch {
      s = !1
    }
    if (s) o = a.contentWindow
    else break
    a = Xa(o.document)
  }
  return a
}
function Oe(o) {
  var a = o && o.nodeName && o.nodeName.toLowerCase()
  return (
    a &&
    ((a === 'input' &&
      (o.type === 'text' ||
        o.type === 'search' ||
        o.type === 'tel' ||
        o.type === 'url' ||
        o.type === 'password')) ||
      a === 'textarea' ||
      o.contentEditable === 'true')
  )
}
var Pe = fa && 'documentMode' in document && 11 >= document.documentMode,
  Qe = null,
  Re = null,
  Se = null,
  Te = !1
function Ue(o, a, s) {
  var $ = s.window === s ? s.document : s.nodeType === 9 ? s : s.ownerDocument
  Te ||
    Qe == null ||
    Qe !== Xa($) ||
    (($ = Qe),
    'selectionStart' in $ && Oe($)
      ? ($ = { start: $.selectionStart, end: $.selectionEnd })
      : (($ = (
          ($.ownerDocument && $.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        ($ = {
          anchorNode: $.anchorNode,
          anchorOffset: $.anchorOffset,
          focusNode: $.focusNode,
          focusOffset: $.focusOffset,
        })),
    (Se && Je(Se, $)) ||
      ((Se = $),
      ($ = oe(Re, 'onSelect')),
      0 < $.length &&
        ((a = new td('onSelect', 'select', null, a, s)),
        o.push({ event: a, listeners: $ }),
        (a.target = Qe))))
}
Pc(
  'cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange'.split(
    ' '
  ),
  0
)
Pc(
  'drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel'.split(
    ' '
  ),
  1
)
Pc(Oc, 2)
for (
  var Ve = 'change selectionchange textInput compositionstart compositionend compositionupdate'.split(
      ' '
    ),
    We = 0;
  We < Ve.length;
  We++
)
  Nc.set(Ve[We], 0)
ea('onMouseEnter', ['mouseout', 'mouseover'])
ea('onMouseLeave', ['mouseout', 'mouseover'])
ea('onPointerEnter', ['pointerout', 'pointerover'])
ea('onPointerLeave', ['pointerout', 'pointerover'])
da(
  'onChange',
  'change click focusin focusout input keydown keyup selectionchange'.split(' ')
)
da(
  'onSelect',
  'focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange'.split(
    ' '
  )
)
da('onBeforeInput', ['compositionend', 'keypress', 'textInput', 'paste'])
da(
  'onCompositionEnd',
  'compositionend focusout keydown keypress keyup mousedown'.split(' ')
)
da(
  'onCompositionStart',
  'compositionstart focusout keydown keypress keyup mousedown'.split(' ')
)
da(
  'onCompositionUpdate',
  'compositionupdate focusout keydown keypress keyup mousedown'.split(' ')
)
var Xe = 'abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting'.split(
    ' '
  ),
  Ye = new Set('cancel close invalid load scroll toggle'.split(' ').concat(Xe))
function Ze(o, a, s) {
  var $ = o.type || 'unknown-event'
  ;(o.currentTarget = s), Yb($, a, void 0, o), (o.currentTarget = null)
}
function se(o, a) {
  a = (a & 4) !== 0
  for (var s = 0; s < o.length; s++) {
    var $ = o[s],
      j = $.event
    $ = $.listeners
    e: {
      var _e = void 0
      if (a)
        for (var et = $.length - 1; 0 <= et; et--) {
          var tt = $[et],
            rt = tt.instance,
            nt = tt.currentTarget
          if (((tt = tt.listener), rt !== _e && j.isPropagationStopped()))
            break e
          Ze(j, tt, nt), (_e = rt)
        }
      else
        for (et = 0; et < $.length; et++) {
          if (
            ((tt = $[et]),
            (rt = tt.instance),
            (nt = tt.currentTarget),
            (tt = tt.listener),
            rt !== _e && j.isPropagationStopped())
          )
            break e
          Ze(j, tt, nt), (_e = rt)
        }
    }
  }
  if (Ub) throw ((o = Vb), (Ub = !1), (Vb = null), o)
}
function G(o, a) {
  var s = $e(a),
    $ = o + '__bubble'
  s.has($) || (af(a, o, 2, !1), s.add($))
}
var bf =
  '_reactListening' +
  Math.random()
    .toString(36)
    .slice(2)
function cf(o) {
  o[bf] ||
    ((o[bf] = !0),
    ba.forEach(function(a) {
      Ye.has(a) || df(a, !1, o, null), df(a, !0, o, null)
    }))
}
function df(o, a, s, $) {
  var j = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0,
    _e = s
  o === 'selectionchange' && s.nodeType !== 9 && (_e = s.ownerDocument)
  var et = $e(_e),
    tt = o + '__' + (a ? 'capture' : 'bubble')
  et.has(tt) || (a && (j |= 4), af(_e, o, j, a), et.add(tt))
}
function af(o, a, s, $) {
  var j = Nc.get(a)
  switch (j === void 0 ? 2 : j) {
    case 0:
      j = gd
      break
    case 1:
      j = id
      break
    default:
      j = hd
  }
  ;(s = j.bind(null, a, s, o)),
    (j = void 0),
    !Pb ||
      (a !== 'touchstart' && a !== 'touchmove' && a !== 'wheel') ||
      (j = !0),
    $
      ? j !== void 0
        ? o.addEventListener(a, s, { capture: !0, passive: j })
        : o.addEventListener(a, s, !0)
      : j !== void 0
      ? o.addEventListener(a, s, { passive: j })
      : o.addEventListener(a, s, !1)
}
function jd(o, a, s, $, j) {
  var _e = $
  if (!(a & 1) && !(a & 2) && $ !== null)
    e: for (;;) {
      if ($ === null) return
      var et = $.tag
      if (et === 3 || et === 4) {
        var tt = $.stateNode.containerInfo
        if (tt === j || (tt.nodeType === 8 && tt.parentNode === j)) break
        if (et === 4)
          for (et = $.return; et !== null; ) {
            var rt = et.tag
            if (
              (rt === 3 || rt === 4) &&
              ((rt = et.stateNode.containerInfo),
              rt === j || (rt.nodeType === 8 && rt.parentNode === j))
            )
              return
            et = et.return
          }
        for (; tt !== null; ) {
          if (((et = wc(tt)), et === null)) return
          if (((rt = et.tag), rt === 5 || rt === 6)) {
            $ = _e = et
            continue e
          }
          tt = tt.parentNode
        }
      }
      $ = $.return
    }
  Nb(function() {
    var nt = _e,
      it = xb(s),
      ot = []
    e: {
      var at = Mc.get(o)
      if (at !== void 0) {
        var st = td,
          ut = o
        switch (o) {
          case 'keypress':
            if (od(s) === 0) break e
          case 'keydown':
          case 'keyup':
            st = Rd
            break
          case 'focusin':
            ;(ut = 'focus'), (st = Fd)
            break
          case 'focusout':
            ;(ut = 'blur'), (st = Fd)
            break
          case 'beforeblur':
          case 'afterblur':
            st = Fd
            break
          case 'click':
            if (s.button === 2) break e
          case 'auxclick':
          case 'dblclick':
          case 'mousedown':
          case 'mousemove':
          case 'mouseup':
          case 'mouseout':
          case 'mouseover':
          case 'contextmenu':
            st = Bd
            break
          case 'drag':
          case 'dragend':
          case 'dragenter':
          case 'dragexit':
          case 'dragleave':
          case 'dragover':
          case 'dragstart':
          case 'drop':
            st = Dd
            break
          case 'touchcancel':
          case 'touchend':
          case 'touchmove':
          case 'touchstart':
            st = Vd
            break
          case Ic:
          case Jc:
          case Kc:
            st = Hd
            break
          case Lc:
            st = Xd
            break
          case 'scroll':
            st = vd
            break
          case 'wheel':
            st = Zd
            break
          case 'copy':
          case 'cut':
          case 'paste':
            st = Jd
            break
          case 'gotpointercapture':
          case 'lostpointercapture':
          case 'pointercancel':
          case 'pointerdown':
          case 'pointermove':
          case 'pointerout':
          case 'pointerover':
          case 'pointerup':
            st = Td
        }
        var ct = (a & 4) !== 0,
          dt = !ct && o === 'scroll',
          ft = ct ? (at !== null ? at + 'Capture' : null) : at
        ct = []
        for (var mt = nt, vt; mt !== null; ) {
          vt = mt
          var yt = vt.stateNode
          if (
            (vt.tag === 5 &&
              yt !== null &&
              ((vt = yt),
              ft !== null &&
                ((yt = Ob(mt, ft)), yt != null && ct.push(ef(mt, yt, vt)))),
            dt)
          )
            break
          mt = mt.return
        }
        0 < ct.length &&
          ((at = new st(at, ut, null, s, it)),
          ot.push({ event: at, listeners: ct }))
      }
    }
    if (!(a & 7)) {
      e: {
        if (
          ((at = o === 'mouseover' || o === 'pointerover'),
          (st = o === 'mouseout' || o === 'pointerout'),
          at &&
            !(a & 16) &&
            (ut = s.relatedTarget || s.fromElement) &&
            (wc(ut) || ut[ff]))
        )
          break e
        if (
          (st || at) &&
          ((at =
            it.window === it
              ? it
              : (at = it.ownerDocument)
              ? at.defaultView || at.parentWindow
              : window),
          st
            ? ((ut = s.relatedTarget || s.toElement),
              (st = nt),
              (ut = ut ? wc(ut) : null),
              ut !== null &&
                ((dt = Zb(ut)), ut !== dt || (ut.tag !== 5 && ut.tag !== 6)) &&
                (ut = null))
            : ((st = null), (ut = nt)),
          st !== ut)
        ) {
          if (
            ((ct = Bd),
            (yt = 'onMouseLeave'),
            (ft = 'onMouseEnter'),
            (mt = 'mouse'),
            (o === 'pointerout' || o === 'pointerover') &&
              ((ct = Td),
              (yt = 'onPointerLeave'),
              (ft = 'onPointerEnter'),
              (mt = 'pointer')),
            (dt = st == null ? at : ue(st)),
            (vt = ut == null ? at : ue(ut)),
            (at = new ct(yt, mt + 'leave', st, s, it)),
            (at.target = dt),
            (at.relatedTarget = vt),
            (yt = null),
            wc(it) === nt &&
              ((ct = new ct(ft, mt + 'enter', ut, s, it)),
              (ct.target = vt),
              (ct.relatedTarget = dt),
              (yt = ct)),
            (dt = yt),
            st && ut)
          )
            t: {
              for (ct = st, ft = ut, mt = 0, vt = ct; vt; vt = gf(vt)) mt++
              for (vt = 0, yt = ft; yt; yt = gf(yt)) vt++
              for (; 0 < mt - vt; ) (ct = gf(ct)), mt--
              for (; 0 < vt - mt; ) (ft = gf(ft)), vt--
              for (; mt--; ) {
                if (ct === ft || (ft !== null && ct === ft.alternate)) break t
                ;(ct = gf(ct)), (ft = gf(ft))
              }
              ct = null
            }
          else ct = null
          st !== null && hf(ot, at, st, ct, !1),
            ut !== null && dt !== null && hf(ot, dt, ut, ct, !0)
        }
      }
      e: {
        if (
          ((at = nt ? ue(nt) : window),
          (st = at.nodeName && at.nodeName.toLowerCase()),
          st === 'select' || (st === 'input' && at.type === 'file'))
        )
          var pt = ve
        else if (me(at))
          if (we) pt = Fe
          else {
            pt = De
            var ht = Ce
          }
        else
          (st = at.nodeName) &&
            st.toLowerCase() === 'input' &&
            (at.type === 'checkbox' || at.type === 'radio') &&
            (pt = Ee)
        if (pt && (pt = pt(o, nt))) {
          ne(ot, pt, s, it)
          break e
        }
        ht && ht(o, at, nt),
          o === 'focusout' &&
            (ht = at._wrapperState) &&
            ht.controlled &&
            at.type === 'number' &&
            bb(at, 'number', at.value)
      }
      switch (((ht = nt ? ue(nt) : window), o)) {
        case 'focusin':
          ;(me(ht) || ht.contentEditable === 'true') &&
            ((Qe = ht), (Re = nt), (Se = null))
          break
        case 'focusout':
          Se = Re = Qe = null
          break
        case 'mousedown':
          Te = !0
          break
        case 'contextmenu':
        case 'mouseup':
        case 'dragend':
          ;(Te = !1), Ue(ot, s, it)
          break
        case 'selectionchange':
          if (Pe) break
        case 'keydown':
        case 'keyup':
          Ue(ot, s, it)
      }
      var At
      if (ae)
        e: {
          switch (o) {
            case 'compositionstart':
              var wt = 'onCompositionStart'
              break e
            case 'compositionend':
              wt = 'onCompositionEnd'
              break e
            case 'compositionupdate':
              wt = 'onCompositionUpdate'
              break e
          }
          wt = void 0
        }
      else
        ie
          ? ge(o, s) && (wt = 'onCompositionEnd')
          : o === 'keydown' && s.keyCode === 229 && (wt = 'onCompositionStart')
      wt &&
        (de &&
          s.locale !== 'ko' &&
          (ie || wt !== 'onCompositionStart'
            ? wt === 'onCompositionEnd' && ie && (At = nd())
            : ((kd = it),
              (ld = 'value' in kd ? kd.value : kd.textContent),
              (ie = !0))),
        (ht = oe(nt, wt)),
        0 < ht.length &&
          ((wt = new Ld(wt, o, null, s, it)),
          ot.push({ event: wt, listeners: ht }),
          At ? (wt.data = At) : ((At = he(s)), At !== null && (wt.data = At)))),
        (At = ce ? je(o, s) : ke(o, s)) &&
          ((nt = oe(nt, 'onBeforeInput')),
          0 < nt.length &&
            ((it = new Ld('onBeforeInput', 'beforeinput', null, s, it)),
            ot.push({ event: it, listeners: nt }),
            (it.data = At)))
    }
    se(ot, a)
  })
}
function ef(o, a, s) {
  return { instance: o, listener: a, currentTarget: s }
}
function oe(o, a) {
  for (var s = a + 'Capture', $ = []; o !== null; ) {
    var j = o,
      _e = j.stateNode
    j.tag === 5 &&
      _e !== null &&
      ((j = _e),
      (_e = Ob(o, s)),
      _e != null && $.unshift(ef(o, _e, j)),
      (_e = Ob(o, a)),
      _e != null && $.push(ef(o, _e, j))),
      (o = o.return)
  }
  return $
}
function gf(o) {
  if (o === null) return null
  do o = o.return
  while (o && o.tag !== 5)
  return o || null
}
function hf(o, a, s, $, j) {
  for (var _e = a._reactName, et = []; s !== null && s !== $; ) {
    var tt = s,
      rt = tt.alternate,
      nt = tt.stateNode
    if (rt !== null && rt === $) break
    tt.tag === 5 &&
      nt !== null &&
      ((tt = nt),
      j
        ? ((rt = Ob(s, _e)), rt != null && et.unshift(ef(s, rt, tt)))
        : j || ((rt = Ob(s, _e)), rt != null && et.push(ef(s, rt, tt)))),
      (s = s.return)
  }
  et.length !== 0 && o.push({ event: a, listeners: et })
}
function jf() {}
var kf = null,
  lf = null
function mf(o, a) {
  switch (o) {
    case 'button':
    case 'input':
    case 'select':
    case 'textarea':
      return !!a.autoFocus
  }
  return !1
}
function nf(o, a) {
  return (
    o === 'textarea' ||
    o === 'option' ||
    o === 'noscript' ||
    typeof a.children == 'string' ||
    typeof a.children == 'number' ||
    (typeof a.dangerouslySetInnerHTML == 'object' &&
      a.dangerouslySetInnerHTML !== null &&
      a.dangerouslySetInnerHTML.__html != null)
  )
}
var of = typeof setTimeout == 'function' ? setTimeout : void 0,
  pf = typeof clearTimeout == 'function' ? clearTimeout : void 0
function qf(o) {
  o.nodeType === 1
    ? (o.textContent = '')
    : o.nodeType === 9 && ((o = o.body), o != null && (o.textContent = ''))
}
function rf(o) {
  for (; o != null; o = o.nextSibling) {
    var a = o.nodeType
    if (a === 1 || a === 3) break
  }
  return o
}
function sf(o) {
  o = o.previousSibling
  for (var a = 0; o; ) {
    if (o.nodeType === 8) {
      var s = o.data
      if (s === '$' || s === '$!' || s === '$?') {
        if (a === 0) return o
        a--
      } else s === '/$' && a++
    }
    o = o.previousSibling
  }
  return null
}
var tf = 0
function uf(o) {
  return { $$typeof: Ga, toString: o, valueOf: o }
}
var vf = Math.random()
    .toString(36)
    .slice(2),
  wf = '__reactFiber$' + vf,
  xf = '__reactProps$' + vf,
  ff = '__reactContainer$' + vf,
  yf = '__reactEvents$' + vf
function wc(o) {
  var a = o[wf]
  if (a) return a
  for (var s = o.parentNode; s; ) {
    if ((a = s[ff] || s[wf])) {
      if (
        ((s = a.alternate),
        a.child !== null || (s !== null && s.child !== null))
      )
        for (o = sf(o); o !== null; ) {
          if ((s = o[wf])) return s
          o = sf(o)
        }
      return a
    }
    ;(o = s), (s = o.parentNode)
  }
  return null
}
function Cb(o) {
  return (
    (o = o[wf] || o[ff]),
    !o || (o.tag !== 5 && o.tag !== 6 && o.tag !== 13 && o.tag !== 3) ? null : o
  )
}
function ue(o) {
  if (o.tag === 5 || o.tag === 6) return o.stateNode
  throw Error(y$3(33))
}
function Db(o) {
  return o[xf] || null
}
function $e(o) {
  var a = o[yf]
  return a === void 0 && (a = o[yf] = new Set()), a
}
var zf = [],
  Af = -1
function Bf(o) {
  return { current: o }
}
function H(o) {
  0 > Af || ((o.current = zf[Af]), (zf[Af] = null), Af--)
}
function I(o, a) {
  Af++, (zf[Af] = o.current), (o.current = a)
}
var Cf = {},
  M = Bf(Cf),
  N = Bf(!1),
  Df = Cf
function Ef(o, a) {
  var s = o.type.contextTypes
  if (!s) return Cf
  var $ = o.stateNode
  if ($ && $.__reactInternalMemoizedUnmaskedChildContext === a)
    return $.__reactInternalMemoizedMaskedChildContext
  var j = {},
    _e
  for (_e in s) j[_e] = a[_e]
  return (
    $ &&
      ((o = o.stateNode),
      (o.__reactInternalMemoizedUnmaskedChildContext = a),
      (o.__reactInternalMemoizedMaskedChildContext = j)),
    j
  )
}
function Ff(o) {
  return (o = o.childContextTypes), o != null
}
function Gf() {
  H(N), H(M)
}
function Hf(o, a, s) {
  if (M.current !== Cf) throw Error(y$3(168))
  I(M, a), I(N, s)
}
function If(o, a, s) {
  var $ = o.stateNode
  if (((o = a.childContextTypes), typeof $.getChildContext != 'function'))
    return s
  $ = $.getChildContext()
  for (var j in $) if (!(j in o)) throw Error(y$3(108, Ra(a) || 'Unknown', j))
  return m$4({}, s, $)
}
function Jf(o) {
  return (
    (o =
      ((o = o.stateNode) && o.__reactInternalMemoizedMergedChildContext) || Cf),
    (Df = M.current),
    I(M, o),
    I(N, N.current),
    !0
  )
}
function Kf(o, a, s) {
  var $ = o.stateNode
  if (!$) throw Error(y$3(169))
  s
    ? ((o = If(o, a, Df)),
      ($.__reactInternalMemoizedMergedChildContext = o),
      H(N),
      H(M),
      I(M, o))
    : H(N),
    I(N, s)
}
var Lf = null,
  Mf = null,
  Nf = r$5.unstable_runWithPriority,
  Of = r$5.unstable_scheduleCallback,
  Pf = r$5.unstable_cancelCallback,
  Qf = r$5.unstable_shouldYield,
  Rf = r$5.unstable_requestPaint,
  Sf = r$5.unstable_now,
  Tf = r$5.unstable_getCurrentPriorityLevel,
  Uf = r$5.unstable_ImmediatePriority,
  Vf = r$5.unstable_UserBlockingPriority,
  Wf = r$5.unstable_NormalPriority,
  Xf = r$5.unstable_LowPriority,
  Yf = r$5.unstable_IdlePriority,
  Zf = {},
  $f = Rf !== void 0 ? Rf : function() {},
  ag = null,
  bg = null,
  cg = !1,
  dg = Sf(),
  O =
    1e4 > dg
      ? Sf
      : function() {
          return Sf() - dg
        }
function eg() {
  switch (Tf()) {
    case Uf:
      return 99
    case Vf:
      return 98
    case Wf:
      return 97
    case Xf:
      return 96
    case Yf:
      return 95
    default:
      throw Error(y$3(332))
  }
}
function fg(o) {
  switch (o) {
    case 99:
      return Uf
    case 98:
      return Vf
    case 97:
      return Wf
    case 96:
      return Xf
    case 95:
      return Yf
    default:
      throw Error(y$3(332))
  }
}
function gg(o, a) {
  return (o = fg(o)), Nf(o, a)
}
function hg(o, a, s) {
  return (o = fg(o)), Of(o, a, s)
}
function ig() {
  if (bg !== null) {
    var o = bg
    ;(bg = null), Pf(o)
  }
  jg()
}
function jg() {
  if (!cg && ag !== null) {
    cg = !0
    var o = 0
    try {
      var a = ag
      gg(99, function() {
        for (; o < a.length; o++) {
          var s = a[o]
          do s = s(!0)
          while (s !== null)
        }
      }),
        (ag = null)
    } catch (s) {
      throw (ag !== null && (ag = ag.slice(o + 1)), Of(Uf, ig), s)
    } finally {
      cg = !1
    }
  }
}
var kg = ra.ReactCurrentBatchConfig
function lg(o, a) {
  if (o && o.defaultProps) {
    ;(a = m$4({}, a)), (o = o.defaultProps)
    for (var s in o) a[s] === void 0 && (a[s] = o[s])
    return a
  }
  return a
}
var mg = Bf(null),
  ng = null,
  og = null,
  pg = null
function qg() {
  pg = og = ng = null
}
function rg(o) {
  var a = mg.current
  H(mg), (o.type._context._currentValue = a)
}
function sg(o, a) {
  for (; o !== null; ) {
    var s = o.alternate
    if ((o.childLanes & a) === a) {
      if (s === null || (s.childLanes & a) === a) break
      s.childLanes |= a
    } else (o.childLanes |= a), s !== null && (s.childLanes |= a)
    o = o.return
  }
}
function tg(o, a) {
  ;(ng = o),
    (pg = og = null),
    (o = o.dependencies),
    o !== null &&
      o.firstContext !== null &&
      (o.lanes & a && (ug = !0), (o.firstContext = null))
}
function vg(o, a) {
  if (pg !== o && a !== !1 && a !== 0)
    if (
      ((typeof a != 'number' || a === 1073741823) &&
        ((pg = o), (a = 1073741823)),
      (a = { context: o, observedBits: a, next: null }),
      og === null)
    ) {
      if (ng === null) throw Error(y$3(308))
      ;(og = a),
        (ng.dependencies = { lanes: 0, firstContext: a, responders: null })
    } else og = og.next = a
  return o._currentValue
}
var wg = !1
function xg(o) {
  o.updateQueue = {
    baseState: o.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null },
    effects: null,
  }
}
function yg(o, a) {
  ;(o = o.updateQueue),
    a.updateQueue === o &&
      (a.updateQueue = {
        baseState: o.baseState,
        firstBaseUpdate: o.firstBaseUpdate,
        lastBaseUpdate: o.lastBaseUpdate,
        shared: o.shared,
        effects: o.effects,
      })
}
function zg(o, a) {
  return {
    eventTime: o,
    lane: a,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  }
}
function Ag(o, a) {
  if (((o = o.updateQueue), o !== null)) {
    o = o.shared
    var s = o.pending
    s === null ? (a.next = a) : ((a.next = s.next), (s.next = a)),
      (o.pending = a)
  }
}
function Bg(o, a) {
  var s = o.updateQueue,
    $ = o.alternate
  if ($ !== null && (($ = $.updateQueue), s === $)) {
    var j = null,
      _e = null
    if (((s = s.firstBaseUpdate), s !== null)) {
      do {
        var et = {
          eventTime: s.eventTime,
          lane: s.lane,
          tag: s.tag,
          payload: s.payload,
          callback: s.callback,
          next: null,
        }
        _e === null ? (j = _e = et) : (_e = _e.next = et), (s = s.next)
      } while (s !== null)
      _e === null ? (j = _e = a) : (_e = _e.next = a)
    } else j = _e = a
    ;(s = {
      baseState: $.baseState,
      firstBaseUpdate: j,
      lastBaseUpdate: _e,
      shared: $.shared,
      effects: $.effects,
    }),
      (o.updateQueue = s)
    return
  }
  ;(o = s.lastBaseUpdate),
    o === null ? (s.firstBaseUpdate = a) : (o.next = a),
    (s.lastBaseUpdate = a)
}
function Cg(o, a, s, $) {
  var j = o.updateQueue
  wg = !1
  var _e = j.firstBaseUpdate,
    et = j.lastBaseUpdate,
    tt = j.shared.pending
  if (tt !== null) {
    j.shared.pending = null
    var rt = tt,
      nt = rt.next
    ;(rt.next = null), et === null ? (_e = nt) : (et.next = nt), (et = rt)
    var it = o.alternate
    if (it !== null) {
      it = it.updateQueue
      var ot = it.lastBaseUpdate
      ot !== et &&
        (ot === null ? (it.firstBaseUpdate = nt) : (ot.next = nt),
        (it.lastBaseUpdate = rt))
    }
  }
  if (_e !== null) {
    ;(ot = j.baseState), (et = 0), (it = nt = rt = null)
    do {
      tt = _e.lane
      var at = _e.eventTime
      if (($ & tt) === tt) {
        it !== null &&
          (it = it.next = {
            eventTime: at,
            lane: 0,
            tag: _e.tag,
            payload: _e.payload,
            callback: _e.callback,
            next: null,
          })
        e: {
          var st = o,
            ut = _e
          switch (((tt = a), (at = s), ut.tag)) {
            case 1:
              if (((st = ut.payload), typeof st == 'function')) {
                ot = st.call(at, ot, tt)
                break e
              }
              ot = st
              break e
            case 3:
              st.flags = (st.flags & -4097) | 64
            case 0:
              if (
                ((st = ut.payload),
                (tt = typeof st == 'function' ? st.call(at, ot, tt) : st),
                tt == null)
              )
                break e
              ot = m$4({}, ot, tt)
              break e
            case 2:
              wg = !0
          }
        }
        _e.callback !== null &&
          ((o.flags |= 32),
          (tt = j.effects),
          tt === null ? (j.effects = [_e]) : tt.push(_e))
      } else
        (at = {
          eventTime: at,
          lane: tt,
          tag: _e.tag,
          payload: _e.payload,
          callback: _e.callback,
          next: null,
        }),
          it === null ? ((nt = it = at), (rt = ot)) : (it = it.next = at),
          (et |= tt)
      if (((_e = _e.next), _e === null)) {
        if (((tt = j.shared.pending), tt === null)) break
        ;(_e = tt.next),
          (tt.next = null),
          (j.lastBaseUpdate = tt),
          (j.shared.pending = null)
      }
    } while (!0)
    it === null && (rt = ot),
      (j.baseState = rt),
      (j.firstBaseUpdate = nt),
      (j.lastBaseUpdate = it),
      (Dg |= et),
      (o.lanes = et),
      (o.memoizedState = ot)
  }
}
function Eg(o, a, s) {
  if (((o = a.effects), (a.effects = null), o !== null))
    for (a = 0; a < o.length; a++) {
      var $ = o[a],
        j = $.callback
      if (j !== null) {
        if ((($.callback = null), ($ = s), typeof j != 'function'))
          throw Error(y$3(191, j))
        j.call($)
      }
    }
}
var Fg = new aa.Component().refs
function Gg(o, a, s, $) {
  ;(a = o.memoizedState),
    (s = s($, a)),
    (s = s == null ? a : m$4({}, a, s)),
    (o.memoizedState = s),
    o.lanes === 0 && (o.updateQueue.baseState = s)
}
var Kg = {
  isMounted: function(o) {
    return (o = o._reactInternals) ? Zb(o) === o : !1
  },
  enqueueSetState: function(o, a, s) {
    o = o._reactInternals
    var $ = Hg(),
      j = Ig(o),
      _e = zg($, j)
    ;(_e.payload = a), s != null && (_e.callback = s), Ag(o, _e), Jg(o, j, $)
  },
  enqueueReplaceState: function(o, a, s) {
    o = o._reactInternals
    var $ = Hg(),
      j = Ig(o),
      _e = zg($, j)
    ;(_e.tag = 1),
      (_e.payload = a),
      s != null && (_e.callback = s),
      Ag(o, _e),
      Jg(o, j, $)
  },
  enqueueForceUpdate: function(o, a) {
    o = o._reactInternals
    var s = Hg(),
      $ = Ig(o),
      j = zg(s, $)
    ;(j.tag = 2), a != null && (j.callback = a), Ag(o, j), Jg(o, $, s)
  },
}
function Lg(o, a, s, $, j, _e, et) {
  return (
    (o = o.stateNode),
    typeof o.shouldComponentUpdate == 'function'
      ? o.shouldComponentUpdate($, _e, et)
      : a.prototype && a.prototype.isPureReactComponent
      ? !Je(s, $) || !Je(j, _e)
      : !0
  )
}
function Mg(o, a, s) {
  var $ = !1,
    j = Cf,
    _e = a.contextType
  return (
    typeof _e == 'object' && _e !== null
      ? (_e = vg(_e))
      : ((j = Ff(a) ? Df : M.current),
        ($ = a.contextTypes),
        (_e = ($ = $ != null) ? Ef(o, j) : Cf)),
    (a = new a(s, _e)),
    (o.memoizedState = a.state !== null && a.state !== void 0 ? a.state : null),
    (a.updater = Kg),
    (o.stateNode = a),
    (a._reactInternals = o),
    $ &&
      ((o = o.stateNode),
      (o.__reactInternalMemoizedUnmaskedChildContext = j),
      (o.__reactInternalMemoizedMaskedChildContext = _e)),
    a
  )
}
function Ng(o, a, s, $) {
  ;(o = a.state),
    typeof a.componentWillReceiveProps == 'function' &&
      a.componentWillReceiveProps(s, $),
    typeof a.UNSAFE_componentWillReceiveProps == 'function' &&
      a.UNSAFE_componentWillReceiveProps(s, $),
    a.state !== o && Kg.enqueueReplaceState(a, a.state, null)
}
function Og(o, a, s, $) {
  var j = o.stateNode
  ;(j.props = s), (j.state = o.memoizedState), (j.refs = Fg), xg(o)
  var _e = a.contextType
  typeof _e == 'object' && _e !== null
    ? (j.context = vg(_e))
    : ((_e = Ff(a) ? Df : M.current), (j.context = Ef(o, _e))),
    Cg(o, s, j, $),
    (j.state = o.memoizedState),
    (_e = a.getDerivedStateFromProps),
    typeof _e == 'function' && (Gg(o, a, _e, s), (j.state = o.memoizedState)),
    typeof a.getDerivedStateFromProps == 'function' ||
      typeof j.getSnapshotBeforeUpdate == 'function' ||
      (typeof j.UNSAFE_componentWillMount != 'function' &&
        typeof j.componentWillMount != 'function') ||
      ((a = j.state),
      typeof j.componentWillMount == 'function' && j.componentWillMount(),
      typeof j.UNSAFE_componentWillMount == 'function' &&
        j.UNSAFE_componentWillMount(),
      a !== j.state && Kg.enqueueReplaceState(j, j.state, null),
      Cg(o, s, j, $),
      (j.state = o.memoizedState)),
    typeof j.componentDidMount == 'function' && (o.flags |= 4)
}
var Pg = Array.isArray
function Qg(o, a, s) {
  if (
    ((o = s.ref), o !== null && typeof o != 'function' && typeof o != 'object')
  ) {
    if (s._owner) {
      if (((s = s._owner), s)) {
        if (s.tag !== 1) throw Error(y$3(309))
        var $ = s.stateNode
      }
      if (!$) throw Error(y$3(147, o))
      var j = '' + o
      return a !== null &&
        a.ref !== null &&
        typeof a.ref == 'function' &&
        a.ref._stringRef === j
        ? a.ref
        : ((a = function(_e) {
            var et = $.refs
            et === Fg && (et = $.refs = {}),
              _e === null ? delete et[j] : (et[j] = _e)
          }),
          (a._stringRef = j),
          a)
    }
    if (typeof o != 'string') throw Error(y$3(284))
    if (!s._owner) throw Error(y$3(290, o))
  }
  return o
}
function Rg(o, a) {
  if (o.type !== 'textarea')
    throw Error(
      y$3(
        31,
        Object.prototype.toString.call(a) === '[object Object]'
          ? 'object with keys {' + Object.keys(a).join(', ') + '}'
          : a
      )
    )
}
function Sg(o) {
  function a(dt, ft) {
    if (o) {
      var mt = dt.lastEffect
      mt !== null
        ? ((mt.nextEffect = ft), (dt.lastEffect = ft))
        : (dt.firstEffect = dt.lastEffect = ft),
        (ft.nextEffect = null),
        (ft.flags = 8)
    }
  }
  function s(dt, ft) {
    if (!o) return null
    for (; ft !== null; ) a(dt, ft), (ft = ft.sibling)
    return null
  }
  function $(dt, ft) {
    for (dt = new Map(); ft !== null; )
      ft.key !== null ? dt.set(ft.key, ft) : dt.set(ft.index, ft),
        (ft = ft.sibling)
    return dt
  }
  function j(dt, ft) {
    return (dt = Tg(dt, ft)), (dt.index = 0), (dt.sibling = null), dt
  }
  function _e(dt, ft, mt) {
    return (
      (dt.index = mt),
      o
        ? ((mt = dt.alternate),
          mt !== null
            ? ((mt = mt.index), mt < ft ? ((dt.flags = 2), ft) : mt)
            : ((dt.flags = 2), ft))
        : ft
    )
  }
  function et(dt) {
    return o && dt.alternate === null && (dt.flags = 2), dt
  }
  function tt(dt, ft, mt, vt) {
    return ft === null || ft.tag !== 6
      ? ((ft = Ug(mt, dt.mode, vt)), (ft.return = dt), ft)
      : ((ft = j(ft, mt)), (ft.return = dt), ft)
  }
  function rt(dt, ft, mt, vt) {
    return ft !== null && ft.elementType === mt.type
      ? ((vt = j(ft, mt.props)),
        (vt.ref = Qg(dt, ft, mt)),
        (vt.return = dt),
        vt)
      : ((vt = Vg(mt.type, mt.key, mt.props, null, dt.mode, vt)),
        (vt.ref = Qg(dt, ft, mt)),
        (vt.return = dt),
        vt)
  }
  function nt(dt, ft, mt, vt) {
    return ft === null ||
      ft.tag !== 4 ||
      ft.stateNode.containerInfo !== mt.containerInfo ||
      ft.stateNode.implementation !== mt.implementation
      ? ((ft = Wg(mt, dt.mode, vt)), (ft.return = dt), ft)
      : ((ft = j(ft, mt.children || [])), (ft.return = dt), ft)
  }
  function it(dt, ft, mt, vt, yt) {
    return ft === null || ft.tag !== 7
      ? ((ft = Xg(mt, dt.mode, vt, yt)), (ft.return = dt), ft)
      : ((ft = j(ft, mt)), (ft.return = dt), ft)
  }
  function ot(dt, ft, mt) {
    if (typeof ft == 'string' || typeof ft == 'number')
      return (ft = Ug('' + ft, dt.mode, mt)), (ft.return = dt), ft
    if (typeof ft == 'object' && ft !== null) {
      switch (ft.$$typeof) {
        case sa:
          return (
            (mt = Vg(ft.type, ft.key, ft.props, null, dt.mode, mt)),
            (mt.ref = Qg(dt, null, ft)),
            (mt.return = dt),
            mt
          )
        case ta:
          return (ft = Wg(ft, dt.mode, mt)), (ft.return = dt), ft
      }
      if (Pg(ft) || La(ft))
        return (ft = Xg(ft, dt.mode, mt, null)), (ft.return = dt), ft
      Rg(dt, ft)
    }
    return null
  }
  function at(dt, ft, mt, vt) {
    var yt = ft !== null ? ft.key : null
    if (typeof mt == 'string' || typeof mt == 'number')
      return yt !== null ? null : tt(dt, ft, '' + mt, vt)
    if (typeof mt == 'object' && mt !== null) {
      switch (mt.$$typeof) {
        case sa:
          return mt.key === yt
            ? mt.type === ua
              ? it(dt, ft, mt.props.children, vt, yt)
              : rt(dt, ft, mt, vt)
            : null
        case ta:
          return mt.key === yt ? nt(dt, ft, mt, vt) : null
      }
      if (Pg(mt) || La(mt)) return yt !== null ? null : it(dt, ft, mt, vt, null)
      Rg(dt, mt)
    }
    return null
  }
  function st(dt, ft, mt, vt, yt) {
    if (typeof vt == 'string' || typeof vt == 'number')
      return (dt = dt.get(mt) || null), tt(ft, dt, '' + vt, yt)
    if (typeof vt == 'object' && vt !== null) {
      switch (vt.$$typeof) {
        case sa:
          return (
            (dt = dt.get(vt.key === null ? mt : vt.key) || null),
            vt.type === ua
              ? it(ft, dt, vt.props.children, yt, vt.key)
              : rt(ft, dt, vt, yt)
          )
        case ta:
          return (
            (dt = dt.get(vt.key === null ? mt : vt.key) || null),
            nt(ft, dt, vt, yt)
          )
      }
      if (Pg(vt) || La(vt))
        return (dt = dt.get(mt) || null), it(ft, dt, vt, yt, null)
      Rg(ft, vt)
    }
    return null
  }
  function ut(dt, ft, mt, vt) {
    for (
      var yt = null, pt = null, ht = ft, At = (ft = 0), wt = null;
      ht !== null && At < mt.length;
      At++
    ) {
      ht.index > At ? ((wt = ht), (ht = null)) : (wt = ht.sibling)
      var Ct = at(dt, ht, mt[At], vt)
      if (Ct === null) {
        ht === null && (ht = wt)
        break
      }
      o && ht && Ct.alternate === null && a(dt, ht),
        (ft = _e(Ct, ft, At)),
        pt === null ? (yt = Ct) : (pt.sibling = Ct),
        (pt = Ct),
        (ht = wt)
    }
    if (At === mt.length) return s(dt, ht), yt
    if (ht === null) {
      for (; At < mt.length; At++)
        (ht = ot(dt, mt[At], vt)),
          ht !== null &&
            ((ft = _e(ht, ft, At)),
            pt === null ? (yt = ht) : (pt.sibling = ht),
            (pt = ht))
      return yt
    }
    for (ht = $(dt, ht); At < mt.length; At++)
      (wt = st(ht, dt, At, mt[At], vt)),
        wt !== null &&
          (o &&
            wt.alternate !== null &&
            ht.delete(wt.key === null ? At : wt.key),
          (ft = _e(wt, ft, At)),
          pt === null ? (yt = wt) : (pt.sibling = wt),
          (pt = wt))
    return (
      o &&
        ht.forEach(function(Dt) {
          return a(dt, Dt)
        }),
      yt
    )
  }
  function ct(dt, ft, mt, vt) {
    var yt = La(mt)
    if (typeof yt != 'function') throw Error(y$3(150))
    if (((mt = yt.call(mt)), mt == null)) throw Error(y$3(151))
    for (
      var pt = (yt = null), ht = ft, At = (ft = 0), wt = null, Ct = mt.next();
      ht !== null && !Ct.done;
      At++, Ct = mt.next()
    ) {
      ht.index > At ? ((wt = ht), (ht = null)) : (wt = ht.sibling)
      var Dt = at(dt, ht, Ct.value, vt)
      if (Dt === null) {
        ht === null && (ht = wt)
        break
      }
      o && ht && Dt.alternate === null && a(dt, ht),
        (ft = _e(Dt, ft, At)),
        pt === null ? (yt = Dt) : (pt.sibling = Dt),
        (pt = Dt),
        (ht = wt)
    }
    if (Ct.done) return s(dt, ht), yt
    if (ht === null) {
      for (; !Ct.done; At++, Ct = mt.next())
        (Ct = ot(dt, Ct.value, vt)),
          Ct !== null &&
            ((ft = _e(Ct, ft, At)),
            pt === null ? (yt = Ct) : (pt.sibling = Ct),
            (pt = Ct))
      return yt
    }
    for (ht = $(dt, ht); !Ct.done; At++, Ct = mt.next())
      (Ct = st(ht, dt, At, Ct.value, vt)),
        Ct !== null &&
          (o &&
            Ct.alternate !== null &&
            ht.delete(Ct.key === null ? At : Ct.key),
          (ft = _e(Ct, ft, At)),
          pt === null ? (yt = Ct) : (pt.sibling = Ct),
          (pt = Ct))
    return (
      o &&
        ht.forEach(function(jt) {
          return a(dt, jt)
        }),
      yt
    )
  }
  return function(dt, ft, mt, vt) {
    var yt =
      typeof mt == 'object' && mt !== null && mt.type === ua && mt.key === null
    yt && (mt = mt.props.children)
    var pt = typeof mt == 'object' && mt !== null
    if (pt)
      switch (mt.$$typeof) {
        case sa:
          e: {
            for (pt = mt.key, yt = ft; yt !== null; ) {
              if (yt.key === pt) {
                switch (yt.tag) {
                  case 7:
                    if (mt.type === ua) {
                      s(dt, yt.sibling),
                        (ft = j(yt, mt.props.children)),
                        (ft.return = dt),
                        (dt = ft)
                      break e
                    }
                    break
                  default:
                    if (yt.elementType === mt.type) {
                      s(dt, yt.sibling),
                        (ft = j(yt, mt.props)),
                        (ft.ref = Qg(dt, yt, mt)),
                        (ft.return = dt),
                        (dt = ft)
                      break e
                    }
                }
                s(dt, yt)
                break
              } else a(dt, yt)
              yt = yt.sibling
            }
            mt.type === ua
              ? ((ft = Xg(mt.props.children, dt.mode, vt, mt.key)),
                (ft.return = dt),
                (dt = ft))
              : ((vt = Vg(mt.type, mt.key, mt.props, null, dt.mode, vt)),
                (vt.ref = Qg(dt, ft, mt)),
                (vt.return = dt),
                (dt = vt))
          }
          return et(dt)
        case ta:
          e: {
            for (yt = mt.key; ft !== null; ) {
              if (ft.key === yt)
                if (
                  ft.tag === 4 &&
                  ft.stateNode.containerInfo === mt.containerInfo &&
                  ft.stateNode.implementation === mt.implementation
                ) {
                  s(dt, ft.sibling),
                    (ft = j(ft, mt.children || [])),
                    (ft.return = dt),
                    (dt = ft)
                  break e
                } else {
                  s(dt, ft)
                  break
                }
              else a(dt, ft)
              ft = ft.sibling
            }
            ;(ft = Wg(mt, dt.mode, vt)), (ft.return = dt), (dt = ft)
          }
          return et(dt)
      }
    if (typeof mt == 'string' || typeof mt == 'number')
      return (
        (mt = '' + mt),
        ft !== null && ft.tag === 6
          ? (s(dt, ft.sibling), (ft = j(ft, mt)), (ft.return = dt), (dt = ft))
          : (s(dt, ft),
            (ft = Ug(mt, dt.mode, vt)),
            (ft.return = dt),
            (dt = ft)),
        et(dt)
      )
    if (Pg(mt)) return ut(dt, ft, mt, vt)
    if (La(mt)) return ct(dt, ft, mt, vt)
    if ((pt && Rg(dt, mt), typeof mt > 'u' && !yt))
      switch (dt.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y$3(152, Ra(dt.type) || 'Component'))
      }
    return s(dt, ft)
  }
}
var Yg = Sg(!0),
  Zg = Sg(!1),
  $g = {},
  ah = Bf($g),
  bh = Bf($g),
  ch = Bf($g)
function dh(o) {
  if (o === $g) throw Error(y$3(174))
  return o
}
function eh(o, a) {
  switch ((I(ch, a), I(bh, o), I(ah, $g), (o = a.nodeType), o)) {
    case 9:
    case 11:
      a = (a = a.documentElement) ? a.namespaceURI : mb(null, '')
      break
    default:
      ;(o = o === 8 ? a.parentNode : a),
        (a = o.namespaceURI || null),
        (o = o.tagName),
        (a = mb(a, o))
  }
  H(ah), I(ah, a)
}
function fh() {
  H(ah), H(bh), H(ch)
}
function gh(o) {
  dh(ch.current)
  var a = dh(ah.current),
    s = mb(a, o.type)
  a !== s && (I(bh, o), I(ah, s))
}
function hh(o) {
  bh.current === o && (H(ah), H(bh))
}
var P$1 = Bf(0)
function ih(o) {
  for (var a = o; a !== null; ) {
    if (a.tag === 13) {
      var s = a.memoizedState
      if (
        s !== null &&
        ((s = s.dehydrated), s === null || s.data === '$?' || s.data === '$!')
      )
        return a
    } else if (a.tag === 19 && a.memoizedProps.revealOrder !== void 0) {
      if (a.flags & 64) return a
    } else if (a.child !== null) {
      ;(a.child.return = a), (a = a.child)
      continue
    }
    if (a === o) break
    for (; a.sibling === null; ) {
      if (a.return === null || a.return === o) return null
      a = a.return
    }
    ;(a.sibling.return = a.return), (a = a.sibling)
  }
  return null
}
var jh = null,
  kh = null,
  lh = !1
function mh(o, a) {
  var s = nh(5, null, null, 0)
  ;(s.elementType = 'DELETED'),
    (s.type = 'DELETED'),
    (s.stateNode = a),
    (s.return = o),
    (s.flags = 8),
    o.lastEffect !== null
      ? ((o.lastEffect.nextEffect = s), (o.lastEffect = s))
      : (o.firstEffect = o.lastEffect = s)
}
function oh(o, a) {
  switch (o.tag) {
    case 5:
      var s = o.type
      return (
        (a =
          a.nodeType !== 1 || s.toLowerCase() !== a.nodeName.toLowerCase()
            ? null
            : a),
        a !== null ? ((o.stateNode = a), !0) : !1
      )
    case 6:
      return (
        (a = o.pendingProps === '' || a.nodeType !== 3 ? null : a),
        a !== null ? ((o.stateNode = a), !0) : !1
      )
    case 13:
      return !1
    default:
      return !1
  }
}
function ph(o) {
  if (lh) {
    var a = kh
    if (a) {
      var s = a
      if (!oh(o, a)) {
        if (((a = rf(s.nextSibling)), !a || !oh(o, a))) {
          ;(o.flags = (o.flags & -1025) | 2), (lh = !1), (jh = o)
          return
        }
        mh(jh, s)
      }
      ;(jh = o), (kh = rf(a.firstChild))
    } else (o.flags = (o.flags & -1025) | 2), (lh = !1), (jh = o)
  }
}
function qh(o) {
  for (o = o.return; o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13; )
    o = o.return
  jh = o
}
function rh(o) {
  if (o !== jh) return !1
  if (!lh) return qh(o), (lh = !0), !1
  var a = o.type
  if (o.tag !== 5 || (a !== 'head' && a !== 'body' && !nf(a, o.memoizedProps)))
    for (a = kh; a; ) mh(o, a), (a = rf(a.nextSibling))
  if ((qh(o), o.tag === 13)) {
    if (((o = o.memoizedState), (o = o !== null ? o.dehydrated : null), !o))
      throw Error(y$3(317))
    e: {
      for (o = o.nextSibling, a = 0; o; ) {
        if (o.nodeType === 8) {
          var s = o.data
          if (s === '/$') {
            if (a === 0) {
              kh = rf(o.nextSibling)
              break e
            }
            a--
          } else (s !== '$' && s !== '$!' && s !== '$?') || a++
        }
        o = o.nextSibling
      }
      kh = null
    }
  } else kh = jh ? rf(o.stateNode.nextSibling) : null
  return !0
}
function sh() {
  ;(kh = jh = null), (lh = !1)
}
var th = []
function uh() {
  for (var o = 0; o < th.length; o++) th[o]._workInProgressVersionPrimary = null
  th.length = 0
}
var vh = ra.ReactCurrentDispatcher,
  wh = ra.ReactCurrentBatchConfig,
  xh = 0,
  R$1 = null,
  S = null,
  T = null,
  yh = !1,
  zh = !1
function Ah() {
  throw Error(y$3(321))
}
function Bh(o, a) {
  if (a === null) return !1
  for (var s = 0; s < a.length && s < o.length; s++)
    if (!He(o[s], a[s])) return !1
  return !0
}
function Ch(o, a, s, $, j, _e) {
  if (
    ((xh = _e),
    (R$1 = a),
    (a.memoizedState = null),
    (a.updateQueue = null),
    (a.lanes = 0),
    (vh.current = o === null || o.memoizedState === null ? Dh : Eh),
    (o = s($, j)),
    zh)
  ) {
    _e = 0
    do {
      if (((zh = !1), !(25 > _e))) throw Error(y$3(301))
      ;(_e += 1),
        (T = S = null),
        (a.updateQueue = null),
        (vh.current = Fh),
        (o = s($, j))
    } while (zh)
  }
  if (
    ((vh.current = Gh),
    (a = S !== null && S.next !== null),
    (xh = 0),
    (T = S = R$1 = null),
    (yh = !1),
    a)
  )
    throw Error(y$3(300))
  return o
}
function Hh() {
  var o = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  }
  return T === null ? (R$1.memoizedState = T = o) : (T = T.next = o), T
}
function Ih() {
  if (S === null) {
    var o = R$1.alternate
    o = o !== null ? o.memoizedState : null
  } else o = S.next
  var a = T === null ? R$1.memoizedState : T.next
  if (a !== null) (T = a), (S = o)
  else {
    if (o === null) throw Error(y$3(310))
    ;(S = o),
      (o = {
        memoizedState: S.memoizedState,
        baseState: S.baseState,
        baseQueue: S.baseQueue,
        queue: S.queue,
        next: null,
      }),
      T === null ? (R$1.memoizedState = T = o) : (T = T.next = o)
  }
  return T
}
function Jh(o, a) {
  return typeof a == 'function' ? a(o) : a
}
function Kh(o) {
  var a = Ih(),
    s = a.queue
  if (s === null) throw Error(y$3(311))
  s.lastRenderedReducer = o
  var $ = S,
    j = $.baseQueue,
    _e = s.pending
  if (_e !== null) {
    if (j !== null) {
      var et = j.next
      ;(j.next = _e.next), (_e.next = et)
    }
    ;($.baseQueue = j = _e), (s.pending = null)
  }
  if (j !== null) {
    ;(j = j.next), ($ = $.baseState)
    var tt = (et = _e = null),
      rt = j
    do {
      var nt = rt.lane
      if ((xh & nt) === nt)
        tt !== null &&
          (tt = tt.next = {
            lane: 0,
            action: rt.action,
            eagerReducer: rt.eagerReducer,
            eagerState: rt.eagerState,
            next: null,
          }),
          ($ = rt.eagerReducer === o ? rt.eagerState : o($, rt.action))
      else {
        var it = {
          lane: nt,
          action: rt.action,
          eagerReducer: rt.eagerReducer,
          eagerState: rt.eagerState,
          next: null,
        }
        tt === null ? ((et = tt = it), (_e = $)) : (tt = tt.next = it),
          (R$1.lanes |= nt),
          (Dg |= nt)
      }
      rt = rt.next
    } while (rt !== null && rt !== j)
    tt === null ? (_e = $) : (tt.next = et),
      He($, a.memoizedState) || (ug = !0),
      (a.memoizedState = $),
      (a.baseState = _e),
      (a.baseQueue = tt),
      (s.lastRenderedState = $)
  }
  return [a.memoizedState, s.dispatch]
}
function Lh(o) {
  var a = Ih(),
    s = a.queue
  if (s === null) throw Error(y$3(311))
  s.lastRenderedReducer = o
  var $ = s.dispatch,
    j = s.pending,
    _e = a.memoizedState
  if (j !== null) {
    s.pending = null
    var et = (j = j.next)
    do (_e = o(_e, et.action)), (et = et.next)
    while (et !== j)
    He(_e, a.memoizedState) || (ug = !0),
      (a.memoizedState = _e),
      a.baseQueue === null && (a.baseState = _e),
      (s.lastRenderedState = _e)
  }
  return [_e, $]
}
function Mh(o, a, s) {
  var $ = a._getVersion
  $ = $(a._source)
  var j = a._workInProgressVersionPrimary
  if (
    (j !== null
      ? (o = j === $)
      : ((o = o.mutableReadLanes),
        (o = (xh & o) === o) &&
          ((a._workInProgressVersionPrimary = $), th.push(a))),
    o)
  )
    return s(a._source)
  throw (th.push(a), Error(y$3(350)))
}
function Nh(o, a, s, $) {
  var j = U
  if (j === null) throw Error(y$3(349))
  var _e = a._getVersion,
    et = _e(a._source),
    tt = vh.current,
    rt = tt.useState(function() {
      return Mh(j, a, s)
    }),
    nt = rt[1],
    it = rt[0]
  rt = T
  var ot = o.memoizedState,
    at = ot.refs,
    st = at.getSnapshot,
    ut = ot.source
  ot = ot.subscribe
  var ct = R$1
  return (
    (o.memoizedState = { refs: at, source: a, subscribe: $ }),
    tt.useEffect(
      function() {
        ;(at.getSnapshot = s), (at.setSnapshot = nt)
        var dt = _e(a._source)
        if (!He(et, dt)) {
          ;(dt = s(a._source)),
            He(it, dt) ||
              (nt(dt),
              (dt = Ig(ct)),
              (j.mutableReadLanes |= dt & j.pendingLanes)),
            (dt = j.mutableReadLanes),
            (j.entangledLanes |= dt)
          for (var ft = j.entanglements, mt = dt; 0 < mt; ) {
            var vt = 31 - Vc(mt),
              yt = 1 << vt
            ;(ft[vt] |= dt), (mt &= ~yt)
          }
        }
      },
      [s, a, $]
    ),
    tt.useEffect(
      function() {
        return $(a._source, function() {
          var dt = at.getSnapshot,
            ft = at.setSnapshot
          try {
            ft(dt(a._source))
            var mt = Ig(ct)
            j.mutableReadLanes |= mt & j.pendingLanes
          } catch (vt) {
            ft(function() {
              throw vt
            })
          }
        })
      },
      [a, $]
    ),
    (He(st, s) && He(ut, a) && He(ot, $)) ||
      ((o = {
        pending: null,
        dispatch: null,
        lastRenderedReducer: Jh,
        lastRenderedState: it,
      }),
      (o.dispatch = nt = Oh.bind(null, R$1, o)),
      (rt.queue = o),
      (rt.baseQueue = null),
      (it = Mh(j, a, s)),
      (rt.memoizedState = rt.baseState = it)),
    it
  )
}
function Ph(o, a, s) {
  var $ = Ih()
  return Nh($, o, a, s)
}
function Qh(o) {
  var a = Hh()
  return (
    typeof o == 'function' && (o = o()),
    (a.memoizedState = a.baseState = o),
    (o = a.queue = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: Jh,
      lastRenderedState: o,
    }),
    (o = o.dispatch = Oh.bind(null, R$1, o)),
    [a.memoizedState, o]
  )
}
function Rh(o, a, s, $) {
  return (
    (o = { tag: o, create: a, destroy: s, deps: $, next: null }),
    (a = R$1.updateQueue),
    a === null
      ? ((a = { lastEffect: null }),
        (R$1.updateQueue = a),
        (a.lastEffect = o.next = o))
      : ((s = a.lastEffect),
        s === null
          ? (a.lastEffect = o.next = o)
          : (($ = s.next), (s.next = o), (o.next = $), (a.lastEffect = o))),
    o
  )
}
function Sh(o) {
  var a = Hh()
  return (o = { current: o }), (a.memoizedState = o)
}
function Th() {
  return Ih().memoizedState
}
function Uh(o, a, s, $) {
  var j = Hh()
  ;(R$1.flags |= o),
    (j.memoizedState = Rh(1 | a, s, void 0, $ === void 0 ? null : $))
}
function Vh(o, a, s, $) {
  var j = Ih()
  $ = $ === void 0 ? null : $
  var _e = void 0
  if (S !== null) {
    var et = S.memoizedState
    if (((_e = et.destroy), $ !== null && Bh($, et.deps))) {
      Rh(a, s, _e, $)
      return
    }
  }
  ;(R$1.flags |= o), (j.memoizedState = Rh(1 | a, s, _e, $))
}
function Wh(o, a) {
  return Uh(516, 4, o, a)
}
function Xh(o, a) {
  return Vh(516, 4, o, a)
}
function Yh(o, a) {
  return Vh(4, 2, o, a)
}
function Zh(o, a) {
  if (typeof a == 'function')
    return (
      (o = o()),
      a(o),
      function() {
        a(null)
      }
    )
  if (a != null)
    return (
      (o = o()),
      (a.current = o),
      function() {
        a.current = null
      }
    )
}
function $h(o, a, s) {
  return (
    (s = s != null ? s.concat([o]) : null), Vh(4, 2, Zh.bind(null, a, o), s)
  )
}
function ai() {}
function bi(o, a) {
  var s = Ih()
  a = a === void 0 ? null : a
  var $ = s.memoizedState
  return $ !== null && a !== null && Bh(a, $[1])
    ? $[0]
    : ((s.memoizedState = [o, a]), o)
}
function ci(o, a) {
  var s = Ih()
  a = a === void 0 ? null : a
  var $ = s.memoizedState
  return $ !== null && a !== null && Bh(a, $[1])
    ? $[0]
    : ((o = o()), (s.memoizedState = [o, a]), o)
}
function di(o, a) {
  var s = eg()
  gg(98 > s ? 98 : s, function() {
    o(!0)
  }),
    gg(97 < s ? 97 : s, function() {
      var $ = wh.transition
      wh.transition = 1
      try {
        o(!1), a()
      } finally {
        wh.transition = $
      }
    })
}
function Oh(o, a, s) {
  var $ = Hg(),
    j = Ig(o),
    _e = {
      lane: j,
      action: s,
      eagerReducer: null,
      eagerState: null,
      next: null,
    },
    et = a.pending
  if (
    (et === null ? (_e.next = _e) : ((_e.next = et.next), (et.next = _e)),
    (a.pending = _e),
    (et = o.alternate),
    o === R$1 || (et !== null && et === R$1))
  )
    zh = yh = !0
  else {
    if (
      o.lanes === 0 &&
      (et === null || et.lanes === 0) &&
      ((et = a.lastRenderedReducer), et !== null)
    )
      try {
        var tt = a.lastRenderedState,
          rt = et(tt, s)
        if (((_e.eagerReducer = et), (_e.eagerState = rt), He(rt, tt))) return
      } catch {
      } finally {
      }
    Jg(o, j, $)
  }
}
var Gh = {
    readContext: vg,
    useCallback: Ah,
    useContext: Ah,
    useEffect: Ah,
    useImperativeHandle: Ah,
    useLayoutEffect: Ah,
    useMemo: Ah,
    useReducer: Ah,
    useRef: Ah,
    useState: Ah,
    useDebugValue: Ah,
    useDeferredValue: Ah,
    useTransition: Ah,
    useMutableSource: Ah,
    useOpaqueIdentifier: Ah,
    unstable_isNewReconciler: !1,
  },
  Dh = {
    readContext: vg,
    useCallback: function(o, a) {
      return (Hh().memoizedState = [o, a === void 0 ? null : a]), o
    },
    useContext: vg,
    useEffect: Wh,
    useImperativeHandle: function(o, a, s) {
      return (
        (s = s != null ? s.concat([o]) : null), Uh(4, 2, Zh.bind(null, a, o), s)
      )
    },
    useLayoutEffect: function(o, a) {
      return Uh(4, 2, o, a)
    },
    useMemo: function(o, a) {
      var s = Hh()
      return (
        (a = a === void 0 ? null : a), (o = o()), (s.memoizedState = [o, a]), o
      )
    },
    useReducer: function(o, a, s) {
      var $ = Hh()
      return (
        (a = s !== void 0 ? s(a) : a),
        ($.memoizedState = $.baseState = a),
        (o = $.queue = {
          pending: null,
          dispatch: null,
          lastRenderedReducer: o,
          lastRenderedState: a,
        }),
        (o = o.dispatch = Oh.bind(null, R$1, o)),
        [$.memoizedState, o]
      )
    },
    useRef: Sh,
    useState: Qh,
    useDebugValue: ai,
    useDeferredValue: function(o) {
      var a = Qh(o),
        s = a[0],
        $ = a[1]
      return (
        Wh(
          function() {
            var j = wh.transition
            wh.transition = 1
            try {
              $(o)
            } finally {
              wh.transition = j
            }
          },
          [o]
        ),
        s
      )
    },
    useTransition: function() {
      var o = Qh(!1),
        a = o[0]
      return (o = di.bind(null, o[1])), Sh(o), [o, a]
    },
    useMutableSource: function(o, a, s) {
      var $ = Hh()
      return (
        ($.memoizedState = {
          refs: { getSnapshot: a, setSnapshot: null },
          source: o,
          subscribe: s,
        }),
        Nh($, o, a, s)
      )
    },
    useOpaqueIdentifier: function() {
      if (lh) {
        var o = !1,
          a = uf(function() {
            throw (o || ((o = !0), s('r:' + (tf++).toString(36))),
            Error(y$3(355)))
          }),
          s = Qh(a)[1]
        return (
          !(R$1.mode & 2) &&
            ((R$1.flags |= 516),
            Rh(
              5,
              function() {
                s('r:' + (tf++).toString(36))
              },
              void 0,
              null
            )),
          a
        )
      }
      return (a = 'r:' + (tf++).toString(36)), Qh(a), a
    },
    unstable_isNewReconciler: !1,
  },
  Eh = {
    readContext: vg,
    useCallback: bi,
    useContext: vg,
    useEffect: Xh,
    useImperativeHandle: $h,
    useLayoutEffect: Yh,
    useMemo: ci,
    useReducer: Kh,
    useRef: Th,
    useState: function() {
      return Kh(Jh)
    },
    useDebugValue: ai,
    useDeferredValue: function(o) {
      var a = Kh(Jh),
        s = a[0],
        $ = a[1]
      return (
        Xh(
          function() {
            var j = wh.transition
            wh.transition = 1
            try {
              $(o)
            } finally {
              wh.transition = j
            }
          },
          [o]
        ),
        s
      )
    },
    useTransition: function() {
      var o = Kh(Jh)[0]
      return [Th().current, o]
    },
    useMutableSource: Ph,
    useOpaqueIdentifier: function() {
      return Kh(Jh)[0]
    },
    unstable_isNewReconciler: !1,
  },
  Fh = {
    readContext: vg,
    useCallback: bi,
    useContext: vg,
    useEffect: Xh,
    useImperativeHandle: $h,
    useLayoutEffect: Yh,
    useMemo: ci,
    useReducer: Lh,
    useRef: Th,
    useState: function() {
      return Lh(Jh)
    },
    useDebugValue: ai,
    useDeferredValue: function(o) {
      var a = Lh(Jh),
        s = a[0],
        $ = a[1]
      return (
        Xh(
          function() {
            var j = wh.transition
            wh.transition = 1
            try {
              $(o)
            } finally {
              wh.transition = j
            }
          },
          [o]
        ),
        s
      )
    },
    useTransition: function() {
      var o = Lh(Jh)[0]
      return [Th().current, o]
    },
    useMutableSource: Ph,
    useOpaqueIdentifier: function() {
      return Lh(Jh)[0]
    },
    unstable_isNewReconciler: !1,
  },
  ei = ra.ReactCurrentOwner,
  ug = !1
function fi(o, a, s, $) {
  a.child = o === null ? Zg(a, null, s, $) : Yg(a, o.child, s, $)
}
function gi(o, a, s, $, j) {
  s = s.render
  var _e = a.ref
  return (
    tg(a, j),
    ($ = Ch(o, a, s, $, _e, j)),
    o !== null && !ug
      ? ((a.updateQueue = o.updateQueue),
        (a.flags &= -517),
        (o.lanes &= ~j),
        hi(o, a, j))
      : ((a.flags |= 1), fi(o, a, $, j), a.child)
  )
}
function ii(o, a, s, $, j, _e) {
  if (o === null) {
    var et = s.type
    return typeof et == 'function' &&
      !ji(et) &&
      et.defaultProps === void 0 &&
      s.compare === null &&
      s.defaultProps === void 0
      ? ((a.tag = 15), (a.type = et), ki(o, a, et, $, j, _e))
      : ((o = Vg(s.type, null, $, a, a.mode, _e)),
        (o.ref = a.ref),
        (o.return = a),
        (a.child = o))
  }
  return (
    (et = o.child),
    !(j & _e) &&
    ((j = et.memoizedProps),
    (s = s.compare),
    (s = s !== null ? s : Je),
    s(j, $) && o.ref === a.ref)
      ? hi(o, a, _e)
      : ((a.flags |= 1),
        (o = Tg(et, $)),
        (o.ref = a.ref),
        (o.return = a),
        (a.child = o))
  )
}
function ki(o, a, s, $, j, _e) {
  if (o !== null && Je(o.memoizedProps, $) && o.ref === a.ref)
    if (((ug = !1), (_e & j) !== 0)) o.flags & 16384 && (ug = !0)
    else return (a.lanes = o.lanes), hi(o, a, _e)
  return li(o, a, s, $, _e)
}
function mi(o, a, s) {
  var $ = a.pendingProps,
    j = $.children,
    _e = o !== null ? o.memoizedState : null
  if ($.mode === 'hidden' || $.mode === 'unstable-defer-without-hiding')
    if (!(a.mode & 4)) (a.memoizedState = { baseLanes: 0 }), ni(a, s)
    else if (s & 1073741824)
      (a.memoizedState = { baseLanes: 0 }),
        ni(a, _e !== null ? _e.baseLanes : s)
    else
      return (
        (o = _e !== null ? _e.baseLanes | s : s),
        (a.lanes = a.childLanes = 1073741824),
        (a.memoizedState = { baseLanes: o }),
        ni(a, o),
        null
      )
  else
    _e !== null ? (($ = _e.baseLanes | s), (a.memoizedState = null)) : ($ = s),
      ni(a, $)
  return fi(o, a, j, s), a.child
}
function oi(o, a) {
  var s = a.ref
  ;((o === null && s !== null) || (o !== null && o.ref !== s)) &&
    (a.flags |= 128)
}
function li(o, a, s, $, j) {
  var _e = Ff(s) ? Df : M.current
  return (
    (_e = Ef(a, _e)),
    tg(a, j),
    (s = Ch(o, a, s, $, _e, j)),
    o !== null && !ug
      ? ((a.updateQueue = o.updateQueue),
        (a.flags &= -517),
        (o.lanes &= ~j),
        hi(o, a, j))
      : ((a.flags |= 1), fi(o, a, s, j), a.child)
  )
}
function pi(o, a, s, $, j) {
  if (Ff(s)) {
    var _e = !0
    Jf(a)
  } else _e = !1
  if ((tg(a, j), a.stateNode === null))
    o !== null && ((o.alternate = null), (a.alternate = null), (a.flags |= 2)),
      Mg(a, s, $),
      Og(a, s, $, j),
      ($ = !0)
  else if (o === null) {
    var et = a.stateNode,
      tt = a.memoizedProps
    et.props = tt
    var rt = et.context,
      nt = s.contextType
    typeof nt == 'object' && nt !== null
      ? (nt = vg(nt))
      : ((nt = Ff(s) ? Df : M.current), (nt = Ef(a, nt)))
    var it = s.getDerivedStateFromProps,
      ot =
        typeof it == 'function' ||
        typeof et.getSnapshotBeforeUpdate == 'function'
    ot ||
      (typeof et.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof et.componentWillReceiveProps != 'function') ||
      ((tt !== $ || rt !== nt) && Ng(a, et, $, nt)),
      (wg = !1)
    var at = a.memoizedState
    ;(et.state = at),
      Cg(a, $, et, j),
      (rt = a.memoizedState),
      tt !== $ || at !== rt || N.current || wg
        ? (typeof it == 'function' && (Gg(a, s, it, $), (rt = a.memoizedState)),
          (tt = wg || Lg(a, s, tt, $, at, rt, nt))
            ? (ot ||
                (typeof et.UNSAFE_componentWillMount != 'function' &&
                  typeof et.componentWillMount != 'function') ||
                (typeof et.componentWillMount == 'function' &&
                  et.componentWillMount(),
                typeof et.UNSAFE_componentWillMount == 'function' &&
                  et.UNSAFE_componentWillMount()),
              typeof et.componentDidMount == 'function' && (a.flags |= 4))
            : (typeof et.componentDidMount == 'function' && (a.flags |= 4),
              (a.memoizedProps = $),
              (a.memoizedState = rt)),
          (et.props = $),
          (et.state = rt),
          (et.context = nt),
          ($ = tt))
        : (typeof et.componentDidMount == 'function' && (a.flags |= 4),
          ($ = !1))
  } else {
    ;(et = a.stateNode),
      yg(o, a),
      (tt = a.memoizedProps),
      (nt = a.type === a.elementType ? tt : lg(a.type, tt)),
      (et.props = nt),
      (ot = a.pendingProps),
      (at = et.context),
      (rt = s.contextType),
      typeof rt == 'object' && rt !== null
        ? (rt = vg(rt))
        : ((rt = Ff(s) ? Df : M.current), (rt = Ef(a, rt)))
    var st = s.getDerivedStateFromProps
    ;(it =
      typeof st == 'function' ||
      typeof et.getSnapshotBeforeUpdate == 'function') ||
      (typeof et.UNSAFE_componentWillReceiveProps != 'function' &&
        typeof et.componentWillReceiveProps != 'function') ||
      ((tt !== ot || at !== rt) && Ng(a, et, $, rt)),
      (wg = !1),
      (at = a.memoizedState),
      (et.state = at),
      Cg(a, $, et, j)
    var ut = a.memoizedState
    tt !== ot || at !== ut || N.current || wg
      ? (typeof st == 'function' && (Gg(a, s, st, $), (ut = a.memoizedState)),
        (nt = wg || Lg(a, s, nt, $, at, ut, rt))
          ? (it ||
              (typeof et.UNSAFE_componentWillUpdate != 'function' &&
                typeof et.componentWillUpdate != 'function') ||
              (typeof et.componentWillUpdate == 'function' &&
                et.componentWillUpdate($, ut, rt),
              typeof et.UNSAFE_componentWillUpdate == 'function' &&
                et.UNSAFE_componentWillUpdate($, ut, rt)),
            typeof et.componentDidUpdate == 'function' && (a.flags |= 4),
            typeof et.getSnapshotBeforeUpdate == 'function' && (a.flags |= 256))
          : (typeof et.componentDidUpdate != 'function' ||
              (tt === o.memoizedProps && at === o.memoizedState) ||
              (a.flags |= 4),
            typeof et.getSnapshotBeforeUpdate != 'function' ||
              (tt === o.memoizedProps && at === o.memoizedState) ||
              (a.flags |= 256),
            (a.memoizedProps = $),
            (a.memoizedState = ut)),
        (et.props = $),
        (et.state = ut),
        (et.context = rt),
        ($ = nt))
      : (typeof et.componentDidUpdate != 'function' ||
          (tt === o.memoizedProps && at === o.memoizedState) ||
          (a.flags |= 4),
        typeof et.getSnapshotBeforeUpdate != 'function' ||
          (tt === o.memoizedProps && at === o.memoizedState) ||
          (a.flags |= 256),
        ($ = !1))
  }
  return qi(o, a, s, $, _e, j)
}
function qi(o, a, s, $, j, _e) {
  oi(o, a)
  var et = (a.flags & 64) !== 0
  if (!$ && !et) return j && Kf(a, s, !1), hi(o, a, _e)
  ;($ = a.stateNode), (ei.current = a)
  var tt =
    et && typeof s.getDerivedStateFromError != 'function' ? null : $.render()
  return (
    (a.flags |= 1),
    o !== null && et
      ? ((a.child = Yg(a, o.child, null, _e)), (a.child = Yg(a, null, tt, _e)))
      : fi(o, a, tt, _e),
    (a.memoizedState = $.state),
    j && Kf(a, s, !0),
    a.child
  )
}
function ri(o) {
  var a = o.stateNode
  a.pendingContext
    ? Hf(o, a.pendingContext, a.pendingContext !== a.context)
    : a.context && Hf(o, a.context, !1),
    eh(o, a.containerInfo)
}
var si = { dehydrated: null, retryLane: 0 }
function ti(o, a, s) {
  var $ = a.pendingProps,
    j = P$1.current,
    _e = !1,
    et
  return (
    (et = (a.flags & 64) !== 0) ||
      (et = o !== null && o.memoizedState === null ? !1 : (j & 2) !== 0),
    et
      ? ((_e = !0), (a.flags &= -65))
      : (o !== null && o.memoizedState === null) ||
        $.fallback === void 0 ||
        $.unstable_avoidThisFallback === !0 ||
        (j |= 1),
    I(P$1, j & 1),
    o === null
      ? ($.fallback !== void 0 && ph(a),
        (o = $.children),
        (j = $.fallback),
        _e
          ? ((o = ui(a, o, j, s)),
            (a.child.memoizedState = { baseLanes: s }),
            (a.memoizedState = si),
            o)
          : typeof $.unstable_expectedLoadTime == 'number'
          ? ((o = ui(a, o, j, s)),
            (a.child.memoizedState = { baseLanes: s }),
            (a.memoizedState = si),
            (a.lanes = 33554432),
            o)
          : ((s = vi({ mode: 'visible', children: o }, a.mode, s, null)),
            (s.return = a),
            (a.child = s)))
      : o.memoizedState !== null
      ? _e
        ? (($ = wi(o, a, $.children, $.fallback, s)),
          (_e = a.child),
          (j = o.child.memoizedState),
          (_e.memoizedState =
            j === null ? { baseLanes: s } : { baseLanes: j.baseLanes | s }),
          (_e.childLanes = o.childLanes & ~s),
          (a.memoizedState = si),
          $)
        : ((s = xi(o, a, $.children, s)), (a.memoizedState = null), s)
      : _e
      ? (($ = wi(o, a, $.children, $.fallback, s)),
        (_e = a.child),
        (j = o.child.memoizedState),
        (_e.memoizedState =
          j === null ? { baseLanes: s } : { baseLanes: j.baseLanes | s }),
        (_e.childLanes = o.childLanes & ~s),
        (a.memoizedState = si),
        $)
      : ((s = xi(o, a, $.children, s)), (a.memoizedState = null), s)
  )
}
function ui(o, a, s, $) {
  var j = o.mode,
    _e = o.child
  return (
    (a = { mode: 'hidden', children: a }),
    !(j & 2) && _e !== null
      ? ((_e.childLanes = 0), (_e.pendingProps = a))
      : (_e = vi(a, j, 0, null)),
    (s = Xg(s, j, $, null)),
    (_e.return = o),
    (s.return = o),
    (_e.sibling = s),
    (o.child = _e),
    s
  )
}
function xi(o, a, s, $) {
  var j = o.child
  return (
    (o = j.sibling),
    (s = Tg(j, { mode: 'visible', children: s })),
    !(a.mode & 2) && (s.lanes = $),
    (s.return = a),
    (s.sibling = null),
    o !== null &&
      ((o.nextEffect = null),
      (o.flags = 8),
      (a.firstEffect = a.lastEffect = o)),
    (a.child = s)
  )
}
function wi(o, a, s, $, j) {
  var _e = a.mode,
    et = o.child
  o = et.sibling
  var tt = { mode: 'hidden', children: s }
  return (
    !(_e & 2) && a.child !== et
      ? ((s = a.child),
        (s.childLanes = 0),
        (s.pendingProps = tt),
        (et = s.lastEffect),
        et !== null
          ? ((a.firstEffect = s.firstEffect),
            (a.lastEffect = et),
            (et.nextEffect = null))
          : (a.firstEffect = a.lastEffect = null))
      : (s = Tg(et, tt)),
    o !== null ? ($ = Tg(o, $)) : (($ = Xg($, _e, j, null)), ($.flags |= 2)),
    ($.return = a),
    (s.return = a),
    (s.sibling = $),
    (a.child = s),
    $
  )
}
function yi(o, a) {
  o.lanes |= a
  var s = o.alternate
  s !== null && (s.lanes |= a), sg(o.return, a)
}
function zi(o, a, s, $, j, _e) {
  var et = o.memoizedState
  et === null
    ? (o.memoizedState = {
        isBackwards: a,
        rendering: null,
        renderingStartTime: 0,
        last: $,
        tail: s,
        tailMode: j,
        lastEffect: _e,
      })
    : ((et.isBackwards = a),
      (et.rendering = null),
      (et.renderingStartTime = 0),
      (et.last = $),
      (et.tail = s),
      (et.tailMode = j),
      (et.lastEffect = _e))
}
function Ai(o, a, s) {
  var $ = a.pendingProps,
    j = $.revealOrder,
    _e = $.tail
  if ((fi(o, a, $.children, s), ($ = P$1.current), $ & 2))
    ($ = ($ & 1) | 2), (a.flags |= 64)
  else {
    if (o !== null && o.flags & 64)
      e: for (o = a.child; o !== null; ) {
        if (o.tag === 13) o.memoizedState !== null && yi(o, s)
        else if (o.tag === 19) yi(o, s)
        else if (o.child !== null) {
          ;(o.child.return = o), (o = o.child)
          continue
        }
        if (o === a) break e
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === a) break e
          o = o.return
        }
        ;(o.sibling.return = o.return), (o = o.sibling)
      }
    $ &= 1
  }
  if ((I(P$1, $), !(a.mode & 2))) a.memoizedState = null
  else
    switch (j) {
      case 'forwards':
        for (s = a.child, j = null; s !== null; )
          (o = s.alternate),
            o !== null && ih(o) === null && (j = s),
            (s = s.sibling)
        ;(s = j),
          s === null
            ? ((j = a.child), (a.child = null))
            : ((j = s.sibling), (s.sibling = null)),
          zi(a, !1, j, s, _e, a.lastEffect)
        break
      case 'backwards':
        for (s = null, j = a.child, a.child = null; j !== null; ) {
          if (((o = j.alternate), o !== null && ih(o) === null)) {
            a.child = j
            break
          }
          ;(o = j.sibling), (j.sibling = s), (s = j), (j = o)
        }
        zi(a, !0, s, null, _e, a.lastEffect)
        break
      case 'together':
        zi(a, !1, null, null, void 0, a.lastEffect)
        break
      default:
        a.memoizedState = null
    }
  return a.child
}
function hi(o, a, s) {
  if (
    (o !== null && (a.dependencies = o.dependencies),
    (Dg |= a.lanes),
    s & a.childLanes)
  ) {
    if (o !== null && a.child !== o.child) throw Error(y$3(153))
    if (a.child !== null) {
      for (
        o = a.child, s = Tg(o, o.pendingProps), a.child = s, s.return = a;
        o.sibling !== null;

      )
        (o = o.sibling), (s = s.sibling = Tg(o, o.pendingProps)), (s.return = a)
      s.sibling = null
    }
    return a.child
  }
  return null
}
var Bi, Ci, Di, Ei
Bi = function(o, a) {
  for (var s = a.child; s !== null; ) {
    if (s.tag === 5 || s.tag === 6) o.appendChild(s.stateNode)
    else if (s.tag !== 4 && s.child !== null) {
      ;(s.child.return = s), (s = s.child)
      continue
    }
    if (s === a) break
    for (; s.sibling === null; ) {
      if (s.return === null || s.return === a) return
      s = s.return
    }
    ;(s.sibling.return = s.return), (s = s.sibling)
  }
}
Ci = function() {}
Di = function(o, a, s, $) {
  var j = o.memoizedProps
  if (j !== $) {
    ;(o = a.stateNode), dh(ah.current)
    var _e = null
    switch (s) {
      case 'input':
        ;(j = Ya(o, j)), ($ = Ya(o, $)), (_e = [])
        break
      case 'option':
        ;(j = eb(o, j)), ($ = eb(o, $)), (_e = [])
        break
      case 'select':
        ;(j = m$4({}, j, { value: void 0 })),
          ($ = m$4({}, $, { value: void 0 })),
          (_e = [])
        break
      case 'textarea':
        ;(j = gb(o, j)), ($ = gb(o, $)), (_e = [])
        break
      default:
        typeof j.onClick != 'function' &&
          typeof $.onClick == 'function' &&
          (o.onclick = jf)
    }
    vb(s, $)
    var et
    s = null
    for (nt in j)
      if (!$.hasOwnProperty(nt) && j.hasOwnProperty(nt) && j[nt] != null)
        if (nt === 'style') {
          var tt = j[nt]
          for (et in tt) tt.hasOwnProperty(et) && (s || (s = {}), (s[et] = ''))
        } else
          nt !== 'dangerouslySetInnerHTML' &&
            nt !== 'children' &&
            nt !== 'suppressContentEditableWarning' &&
            nt !== 'suppressHydrationWarning' &&
            nt !== 'autoFocus' &&
            (ca.hasOwnProperty(nt)
              ? _e || (_e = [])
              : (_e = _e || []).push(nt, null))
    for (nt in $) {
      var rt = $[nt]
      if (
        ((tt = j != null ? j[nt] : void 0),
        $.hasOwnProperty(nt) && rt !== tt && (rt != null || tt != null))
      )
        if (nt === 'style')
          if (tt) {
            for (et in tt)
              !tt.hasOwnProperty(et) ||
                (rt && rt.hasOwnProperty(et)) ||
                (s || (s = {}), (s[et] = ''))
            for (et in rt)
              rt.hasOwnProperty(et) &&
                tt[et] !== rt[et] &&
                (s || (s = {}), (s[et] = rt[et]))
          } else s || (_e || (_e = []), _e.push(nt, s)), (s = rt)
        else
          nt === 'dangerouslySetInnerHTML'
            ? ((rt = rt ? rt.__html : void 0),
              (tt = tt ? tt.__html : void 0),
              rt != null && tt !== rt && (_e = _e || []).push(nt, rt))
            : nt === 'children'
            ? (typeof rt != 'string' && typeof rt != 'number') ||
              (_e = _e || []).push(nt, '' + rt)
            : nt !== 'suppressContentEditableWarning' &&
              nt !== 'suppressHydrationWarning' &&
              (ca.hasOwnProperty(nt)
                ? (rt != null && nt === 'onScroll' && G('scroll', o),
                  _e || tt === rt || (_e = []))
                : typeof rt == 'object' && rt !== null && rt.$$typeof === Ga
                ? rt.toString()
                : (_e = _e || []).push(nt, rt))
    }
    s && (_e = _e || []).push('style', s)
    var nt = _e
    ;(a.updateQueue = nt) && (a.flags |= 4)
  }
}
Ei = function(o, a, s, $) {
  s !== $ && (a.flags |= 4)
}
function Fi(o, a) {
  if (!lh)
    switch (o.tailMode) {
      case 'hidden':
        a = o.tail
        for (var s = null; a !== null; )
          a.alternate !== null && (s = a), (a = a.sibling)
        s === null ? (o.tail = null) : (s.sibling = null)
        break
      case 'collapsed':
        s = o.tail
        for (var $ = null; s !== null; )
          s.alternate !== null && ($ = s), (s = s.sibling)
        $ === null
          ? a || o.tail === null
            ? (o.tail = null)
            : (o.tail.sibling = null)
          : ($.sibling = null)
    }
}
function Gi(o, a, s) {
  var $ = a.pendingProps
  switch (a.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null
    case 1:
      return Ff(a.type) && Gf(), null
    case 3:
      return (
        fh(),
        H(N),
        H(M),
        uh(),
        ($ = a.stateNode),
        $.pendingContext &&
          (($.context = $.pendingContext), ($.pendingContext = null)),
        (o === null || o.child === null) &&
          (rh(a) ? (a.flags |= 4) : $.hydrate || (a.flags |= 256)),
        Ci(a),
        null
      )
    case 5:
      hh(a)
      var j = dh(ch.current)
      if (((s = a.type), o !== null && a.stateNode != null))
        Di(o, a, s, $, j), o.ref !== a.ref && (a.flags |= 128)
      else {
        if (!$) {
          if (a.stateNode === null) throw Error(y$3(166))
          return null
        }
        if (((o = dh(ah.current)), rh(a))) {
          ;($ = a.stateNode), (s = a.type)
          var _e = a.memoizedProps
          switch ((($[wf] = a), ($[xf] = _e), s)) {
            case 'dialog':
              G('cancel', $), G('close', $)
              break
            case 'iframe':
            case 'object':
            case 'embed':
              G('load', $)
              break
            case 'video':
            case 'audio':
              for (o = 0; o < Xe.length; o++) G(Xe[o], $)
              break
            case 'source':
              G('error', $)
              break
            case 'img':
            case 'image':
            case 'link':
              G('error', $), G('load', $)
              break
            case 'details':
              G('toggle', $)
              break
            case 'input':
              Za($, _e), G('invalid', $)
              break
            case 'select':
              ;($._wrapperState = { wasMultiple: !!_e.multiple }),
                G('invalid', $)
              break
            case 'textarea':
              hb($, _e), G('invalid', $)
          }
          vb(s, _e), (o = null)
          for (var et in _e)
            _e.hasOwnProperty(et) &&
              ((j = _e[et]),
              et === 'children'
                ? typeof j == 'string'
                  ? $.textContent !== j && (o = ['children', j])
                  : typeof j == 'number' &&
                    $.textContent !== '' + j &&
                    (o = ['children', '' + j])
                : ca.hasOwnProperty(et) &&
                  j != null &&
                  et === 'onScroll' &&
                  G('scroll', $))
          switch (s) {
            case 'input':
              Va($), cb($, _e, !0)
              break
            case 'textarea':
              Va($), jb($)
              break
            case 'select':
            case 'option':
              break
            default:
              typeof _e.onClick == 'function' && ($.onclick = jf)
          }
          ;($ = o), (a.updateQueue = $), $ !== null && (a.flags |= 4)
        } else {
          switch (
            ((et = j.nodeType === 9 ? j : j.ownerDocument),
            o === kb.html && (o = lb(s)),
            o === kb.html
              ? s === 'script'
                ? ((o = et.createElement('div')),
                  (o.innerHTML = '<script></script>'),
                  (o = o.removeChild(o.firstChild)))
                : typeof $.is == 'string'
                ? (o = et.createElement(s, { is: $.is }))
                : ((o = et.createElement(s)),
                  s === 'select' &&
                    ((et = o),
                    $.multiple
                      ? (et.multiple = !0)
                      : $.size && (et.size = $.size)))
              : (o = et.createElementNS(o, s)),
            (o[wf] = a),
            (o[xf] = $),
            Bi(o, a, !1, !1),
            (a.stateNode = o),
            (et = wb(s, $)),
            s)
          ) {
            case 'dialog':
              G('cancel', o), G('close', o), (j = $)
              break
            case 'iframe':
            case 'object':
            case 'embed':
              G('load', o), (j = $)
              break
            case 'video':
            case 'audio':
              for (j = 0; j < Xe.length; j++) G(Xe[j], o)
              j = $
              break
            case 'source':
              G('error', o), (j = $)
              break
            case 'img':
            case 'image':
            case 'link':
              G('error', o), G('load', o), (j = $)
              break
            case 'details':
              G('toggle', o), (j = $)
              break
            case 'input':
              Za(o, $), (j = Ya(o, $)), G('invalid', o)
              break
            case 'option':
              j = eb(o, $)
              break
            case 'select':
              ;(o._wrapperState = { wasMultiple: !!$.multiple }),
                (j = m$4({}, $, { value: void 0 })),
                G('invalid', o)
              break
            case 'textarea':
              hb(o, $), (j = gb(o, $)), G('invalid', o)
              break
            default:
              j = $
          }
          vb(s, j)
          var tt = j
          for (_e in tt)
            if (tt.hasOwnProperty(_e)) {
              var rt = tt[_e]
              _e === 'style'
                ? tb(o, rt)
                : _e === 'dangerouslySetInnerHTML'
                ? ((rt = rt ? rt.__html : void 0), rt != null && ob(o, rt))
                : _e === 'children'
                ? typeof rt == 'string'
                  ? (s !== 'textarea' || rt !== '') && pb(o, rt)
                  : typeof rt == 'number' && pb(o, '' + rt)
                : _e !== 'suppressContentEditableWarning' &&
                  _e !== 'suppressHydrationWarning' &&
                  _e !== 'autoFocus' &&
                  (ca.hasOwnProperty(_e)
                    ? rt != null && _e === 'onScroll' && G('scroll', o)
                    : rt != null && qa(o, _e, rt, et))
            }
          switch (s) {
            case 'input':
              Va(o), cb(o, $, !1)
              break
            case 'textarea':
              Va(o), jb(o)
              break
            case 'option':
              $.value != null && o.setAttribute('value', '' + Sa($.value))
              break
            case 'select':
              ;(o.multiple = !!$.multiple),
                (_e = $.value),
                _e != null
                  ? fb(o, !!$.multiple, _e, !1)
                  : $.defaultValue != null &&
                    fb(o, !!$.multiple, $.defaultValue, !0)
              break
            default:
              typeof j.onClick == 'function' && (o.onclick = jf)
          }
          mf(s, $) && (a.flags |= 4)
        }
        a.ref !== null && (a.flags |= 128)
      }
      return null
    case 6:
      if (o && a.stateNode != null) Ei(o, a, o.memoizedProps, $)
      else {
        if (typeof $ != 'string' && a.stateNode === null) throw Error(y$3(166))
        ;(s = dh(ch.current)),
          dh(ah.current),
          rh(a)
            ? (($ = a.stateNode),
              (s = a.memoizedProps),
              ($[wf] = a),
              $.nodeValue !== s && (a.flags |= 4))
            : (($ = (s.nodeType === 9 ? s : s.ownerDocument).createTextNode($)),
              ($[wf] = a),
              (a.stateNode = $))
      }
      return null
    case 13:
      return (
        H(P$1),
        ($ = a.memoizedState),
        a.flags & 64
          ? ((a.lanes = s), a)
          : (($ = $ !== null),
            (s = !1),
            o === null
              ? a.memoizedProps.fallback !== void 0 && rh(a)
              : (s = o.memoizedState !== null),
            $ &&
              !s &&
              a.mode & 2 &&
              ((o === null &&
                a.memoizedProps.unstable_avoidThisFallback !== !0) ||
              P$1.current & 1
                ? V === 0 && (V = 3)
                : ((V === 0 || V === 3) && (V = 4),
                  U === null ||
                    (!(Dg & 134217727) && !(Hi & 134217727)) ||
                    Ii(U, W))),
            ($ || s) && (a.flags |= 4),
            null)
      )
    case 4:
      return fh(), Ci(a), o === null && cf(a.stateNode.containerInfo), null
    case 10:
      return rg(a), null
    case 17:
      return Ff(a.type) && Gf(), null
    case 19:
      if ((H(P$1), ($ = a.memoizedState), $ === null)) return null
      if (((_e = (a.flags & 64) !== 0), (et = $.rendering), et === null))
        if (_e) Fi($, !1)
        else {
          if (V !== 0 || (o !== null && o.flags & 64))
            for (o = a.child; o !== null; ) {
              if (((et = ih(o)), et !== null)) {
                for (
                  a.flags |= 64,
                    Fi($, !1),
                    _e = et.updateQueue,
                    _e !== null && ((a.updateQueue = _e), (a.flags |= 4)),
                    $.lastEffect === null && (a.firstEffect = null),
                    a.lastEffect = $.lastEffect,
                    $ = s,
                    s = a.child;
                  s !== null;

                )
                  (_e = s),
                    (o = $),
                    (_e.flags &= 2),
                    (_e.nextEffect = null),
                    (_e.firstEffect = null),
                    (_e.lastEffect = null),
                    (et = _e.alternate),
                    et === null
                      ? ((_e.childLanes = 0),
                        (_e.lanes = o),
                        (_e.child = null),
                        (_e.memoizedProps = null),
                        (_e.memoizedState = null),
                        (_e.updateQueue = null),
                        (_e.dependencies = null),
                        (_e.stateNode = null))
                      : ((_e.childLanes = et.childLanes),
                        (_e.lanes = et.lanes),
                        (_e.child = et.child),
                        (_e.memoizedProps = et.memoizedProps),
                        (_e.memoizedState = et.memoizedState),
                        (_e.updateQueue = et.updateQueue),
                        (_e.type = et.type),
                        (o = et.dependencies),
                        (_e.dependencies =
                          o === null
                            ? null
                            : {
                                lanes: o.lanes,
                                firstContext: o.firstContext,
                              })),
                    (s = s.sibling)
                return I(P$1, (P$1.current & 1) | 2), a.child
              }
              o = o.sibling
            }
          $.tail !== null &&
            O() > Ji &&
            ((a.flags |= 64), (_e = !0), Fi($, !1), (a.lanes = 33554432))
        }
      else {
        if (!_e)
          if (((o = ih(et)), o !== null)) {
            if (
              ((a.flags |= 64),
              (_e = !0),
              (s = o.updateQueue),
              s !== null && ((a.updateQueue = s), (a.flags |= 4)),
              Fi($, !0),
              $.tail === null &&
                $.tailMode === 'hidden' &&
                !et.alternate &&
                !lh)
            )
              return (
                (a = a.lastEffect = $.lastEffect),
                a !== null && (a.nextEffect = null),
                null
              )
          } else
            2 * O() - $.renderingStartTime > Ji &&
              s !== 1073741824 &&
              ((a.flags |= 64), (_e = !0), Fi($, !1), (a.lanes = 33554432))
        $.isBackwards
          ? ((et.sibling = a.child), (a.child = et))
          : ((s = $.last),
            s !== null ? (s.sibling = et) : (a.child = et),
            ($.last = et))
      }
      return $.tail !== null
        ? ((s = $.tail),
          ($.rendering = s),
          ($.tail = s.sibling),
          ($.lastEffect = a.lastEffect),
          ($.renderingStartTime = O()),
          (s.sibling = null),
          (a = P$1.current),
          I(P$1, _e ? (a & 1) | 2 : a & 1),
          s)
        : null
    case 23:
    case 24:
      return (
        Ki(),
        o !== null &&
          (o.memoizedState !== null) != (a.memoizedState !== null) &&
          $.mode !== 'unstable-defer-without-hiding' &&
          (a.flags |= 4),
        null
      )
  }
  throw Error(y$3(156, a.tag))
}
function Li(o) {
  switch (o.tag) {
    case 1:
      Ff(o.type) && Gf()
      var a = o.flags
      return a & 4096 ? ((o.flags = (a & -4097) | 64), o) : null
    case 3:
      if ((fh(), H(N), H(M), uh(), (a = o.flags), a & 64)) throw Error(y$3(285))
      return (o.flags = (a & -4097) | 64), o
    case 5:
      return hh(o), null
    case 13:
      return (
        H(P$1),
        (a = o.flags),
        a & 4096 ? ((o.flags = (a & -4097) | 64), o) : null
      )
    case 19:
      return H(P$1), null
    case 4:
      return fh(), null
    case 10:
      return rg(o), null
    case 23:
    case 24:
      return Ki(), null
    default:
      return null
  }
}
function Mi(o, a) {
  try {
    var s = '',
      $ = a
    do (s += Qa($)), ($ = $.return)
    while ($)
    var j = s
  } catch (_e) {
    j =
      `
Error generating stack: ` +
      _e.message +
      `
` +
      _e.stack
  }
  return { value: o, source: a, stack: j }
}
function Ni(o, a) {
  try {
    console.error(a.value)
  } catch (s) {
    setTimeout(function() {
      throw s
    })
  }
}
var Oi = typeof WeakMap == 'function' ? WeakMap : Map
function Pi(o, a, s) {
  ;(s = zg(-1, s)), (s.tag = 3), (s.payload = { element: null })
  var $ = a.value
  return (
    (s.callback = function() {
      Qi || ((Qi = !0), (Ri = $)), Ni(o, a)
    }),
    s
  )
}
function Si(o, a, s) {
  ;(s = zg(-1, s)), (s.tag = 3)
  var $ = o.type.getDerivedStateFromError
  if (typeof $ == 'function') {
    var j = a.value
    s.payload = function() {
      return Ni(o, a), $(j)
    }
  }
  var _e = o.stateNode
  return (
    _e !== null &&
      typeof _e.componentDidCatch == 'function' &&
      (s.callback = function() {
        typeof $ != 'function' &&
          (Ti === null ? (Ti = new Set([this])) : Ti.add(this), Ni(o, a))
        var et = a.stack
        this.componentDidCatch(a.value, {
          componentStack: et !== null ? et : '',
        })
      }),
    s
  )
}
var Ui = typeof WeakSet == 'function' ? WeakSet : Set
function Vi(o) {
  var a = o.ref
  if (a !== null)
    if (typeof a == 'function')
      try {
        a(null)
      } catch (s) {
        Wi(o, s)
      }
    else a.current = null
}
function Xi(o, a) {
  switch (a.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return
    case 1:
      if (a.flags & 256 && o !== null) {
        var s = o.memoizedProps,
          $ = o.memoizedState
        ;(o = a.stateNode),
          (a = o.getSnapshotBeforeUpdate(
            a.elementType === a.type ? s : lg(a.type, s),
            $
          )),
          (o.__reactInternalSnapshotBeforeUpdate = a)
      }
      return
    case 3:
      a.flags & 256 && qf(a.stateNode.containerInfo)
      return
    case 5:
    case 6:
    case 4:
    case 17:
      return
  }
  throw Error(y$3(163))
}
function Yi(o, a, s) {
  switch (s.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      if (
        ((a = s.updateQueue),
        (a = a !== null ? a.lastEffect : null),
        a !== null)
      ) {
        o = a = a.next
        do {
          if ((o.tag & 3) === 3) {
            var $ = o.create
            o.destroy = $()
          }
          o = o.next
        } while (o !== a)
      }
      if (
        ((a = s.updateQueue),
        (a = a !== null ? a.lastEffect : null),
        a !== null)
      ) {
        o = a = a.next
        do {
          var j = o
          ;($ = j.next),
            (j = j.tag),
            j & 4 && j & 1 && (Zi(s, o), $i(s, o)),
            (o = $)
        } while (o !== a)
      }
      return
    case 1:
      ;(o = s.stateNode),
        s.flags & 4 &&
          (a === null
            ? o.componentDidMount()
            : (($ =
                s.elementType === s.type
                  ? a.memoizedProps
                  : lg(s.type, a.memoizedProps)),
              o.componentDidUpdate(
                $,
                a.memoizedState,
                o.__reactInternalSnapshotBeforeUpdate
              ))),
        (a = s.updateQueue),
        a !== null && Eg(s, a, o)
      return
    case 3:
      if (((a = s.updateQueue), a !== null)) {
        if (((o = null), s.child !== null))
          switch (s.child.tag) {
            case 5:
              o = s.child.stateNode
              break
            case 1:
              o = s.child.stateNode
          }
        Eg(s, a, o)
      }
      return
    case 5:
      ;(o = s.stateNode),
        a === null && s.flags & 4 && mf(s.type, s.memoizedProps) && o.focus()
      return
    case 6:
      return
    case 4:
      return
    case 12:
      return
    case 13:
      s.memoizedState === null &&
        ((s = s.alternate),
        s !== null &&
          ((s = s.memoizedState),
          s !== null && ((s = s.dehydrated), s !== null && Cc(s))))
      return
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return
  }
  throw Error(y$3(163))
}
function aj(o, a) {
  for (var s = o; ; ) {
    if (s.tag === 5) {
      var $ = s.stateNode
      if (a)
        ($ = $.style),
          typeof $.setProperty == 'function'
            ? $.setProperty('display', 'none', 'important')
            : ($.display = 'none')
      else {
        $ = s.stateNode
        var j = s.memoizedProps.style
        ;(j = j != null && j.hasOwnProperty('display') ? j.display : null),
          ($.style.display = sb('display', j))
      }
    } else if (s.tag === 6) s.stateNode.nodeValue = a ? '' : s.memoizedProps
    else if (
      ((s.tag !== 23 && s.tag !== 24) || s.memoizedState === null || s === o) &&
      s.child !== null
    ) {
      ;(s.child.return = s), (s = s.child)
      continue
    }
    if (s === o) break
    for (; s.sibling === null; ) {
      if (s.return === null || s.return === o) return
      s = s.return
    }
    ;(s.sibling.return = s.return), (s = s.sibling)
  }
}
function bj(o, a) {
  if (Mf && typeof Mf.onCommitFiberUnmount == 'function')
    try {
      Mf.onCommitFiberUnmount(Lf, a)
    } catch {}
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      if (
        ((o = a.updateQueue), o !== null && ((o = o.lastEffect), o !== null))
      ) {
        var s = (o = o.next)
        do {
          var $ = s,
            j = $.destroy
          if ((($ = $.tag), j !== void 0))
            if ($ & 4) Zi(a, s)
            else {
              $ = a
              try {
                j()
              } catch (_e) {
                Wi($, _e)
              }
            }
          s = s.next
        } while (s !== o)
      }
      break
    case 1:
      if (
        (Vi(a), (o = a.stateNode), typeof o.componentWillUnmount == 'function')
      )
        try {
          ;(o.props = a.memoizedProps),
            (o.state = a.memoizedState),
            o.componentWillUnmount()
        } catch (_e) {
          Wi(a, _e)
        }
      break
    case 5:
      Vi(a)
      break
    case 4:
      cj(o, a)
  }
}
function dj(o) {
  ;(o.alternate = null),
    (o.child = null),
    (o.dependencies = null),
    (o.firstEffect = null),
    (o.lastEffect = null),
    (o.memoizedProps = null),
    (o.memoizedState = null),
    (o.pendingProps = null),
    (o.return = null),
    (o.updateQueue = null)
}
function ej(o) {
  return o.tag === 5 || o.tag === 3 || o.tag === 4
}
function fj(o) {
  e: {
    for (var a = o.return; a !== null; ) {
      if (ej(a)) break e
      a = a.return
    }
    throw Error(y$3(160))
  }
  var s = a
  switch (((a = s.stateNode), s.tag)) {
    case 5:
      var $ = !1
      break
    case 3:
      ;(a = a.containerInfo), ($ = !0)
      break
    case 4:
      ;(a = a.containerInfo), ($ = !0)
      break
    default:
      throw Error(y$3(161))
  }
  s.flags & 16 && (pb(a, ''), (s.flags &= -17))
  e: t: for (s = o; ; ) {
    for (; s.sibling === null; ) {
      if (s.return === null || ej(s.return)) {
        s = null
        break e
      }
      s = s.return
    }
    for (
      s.sibling.return = s.return, s = s.sibling;
      s.tag !== 5 && s.tag !== 6 && s.tag !== 18;

    ) {
      if (s.flags & 2 || s.child === null || s.tag === 4) continue t
      ;(s.child.return = s), (s = s.child)
    }
    if (!(s.flags & 2)) {
      s = s.stateNode
      break e
    }
  }
  $ ? gj(o, s, a) : hj(o, s, a)
}
function gj(o, a, s) {
  var $ = o.tag,
    j = $ === 5 || $ === 6
  if (j)
    (o = j ? o.stateNode : o.stateNode.instance),
      a
        ? s.nodeType === 8
          ? s.parentNode.insertBefore(o, a)
          : s.insertBefore(o, a)
        : (s.nodeType === 8
            ? ((a = s.parentNode), a.insertBefore(o, s))
            : ((a = s), a.appendChild(o)),
          (s = s._reactRootContainer),
          s != null || a.onclick !== null || (a.onclick = jf))
  else if ($ !== 4 && ((o = o.child), o !== null))
    for (gj(o, a, s), o = o.sibling; o !== null; ) gj(o, a, s), (o = o.sibling)
}
function hj(o, a, s) {
  var $ = o.tag,
    j = $ === 5 || $ === 6
  if (j)
    (o = j ? o.stateNode : o.stateNode.instance),
      a ? s.insertBefore(o, a) : s.appendChild(o)
  else if ($ !== 4 && ((o = o.child), o !== null))
    for (hj(o, a, s), o = o.sibling; o !== null; ) hj(o, a, s), (o = o.sibling)
}
function cj(o, a) {
  for (var s = a, $ = !1, j, _e; ; ) {
    if (!$) {
      $ = s.return
      e: for (;;) {
        if ($ === null) throw Error(y$3(160))
        switch (((j = $.stateNode), $.tag)) {
          case 5:
            _e = !1
            break e
          case 3:
            ;(j = j.containerInfo), (_e = !0)
            break e
          case 4:
            ;(j = j.containerInfo), (_e = !0)
            break e
        }
        $ = $.return
      }
      $ = !0
    }
    if (s.tag === 5 || s.tag === 6) {
      e: for (var et = o, tt = s, rt = tt; ; )
        if ((bj(et, rt), rt.child !== null && rt.tag !== 4))
          (rt.child.return = rt), (rt = rt.child)
        else {
          if (rt === tt) break e
          for (; rt.sibling === null; ) {
            if (rt.return === null || rt.return === tt) break e
            rt = rt.return
          }
          ;(rt.sibling.return = rt.return), (rt = rt.sibling)
        }
      _e
        ? ((et = j),
          (tt = s.stateNode),
          et.nodeType === 8
            ? et.parentNode.removeChild(tt)
            : et.removeChild(tt))
        : j.removeChild(s.stateNode)
    } else if (s.tag === 4) {
      if (s.child !== null) {
        ;(j = s.stateNode.containerInfo),
          (_e = !0),
          (s.child.return = s),
          (s = s.child)
        continue
      }
    } else if ((bj(o, s), s.child !== null)) {
      ;(s.child.return = s), (s = s.child)
      continue
    }
    if (s === a) break
    for (; s.sibling === null; ) {
      if (s.return === null || s.return === a) return
      ;(s = s.return), s.tag === 4 && ($ = !1)
    }
    ;(s.sibling.return = s.return), (s = s.sibling)
  }
}
function ij(o, a) {
  switch (a.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var s = a.updateQueue
      if (((s = s !== null ? s.lastEffect : null), s !== null)) {
        var $ = (s = s.next)
        do
          ($.tag & 3) === 3 &&
            ((o = $.destroy), ($.destroy = void 0), o !== void 0 && o()),
            ($ = $.next)
        while ($ !== s)
      }
      return
    case 1:
      return
    case 5:
      if (((s = a.stateNode), s != null)) {
        $ = a.memoizedProps
        var j = o !== null ? o.memoizedProps : $
        o = a.type
        var _e = a.updateQueue
        if (((a.updateQueue = null), _e !== null)) {
          for (
            s[xf] = $,
              o === 'input' && $.type === 'radio' && $.name != null && $a(s, $),
              wb(o, j),
              a = wb(o, $),
              j = 0;
            j < _e.length;
            j += 2
          ) {
            var et = _e[j],
              tt = _e[j + 1]
            et === 'style'
              ? tb(s, tt)
              : et === 'dangerouslySetInnerHTML'
              ? ob(s, tt)
              : et === 'children'
              ? pb(s, tt)
              : qa(s, et, tt, a)
          }
          switch (o) {
            case 'input':
              ab(s, $)
              break
            case 'textarea':
              ib(s, $)
              break
            case 'select':
              ;(o = s._wrapperState.wasMultiple),
                (s._wrapperState.wasMultiple = !!$.multiple),
                (_e = $.value),
                _e != null
                  ? fb(s, !!$.multiple, _e, !1)
                  : o !== !!$.multiple &&
                    ($.defaultValue != null
                      ? fb(s, !!$.multiple, $.defaultValue, !0)
                      : fb(s, !!$.multiple, $.multiple ? [] : '', !1))
          }
        }
      }
      return
    case 6:
      if (a.stateNode === null) throw Error(y$3(162))
      a.stateNode.nodeValue = a.memoizedProps
      return
    case 3:
      ;(s = a.stateNode), s.hydrate && ((s.hydrate = !1), Cc(s.containerInfo))
      return
    case 12:
      return
    case 13:
      a.memoizedState !== null && ((jj = O()), aj(a.child, !0)), kj(a)
      return
    case 19:
      kj(a)
      return
    case 17:
      return
    case 23:
    case 24:
      aj(a, a.memoizedState !== null)
      return
  }
  throw Error(y$3(163))
}
function kj(o) {
  var a = o.updateQueue
  if (a !== null) {
    o.updateQueue = null
    var s = o.stateNode
    s === null && (s = o.stateNode = new Ui()),
      a.forEach(function($) {
        var j = lj.bind(null, o, $)
        s.has($) || (s.add($), $.then(j, j))
      })
  }
}
function mj(o, a) {
  return o !== null &&
    ((o = o.memoizedState), o === null || o.dehydrated !== null)
    ? ((a = a.memoizedState), a !== null && a.dehydrated === null)
    : !1
}
var nj = Math.ceil,
  oj = ra.ReactCurrentDispatcher,
  pj = ra.ReactCurrentOwner,
  X = 0,
  U = null,
  Y = null,
  W = 0,
  qj = 0,
  rj = Bf(0),
  V = 0,
  sj = null,
  tj = 0,
  Dg = 0,
  Hi = 0,
  uj = 0,
  vj = null,
  jj = 0,
  Ji = 1 / 0
function wj() {
  Ji = O() + 500
}
var Z = null,
  Qi = !1,
  Ri = null,
  Ti = null,
  xj = !1,
  yj = null,
  zj = 90,
  Aj = [],
  Bj = [],
  Cj = null,
  Dj = 0,
  Ej = null,
  Fj = -1,
  Gj = 0,
  Hj = 0,
  Ij = null,
  Jj = !1
function Hg() {
  return X & 48 ? O() : Fj !== -1 ? Fj : (Fj = O())
}
function Ig(o) {
  if (((o = o.mode), !(o & 2))) return 1
  if (!(o & 4)) return eg() === 99 ? 1 : 2
  if ((Gj === 0 && (Gj = tj), kg.transition !== 0)) {
    Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0), (o = Gj)
    var a = 4186112 & ~Hj
    return (
      (a &= -a),
      a === 0 && ((o = 4186112 & ~o), (a = o & -o), a === 0 && (a = 8192)),
      a
    )
  }
  return (
    (o = eg()),
    X & 4 && o === 98 ? (o = Xc(12, Gj)) : ((o = Sc(o)), (o = Xc(o, Gj))),
    o
  )
}
function Jg(o, a, s) {
  if (50 < Dj) throw ((Dj = 0), (Ej = null), Error(y$3(185)))
  if (((o = Kj(o, a)), o === null)) return null
  $c(o, a, s), o === U && ((Hi |= a), V === 4 && Ii(o, W))
  var $ = eg()
  a === 1
    ? X & 8 && !(X & 48)
      ? Lj(o)
      : (Mj(o, s), X === 0 && (wj(), ig()))
    : (!(X & 4) ||
        ($ !== 98 && $ !== 99) ||
        (Cj === null ? (Cj = new Set([o])) : Cj.add(o)),
      Mj(o, s)),
    (vj = o)
}
function Kj(o, a) {
  o.lanes |= a
  var s = o.alternate
  for (s !== null && (s.lanes |= a), s = o, o = o.return; o !== null; )
    (o.childLanes |= a),
      (s = o.alternate),
      s !== null && (s.childLanes |= a),
      (s = o),
      (o = o.return)
  return s.tag === 3 ? s.stateNode : null
}
function Mj(o, a) {
  for (
    var s = o.callbackNode,
      $ = o.suspendedLanes,
      j = o.pingedLanes,
      _e = o.expirationTimes,
      et = o.pendingLanes;
    0 < et;

  ) {
    var tt = 31 - Vc(et),
      rt = 1 << tt,
      nt = _e[tt]
    if (nt === -1) {
      if (!(rt & $) || rt & j) {
        ;(nt = a), Rc(rt)
        var it = F
        _e[tt] = 10 <= it ? nt + 250 : 6 <= it ? nt + 5e3 : -1
      }
    } else nt <= a && (o.expiredLanes |= rt)
    et &= ~rt
  }
  if ((($ = Uc(o, o === U ? W : 0)), (a = F), $ === 0))
    s !== null &&
      (s !== Zf && Pf(s), (o.callbackNode = null), (o.callbackPriority = 0))
  else {
    if (s !== null) {
      if (o.callbackPriority === a) return
      s !== Zf && Pf(s)
    }
    a === 15
      ? ((s = Lj.bind(null, o)),
        ag === null ? ((ag = [s]), (bg = Of(Uf, jg))) : ag.push(s),
        (s = Zf))
      : a === 14
      ? (s = hg(99, Lj.bind(null, o)))
      : ((s = Tc(a)), (s = hg(s, Nj.bind(null, o)))),
      (o.callbackPriority = a),
      (o.callbackNode = s)
  }
}
function Nj(o) {
  if (((Fj = -1), (Hj = Gj = 0), X & 48)) throw Error(y$3(327))
  var a = o.callbackNode
  if (Oj() && o.callbackNode !== a) return null
  var s = Uc(o, o === U ? W : 0)
  if (s === 0) return null
  var $ = s,
    j = X
  X |= 16
  var _e = Pj()
  ;(U !== o || W !== $) && (wj(), Qj(o, $))
  do
    try {
      Rj()
      break
    } catch (tt) {
      Sj(o, tt)
    }
  while (!0)
  if (
    (qg(),
    (oj.current = _e),
    (X = j),
    Y !== null ? ($ = 0) : ((U = null), (W = 0), ($ = V)),
    tj & Hi)
  )
    Qj(o, 0)
  else if ($ !== 0) {
    if (
      ($ === 2 &&
        ((X |= 64),
        o.hydrate && ((o.hydrate = !1), qf(o.containerInfo)),
        (s = Wc(o)),
        s !== 0 && ($ = Tj(o, s))),
      $ === 1)
    )
      throw ((a = sj), Qj(o, 0), Ii(o, s), Mj(o, O()), a)
    switch (
      ((o.finishedWork = o.current.alternate), (o.finishedLanes = s), $)
    ) {
      case 0:
      case 1:
        throw Error(y$3(345))
      case 2:
        Uj(o)
        break
      case 3:
        if (
          (Ii(o, s), (s & 62914560) === s && (($ = jj + 500 - O()), 10 < $))
        ) {
          if (Uc(o, 0) !== 0) break
          if (((j = o.suspendedLanes), (j & s) !== s)) {
            Hg(), (o.pingedLanes |= o.suspendedLanes & j)
            break
          }
          o.timeoutHandle = of(Uj.bind(null, o), $)
          break
        }
        Uj(o)
        break
      case 4:
        if ((Ii(o, s), (s & 4186112) === s)) break
        for ($ = o.eventTimes, j = -1; 0 < s; ) {
          var et = 31 - Vc(s)
          ;(_e = 1 << et), (et = $[et]), et > j && (j = et), (s &= ~_e)
        }
        if (
          ((s = j),
          (s = O() - s),
          (s =
            (120 > s
              ? 120
              : 480 > s
              ? 480
              : 1080 > s
              ? 1080
              : 1920 > s
              ? 1920
              : 3e3 > s
              ? 3e3
              : 4320 > s
              ? 4320
              : 1960 * nj(s / 1960)) - s),
          10 < s)
        ) {
          o.timeoutHandle = of(Uj.bind(null, o), s)
          break
        }
        Uj(o)
        break
      case 5:
        Uj(o)
        break
      default:
        throw Error(y$3(329))
    }
  }
  return Mj(o, O()), o.callbackNode === a ? Nj.bind(null, o) : null
}
function Ii(o, a) {
  for (
    a &= ~uj,
      a &= ~Hi,
      o.suspendedLanes |= a,
      o.pingedLanes &= ~a,
      o = o.expirationTimes;
    0 < a;

  ) {
    var s = 31 - Vc(a),
      $ = 1 << s
    ;(o[s] = -1), (a &= ~$)
  }
}
function Lj(o) {
  if (X & 48) throw Error(y$3(327))
  if ((Oj(), o === U && o.expiredLanes & W)) {
    var a = W,
      s = Tj(o, a)
    tj & Hi && ((a = Uc(o, a)), (s = Tj(o, a)))
  } else (a = Uc(o, 0)), (s = Tj(o, a))
  if (
    (o.tag !== 0 &&
      s === 2 &&
      ((X |= 64),
      o.hydrate && ((o.hydrate = !1), qf(o.containerInfo)),
      (a = Wc(o)),
      a !== 0 && (s = Tj(o, a))),
    s === 1)
  )
    throw ((s = sj), Qj(o, 0), Ii(o, a), Mj(o, O()), s)
  return (
    (o.finishedWork = o.current.alternate),
    (o.finishedLanes = a),
    Uj(o),
    Mj(o, O()),
    null
  )
}
function Vj() {
  if (Cj !== null) {
    var o = Cj
    ;(Cj = null),
      o.forEach(function(a) {
        ;(a.expiredLanes |= 24 & a.pendingLanes), Mj(a, O())
      })
  }
  ig()
}
function Wj(o, a) {
  var s = X
  X |= 1
  try {
    return o(a)
  } finally {
    ;(X = s), X === 0 && (wj(), ig())
  }
}
function Xj(o, a) {
  var s = X
  ;(X &= -2), (X |= 8)
  try {
    return o(a)
  } finally {
    ;(X = s), X === 0 && (wj(), ig())
  }
}
function ni(o, a) {
  I(rj, qj), (qj |= a), (tj |= a)
}
function Ki() {
  ;(qj = rj.current), H(rj)
}
function Qj(o, a) {
  ;(o.finishedWork = null), (o.finishedLanes = 0)
  var s = o.timeoutHandle
  if ((s !== -1 && ((o.timeoutHandle = -1), pf(s)), Y !== null))
    for (s = Y.return; s !== null; ) {
      var $ = s
      switch ($.tag) {
        case 1:
          ;($ = $.type.childContextTypes), $ != null && Gf()
          break
        case 3:
          fh(), H(N), H(M), uh()
          break
        case 5:
          hh($)
          break
        case 4:
          fh()
          break
        case 13:
          H(P$1)
          break
        case 19:
          H(P$1)
          break
        case 10:
          rg($)
          break
        case 23:
        case 24:
          Ki()
      }
      s = s.return
    }
  ;(U = o),
    (Y = Tg(o.current, null)),
    (W = qj = tj = a),
    (V = 0),
    (sj = null),
    (uj = Hi = Dg = 0)
}
function Sj(o, a) {
  do {
    var s = Y
    try {
      if ((qg(), (vh.current = Gh), yh)) {
        for (var $ = R$1.memoizedState; $ !== null; ) {
          var j = $.queue
          j !== null && (j.pending = null), ($ = $.next)
        }
        yh = !1
      }
      if (
        ((xh = 0),
        (T = S = R$1 = null),
        (zh = !1),
        (pj.current = null),
        s === null || s.return === null)
      ) {
        ;(V = 1), (sj = a), (Y = null)
        break
      }
      e: {
        var _e = o,
          et = s.return,
          tt = s,
          rt = a
        if (
          ((a = W),
          (tt.flags |= 2048),
          (tt.firstEffect = tt.lastEffect = null),
          rt !== null && typeof rt == 'object' && typeof rt.then == 'function')
        ) {
          var nt = rt
          if (!(tt.mode & 2)) {
            var it = tt.alternate
            it
              ? ((tt.updateQueue = it.updateQueue),
                (tt.memoizedState = it.memoizedState),
                (tt.lanes = it.lanes))
              : ((tt.updateQueue = null), (tt.memoizedState = null))
          }
          var ot = (P$1.current & 1) !== 0,
            at = et
          do {
            var st
            if ((st = at.tag === 13)) {
              var ut = at.memoizedState
              if (ut !== null) st = ut.dehydrated !== null
              else {
                var ct = at.memoizedProps
                st =
                  ct.fallback === void 0
                    ? !1
                    : ct.unstable_avoidThisFallback !== !0
                    ? !0
                    : !ot
              }
            }
            if (st) {
              var dt = at.updateQueue
              if (dt === null) {
                var ft = new Set()
                ft.add(nt), (at.updateQueue = ft)
              } else dt.add(nt)
              if (!(at.mode & 2)) {
                if (
                  ((at.flags |= 64),
                  (tt.flags |= 16384),
                  (tt.flags &= -2981),
                  tt.tag === 1)
                )
                  if (tt.alternate === null) tt.tag = 17
                  else {
                    var mt = zg(-1, 1)
                    ;(mt.tag = 2), Ag(tt, mt)
                  }
                tt.lanes |= 1
                break e
              }
              ;(rt = void 0), (tt = a)
              var vt = _e.pingCache
              if (
                (vt === null
                  ? ((vt = _e.pingCache = new Oi()),
                    (rt = new Set()),
                    vt.set(nt, rt))
                  : ((rt = vt.get(nt)),
                    rt === void 0 && ((rt = new Set()), vt.set(nt, rt))),
                !rt.has(tt))
              ) {
                rt.add(tt)
                var yt = Yj.bind(null, _e, nt, tt)
                nt.then(yt, yt)
              }
              ;(at.flags |= 4096), (at.lanes = a)
              break e
            }
            at = at.return
          } while (at !== null)
          rt = Error(
            (Ra(tt.type) || 'A React component') +
              ` suspended while rendering, but no fallback UI was specified.

Add a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.`
          )
        }
        V !== 5 && (V = 2), (rt = Mi(rt, tt)), (at = et)
        do {
          switch (at.tag) {
            case 3:
              ;(_e = rt), (at.flags |= 4096), (a &= -a), (at.lanes |= a)
              var pt = Pi(at, _e, a)
              Bg(at, pt)
              break e
            case 1:
              _e = rt
              var ht = at.type,
                At = at.stateNode
              if (
                !(at.flags & 64) &&
                (typeof ht.getDerivedStateFromError == 'function' ||
                  (At !== null &&
                    typeof At.componentDidCatch == 'function' &&
                    (Ti === null || !Ti.has(At))))
              ) {
                ;(at.flags |= 4096), (a &= -a), (at.lanes |= a)
                var wt = Si(at, _e, a)
                Bg(at, wt)
                break e
              }
          }
          at = at.return
        } while (at !== null)
      }
      Zj(s)
    } catch (Ct) {
      ;(a = Ct), Y === s && s !== null && (Y = s = s.return)
      continue
    }
    break
  } while (!0)
}
function Pj() {
  var o = oj.current
  return (oj.current = Gh), o === null ? Gh : o
}
function Tj(o, a) {
  var s = X
  X |= 16
  var $ = Pj()
  ;(U === o && W === a) || Qj(o, a)
  do
    try {
      ak()
      break
    } catch (j) {
      Sj(o, j)
    }
  while (!0)
  if ((qg(), (X = s), (oj.current = $), Y !== null)) throw Error(y$3(261))
  return (U = null), (W = 0), V
}
function ak() {
  for (; Y !== null; ) bk(Y)
}
function Rj() {
  for (; Y !== null && !Qf(); ) bk(Y)
}
function bk(o) {
  var a = ck(o.alternate, o, qj)
  ;(o.memoizedProps = o.pendingProps),
    a === null ? Zj(o) : (Y = a),
    (pj.current = null)
}
function Zj(o) {
  var a = o
  do {
    var s = a.alternate
    if (((o = a.return), a.flags & 2048)) {
      if (((s = Li(a)), s !== null)) {
        ;(s.flags &= 2047), (Y = s)
        return
      }
      o !== null && ((o.firstEffect = o.lastEffect = null), (o.flags |= 2048))
    } else {
      if (((s = Gi(s, a, qj)), s !== null)) {
        Y = s
        return
      }
      if (
        ((s = a),
        (s.tag !== 24 && s.tag !== 23) ||
          s.memoizedState === null ||
          qj & 1073741824 ||
          !(s.mode & 4))
      ) {
        for (var $ = 0, j = s.child; j !== null; )
          ($ |= j.lanes | j.childLanes), (j = j.sibling)
        s.childLanes = $
      }
      o !== null &&
        !(o.flags & 2048) &&
        (o.firstEffect === null && (o.firstEffect = a.firstEffect),
        a.lastEffect !== null &&
          (o.lastEffect !== null && (o.lastEffect.nextEffect = a.firstEffect),
          (o.lastEffect = a.lastEffect)),
        1 < a.flags &&
          (o.lastEffect !== null
            ? (o.lastEffect.nextEffect = a)
            : (o.firstEffect = a),
          (o.lastEffect = a)))
    }
    if (((a = a.sibling), a !== null)) {
      Y = a
      return
    }
    Y = a = o
  } while (a !== null)
  V === 0 && (V = 5)
}
function Uj(o) {
  var a = eg()
  return gg(99, dk.bind(null, o, a)), null
}
function dk(o, a) {
  do Oj()
  while (yj !== null)
  if (X & 48) throw Error(y$3(327))
  var s = o.finishedWork
  if (s === null) return null
  if (((o.finishedWork = null), (o.finishedLanes = 0), s === o.current))
    throw Error(y$3(177))
  o.callbackNode = null
  var $ = s.lanes | s.childLanes,
    j = $,
    _e = o.pendingLanes & ~j
  ;(o.pendingLanes = j),
    (o.suspendedLanes = 0),
    (o.pingedLanes = 0),
    (o.expiredLanes &= j),
    (o.mutableReadLanes &= j),
    (o.entangledLanes &= j),
    (j = o.entanglements)
  for (var et = o.eventTimes, tt = o.expirationTimes; 0 < _e; ) {
    var rt = 31 - Vc(_e),
      nt = 1 << rt
    ;(j[rt] = 0), (et[rt] = -1), (tt[rt] = -1), (_e &= ~nt)
  }
  if (
    (Cj !== null && !($ & 24) && Cj.has(o) && Cj.delete(o),
    o === U && ((Y = U = null), (W = 0)),
    1 < s.flags
      ? s.lastEffect !== null
        ? ((s.lastEffect.nextEffect = s), ($ = s.firstEffect))
        : ($ = s)
      : ($ = s.firstEffect),
    $ !== null)
  ) {
    if (
      ((j = X), (X |= 32), (pj.current = null), (kf = fd), (et = Ne()), Oe(et))
    ) {
      if ('selectionStart' in et)
        tt = { start: et.selectionStart, end: et.selectionEnd }
      else
        e: if (
          ((tt = ((tt = et.ownerDocument) && tt.defaultView) || window),
          (nt = tt.getSelection && tt.getSelection()) && nt.rangeCount !== 0)
        ) {
          ;(tt = nt.anchorNode),
            (_e = nt.anchorOffset),
            (rt = nt.focusNode),
            (nt = nt.focusOffset)
          try {
            tt.nodeType, rt.nodeType
          } catch {
            tt = null
            break e
          }
          var it = 0,
            ot = -1,
            at = -1,
            st = 0,
            ut = 0,
            ct = et,
            dt = null
          t: for (;;) {
            for (
              var ft;
              ct !== tt || (_e !== 0 && ct.nodeType !== 3) || (ot = it + _e),
                ct !== rt || (nt !== 0 && ct.nodeType !== 3) || (at = it + nt),
                ct.nodeType === 3 && (it += ct.nodeValue.length),
                (ft = ct.firstChild) !== null;

            )
              (dt = ct), (ct = ft)
            for (;;) {
              if (ct === et) break t
              if (
                (dt === tt && ++st === _e && (ot = it),
                dt === rt && ++ut === nt && (at = it),
                (ft = ct.nextSibling) !== null)
              )
                break
              ;(ct = dt), (dt = ct.parentNode)
            }
            ct = ft
          }
          tt = ot === -1 || at === -1 ? null : { start: ot, end: at }
        } else tt = null
      tt = tt || { start: 0, end: 0 }
    } else tt = null
    ;(lf = { focusedElem: et, selectionRange: tt }),
      (fd = !1),
      (Ij = null),
      (Jj = !1),
      (Z = $)
    do
      try {
        ek()
      } catch (Ct) {
        if (Z === null) throw Error(y$3(330))
        Wi(Z, Ct), (Z = Z.nextEffect)
      }
    while (Z !== null)
    ;(Ij = null), (Z = $)
    do
      try {
        for (et = o; Z !== null; ) {
          var mt = Z.flags
          if ((mt & 16 && pb(Z.stateNode, ''), mt & 128)) {
            var vt = Z.alternate
            if (vt !== null) {
              var yt = vt.ref
              yt !== null &&
                (typeof yt == 'function' ? yt(null) : (yt.current = null))
            }
          }
          switch (mt & 1038) {
            case 2:
              fj(Z), (Z.flags &= -3)
              break
            case 6:
              fj(Z), (Z.flags &= -3), ij(Z.alternate, Z)
              break
            case 1024:
              Z.flags &= -1025
              break
            case 1028:
              ;(Z.flags &= -1025), ij(Z.alternate, Z)
              break
            case 4:
              ij(Z.alternate, Z)
              break
            case 8:
              ;(tt = Z), cj(et, tt)
              var pt = tt.alternate
              dj(tt), pt !== null && dj(pt)
          }
          Z = Z.nextEffect
        }
      } catch (Ct) {
        if (Z === null) throw Error(y$3(330))
        Wi(Z, Ct), (Z = Z.nextEffect)
      }
    while (Z !== null)
    if (
      ((yt = lf),
      (vt = Ne()),
      (mt = yt.focusedElem),
      (et = yt.selectionRange),
      vt !== mt &&
        mt &&
        mt.ownerDocument &&
        Me(mt.ownerDocument.documentElement, mt))
    ) {
      for (
        et !== null &&
          Oe(mt) &&
          ((vt = et.start),
          (yt = et.end),
          yt === void 0 && (yt = vt),
          ('selectionStart' in mt)
            ? ((mt.selectionStart = vt),
              (mt.selectionEnd = Math.min(yt, mt.value.length)))
            : ((yt =
                ((vt = mt.ownerDocument || document) && vt.defaultView) ||
                window),
              yt.getSelection &&
                ((yt = yt.getSelection()),
                (tt = mt.textContent.length),
                (pt = Math.min(et.start, tt)),
                (et = et.end === void 0 ? pt : Math.min(et.end, tt)),
                !yt.extend && pt > et && ((tt = et), (et = pt), (pt = tt)),
                (tt = Le(mt, pt)),
                (_e = Le(mt, et)),
                tt &&
                  _e &&
                  (yt.rangeCount !== 1 ||
                    yt.anchorNode !== tt.node ||
                    yt.anchorOffset !== tt.offset ||
                    yt.focusNode !== _e.node ||
                    yt.focusOffset !== _e.offset) &&
                  ((vt = vt.createRange()),
                  vt.setStart(tt.node, tt.offset),
                  yt.removeAllRanges(),
                  pt > et
                    ? (yt.addRange(vt), yt.extend(_e.node, _e.offset))
                    : (vt.setEnd(_e.node, _e.offset), yt.addRange(vt)))))),
          vt = [],
          yt = mt;
        (yt = yt.parentNode);

      )
        yt.nodeType === 1 &&
          vt.push({ element: yt, left: yt.scrollLeft, top: yt.scrollTop })
      for (
        typeof mt.focus == 'function' && mt.focus(), mt = 0;
        mt < vt.length;
        mt++
      )
        (yt = vt[mt]),
          (yt.element.scrollLeft = yt.left),
          (yt.element.scrollTop = yt.top)
    }
    ;(fd = !!kf), (lf = kf = null), (o.current = s), (Z = $)
    do
      try {
        for (mt = o; Z !== null; ) {
          var ht = Z.flags
          if ((ht & 36 && Yi(mt, Z.alternate, Z), ht & 128)) {
            vt = void 0
            var At = Z.ref
            if (At !== null) {
              var wt = Z.stateNode
              switch (Z.tag) {
                case 5:
                  vt = wt
                  break
                default:
                  vt = wt
              }
              typeof At == 'function' ? At(vt) : (At.current = vt)
            }
          }
          Z = Z.nextEffect
        }
      } catch (Ct) {
        if (Z === null) throw Error(y$3(330))
        Wi(Z, Ct), (Z = Z.nextEffect)
      }
    while (Z !== null)
    ;(Z = null), $f(), (X = j)
  } else o.current = s
  if (xj) (xj = !1), (yj = o), (zj = a)
  else
    for (Z = $; Z !== null; )
      (a = Z.nextEffect),
        (Z.nextEffect = null),
        Z.flags & 8 && ((ht = Z), (ht.sibling = null), (ht.stateNode = null)),
        (Z = a)
  if (
    (($ = o.pendingLanes),
    $ === 0 && (Ti = null),
    $ === 1 ? (o === Ej ? Dj++ : ((Dj = 0), (Ej = o))) : (Dj = 0),
    (s = s.stateNode),
    Mf && typeof Mf.onCommitFiberRoot == 'function')
  )
    try {
      Mf.onCommitFiberRoot(Lf, s, void 0, (s.current.flags & 64) === 64)
    } catch {}
  if ((Mj(o, O()), Qi)) throw ((Qi = !1), (o = Ri), (Ri = null), o)
  return X & 8 || ig(), null
}
function ek() {
  for (; Z !== null; ) {
    var o = Z.alternate
    Jj ||
      Ij === null ||
      (Z.flags & 8
        ? dc(Z, Ij) && (Jj = !0)
        : Z.tag === 13 && mj(o, Z) && dc(Z, Ij) && (Jj = !0))
    var a = Z.flags
    a & 256 && Xi(o, Z),
      !(a & 512) ||
        xj ||
        ((xj = !0),
        hg(97, function() {
          return Oj(), null
        })),
      (Z = Z.nextEffect)
  }
}
function Oj() {
  if (zj !== 90) {
    var o = 97 < zj ? 97 : zj
    return (zj = 90), gg(o, fk)
  }
  return !1
}
function $i(o, a) {
  Aj.push(a, o),
    xj ||
      ((xj = !0),
      hg(97, function() {
        return Oj(), null
      }))
}
function Zi(o, a) {
  Bj.push(a, o),
    xj ||
      ((xj = !0),
      hg(97, function() {
        return Oj(), null
      }))
}
function fk() {
  if (yj === null) return !1
  var o = yj
  if (((yj = null), X & 48)) throw Error(y$3(331))
  var a = X
  X |= 32
  var s = Bj
  Bj = []
  for (var $ = 0; $ < s.length; $ += 2) {
    var j = s[$],
      _e = s[$ + 1],
      et = j.destroy
    if (((j.destroy = void 0), typeof et == 'function'))
      try {
        et()
      } catch (rt) {
        if (_e === null) throw Error(y$3(330))
        Wi(_e, rt)
      }
  }
  for (s = Aj, Aj = [], $ = 0; $ < s.length; $ += 2) {
    ;(j = s[$]), (_e = s[$ + 1])
    try {
      var tt = j.create
      j.destroy = tt()
    } catch (rt) {
      if (_e === null) throw Error(y$3(330))
      Wi(_e, rt)
    }
  }
  for (tt = o.current.firstEffect; tt !== null; )
    (o = tt.nextEffect),
      (tt.nextEffect = null),
      tt.flags & 8 && ((tt.sibling = null), (tt.stateNode = null)),
      (tt = o)
  return (X = a), ig(), !0
}
function gk(o, a, s) {
  ;(a = Mi(s, a)),
    (a = Pi(o, a, 1)),
    Ag(o, a),
    (a = Hg()),
    (o = Kj(o, 1)),
    o !== null && ($c(o, 1, a), Mj(o, a))
}
function Wi(o, a) {
  if (o.tag === 3) gk(o, o, a)
  else
    for (var s = o.return; s !== null; ) {
      if (s.tag === 3) {
        gk(s, o, a)
        break
      } else if (s.tag === 1) {
        var $ = s.stateNode
        if (
          typeof s.type.getDerivedStateFromError == 'function' ||
          (typeof $.componentDidCatch == 'function' &&
            (Ti === null || !Ti.has($)))
        ) {
          o = Mi(a, o)
          var j = Si(s, o, 1)
          if ((Ag(s, j), (j = Hg()), (s = Kj(s, 1)), s !== null))
            $c(s, 1, j), Mj(s, j)
          else if (
            typeof $.componentDidCatch == 'function' &&
            (Ti === null || !Ti.has($))
          )
            try {
              $.componentDidCatch(a, o)
            } catch {}
          break
        }
      }
      s = s.return
    }
}
function Yj(o, a, s) {
  var $ = o.pingCache
  $ !== null && $.delete(a),
    (a = Hg()),
    (o.pingedLanes |= o.suspendedLanes & s),
    U === o &&
      (W & s) === s &&
      (V === 4 || (V === 3 && (W & 62914560) === W && 500 > O() - jj)
        ? Qj(o, 0)
        : (uj |= s)),
    Mj(o, a)
}
function lj(o, a) {
  var s = o.stateNode
  s !== null && s.delete(a),
    (a = 0),
    a === 0 &&
      ((a = o.mode),
      a & 2
        ? a & 4
          ? (Gj === 0 && (Gj = tj),
            (a = Yc(62914560 & ~Gj)),
            a === 0 && (a = 4194304))
          : (a = eg() === 99 ? 1 : 2)
        : (a = 1)),
    (s = Hg()),
    (o = Kj(o, a)),
    o !== null && ($c(o, a, s), Mj(o, s))
}
var ck
ck = function(o, a, s) {
  var $ = a.lanes
  if (o !== null)
    if (o.memoizedProps !== a.pendingProps || N.current) ug = !0
    else if (s & $) ug = !!(o.flags & 16384)
    else {
      switch (((ug = !1), a.tag)) {
        case 3:
          ri(a), sh()
          break
        case 5:
          gh(a)
          break
        case 1:
          Ff(a.type) && Jf(a)
          break
        case 4:
          eh(a, a.stateNode.containerInfo)
          break
        case 10:
          $ = a.memoizedProps.value
          var j = a.type._context
          I(mg, j._currentValue), (j._currentValue = $)
          break
        case 13:
          if (a.memoizedState !== null)
            return s & a.child.childLanes
              ? ti(o, a, s)
              : (I(P$1, P$1.current & 1),
                (a = hi(o, a, s)),
                a !== null ? a.sibling : null)
          I(P$1, P$1.current & 1)
          break
        case 19:
          if ((($ = (s & a.childLanes) !== 0), o.flags & 64)) {
            if ($) return Ai(o, a, s)
            a.flags |= 64
          }
          if (
            ((j = a.memoizedState),
            j !== null &&
              ((j.rendering = null), (j.tail = null), (j.lastEffect = null)),
            I(P$1, P$1.current),
            $)
          )
            break
          return null
        case 23:
        case 24:
          return (a.lanes = 0), mi(o, a, s)
      }
      return hi(o, a, s)
    }
  else ug = !1
  switch (((a.lanes = 0), a.tag)) {
    case 2:
      if (
        (($ = a.type),
        o !== null &&
          ((o.alternate = null), (a.alternate = null), (a.flags |= 2)),
        (o = a.pendingProps),
        (j = Ef(a, M.current)),
        tg(a, s),
        (j = Ch(null, a, $, o, j, s)),
        (a.flags |= 1),
        typeof j == 'object' &&
          j !== null &&
          typeof j.render == 'function' &&
          j.$$typeof === void 0)
      ) {
        if (
          ((a.tag = 1), (a.memoizedState = null), (a.updateQueue = null), Ff($))
        ) {
          var _e = !0
          Jf(a)
        } else _e = !1
        ;(a.memoizedState =
          j.state !== null && j.state !== void 0 ? j.state : null),
          xg(a)
        var et = $.getDerivedStateFromProps
        typeof et == 'function' && Gg(a, $, et, o),
          (j.updater = Kg),
          (a.stateNode = j),
          (j._reactInternals = a),
          Og(a, $, o, s),
          (a = qi(null, a, $, !0, _e, s))
      } else (a.tag = 0), fi(null, a, j, s), (a = a.child)
      return a
    case 16:
      j = a.elementType
      e: {
        switch (
          (o !== null &&
            ((o.alternate = null), (a.alternate = null), (a.flags |= 2)),
          (o = a.pendingProps),
          (_e = j._init),
          (j = _e(j._payload)),
          (a.type = j),
          (_e = a.tag = hk(j)),
          (o = lg(j, o)),
          _e)
        ) {
          case 0:
            a = li(null, a, j, o, s)
            break e
          case 1:
            a = pi(null, a, j, o, s)
            break e
          case 11:
            a = gi(null, a, j, o, s)
            break e
          case 14:
            a = ii(null, a, j, lg(j.type, o), $, s)
            break e
        }
        throw Error(y$3(306, j, ''))
      }
      return a
    case 0:
      return (
        ($ = a.type),
        (j = a.pendingProps),
        (j = a.elementType === $ ? j : lg($, j)),
        li(o, a, $, j, s)
      )
    case 1:
      return (
        ($ = a.type),
        (j = a.pendingProps),
        (j = a.elementType === $ ? j : lg($, j)),
        pi(o, a, $, j, s)
      )
    case 3:
      if ((ri(a), ($ = a.updateQueue), o === null || $ === null))
        throw Error(y$3(282))
      if (
        (($ = a.pendingProps),
        (j = a.memoizedState),
        (j = j !== null ? j.element : null),
        yg(o, a),
        Cg(a, $, null, s),
        ($ = a.memoizedState.element),
        $ === j)
      )
        sh(), (a = hi(o, a, s))
      else {
        if (
          ((j = a.stateNode),
          (_e = j.hydrate) &&
            ((kh = rf(a.stateNode.containerInfo.firstChild)),
            (jh = a),
            (_e = lh = !0)),
          _e)
        ) {
          if (((o = j.mutableSourceEagerHydrationData), o != null))
            for (j = 0; j < o.length; j += 2)
              (_e = o[j]),
                (_e._workInProgressVersionPrimary = o[j + 1]),
                th.push(_e)
          for (s = Zg(a, null, $, s), a.child = s; s; )
            (s.flags = (s.flags & -3) | 1024), (s = s.sibling)
        } else fi(o, a, $, s), sh()
        a = a.child
      }
      return a
    case 5:
      return (
        gh(a),
        o === null && ph(a),
        ($ = a.type),
        (j = a.pendingProps),
        (_e = o !== null ? o.memoizedProps : null),
        (et = j.children),
        nf($, j) ? (et = null) : _e !== null && nf($, _e) && (a.flags |= 16),
        oi(o, a),
        fi(o, a, et, s),
        a.child
      )
    case 6:
      return o === null && ph(a), null
    case 13:
      return ti(o, a, s)
    case 4:
      return (
        eh(a, a.stateNode.containerInfo),
        ($ = a.pendingProps),
        o === null ? (a.child = Yg(a, null, $, s)) : fi(o, a, $, s),
        a.child
      )
    case 11:
      return (
        ($ = a.type),
        (j = a.pendingProps),
        (j = a.elementType === $ ? j : lg($, j)),
        gi(o, a, $, j, s)
      )
    case 7:
      return fi(o, a, a.pendingProps, s), a.child
    case 8:
      return fi(o, a, a.pendingProps.children, s), a.child
    case 12:
      return fi(o, a, a.pendingProps.children, s), a.child
    case 10:
      e: {
        ;($ = a.type._context),
          (j = a.pendingProps),
          (et = a.memoizedProps),
          (_e = j.value)
        var tt = a.type._context
        if ((I(mg, tt._currentValue), (tt._currentValue = _e), et !== null))
          if (
            ((tt = et.value),
            (_e = He(tt, _e)
              ? 0
              : (typeof $._calculateChangedBits == 'function'
                  ? $._calculateChangedBits(tt, _e)
                  : 1073741823) | 0),
            _e === 0)
          ) {
            if (et.children === j.children && !N.current) {
              a = hi(o, a, s)
              break e
            }
          } else
            for (tt = a.child, tt !== null && (tt.return = a); tt !== null; ) {
              var rt = tt.dependencies
              if (rt !== null) {
                et = tt.child
                for (var nt = rt.firstContext; nt !== null; ) {
                  if (nt.context === $ && nt.observedBits & _e) {
                    tt.tag === 1 &&
                      ((nt = zg(-1, s & -s)), (nt.tag = 2), Ag(tt, nt)),
                      (tt.lanes |= s),
                      (nt = tt.alternate),
                      nt !== null && (nt.lanes |= s),
                      sg(tt.return, s),
                      (rt.lanes |= s)
                    break
                  }
                  nt = nt.next
                }
              } else et = tt.tag === 10 && tt.type === a.type ? null : tt.child
              if (et !== null) et.return = tt
              else
                for (et = tt; et !== null; ) {
                  if (et === a) {
                    et = null
                    break
                  }
                  if (((tt = et.sibling), tt !== null)) {
                    ;(tt.return = et.return), (et = tt)
                    break
                  }
                  et = et.return
                }
              tt = et
            }
        fi(o, a, j.children, s), (a = a.child)
      }
      return a
    case 9:
      return (
        (j = a.type),
        (_e = a.pendingProps),
        ($ = _e.children),
        tg(a, s),
        (j = vg(j, _e.unstable_observedBits)),
        ($ = $(j)),
        (a.flags |= 1),
        fi(o, a, $, s),
        a.child
      )
    case 14:
      return (
        (j = a.type),
        (_e = lg(j, a.pendingProps)),
        (_e = lg(j.type, _e)),
        ii(o, a, j, _e, $, s)
      )
    case 15:
      return ki(o, a, a.type, a.pendingProps, $, s)
    case 17:
      return (
        ($ = a.type),
        (j = a.pendingProps),
        (j = a.elementType === $ ? j : lg($, j)),
        o !== null &&
          ((o.alternate = null), (a.alternate = null), (a.flags |= 2)),
        (a.tag = 1),
        Ff($) ? ((o = !0), Jf(a)) : (o = !1),
        tg(a, s),
        Mg(a, $, j),
        Og(a, $, j, s),
        qi(null, a, $, !0, o, s)
      )
    case 19:
      return Ai(o, a, s)
    case 23:
      return mi(o, a, s)
    case 24:
      return mi(o, a, s)
  }
  throw Error(y$3(156, a.tag))
}
function ik(o, a, s, $) {
  ;(this.tag = o),
    (this.key = s),
    (this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = a),
    (this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null),
    (this.mode = $),
    (this.flags = 0),
    (this.lastEffect = this.firstEffect = this.nextEffect = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null)
}
function nh(o, a, s, $) {
  return new ik(o, a, s, $)
}
function ji(o) {
  return (o = o.prototype), !(!o || !o.isReactComponent)
}
function hk(o) {
  if (typeof o == 'function') return ji(o) ? 1 : 0
  if (o != null) {
    if (((o = o.$$typeof), o === Aa)) return 11
    if (o === Da) return 14
  }
  return 2
}
function Tg(o, a) {
  var s = o.alternate
  return (
    s === null
      ? ((s = nh(o.tag, a, o.key, o.mode)),
        (s.elementType = o.elementType),
        (s.type = o.type),
        (s.stateNode = o.stateNode),
        (s.alternate = o),
        (o.alternate = s))
      : ((s.pendingProps = a),
        (s.type = o.type),
        (s.flags = 0),
        (s.nextEffect = null),
        (s.firstEffect = null),
        (s.lastEffect = null)),
    (s.childLanes = o.childLanes),
    (s.lanes = o.lanes),
    (s.child = o.child),
    (s.memoizedProps = o.memoizedProps),
    (s.memoizedState = o.memoizedState),
    (s.updateQueue = o.updateQueue),
    (a = o.dependencies),
    (s.dependencies =
      a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }),
    (s.sibling = o.sibling),
    (s.index = o.index),
    (s.ref = o.ref),
    s
  )
}
function Vg(o, a, s, $, j, _e) {
  var et = 2
  if ((($ = o), typeof o == 'function')) ji(o) && (et = 1)
  else if (typeof o == 'string') et = 5
  else
    e: switch (o) {
      case ua:
        return Xg(s.children, j, _e, a)
      case Ha:
        ;(et = 8), (j |= 16)
        break
      case wa:
        ;(et = 8), (j |= 1)
        break
      case xa:
        return (
          (o = nh(12, s, a, j | 8)),
          (o.elementType = xa),
          (o.type = xa),
          (o.lanes = _e),
          o
        )
      case Ba:
        return (
          (o = nh(13, s, a, j)),
          (o.type = Ba),
          (o.elementType = Ba),
          (o.lanes = _e),
          o
        )
      case Ca:
        return (o = nh(19, s, a, j)), (o.elementType = Ca), (o.lanes = _e), o
      case Ia:
        return vi(s, j, _e, a)
      case Ja:
        return (o = nh(24, s, a, j)), (o.elementType = Ja), (o.lanes = _e), o
      default:
        if (typeof o == 'object' && o !== null)
          switch (o.$$typeof) {
            case ya:
              et = 10
              break e
            case za:
              et = 9
              break e
            case Aa:
              et = 11
              break e
            case Da:
              et = 14
              break e
            case Ea:
              ;(et = 16), ($ = null)
              break e
            case Fa:
              et = 22
              break e
          }
        throw Error(y$3(130, o == null ? o : typeof o, ''))
    }
  return (
    (a = nh(et, s, a, j)), (a.elementType = o), (a.type = $), (a.lanes = _e), a
  )
}
function Xg(o, a, s, $) {
  return (o = nh(7, o, $, a)), (o.lanes = s), o
}
function vi(o, a, s, $) {
  return (o = nh(23, o, $, a)), (o.elementType = Ia), (o.lanes = s), o
}
function Ug(o, a, s) {
  return (o = nh(6, o, null, a)), (o.lanes = s), o
}
function Wg(o, a, s) {
  return (
    (a = nh(4, o.children !== null ? o.children : [], o.key, a)),
    (a.lanes = s),
    (a.stateNode = {
      containerInfo: o.containerInfo,
      pendingChildren: null,
      implementation: o.implementation,
    }),
    a
  )
}
function jk(o, a, s) {
  ;(this.tag = a),
    (this.containerInfo = o),
    (this.finishedWork = this.pingCache = this.current = this.pendingChildren = null),
    (this.timeoutHandle = -1),
    (this.pendingContext = this.context = null),
    (this.hydrate = s),
    (this.callbackNode = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Zc(0)),
    (this.expirationTimes = Zc(-1)),
    (this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0),
    (this.entanglements = Zc(0)),
    (this.mutableSourceEagerHydrationData = null)
}
function kk(o, a, s) {
  var $ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null
  return {
    $$typeof: ta,
    key: $ == null ? null : '' + $,
    children: o,
    containerInfo: a,
    implementation: s,
  }
}
function lk(o, a, s, $) {
  var j = a.current,
    _e = Hg(),
    et = Ig(j)
  e: if (s) {
    s = s._reactInternals
    t: {
      if (Zb(s) !== s || s.tag !== 1) throw Error(y$3(170))
      var tt = s
      do {
        switch (tt.tag) {
          case 3:
            tt = tt.stateNode.context
            break t
          case 1:
            if (Ff(tt.type)) {
              tt = tt.stateNode.__reactInternalMemoizedMergedChildContext
              break t
            }
        }
        tt = tt.return
      } while (tt !== null)
      throw Error(y$3(171))
    }
    if (s.tag === 1) {
      var rt = s.type
      if (Ff(rt)) {
        s = If(s, rt, tt)
        break e
      }
    }
    s = tt
  } else s = Cf
  return (
    a.context === null ? (a.context = s) : (a.pendingContext = s),
    (a = zg(_e, et)),
    (a.payload = { element: o }),
    ($ = $ === void 0 ? null : $),
    $ !== null && (a.callback = $),
    Ag(j, a),
    Jg(j, et, _e),
    et
  )
}
function mk(o) {
  if (((o = o.current), !o.child)) return null
  switch (o.child.tag) {
    case 5:
      return o.child.stateNode
    default:
      return o.child.stateNode
  }
}
function nk(o, a) {
  if (((o = o.memoizedState), o !== null && o.dehydrated !== null)) {
    var s = o.retryLane
    o.retryLane = s !== 0 && s < a ? s : a
  }
}
function ok$1(o, a) {
  nk(o, a), (o = o.alternate) && nk(o, a)
}
function pk() {
  return null
}
function qk(o, a, s) {
  var $ =
    (s != null &&
      s.hydrationOptions != null &&
      s.hydrationOptions.mutableSources) ||
    null
  if (
    ((s = new jk(o, a, s != null && s.hydrate === !0)),
    (a = nh(3, null, null, a === 2 ? 7 : a === 1 ? 3 : 0)),
    (s.current = a),
    (a.stateNode = s),
    xg(a),
    (o[ff] = s.current),
    cf(o.nodeType === 8 ? o.parentNode : o),
    $)
  )
    for (o = 0; o < $.length; o++) {
      a = $[o]
      var j = a._getVersion
      ;(j = j(a._source)),
        s.mutableSourceEagerHydrationData == null
          ? (s.mutableSourceEagerHydrationData = [a, j])
          : s.mutableSourceEagerHydrationData.push(a, j)
    }
  this._internalRoot = s
}
qk.prototype.render = function(o) {
  lk(o, this._internalRoot, null, null)
}
qk.prototype.unmount = function() {
  var o = this._internalRoot,
    a = o.containerInfo
  lk(null, o, null, function() {
    a[ff] = null
  })
}
function rk(o) {
  return !(
    !o ||
    (o.nodeType !== 1 &&
      o.nodeType !== 9 &&
      o.nodeType !== 11 &&
      (o.nodeType !== 8 || o.nodeValue !== ' react-mount-point-unstable '))
  )
}
function sk(o, a) {
  if (
    (a ||
      ((a = o ? (o.nodeType === 9 ? o.documentElement : o.firstChild) : null),
      (a = !(!a || a.nodeType !== 1 || !a.hasAttribute('data-reactroot')))),
    !a)
  )
    for (var s; (s = o.lastChild); ) o.removeChild(s)
  return new qk(o, 0, a ? { hydrate: !0 } : void 0)
}
function tk(o, a, s, $, j) {
  var _e = s._reactRootContainer
  if (_e) {
    var et = _e._internalRoot
    if (typeof j == 'function') {
      var tt = j
      j = function() {
        var nt = mk(et)
        tt.call(nt)
      }
    }
    lk(a, et, o, j)
  } else {
    if (
      ((_e = s._reactRootContainer = sk(s, $)),
      (et = _e._internalRoot),
      typeof j == 'function')
    ) {
      var rt = j
      j = function() {
        var nt = mk(et)
        rt.call(nt)
      }
    }
    Xj(function() {
      lk(a, et, o, j)
    })
  }
  return mk(et)
}
ec = function(o) {
  if (o.tag === 13) {
    var a = Hg()
    Jg(o, 4, a), ok$1(o, 4)
  }
}
fc = function(o) {
  if (o.tag === 13) {
    var a = Hg()
    Jg(o, 67108864, a), ok$1(o, 67108864)
  }
}
gc = function(o) {
  if (o.tag === 13) {
    var a = Hg(),
      s = Ig(o)
    Jg(o, s, a), ok$1(o, s)
  }
}
hc = function(o, a) {
  return a()
}
yb = function(o, a, s) {
  switch (a) {
    case 'input':
      if ((ab(o, s), (a = s.name), s.type === 'radio' && a != null)) {
        for (s = o; s.parentNode; ) s = s.parentNode
        for (
          s = s.querySelectorAll(
            'input[name=' + JSON.stringify('' + a) + '][type="radio"]'
          ),
            a = 0;
          a < s.length;
          a++
        ) {
          var $ = s[a]
          if ($ !== o && $.form === o.form) {
            var j = Db($)
            if (!j) throw Error(y$3(90))
            Wa($), ab($, j)
          }
        }
      }
      break
    case 'textarea':
      ib(o, s)
      break
    case 'select':
      ;(a = s.value), a != null && fb(o, !!s.multiple, a, !1)
  }
}
Gb = Wj
Hb = function(o, a, s, $, j) {
  var _e = X
  X |= 4
  try {
    return gg(98, o.bind(null, a, s, $, j))
  } finally {
    ;(X = _e), X === 0 && (wj(), ig())
  }
}
Ib = function() {
  !(X & 49) && (Vj(), Oj())
}
Jb = function(o, a) {
  var s = X
  X |= 2
  try {
    return o(a)
  } finally {
    ;(X = s), X === 0 && (wj(), ig())
  }
}
function uk(o, a) {
  var s = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  if (!rk(a)) throw Error(y$3(200))
  return kk(o, a, null, s)
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: !1 }] },
  wk = {
    findFiberByHostInstance: wc,
    bundleType: 0,
    version: '17.0.2',
    rendererPackageName: 'react-dom',
  },
  xk = {
    bundleType: wk.bundleType,
    version: wk.version,
    rendererPackageName: wk.rendererPackageName,
    rendererConfig: wk.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ra.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(o) {
      return (o = cc(o)), o === null ? null : o.stateNode
    },
    findFiberByHostInstance: wk.findFiberByHostInstance || pk,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
  }
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < 'u') {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      ;(Lf = yk.inject(xk)), (Mf = yk)
    } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk
reactDom_production_min.createPortal = uk
reactDom_production_min.findDOMNode = function(o) {
  if (o == null) return null
  if (o.nodeType === 1) return o
  var a = o._reactInternals
  if (a === void 0)
    throw typeof o.render == 'function'
      ? Error(y$3(188))
      : Error(y$3(268, Object.keys(o)))
  return (o = cc(a)), (o = o === null ? null : o.stateNode), o
}
reactDom_production_min.flushSync = function(o, a) {
  var s = X
  if (s & 48) return o(a)
  X |= 1
  try {
    if (o) return gg(99, o.bind(null, a))
  } finally {
    ;(X = s), ig()
  }
}
reactDom_production_min.hydrate = function(o, a, s) {
  if (!rk(a)) throw Error(y$3(200))
  return tk(null, o, a, !0, s)
}
reactDom_production_min.render = function(o, a, s) {
  if (!rk(a)) throw Error(y$3(200))
  return tk(null, o, a, !1, s)
}
reactDom_production_min.unmountComponentAtNode = function(o) {
  if (!rk(o)) throw Error(y$3(40))
  return o._reactRootContainer
    ? (Xj(function() {
        tk(null, null, o, !1, function() {
          ;(o._reactRootContainer = null), (o[ff] = null)
        })
      }),
      !0)
    : !1
}
reactDom_production_min.unstable_batchedUpdates = Wj
reactDom_production_min.unstable_createPortal = function(o, a) {
  return uk(
    o,
    a,
    2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null
  )
}
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(
  o,
  a,
  s,
  $
) {
  if (!rk(s)) throw Error(y$3(200))
  if (o == null || o._reactInternals === void 0) throw Error(y$3(38))
  return tk(o, a, s, !1, $)
}
reactDom_production_min.version = '17.0.2'
function checkDCE() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > 'u' ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != 'function'
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
    } catch (o) {
      console.error(o)
    }
}
checkDCE(), (reactDom.exports = reactDom_production_min)
var reactDomExports = reactDom.exports
const ReactDOM = getDefaultExportFromCjs(reactDomExports)
function _setPrototypeOf$1(o, a) {
  return (
    (_setPrototypeOf$1 = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function(s, $) {
          return (s.__proto__ = $), s
        }),
    _setPrototypeOf$1(o, a)
  )
}
function _inheritsLoose$2(o, a) {
  ;(o.prototype = Object.create(a.prototype)),
    (o.prototype.constructor = o),
    _setPrototypeOf$1(o, a)
}
var propTypes = { exports: {} },
  ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED',
  ReactPropTypesSecret_1 = ReactPropTypesSecret$1,
  ReactPropTypesSecret = ReactPropTypesSecret_1
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction
var factoryWithThrowingShims = function() {
  function o($, j, _e, et, tt, rt) {
    if (rt !== ReactPropTypesSecret) {
      var nt = new Error(
        'Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types'
      )
      throw ((nt.name = 'Invariant Violation'), nt)
    }
  }
  o.isRequired = o
  function a() {
    return o
  }
  var s = {
    array: o,
    bigint: o,
    bool: o,
    func: o,
    number: o,
    object: o,
    string: o,
    symbol: o,
    any: o,
    arrayOf: a,
    element: o,
    elementType: o,
    instanceOf: a,
    node: o,
    objectOf: a,
    oneOf: a,
    oneOfType: a,
    shape: a,
    exact: a,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction,
  }
  return (s.PropTypes = s), s
}
propTypes.exports = factoryWithThrowingShims()
var propTypesExports = propTypes.exports
const PropTypes$1 = getDefaultExportFromCjs(propTypesExports)
function _extends$5() {
  return (
    (_extends$5 = Object.assign
      ? Object.assign.bind()
      : function(o) {
          for (var a = 1; a < arguments.length; a++) {
            var s = arguments[a]
            for (var $ in s) ({}.hasOwnProperty.call(s, $) && (o[$] = s[$]))
          }
          return o
        }),
    _extends$5.apply(null, arguments)
  )
}
function isAbsolute(o) {
  return o.charAt(0) === '/'
}
function spliceOne$1(o, a) {
  for (var s = a, $ = s + 1, j = o.length; $ < j; s += 1, $ += 1) o[s] = o[$]
  o.pop()
}
function resolvePathname(o, a) {
  a === void 0 && (a = '')
  var s = (o && o.split('/')) || [],
    $ = (a && a.split('/')) || [],
    j = o && isAbsolute(o),
    _e = a && isAbsolute(a),
    et = j || _e
  if (
    (o && isAbsolute(o) ? ($ = s) : s.length && ($.pop(), ($ = $.concat(s))),
    !$.length)
  )
    return '/'
  var tt
  if ($.length) {
    var rt = $[$.length - 1]
    tt = rt === '.' || rt === '..' || rt === ''
  } else tt = !1
  for (var nt = 0, it = $.length; it >= 0; it--) {
    var ot = $[it]
    ot === '.'
      ? spliceOne$1($, it)
      : ot === '..'
      ? (spliceOne$1($, it), nt++)
      : nt && (spliceOne$1($, it), nt--)
  }
  if (!et) for (; nt--; nt) $.unshift('..')
  et && $[0] !== '' && (!$[0] || !isAbsolute($[0])) && $.unshift('')
  var at = $.join('/')
  return tt && at.substr(-1) !== '/' && (at += '/'), at
}
function valueOf(o) {
  return o.valueOf ? o.valueOf() : Object.prototype.valueOf.call(o)
}
function valueEqual(o, a) {
  if (o === a) return !0
  if (o == null || a == null) return !1
  if (Array.isArray(o))
    return (
      Array.isArray(a) &&
      o.length === a.length &&
      o.every(function(j, _e) {
        return valueEqual(j, a[_e])
      })
    )
  if (typeof o == 'object' || typeof a == 'object') {
    var s = valueOf(o),
      $ = valueOf(a)
    return s !== o || $ !== a
      ? valueEqual(s, $)
      : Object.keys(Object.assign({}, o, a)).every(function(j) {
          return valueEqual(o[j], a[j])
        })
  }
  return !1
}
var prefix$2 = 'Invariant failed'
function invariant(o, a) {
  throw new Error(prefix$2)
}
function addLeadingSlash$1(o) {
  return o.charAt(0) === '/' ? o : '/' + o
}
function stripLeadingSlash(o) {
  return o.charAt(0) === '/' ? o.substr(1) : o
}
function hasBasename(o, a) {
  return (
    o.toLowerCase().indexOf(a.toLowerCase()) === 0 &&
    '/?#'.indexOf(o.charAt(a.length)) !== -1
  )
}
function stripBasename$1(o, a) {
  return hasBasename(o, a) ? o.substr(a.length) : o
}
function stripTrailingSlash(o) {
  return o.charAt(o.length - 1) === '/' ? o.slice(0, -1) : o
}
function parsePath(o) {
  var a = o || '/',
    s = '',
    $ = '',
    j = a.indexOf('#')
  j !== -1 && (($ = a.substr(j)), (a = a.substr(0, j)))
  var _e = a.indexOf('?')
  return (
    _e !== -1 && ((s = a.substr(_e)), (a = a.substr(0, _e))),
    { pathname: a, search: s === '?' ? '' : s, hash: $ === '#' ? '' : $ }
  )
}
function createPath(o) {
  var a = o.pathname,
    s = o.search,
    $ = o.hash,
    j = a || '/'
  return (
    s && s !== '?' && (j += s.charAt(0) === '?' ? s : '?' + s),
    $ && $ !== '#' && (j += $.charAt(0) === '#' ? $ : '#' + $),
    j
  )
}
function createLocation(o, a, s, $) {
  var j
  typeof o == 'string'
    ? ((j = parsePath(o)), (j.state = a))
    : ((j = _extends$5({}, o)),
      j.pathname === void 0 && (j.pathname = ''),
      j.search
        ? j.search.charAt(0) !== '?' && (j.search = '?' + j.search)
        : (j.search = ''),
      j.hash
        ? j.hash.charAt(0) !== '#' && (j.hash = '#' + j.hash)
        : (j.hash = ''),
      a !== void 0 && j.state === void 0 && (j.state = a))
  try {
    j.pathname = decodeURI(j.pathname)
  } catch (_e) {
    throw _e instanceof URIError
      ? new URIError(
          'Pathname "' +
            j.pathname +
            '" could not be decoded. This is likely caused by an invalid percent-encoding.'
        )
      : _e
  }
  return (
    s && (j.key = s),
    $
      ? j.pathname
        ? j.pathname.charAt(0) !== '/' &&
          (j.pathname = resolvePathname(j.pathname, $.pathname))
        : (j.pathname = $.pathname)
      : j.pathname || (j.pathname = '/'),
    j
  )
}
function locationsAreEqual(o, a) {
  return (
    o.pathname === a.pathname &&
    o.search === a.search &&
    o.hash === a.hash &&
    o.key === a.key &&
    valueEqual(o.state, a.state)
  )
}
function createTransitionManager() {
  var o = null
  function a(et) {
    return (
      (o = et),
      function() {
        o === et && (o = null)
      }
    )
  }
  function s(et, tt, rt, nt) {
    if (o != null) {
      var it = typeof o == 'function' ? o(et, tt) : o
      typeof it == 'string'
        ? typeof rt == 'function'
          ? rt(it, nt)
          : nt(!0)
        : nt(it !== !1)
    } else nt(!0)
  }
  var $ = []
  function j(et) {
    var tt = !0
    function rt() {
      tt && et.apply(void 0, arguments)
    }
    return (
      $.push(rt),
      function() {
        ;(tt = !1),
          ($ = $.filter(function(nt) {
            return nt !== rt
          }))
      }
    )
  }
  function _e() {
    for (var et = arguments.length, tt = new Array(et), rt = 0; rt < et; rt++)
      tt[rt] = arguments[rt]
    $.forEach(function(nt) {
      return nt.apply(void 0, tt)
    })
  }
  return {
    setPrompt: a,
    confirmTransitionTo: s,
    appendListener: j,
    notifyListeners: _e,
  }
}
var canUseDOM$1 = !!(
  typeof window < 'u' &&
  window.document &&
  window.document.createElement
)
function getConfirmation(o, a) {
  a(window.confirm(o))
}
function supportsHistory() {
  var o = window.navigator.userAgent
  return (o.indexOf('Android 2.') !== -1 || o.indexOf('Android 4.0') !== -1) &&
    o.indexOf('Mobile Safari') !== -1 &&
    o.indexOf('Chrome') === -1 &&
    o.indexOf('Windows Phone') === -1
    ? !1
    : window.history && 'pushState' in window.history
}
function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf('Trident') === -1
}
function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf('Firefox') === -1
}
function isExtraneousPopstateEvent(o) {
  return o.state === void 0 && navigator.userAgent.indexOf('CriOS') === -1
}
var PopStateEvent = 'popstate',
  HashChangeEvent = 'hashchange'
function getHistoryState() {
  try {
    return window.history.state || {}
  } catch {
    return {}
  }
}
function createBrowserHistory(o) {
  o === void 0 && (o = {}), canUseDOM$1 || invariant()
  var a = window.history,
    s = supportsHistory(),
    $ = !supportsPopStateOnHashChange(),
    j = o,
    _e = j.forceRefresh,
    et = _e === void 0 ? !1 : _e,
    tt = j.getUserConfirmation,
    rt = tt === void 0 ? getConfirmation : tt,
    nt = j.keyLength,
    it = nt === void 0 ? 6 : nt,
    ot = o.basename ? stripTrailingSlash(addLeadingSlash$1(o.basename)) : ''
  function at(kt) {
    var Ot = kt || {},
      Nt = Ot.key,
      $t = Ot.state,
      Pt = window.location,
      Ft = Pt.pathname,
      Vt = Pt.search,
      Xt = Pt.hash,
      Yt = Ft + Vt + Xt
    return ot && (Yt = stripBasename$1(Yt, ot)), createLocation(Yt, $t, Nt)
  }
  function st() {
    return Math.random()
      .toString(36)
      .substr(2, it)
  }
  var ut = createTransitionManager()
  function ct(kt) {
    _extends$5(Tt, kt),
      (Tt.length = a.length),
      ut.notifyListeners(Tt.location, Tt.action)
  }
  function dt(kt) {
    isExtraneousPopstateEvent(kt) || vt(at(kt.state))
  }
  function ft() {
    vt(at(getHistoryState()))
  }
  var mt = !1
  function vt(kt) {
    if (mt) (mt = !1), ct()
    else {
      var Ot = 'POP'
      ut.confirmTransitionTo(kt, Ot, rt, function(Nt) {
        Nt ? ct({ action: Ot, location: kt }) : yt(kt)
      })
    }
  }
  function yt(kt) {
    var Ot = Tt.location,
      Nt = ht.indexOf(Ot.key)
    Nt === -1 && (Nt = 0)
    var $t = ht.indexOf(kt.key)
    $t === -1 && ($t = 0)
    var Pt = Nt - $t
    Pt && ((mt = !0), Dt(Pt))
  }
  var pt = at(getHistoryState()),
    ht = [pt.key]
  function At(kt) {
    return ot + createPath(kt)
  }
  function wt(kt, Ot) {
    var Nt = 'PUSH',
      $t = createLocation(kt, Ot, st(), Tt.location)
    ut.confirmTransitionTo($t, Nt, rt, function(Pt) {
      if (Pt) {
        var Ft = At($t),
          Vt = $t.key,
          Xt = $t.state
        if (s)
          if ((a.pushState({ key: Vt, state: Xt }, null, Ft), et))
            window.location.href = Ft
          else {
            var Yt = ht.indexOf(Tt.location.key),
              xt = ht.slice(0, Yt + 1)
            xt.push($t.key), (ht = xt), ct({ action: Nt, location: $t })
          }
        else window.location.href = Ft
      }
    })
  }
  function Ct(kt, Ot) {
    var Nt = 'REPLACE',
      $t = createLocation(kt, Ot, st(), Tt.location)
    ut.confirmTransitionTo($t, Nt, rt, function(Pt) {
      if (Pt) {
        var Ft = At($t),
          Vt = $t.key,
          Xt = $t.state
        if (s)
          if ((a.replaceState({ key: Vt, state: Xt }, null, Ft), et))
            window.location.replace(Ft)
          else {
            var Yt = ht.indexOf(Tt.location.key)
            Yt !== -1 && (ht[Yt] = $t.key), ct({ action: Nt, location: $t })
          }
        else window.location.replace(Ft)
      }
    })
  }
  function Dt(kt) {
    a.go(kt)
  }
  function jt() {
    Dt(-1)
  }
  function Et() {
    Dt(1)
  }
  var St = 0
  function Bt(kt) {
    ;(St += kt),
      St === 1 && kt === 1
        ? (window.addEventListener(PopStateEvent, dt),
          $ && window.addEventListener(HashChangeEvent, ft))
        : St === 0 &&
          (window.removeEventListener(PopStateEvent, dt),
          $ && window.removeEventListener(HashChangeEvent, ft))
  }
  var Mt = !1
  function Ut(kt) {
    kt === void 0 && (kt = !1)
    var Ot = ut.setPrompt(kt)
    return (
      Mt || (Bt(1), (Mt = !0)),
      function() {
        return Mt && ((Mt = !1), Bt(-1)), Ot()
      }
    )
  }
  function Wt(kt) {
    var Ot = ut.appendListener(kt)
    return (
      Bt(1),
      function() {
        Bt(-1), Ot()
      }
    )
  }
  var Tt = {
    length: a.length,
    action: 'POP',
    location: pt,
    createHref: At,
    push: wt,
    replace: Ct,
    go: Dt,
    goBack: jt,
    goForward: Et,
    block: Ut,
    listen: Wt,
  }
  return Tt
}
var HashChangeEvent$1 = 'hashchange',
  HashPathCoders = {
    hashbang: {
      encodePath: function(a) {
        return a.charAt(0) === '!' ? a : '!/' + stripLeadingSlash(a)
      },
      decodePath: function(a) {
        return a.charAt(0) === '!' ? a.substr(1) : a
      },
    },
    noslash: { encodePath: stripLeadingSlash, decodePath: addLeadingSlash$1 },
    slash: { encodePath: addLeadingSlash$1, decodePath: addLeadingSlash$1 },
  }
function stripHash(o) {
  var a = o.indexOf('#')
  return a === -1 ? o : o.slice(0, a)
}
function getHashPath() {
  var o = window.location.href,
    a = o.indexOf('#')
  return a === -1 ? '' : o.substring(a + 1)
}
function pushHashPath(o) {
  window.location.hash = o
}
function replaceHashPath(o) {
  window.location.replace(stripHash(window.location.href) + '#' + o)
}
function createHashHistory(o) {
  o === void 0 && (o = {}), canUseDOM$1 || invariant()
  var a = window.history
  supportsGoWithoutReloadUsingHash()
  var s = o,
    $ = s.getUserConfirmation,
    j = $ === void 0 ? getConfirmation : $,
    _e = s.hashType,
    et = _e === void 0 ? 'slash' : _e,
    tt = o.basename ? stripTrailingSlash(addLeadingSlash$1(o.basename)) : '',
    rt = HashPathCoders[et],
    nt = rt.encodePath,
    it = rt.decodePath
  function ot() {
    var Ot = it(getHashPath())
    return tt && (Ot = stripBasename$1(Ot, tt)), createLocation(Ot)
  }
  var at = createTransitionManager()
  function st(Ot) {
    _extends$5(kt, Ot),
      (kt.length = a.length),
      at.notifyListeners(kt.location, kt.action)
  }
  var ut = !1,
    ct = null
  function dt(Ot, Nt) {
    return (
      Ot.pathname === Nt.pathname &&
      Ot.search === Nt.search &&
      Ot.hash === Nt.hash
    )
  }
  function ft() {
    var Ot = getHashPath(),
      Nt = nt(Ot)
    if (Ot !== Nt) replaceHashPath(Nt)
    else {
      var $t = ot(),
        Pt = kt.location
      if ((!ut && dt(Pt, $t)) || ct === createPath($t)) return
      ;(ct = null), mt($t)
    }
  }
  function mt(Ot) {
    if (ut) (ut = !1), st()
    else {
      var Nt = 'POP'
      at.confirmTransitionTo(Ot, Nt, j, function($t) {
        $t ? st({ action: Nt, location: Ot }) : vt(Ot)
      })
    }
  }
  function vt(Ot) {
    var Nt = kt.location,
      $t = At.lastIndexOf(createPath(Nt))
    $t === -1 && ($t = 0)
    var Pt = At.lastIndexOf(createPath(Ot))
    Pt === -1 && (Pt = 0)
    var Ft = $t - Pt
    Ft && ((ut = !0), jt(Ft))
  }
  var yt = getHashPath(),
    pt = nt(yt)
  yt !== pt && replaceHashPath(pt)
  var ht = ot(),
    At = [createPath(ht)]
  function wt(Ot) {
    var Nt = document.querySelector('base'),
      $t = ''
    return (
      Nt && Nt.getAttribute('href') && ($t = stripHash(window.location.href)),
      $t + '#' + nt(tt + createPath(Ot))
    )
  }
  function Ct(Ot, Nt) {
    var $t = 'PUSH',
      Pt = createLocation(Ot, void 0, void 0, kt.location)
    at.confirmTransitionTo(Pt, $t, j, function(Ft) {
      if (Ft) {
        var Vt = createPath(Pt),
          Xt = nt(tt + Vt),
          Yt = getHashPath() !== Xt
        if (Yt) {
          ;(ct = Vt), pushHashPath(Xt)
          var xt = At.lastIndexOf(createPath(kt.location)),
            It = At.slice(0, xt + 1)
          It.push(Vt), (At = It), st({ action: $t, location: Pt })
        } else st()
      }
    })
  }
  function Dt(Ot, Nt) {
    var $t = 'REPLACE',
      Pt = createLocation(Ot, void 0, void 0, kt.location)
    at.confirmTransitionTo(Pt, $t, j, function(Ft) {
      if (Ft) {
        var Vt = createPath(Pt),
          Xt = nt(tt + Vt),
          Yt = getHashPath() !== Xt
        Yt && ((ct = Vt), replaceHashPath(Xt))
        var xt = At.indexOf(createPath(kt.location))
        xt !== -1 && (At[xt] = Vt), st({ action: $t, location: Pt })
      }
    })
  }
  function jt(Ot) {
    a.go(Ot)
  }
  function Et() {
    jt(-1)
  }
  function St() {
    jt(1)
  }
  var Bt = 0
  function Mt(Ot) {
    ;(Bt += Ot),
      Bt === 1 && Ot === 1
        ? window.addEventListener(HashChangeEvent$1, ft)
        : Bt === 0 && window.removeEventListener(HashChangeEvent$1, ft)
  }
  var Ut = !1
  function Wt(Ot) {
    Ot === void 0 && (Ot = !1)
    var Nt = at.setPrompt(Ot)
    return (
      Ut || (Mt(1), (Ut = !0)),
      function() {
        return Ut && ((Ut = !1), Mt(-1)), Nt()
      }
    )
  }
  function Tt(Ot) {
    var Nt = at.appendListener(Ot)
    return (
      Mt(1),
      function() {
        Mt(-1), Nt()
      }
    )
  }
  var kt = {
    length: a.length,
    action: 'POP',
    location: ht,
    createHref: wt,
    push: Ct,
    replace: Dt,
    go: jt,
    goBack: Et,
    goForward: St,
    block: Wt,
    listen: Tt,
  }
  return kt
}
function clamp$3(o, a, s) {
  return Math.min(Math.max(o, a), s)
}
function createMemoryHistory(o) {
  o === void 0 && (o = {})
  var a = o,
    s = a.getUserConfirmation,
    $ = a.initialEntries,
    j = $ === void 0 ? ['/'] : $,
    _e = a.initialIndex,
    et = _e === void 0 ? 0 : _e,
    tt = a.keyLength,
    rt = tt === void 0 ? 6 : tt,
    nt = createTransitionManager()
  function it(wt) {
    _extends$5(At, wt),
      (At.length = At.entries.length),
      nt.notifyListeners(At.location, At.action)
  }
  function ot() {
    return Math.random()
      .toString(36)
      .substr(2, rt)
  }
  var at = clamp$3(et, 0, j.length - 1),
    st = j.map(function(wt) {
      return typeof wt == 'string'
        ? createLocation(wt, void 0, ot())
        : createLocation(wt, void 0, wt.key || ot())
    }),
    ut = createPath
  function ct(wt, Ct) {
    var Dt = 'PUSH',
      jt = createLocation(wt, Ct, ot(), At.location)
    nt.confirmTransitionTo(jt, Dt, s, function(Et) {
      if (Et) {
        var St = At.index,
          Bt = St + 1,
          Mt = At.entries.slice(0)
        Mt.length > Bt ? Mt.splice(Bt, Mt.length - Bt, jt) : Mt.push(jt),
          it({ action: Dt, location: jt, index: Bt, entries: Mt })
      }
    })
  }
  function dt(wt, Ct) {
    var Dt = 'REPLACE',
      jt = createLocation(wt, Ct, ot(), At.location)
    nt.confirmTransitionTo(jt, Dt, s, function(Et) {
      Et && ((At.entries[At.index] = jt), it({ action: Dt, location: jt }))
    })
  }
  function ft(wt) {
    var Ct = clamp$3(At.index + wt, 0, At.entries.length - 1),
      Dt = 'POP',
      jt = At.entries[Ct]
    nt.confirmTransitionTo(jt, Dt, s, function(Et) {
      Et ? it({ action: Dt, location: jt, index: Ct }) : it()
    })
  }
  function mt() {
    ft(-1)
  }
  function vt() {
    ft(1)
  }
  function yt(wt) {
    var Ct = At.index + wt
    return Ct >= 0 && Ct < At.entries.length
  }
  function pt(wt) {
    return wt === void 0 && (wt = !1), nt.setPrompt(wt)
  }
  function ht(wt) {
    return nt.appendListener(wt)
  }
  var At = {
    length: st.length,
    action: 'POP',
    location: st[at],
    index: at,
    entries: st,
    createHref: ut,
    push: ct,
    replace: dt,
    go: ft,
    goBack: mt,
    goForward: vt,
    canGo: yt,
    block: pt,
    listen: ht,
  }
  return At
}
var pathToRegexp$2 = { exports: {} },
  isarray$6 =
    Array.isArray ||
    function(o) {
      return Object.prototype.toString.call(o) == '[object Array]'
    },
  isarray$5 = isarray$6
pathToRegexp$2.exports = pathToRegexp
pathToRegexp$2.exports.parse = parse$6
pathToRegexp$2.exports.compile = compile$1
pathToRegexp$2.exports.tokensToFunction = tokensToFunction
pathToRegexp$2.exports.tokensToRegExp = tokensToRegExp
var PATH_REGEXP = new RegExp(
  [
    '(\\\\.)',
    '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))',
  ].join('|'),
  'g'
)
function parse$6(o, a) {
  for (
    var s = [], $ = 0, j = 0, _e = '', et = (a && a.delimiter) || '/', tt;
    (tt = PATH_REGEXP.exec(o)) != null;

  ) {
    var rt = tt[0],
      nt = tt[1],
      it = tt.index
    if (((_e += o.slice(j, it)), (j = it + rt.length), nt)) {
      _e += nt[1]
      continue
    }
    var ot = o[j],
      at = tt[2],
      st = tt[3],
      ut = tt[4],
      ct = tt[5],
      dt = tt[6],
      ft = tt[7]
    _e && (s.push(_e), (_e = ''))
    var mt = at != null && ot != null && ot !== at,
      vt = dt === '+' || dt === '*',
      yt = dt === '?' || dt === '*',
      pt = at || et,
      ht = ut || ct,
      At = at || (typeof s[s.length - 1] == 'string' ? s[s.length - 1] : '')
    s.push({
      name: st || $++,
      prefix: at || '',
      delimiter: pt,
      optional: yt,
      repeat: vt,
      partial: mt,
      asterisk: !!ft,
      pattern: ht ? escapeGroup(ht) : ft ? '.*' : restrictBacktrack(pt, At),
    })
  }
  return j < o.length && (_e += o.substr(j)), _e && s.push(_e), s
}
function restrictBacktrack(o, a) {
  return !a || a.indexOf(o) > -1
    ? '[^' + escapeString(o) + ']+?'
    : escapeString(a) +
        '|(?:(?!' +
        escapeString(a) +
        ')[^' +
        escapeString(o) +
        '])+?'
}
function compile$1(o, a) {
  return tokensToFunction(parse$6(o, a), a)
}
function encodeURIComponentPretty(o) {
  return encodeURI(o).replace(/[\/?#]/g, function(a) {
    return (
      '%' +
      a
        .charCodeAt(0)
        .toString(16)
        .toUpperCase()
    )
  })
}
function encodeAsterisk(o) {
  return encodeURI(o).replace(/[?#]/g, function(a) {
    return (
      '%' +
      a
        .charCodeAt(0)
        .toString(16)
        .toUpperCase()
    )
  })
}
function tokensToFunction(o, a) {
  for (var s = new Array(o.length), $ = 0; $ < o.length; $++)
    typeof o[$] == 'object' &&
      (s[$] = new RegExp('^(?:' + o[$].pattern + ')$', flags(a)))
  return function(j, _e) {
    for (
      var et = '',
        tt = j || {},
        rt = _e || {},
        nt = rt.pretty ? encodeURIComponentPretty : encodeURIComponent,
        it = 0;
      it < o.length;
      it++
    ) {
      var ot = o[it]
      if (typeof ot == 'string') {
        et += ot
        continue
      }
      var at = tt[ot.name],
        st
      if (at == null)
        if (ot.optional) {
          ot.partial && (et += ot.prefix)
          continue
        } else throw new TypeError('Expected "' + ot.name + '" to be defined')
      if (isarray$5(at)) {
        if (!ot.repeat)
          throw new TypeError(
            'Expected "' +
              ot.name +
              '" to not repeat, but received `' +
              JSON.stringify(at) +
              '`'
          )
        if (at.length === 0) {
          if (ot.optional) continue
          throw new TypeError('Expected "' + ot.name + '" to not be empty')
        }
        for (var ut = 0; ut < at.length; ut++) {
          if (((st = nt(at[ut])), !s[it].test(st)))
            throw new TypeError(
              'Expected all "' +
                ot.name +
                '" to match "' +
                ot.pattern +
                '", but received `' +
                JSON.stringify(st) +
                '`'
            )
          et += (ut === 0 ? ot.prefix : ot.delimiter) + st
        }
        continue
      }
      if (((st = ot.asterisk ? encodeAsterisk(at) : nt(at)), !s[it].test(st)))
        throw new TypeError(
          'Expected "' +
            ot.name +
            '" to match "' +
            ot.pattern +
            '", but received "' +
            st +
            '"'
        )
      et += ot.prefix + st
    }
    return et
  }
}
function escapeString(o) {
  return o.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}
function escapeGroup(o) {
  return o.replace(/([=!:$\/()])/g, '\\$1')
}
function attachKeys(o, a) {
  return (o.keys = a), o
}
function flags(o) {
  return o && o.sensitive ? '' : 'i'
}
function regexpToRegexp(o, a) {
  var s = o.source.match(/\((?!\?)/g)
  if (s)
    for (var $ = 0; $ < s.length; $++)
      a.push({
        name: $,
        prefix: null,
        delimiter: null,
        optional: !1,
        repeat: !1,
        partial: !1,
        asterisk: !1,
        pattern: null,
      })
  return attachKeys(o, a)
}
function arrayToRegexp(o, a, s) {
  for (var $ = [], j = 0; j < o.length; j++)
    $.push(pathToRegexp(o[j], a, s).source)
  var _e = new RegExp('(?:' + $.join('|') + ')', flags(s))
  return attachKeys(_e, a)
}
function stringToRegexp(o, a, s) {
  return tokensToRegExp(parse$6(o, s), a, s)
}
function tokensToRegExp(o, a, s) {
  isarray$5(a) || ((s = a || s), (a = [])), (s = s || {})
  for (
    var $ = s.strict, j = s.end !== !1, _e = '', et = 0;
    et < o.length;
    et++
  ) {
    var tt = o[et]
    if (typeof tt == 'string') _e += escapeString(tt)
    else {
      var rt = escapeString(tt.prefix),
        nt = '(?:' + tt.pattern + ')'
      a.push(tt),
        tt.repeat && (nt += '(?:' + rt + nt + ')*'),
        tt.optional
          ? tt.partial
            ? (nt = rt + '(' + nt + ')?')
            : (nt = '(?:' + rt + '(' + nt + '))?')
          : (nt = rt + '(' + nt + ')'),
        (_e += nt)
    }
  }
  var it = escapeString(s.delimiter || '/'),
    ot = _e.slice(-it.length) === it
  return (
    $ || (_e = (ot ? _e.slice(0, -it.length) : _e) + '(?:' + it + '(?=$))?'),
    j ? (_e += '$') : (_e += $ && ot ? '' : '(?=' + it + '|$)'),
    attachKeys(new RegExp('^' + _e, flags(s)), a)
  )
}
function pathToRegexp(o, a, s) {
  return (
    isarray$5(a) || ((s = a || s), (a = [])),
    (s = s || {}),
    o instanceof RegExp
      ? regexpToRegexp(o, a)
      : isarray$5(o)
      ? arrayToRegexp(o, a, s)
      : stringToRegexp(o, a, s)
  )
}
var pathToRegexpExports = pathToRegexp$2.exports
const pathToRegexp$1 = getDefaultExportFromCjs(pathToRegexpExports)
var reactIs_production_min$3 = {}
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b$3 = typeof Symbol == 'function' && Symbol.for,
  c$4 = b$3 ? Symbol.for('react.element') : 60103,
  d$3 = b$3 ? Symbol.for('react.portal') : 60106,
  e$3 = b$3 ? Symbol.for('react.fragment') : 60107,
  f$3 = b$3 ? Symbol.for('react.strict_mode') : 60108,
  g$6 = b$3 ? Symbol.for('react.profiler') : 60114,
  h$3 = b$3 ? Symbol.for('react.provider') : 60109,
  k$3 = b$3 ? Symbol.for('react.context') : 60110,
  l$3 = b$3 ? Symbol.for('react.async_mode') : 60111,
  m$3 = b$3 ? Symbol.for('react.concurrent_mode') : 60111,
  n$3 = b$3 ? Symbol.for('react.forward_ref') : 60112,
  p$3 = b$3 ? Symbol.for('react.suspense') : 60113,
  q$3 = b$3 ? Symbol.for('react.suspense_list') : 60120,
  r$4 = b$3 ? Symbol.for('react.memo') : 60115,
  t$3 = b$3 ? Symbol.for('react.lazy') : 60116,
  v$3 = b$3 ? Symbol.for('react.block') : 60121,
  w$3 = b$3 ? Symbol.for('react.fundamental') : 60117,
  x$2 = b$3 ? Symbol.for('react.responder') : 60118,
  y$2 = b$3 ? Symbol.for('react.scope') : 60119
function z$2(o) {
  if (typeof o == 'object' && o !== null) {
    var a = o.$$typeof
    switch (a) {
      case c$4:
        switch (((o = o.type), o)) {
          case l$3:
          case m$3:
          case e$3:
          case g$6:
          case f$3:
          case p$3:
            return o
          default:
            switch (((o = o && o.$$typeof), o)) {
              case k$3:
              case n$3:
              case t$3:
              case r$4:
              case h$3:
                return o
              default:
                return a
            }
        }
      case d$3:
        return a
    }
  }
}
function A$2(o) {
  return z$2(o) === m$3
}
reactIs_production_min$3.AsyncMode = l$3
reactIs_production_min$3.ConcurrentMode = m$3
reactIs_production_min$3.ContextConsumer = k$3
reactIs_production_min$3.ContextProvider = h$3
reactIs_production_min$3.Element = c$4
reactIs_production_min$3.ForwardRef = n$3
reactIs_production_min$3.Fragment = e$3
reactIs_production_min$3.Lazy = t$3
reactIs_production_min$3.Memo = r$4
reactIs_production_min$3.Portal = d$3
reactIs_production_min$3.Profiler = g$6
reactIs_production_min$3.StrictMode = f$3
reactIs_production_min$3.Suspense = p$3
reactIs_production_min$3.isAsyncMode = function(o) {
  return A$2(o) || z$2(o) === l$3
}
reactIs_production_min$3.isConcurrentMode = A$2
reactIs_production_min$3.isContextConsumer = function(o) {
  return z$2(o) === k$3
}
reactIs_production_min$3.isContextProvider = function(o) {
  return z$2(o) === h$3
}
reactIs_production_min$3.isElement = function(o) {
  return typeof o == 'object' && o !== null && o.$$typeof === c$4
}
reactIs_production_min$3.isForwardRef = function(o) {
  return z$2(o) === n$3
}
reactIs_production_min$3.isFragment = function(o) {
  return z$2(o) === e$3
}
reactIs_production_min$3.isLazy = function(o) {
  return z$2(o) === t$3
}
reactIs_production_min$3.isMemo = function(o) {
  return z$2(o) === r$4
}
reactIs_production_min$3.isPortal = function(o) {
  return z$2(o) === d$3
}
reactIs_production_min$3.isProfiler = function(o) {
  return z$2(o) === g$6
}
reactIs_production_min$3.isStrictMode = function(o) {
  return z$2(o) === f$3
}
reactIs_production_min$3.isSuspense = function(o) {
  return z$2(o) === p$3
}
reactIs_production_min$3.isValidElementType = function(o) {
  return (
    typeof o == 'string' ||
    typeof o == 'function' ||
    o === e$3 ||
    o === m$3 ||
    o === g$6 ||
    o === f$3 ||
    o === p$3 ||
    o === q$3 ||
    (typeof o == 'object' &&
      o !== null &&
      (o.$$typeof === t$3 ||
        o.$$typeof === r$4 ||
        o.$$typeof === h$3 ||
        o.$$typeof === k$3 ||
        o.$$typeof === n$3 ||
        o.$$typeof === w$3 ||
        o.$$typeof === x$2 ||
        o.$$typeof === y$2 ||
        o.$$typeof === v$3))
  )
}
reactIs_production_min$3.typeOf = z$2
function _objectWithoutPropertiesLoose$3(o, a) {
  if (o == null) return {}
  var s = {}
  for (var $ in o)
    if ({}.hasOwnProperty.call(o, $)) {
      if (a.includes($)) continue
      s[$] = o[$]
    }
  return s
}
var reactIs$3 = { exports: {} },
  reactIs_production_min$2 = {}
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b$2 = typeof Symbol == 'function' && Symbol.for,
  c$3 = b$2 ? Symbol.for('react.element') : 60103,
  d$2 = b$2 ? Symbol.for('react.portal') : 60106,
  e$2 = b$2 ? Symbol.for('react.fragment') : 60107,
  f$2 = b$2 ? Symbol.for('react.strict_mode') : 60108,
  g$5 = b$2 ? Symbol.for('react.profiler') : 60114,
  h$2 = b$2 ? Symbol.for('react.provider') : 60109,
  k$2 = b$2 ? Symbol.for('react.context') : 60110,
  l$2 = b$2 ? Symbol.for('react.async_mode') : 60111,
  m$2 = b$2 ? Symbol.for('react.concurrent_mode') : 60111,
  n$2 = b$2 ? Symbol.for('react.forward_ref') : 60112,
  p$2 = b$2 ? Symbol.for('react.suspense') : 60113,
  q$2 = b$2 ? Symbol.for('react.suspense_list') : 60120,
  r$3 = b$2 ? Symbol.for('react.memo') : 60115,
  t$2 = b$2 ? Symbol.for('react.lazy') : 60116,
  v$2 = b$2 ? Symbol.for('react.block') : 60121,
  w$2 = b$2 ? Symbol.for('react.fundamental') : 60117,
  x$1 = b$2 ? Symbol.for('react.responder') : 60118,
  y$1 = b$2 ? Symbol.for('react.scope') : 60119
function z$1(o) {
  if (typeof o == 'object' && o !== null) {
    var a = o.$$typeof
    switch (a) {
      case c$3:
        switch (((o = o.type), o)) {
          case l$2:
          case m$2:
          case e$2:
          case g$5:
          case f$2:
          case p$2:
            return o
          default:
            switch (((o = o && o.$$typeof), o)) {
              case k$2:
              case n$2:
              case t$2:
              case r$3:
              case h$2:
                return o
              default:
                return a
            }
        }
      case d$2:
        return a
    }
  }
}
function A$1(o) {
  return z$1(o) === m$2
}
reactIs_production_min$2.AsyncMode = l$2
reactIs_production_min$2.ConcurrentMode = m$2
reactIs_production_min$2.ContextConsumer = k$2
reactIs_production_min$2.ContextProvider = h$2
reactIs_production_min$2.Element = c$3
reactIs_production_min$2.ForwardRef = n$2
reactIs_production_min$2.Fragment = e$2
reactIs_production_min$2.Lazy = t$2
reactIs_production_min$2.Memo = r$3
reactIs_production_min$2.Portal = d$2
reactIs_production_min$2.Profiler = g$5
reactIs_production_min$2.StrictMode = f$2
reactIs_production_min$2.Suspense = p$2
reactIs_production_min$2.isAsyncMode = function(o) {
  return A$1(o) || z$1(o) === l$2
}
reactIs_production_min$2.isConcurrentMode = A$1
reactIs_production_min$2.isContextConsumer = function(o) {
  return z$1(o) === k$2
}
reactIs_production_min$2.isContextProvider = function(o) {
  return z$1(o) === h$2
}
reactIs_production_min$2.isElement = function(o) {
  return typeof o == 'object' && o !== null && o.$$typeof === c$3
}
reactIs_production_min$2.isForwardRef = function(o) {
  return z$1(o) === n$2
}
reactIs_production_min$2.isFragment = function(o) {
  return z$1(o) === e$2
}
reactIs_production_min$2.isLazy = function(o) {
  return z$1(o) === t$2
}
reactIs_production_min$2.isMemo = function(o) {
  return z$1(o) === r$3
}
reactIs_production_min$2.isPortal = function(o) {
  return z$1(o) === d$2
}
reactIs_production_min$2.isProfiler = function(o) {
  return z$1(o) === g$5
}
reactIs_production_min$2.isStrictMode = function(o) {
  return z$1(o) === f$2
}
reactIs_production_min$2.isSuspense = function(o) {
  return z$1(o) === p$2
}
reactIs_production_min$2.isValidElementType = function(o) {
  return (
    typeof o == 'string' ||
    typeof o == 'function' ||
    o === e$2 ||
    o === m$2 ||
    o === g$5 ||
    o === f$2 ||
    o === p$2 ||
    o === q$2 ||
    (typeof o == 'object' &&
      o !== null &&
      (o.$$typeof === t$2 ||
        o.$$typeof === r$3 ||
        o.$$typeof === h$2 ||
        o.$$typeof === k$2 ||
        o.$$typeof === n$2 ||
        o.$$typeof === w$2 ||
        o.$$typeof === x$1 ||
        o.$$typeof === y$1 ||
        o.$$typeof === v$2))
  )
}
reactIs_production_min$2.typeOf = z$1
reactIs$3.exports = reactIs_production_min$2
var reactIsExports$2 = reactIs$3.exports,
  reactIs$2 = reactIsExports$2,
  REACT_STATICS = {
    childContextTypes: !0,
    contextType: !0,
    contextTypes: !0,
    defaultProps: !0,
    displayName: !0,
    getDefaultProps: !0,
    getDerivedStateFromError: !0,
    getDerivedStateFromProps: !0,
    mixins: !0,
    propTypes: !0,
    type: !0,
  },
  KNOWN_STATICS = {
    name: !0,
    length: !0,
    prototype: !0,
    caller: !0,
    callee: !0,
    arguments: !0,
    arity: !0,
  },
  FORWARD_REF_STATICS = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
  },
  MEMO_STATICS = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0,
  },
  TYPE_STATICS = {}
TYPE_STATICS[reactIs$2.ForwardRef] = FORWARD_REF_STATICS
TYPE_STATICS[reactIs$2.Memo] = MEMO_STATICS
function getStatics(o) {
  return reactIs$2.isMemo(o)
    ? MEMO_STATICS
    : TYPE_STATICS[o.$$typeof] || REACT_STATICS
}
var defineProperty$1 = Object.defineProperty,
  getOwnPropertyNames = Object.getOwnPropertyNames,
  getOwnPropertySymbols = Object.getOwnPropertySymbols,
  getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,
  getPrototypeOf$1 = Object.getPrototypeOf,
  objectPrototype = Object.prototype
function hoistNonReactStatics(o, a, s) {
  if (typeof a != 'string') {
    if (objectPrototype) {
      var $ = getPrototypeOf$1(a)
      $ && $ !== objectPrototype && hoistNonReactStatics(o, $, s)
    }
    var j = getOwnPropertyNames(a)
    getOwnPropertySymbols && (j = j.concat(getOwnPropertySymbols(a)))
    for (
      var _e = getStatics(o), et = getStatics(a), tt = 0;
      tt < j.length;
      ++tt
    ) {
      var rt = j[tt]
      if (
        !KNOWN_STATICS[rt] &&
        !(s && s[rt]) &&
        !(et && et[rt]) &&
        !(_e && _e[rt])
      ) {
        var nt = getOwnPropertyDescriptor(a, rt)
        try {
          defineProperty$1(o, rt, nt)
        } catch {}
      }
    }
  }
  return o
}
var hoistNonReactStatics_cjs = hoistNonReactStatics
const hoistNonReactStatics$1 = getDefaultExportFromCjs(hoistNonReactStatics_cjs)
var define_global_default$9 = {},
  MAX_SIGNED_31_BIT_INT = 1073741823,
  commonjsGlobal =
    typeof globalThis < 'u'
      ? globalThis
      : typeof window < 'u'
      ? window
      : typeof define_global_default$9 < 'u'
      ? define_global_default$9
      : {}
function getUniqueId() {
  var o = '__global_unique_id__'
  return (commonjsGlobal[o] = (commonjsGlobal[o] || 0) + 1)
}
function objectIs$1(o, a) {
  return o === a ? o !== 0 || 1 / o === 1 / a : o !== o && a !== a
}
function createEventEmitter(o) {
  var a = []
  return {
    on: function($) {
      a.push($)
    },
    off: function($) {
      a = a.filter(function(j) {
        return j !== $
      })
    },
    get: function() {
      return o
    },
    set: function($, j) {
      ;(o = $),
        a.forEach(function(_e) {
          return _e(o, j)
        })
    },
  }
}
function onlyChild(o) {
  return Array.isArray(o) ? o[0] : o
}
function createReactContext(o, a) {
  var s,
    $,
    j = '__create-react-context-' + getUniqueId() + '__',
    _e = (function(tt) {
      _inheritsLoose$2(rt, tt)
      function rt() {
        for (
          var it, ot = arguments.length, at = new Array(ot), st = 0;
          st < ot;
          st++
        )
          at[st] = arguments[st]
        return (
          (it = tt.call.apply(tt, [this].concat(at)) || this),
          (it.emitter = createEventEmitter(it.props.value)),
          it
        )
      }
      var nt = rt.prototype
      return (
        (nt.getChildContext = function() {
          var ot
          return (ot = {}), (ot[j] = this.emitter), ot
        }),
        (nt.componentWillReceiveProps = function(ot) {
          if (this.props.value !== ot.value) {
            var at = this.props.value,
              st = ot.value,
              ut
            objectIs$1(at, st)
              ? (ut = 0)
              : ((ut =
                  typeof a == 'function' ? a(at, st) : MAX_SIGNED_31_BIT_INT),
                (ut |= 0),
                ut !== 0 && this.emitter.set(ot.value, ut))
          }
        }),
        (nt.render = function() {
          return this.props.children
        }),
        rt
      )
    })(React$5.Component)
  _e.childContextTypes = ((s = {}), (s[j] = PropTypes$1.object.isRequired), s)
  var et = (function(tt) {
    _inheritsLoose$2(rt, tt)
    function rt() {
      for (
        var it, ot = arguments.length, at = new Array(ot), st = 0;
        st < ot;
        st++
      )
        at[st] = arguments[st]
      return (
        (it = tt.call.apply(tt, [this].concat(at)) || this),
        (it.observedBits = void 0),
        (it.state = { value: it.getValue() }),
        (it.onUpdate = function(ut, ct) {
          var dt = it.observedBits | 0
          dt & ct && it.setState({ value: it.getValue() })
        }),
        it
      )
    }
    var nt = rt.prototype
    return (
      (nt.componentWillReceiveProps = function(ot) {
        var at = ot.observedBits
        this.observedBits = at ?? MAX_SIGNED_31_BIT_INT
      }),
      (nt.componentDidMount = function() {
        this.context[j] && this.context[j].on(this.onUpdate)
        var ot = this.props.observedBits
        this.observedBits = ot ?? MAX_SIGNED_31_BIT_INT
      }),
      (nt.componentWillUnmount = function() {
        this.context[j] && this.context[j].off(this.onUpdate)
      }),
      (nt.getValue = function() {
        return this.context[j] ? this.context[j].get() : o
      }),
      (nt.render = function() {
        return onlyChild(this.props.children)(this.state.value)
      }),
      rt
    )
  })(React$5.Component)
  return (
    (et.contextTypes = (($ = {}), ($[j] = PropTypes$1.object), $)),
    { Provider: _e, Consumer: et }
  )
}
var createContext = React$5.createContext || createReactContext,
  createNamedContext = function(a) {
    var s = createContext()
    return (s.displayName = a), s
  },
  historyContext = createNamedContext('Router-History'),
  context = createNamedContext('Router'),
  Router = (function(o) {
    _inheritsLoose$2(a, o),
      (a.computeRootMatch = function(j) {
        return { path: '/', url: '/', params: {}, isExact: j === '/' }
      })
    function a($) {
      var j
      return (
        (j = o.call(this, $) || this),
        (j.state = { location: $.history.location }),
        (j._isMounted = !1),
        (j._pendingLocation = null),
        $.staticContext ||
          (j.unlisten = $.history.listen(function(_e) {
            j._pendingLocation = _e
          })),
        j
      )
    }
    var s = a.prototype
    return (
      (s.componentDidMount = function() {
        var j = this
        ;(this._isMounted = !0),
          this.unlisten && this.unlisten(),
          this.props.staticContext ||
            (this.unlisten = this.props.history.listen(function(_e) {
              j._isMounted && j.setState({ location: _e })
            })),
          this._pendingLocation &&
            this.setState({ location: this._pendingLocation })
      }),
      (s.componentWillUnmount = function() {
        this.unlisten &&
          (this.unlisten(),
          (this._isMounted = !1),
          (this._pendingLocation = null))
      }),
      (s.render = function() {
        return React$5.createElement(
          context.Provider,
          {
            value: {
              history: this.props.history,
              location: this.state.location,
              match: a.computeRootMatch(this.state.location.pathname),
              staticContext: this.props.staticContext,
            },
          },
          React$5.createElement(historyContext.Provider, {
            children: this.props.children || null,
            value: this.props.history,
          })
        )
      }),
      a
    )
  })(React$5.Component)
React$5.Component
var Lifecycle = (function(o) {
    _inheritsLoose$2(a, o)
    function a() {
      return o.apply(this, arguments) || this
    }
    var s = a.prototype
    return (
      (s.componentDidMount = function() {
        this.props.onMount && this.props.onMount.call(this, this)
      }),
      (s.componentDidUpdate = function(j) {
        this.props.onUpdate && this.props.onUpdate.call(this, this, j)
      }),
      (s.componentWillUnmount = function() {
        this.props.onUnmount && this.props.onUnmount.call(this, this)
      }),
      (s.render = function() {
        return null
      }),
      a
    )
  })(React$5.Component),
  cache$2 = {},
  cacheLimit = 1e4,
  cacheCount = 0
function compilePath(o) {
  if (cache$2[o]) return cache$2[o]
  var a = pathToRegexp$1.compile(o)
  return cacheCount < cacheLimit && ((cache$2[o] = a), cacheCount++), a
}
function generatePath(o, a) {
  return (
    o === void 0 && (o = '/'),
    a === void 0 && (a = {}),
    o === '/' ? o : compilePath(o)(a, { pretty: !0 })
  )
}
function Redirect(o) {
  var a = o.computedMatch,
    s = o.to,
    $ = o.push,
    j = $ === void 0 ? !1 : $
  return React$5.createElement(context.Consumer, null, function(_e) {
    _e || invariant()
    var et = _e.history,
      tt = _e.staticContext,
      rt = j ? et.push : et.replace,
      nt = createLocation(
        a
          ? typeof s == 'string'
            ? generatePath(s, a.params)
            : _extends$5({}, s, {
                pathname: generatePath(s.pathname, a.params),
              })
          : s
      )
    return tt
      ? (rt(nt), null)
      : React$5.createElement(Lifecycle, {
          onMount: function() {
            rt(nt)
          },
          onUpdate: function(ot, at) {
            var st = createLocation(at.to)
            locationsAreEqual(st, _extends$5({}, nt, { key: st.key })) || rt(nt)
          },
          to: s,
        })
  })
}
var cache$1$1 = {},
  cacheLimit$1 = 1e4,
  cacheCount$1 = 0
function compilePath$1(o, a) {
  var s = '' + a.end + a.strict + a.sensitive,
    $ = cache$1$1[s] || (cache$1$1[s] = {})
  if ($[o]) return $[o]
  var j = [],
    _e = pathToRegexp$1(o, j, a),
    et = { regexp: _e, keys: j }
  return cacheCount$1 < cacheLimit$1 && (($[o] = et), cacheCount$1++), et
}
function matchPath(o, a) {
  a === void 0 && (a = {}),
    (typeof a == 'string' || Array.isArray(a)) && (a = { path: a })
  var s = a,
    $ = s.path,
    j = s.exact,
    _e = j === void 0 ? !1 : j,
    et = s.strict,
    tt = et === void 0 ? !1 : et,
    rt = s.sensitive,
    nt = rt === void 0 ? !1 : rt,
    it = [].concat($)
  return it.reduce(function(ot, at) {
    if (!at && at !== '') return null
    if (ot) return ot
    var st = compilePath$1(at, { end: _e, strict: tt, sensitive: nt }),
      ut = st.regexp,
      ct = st.keys,
      dt = ut.exec(o)
    if (!dt) return null
    var ft = dt[0],
      mt = dt.slice(1),
      vt = o === ft
    return _e && !vt
      ? null
      : {
          path: at,
          url: at === '/' && ft === '' ? '/' : ft,
          isExact: vt,
          params: ct.reduce(function(yt, pt, ht) {
            return (yt[pt.name] = mt[ht]), yt
          }, {}),
        }
  }, null)
}
function isEmptyChildren(o) {
  return React$5.Children.count(o) === 0
}
var Route = (function(o) {
  _inheritsLoose$2(a, o)
  function a() {
    return o.apply(this, arguments) || this
  }
  var s = a.prototype
  return (
    (s.render = function() {
      var j = this
      return React$5.createElement(context.Consumer, null, function(_e) {
        _e || invariant()
        var et = j.props.location || _e.location,
          tt = j.props.computedMatch
            ? j.props.computedMatch
            : j.props.path
            ? matchPath(et.pathname, j.props)
            : _e.match,
          rt = _extends$5({}, _e, { location: et, match: tt }),
          nt = j.props,
          it = nt.children,
          ot = nt.component,
          at = nt.render
        return (
          Array.isArray(it) && isEmptyChildren(it) && (it = null),
          React$5.createElement(
            context.Provider,
            { value: rt },
            rt.match
              ? it
                ? typeof it == 'function'
                  ? it(rt)
                  : it
                : ot
                ? React$5.createElement(ot, rt)
                : at
                ? at(rt)
                : null
              : typeof it == 'function'
              ? it(rt)
              : null
          )
        )
      })
    }),
    a
  )
})(React$5.Component)
function addLeadingSlash(o) {
  return o.charAt(0) === '/' ? o : '/' + o
}
function addBasename(o, a) {
  return o
    ? _extends$5({}, a, { pathname: addLeadingSlash(o) + a.pathname })
    : a
}
function stripBasename(o, a) {
  if (!o) return a
  var s = addLeadingSlash(o)
  return a.pathname.indexOf(s) !== 0
    ? a
    : _extends$5({}, a, { pathname: a.pathname.substr(s.length) })
}
function createURL(o) {
  return typeof o == 'string' ? o : createPath(o)
}
function staticHandler(o) {
  return function() {
    invariant()
  }
}
function noop$a() {}
React$5.Component
React$5.Component
React$5.useContext
React$5.Component
var HashRouter = (function(o) {
    _inheritsLoose$2(a, o)
    function a() {
      for (var $, j = arguments.length, _e = new Array(j), et = 0; et < j; et++)
        _e[et] = arguments[et]
      return (
        ($ = o.call.apply(o, [this].concat(_e)) || this),
        ($.history = createHashHistory($.props)),
        $
      )
    }
    var s = a.prototype
    return (
      (s.render = function() {
        return React$5.createElement(Router, {
          history: this.history,
          children: this.props.children,
        })
      }),
      a
    )
  })(React$5.Component),
  resolveToLocation = function(a, s) {
    return typeof a == 'function' ? a(s) : a
  },
  normalizeToLocation = function(a, s) {
    return typeof a == 'string' ? createLocation(a, null, null, s) : a
  },
  forwardRefShim = function(a) {
    return a
  },
  forwardRef = React$5.forwardRef
typeof forwardRef > 'u' && (forwardRef = forwardRefShim)
function isModifiedEvent(o) {
  return !!(o.metaKey || o.altKey || o.ctrlKey || o.shiftKey)
}
var LinkAnchor = forwardRef(function(o, a) {
    var s = o.innerRef,
      $ = o.navigate,
      j = o.onClick,
      _e = _objectWithoutPropertiesLoose$3(o, [
        'innerRef',
        'navigate',
        'onClick',
      ]),
      et = _e.target,
      tt = _extends$5({}, _e, {
        onClick: function(nt) {
          try {
            j && j(nt)
          } catch (it) {
            throw (nt.preventDefault(), it)
          }
          !nt.defaultPrevented &&
            nt.button === 0 &&
            (!et || et === '_self') &&
            !isModifiedEvent(nt) &&
            (nt.preventDefault(), $())
        },
      })
    return (
      forwardRefShim !== forwardRef ? (tt.ref = a || s) : (tt.ref = s),
      React$5.createElement('a', tt)
    )
  }),
  Link = forwardRef(function(o, a) {
    var s = o.component,
      $ = s === void 0 ? LinkAnchor : s,
      j = o.replace,
      _e = o.to,
      et = o.innerRef,
      tt = _objectWithoutPropertiesLoose$3(o, [
        'component',
        'replace',
        'to',
        'innerRef',
      ])
    return React$5.createElement(context.Consumer, null, function(rt) {
      rt || invariant()
      var nt = rt.history,
        it = normalizeToLocation(
          resolveToLocation(_e, rt.location),
          rt.location
        ),
        ot = it ? nt.createHref(it) : '',
        at = _extends$5({}, tt, {
          href: ot,
          navigate: function() {
            var ut = resolveToLocation(_e, rt.location),
              ct =
                createPath(rt.location) === createPath(normalizeToLocation(ut)),
              dt = j || ct ? nt.replace : nt.push
            dt(ut)
          },
        })
      return (
        forwardRefShim !== forwardRef ? (at.ref = a || et) : (at.innerRef = et),
        React$5.createElement($, at)
      )
    })
  }),
  forwardRefShim$1 = function(a) {
    return a
  },
  forwardRef$1 = React$5.forwardRef
typeof forwardRef$1 > 'u' && (forwardRef$1 = forwardRefShim$1)
function joinClassnames() {
  for (var o = arguments.length, a = new Array(o), s = 0; s < o; s++)
    a[s] = arguments[s]
  return a
    .filter(function($) {
      return $
    })
    .join(' ')
}
forwardRef$1(function(o, a) {
  var s = o['aria-current'],
    $ = s === void 0 ? 'page' : s,
    j = o.activeClassName,
    _e = j === void 0 ? 'active' : j,
    et = o.activeStyle,
    tt = o.className,
    rt = o.exact,
    nt = o.isActive,
    it = o.location,
    ot = o.sensitive,
    at = o.strict,
    st = o.style,
    ut = o.to,
    ct = o.innerRef,
    dt = _objectWithoutPropertiesLoose$3(o, [
      'aria-current',
      'activeClassName',
      'activeStyle',
      'className',
      'exact',
      'isActive',
      'location',
      'sensitive',
      'strict',
      'style',
      'to',
      'innerRef',
    ])
  return React$5.createElement(context.Consumer, null, function(ft) {
    ft || invariant()
    var mt = it || ft.location,
      vt = normalizeToLocation(resolveToLocation(ut, mt), mt),
      yt = vt.pathname,
      pt = yt && yt.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1'),
      ht = pt
        ? matchPath(mt.pathname, {
            path: pt,
            exact: rt,
            sensitive: ot,
            strict: at,
          })
        : null,
      At = !!(nt ? nt(ht, mt) : ht),
      wt = typeof tt == 'function' ? tt(At) : tt,
      Ct = typeof st == 'function' ? st(At) : st
    At && ((wt = joinClassnames(wt, _e)), (Ct = _extends$5({}, Ct, et)))
    var Dt = _extends$5(
      { 'aria-current': (At && $) || null, className: wt, style: Ct, to: vt },
      dt
    )
    return (
      forwardRefShim$1 !== forwardRef$1
        ? (Dt.ref = a || ct)
        : (Dt.innerRef = ct),
      React$5.createElement(Link, Dt)
    )
  })
})
var define_global_default$8 = {},
  win
typeof window < 'u'
  ? (win = window)
  : typeof define_global_default$8 < 'u'
  ? (win = define_global_default$8)
  : typeof self < 'u'
  ? (win = self)
  : (win = {})
var window_1 = win
const window$1 = getDefaultExportFromCjs(window_1)
var index_es = { exports: {} }
function _typeof$6(o) {
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (_typeof$6 = function(a) {
          return typeof a
        })
      : (_typeof$6 = function(a) {
          return a &&
            typeof Symbol == 'function' &&
            a.constructor === Symbol &&
            a !== Symbol.prototype
            ? 'symbol'
            : typeof a
        }),
    _typeof$6(o)
  )
}
function _classCallCheck$2(o, a) {
  if (!(o instanceof a))
    throw new TypeError('Cannot call a class as a function')
}
function _defineProperties$2(o, a) {
  for (var s = 0; s < a.length; s++) {
    var $ = a[s]
    ;($.enumerable = $.enumerable || !1),
      ($.configurable = !0),
      'value' in $ && ($.writable = !0),
      Object.defineProperty(o, $.key, $)
  }
}
function _createClass$3(o, a, s) {
  return (
    a && _defineProperties$2(o.prototype, a), s && _defineProperties$2(o, s), o
  )
}
function _defineProperty$4(o, a, s) {
  return (
    a in o
      ? Object.defineProperty(o, a, {
          value: s,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (o[a] = s),
    o
  )
}
function _extends$4() {
  return (
    (_extends$4 =
      Object.assign ||
      function(o) {
        for (var a = 1; a < arguments.length; a++) {
          var s = arguments[a]
          for (var $ in s)
            Object.prototype.hasOwnProperty.call(s, $) && (o[$] = s[$])
        }
        return o
      }),
    _extends$4.apply(this, arguments)
  )
}
function _objectSpread$1(o) {
  for (var a = 1; a < arguments.length; a++) {
    var s = arguments[a] != null ? arguments[a] : {},
      $ = Object.keys(s)
    typeof Object.getOwnPropertySymbols == 'function' &&
      ($ = $.concat(
        Object.getOwnPropertySymbols(s).filter(function(j) {
          return Object.getOwnPropertyDescriptor(s, j).enumerable
        })
      )),
      $.forEach(function(j) {
        _defineProperty$4(o, j, s[j])
      })
  }
  return o
}
function _inherits$1(o, a) {
  if (typeof a != 'function' && a !== null)
    throw new TypeError('Super expression must either be null or a function')
  ;(o.prototype = Object.create(a && a.prototype, {
    constructor: { value: o, writable: !0, configurable: !0 },
  })),
    a && _setPrototypeOf(o, a)
}
function _getPrototypeOf(o) {
  return (
    (_getPrototypeOf = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function(s) {
          return s.__proto__ || Object.getPrototypeOf(s)
        }),
    _getPrototypeOf(o)
  )
}
function _setPrototypeOf(o, a) {
  return (
    (_setPrototypeOf =
      Object.setPrototypeOf ||
      function($, j) {
        return ($.__proto__ = j), $
      }),
    _setPrototypeOf(o, a)
  )
}
function isNativeReflectConstruct() {
  if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
    return !1
  if (typeof Proxy == 'function') return !0
  try {
    return (
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {})),
      !0
    )
  } catch {
    return !1
  }
}
function _construct(o, a, s) {
  return (
    isNativeReflectConstruct()
      ? (_construct = Reflect.construct)
      : (_construct = function(j, _e, et) {
          var tt = [null]
          tt.push.apply(tt, _e)
          var rt = Function.bind.apply(j, tt),
            nt = new rt()
          return et && _setPrototypeOf(nt, et.prototype), nt
        }),
    _construct.apply(null, arguments)
  )
}
function _isNativeFunction(o) {
  return Function.toString.call(o).indexOf('[native code]') !== -1
}
function _wrapNativeSuper(o) {
  var a = typeof Map == 'function' ? new Map() : void 0
  return (
    (_wrapNativeSuper = function($) {
      if ($ === null || !_isNativeFunction($)) return $
      if (typeof $ != 'function')
        throw new TypeError(
          'Super expression must either be null or a function'
        )
      if (typeof a < 'u') {
        if (a.has($)) return a.get($)
        a.set($, j)
      }
      function j() {
        return _construct($, arguments, _getPrototypeOf(this).constructor)
      }
      return (
        (j.prototype = Object.create($.prototype, {
          constructor: {
            value: j,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
        _setPrototypeOf(j, $)
      )
    }),
    _wrapNativeSuper(o)
  )
}
function _objectWithoutPropertiesLoose$2(o, a) {
  if (o == null) return {}
  var s = {},
    $ = Object.keys(o),
    j,
    _e
  for (_e = 0; _e < $.length; _e++)
    (j = $[_e]), !(a.indexOf(j) >= 0) && (s[j] = o[j])
  return s
}
function _objectWithoutProperties$2(o, a) {
  if (o == null) return {}
  var s = _objectWithoutPropertiesLoose$2(o, a),
    $,
    j
  if (Object.getOwnPropertySymbols) {
    var _e = Object.getOwnPropertySymbols(o)
    for (j = 0; j < _e.length; j++)
      ($ = _e[j]),
        !(a.indexOf($) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(o, $) &&
          (s[$] = o[$])
  }
  return s
}
function _assertThisInitialized$2(o) {
  if (o === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return o
}
function _possibleConstructorReturn$1(o, a) {
  return a && (typeof a == 'object' || typeof a == 'function')
    ? a
    : _assertThisInitialized$2(o)
}
function _superPropBase(o, a) {
  for (
    ;
    !Object.prototype.hasOwnProperty.call(o, a) &&
    ((o = _getPrototypeOf(o)), o !== null);

  );
  return o
}
function _get(o, a, s) {
  return (
    typeof Reflect < 'u' && Reflect.get
      ? (_get = Reflect.get)
      : (_get = function(j, _e, et) {
          var tt = _superPropBase(j, _e)
          if (tt) {
            var rt = Object.getOwnPropertyDescriptor(tt, _e)
            return rt.get ? rt.get.call(et) : rt.value
          }
        }),
    _get(o, a, s || o)
  )
}
function _toConsumableArray$2(o) {
  return (
    _arrayWithoutHoles$2(o) || _iterableToArray$3(o) || _nonIterableSpread$2()
  )
}
function _arrayWithoutHoles$2(o) {
  if (Array.isArray(o)) {
    for (var a = 0, s = new Array(o.length); a < o.length; a++) s[a] = o[a]
    return s
  }
}
function _iterableToArray$3(o) {
  if (
    Symbol.iterator in Object(o) ||
    Object.prototype.toString.call(o) === '[object Arguments]'
  )
    return Array.from(o)
}
function _nonIterableSpread$2() {
  throw new TypeError('Invalid attempt to spread non-iterable instance')
}
function dictionaryFrom(o) {
  var a = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : null
  return o.reduce(function(s, $) {
    return (s[$] = a || { value: $ }), s
  }, {})
}
var _defaultConfiguration = {
    logLevel: 'warn',
    defaultKeyEvent: 'keydown',
    defaultComponent: 'div',
    defaultTabIndex: '-1',
    ignoreTags: ['input', 'select', 'textarea'],
    enableHardSequences: !1,
    ignoreKeymapAndHandlerChangesByDefault: !0,
    ignoreEventsCondition: function(a) {
      var s = a.target
      if (s && s.tagName) {
        var $ = s.tagName.toLowerCase()
        return Configuration.option('_ignoreTagsDict')[$] || s.isContentEditable
      }
      return !1
    },
    ignoreRepeatedEventsWhenKeyHeldDown: !0,
    simulateMissingKeyPressEvents: !0,
    stopEventPropagationAfterHandling: !0,
    stopEventPropagationAfterIgnoring: !0,
    allowCombinationSubmatches: !1,
    customKeyCodes: {},
  },
  _configuration = _objectSpread$1({}, _defaultConfiguration)
_configuration._ignoreTagsDict = dictionaryFrom(_configuration.ignoreTags, !0)
var Configuration = (function() {
    function o() {
      _classCallCheck$2(this, o)
    }
    return (
      _createClass$3(o, null, [
        {
          key: 'init',
          value: function(s) {
            var $ = this,
              j = s.ignoreTags,
              _e = s.customKeyCodes
            j && (s._ignoreTagsDict = dictionaryFrom(s.ignoreTags)),
              _e &&
                (s._customKeyNamesDict = dictionaryFrom(
                  Object.values(s.customKeyCodes)
                )),
              ['verbose', 'debug', 'info'].indexOf(s.logLevel) !== -1 &&
                console.warn(
                  "React HotKeys: You have requested log level '".concat(
                    s.logLevel,
                    "' but for performance reasons, logging below severity level 'warning' is disabled in production. Please use the development build for complete logs."
                  )
                ),
              Object.keys(s).forEach(function(et) {
                $.set(et, s[et])
              })
          },
        },
        {
          key: 'set',
          value: function(s, $) {
            _configuration[s] = $
          },
        },
        {
          key: 'reset',
          value: function(s) {
            _configuration[s] = _defaultConfiguration[s]
          },
        },
        {
          key: 'option',
          value: function(s) {
            return _configuration[s]
          },
        },
      ]),
      o
    )
  })(),
  Logger = (function() {
    function o() {
      var a = this,
        s =
          0 < arguments.length && arguments[0] !== void 0
            ? arguments[0]
            : 'warn'
      if (
        (_classCallCheck$2(this, o),
        _defineProperty$4(this, 'verbose', this.noop),
        _defineProperty$4(this, 'debug', this.noop),
        _defineProperty$4(this, 'info', this.noop),
        _defineProperty$4(this, 'warn', this.noop),
        _defineProperty$4(this, 'error', this.noop),
        (this.logLevel = this.constructor.levels[s]),
        this.logLevel >= this.constructor.levels.error)
      )
        this.error = console.error
      else return
      if (this.logLevel >= this.constructor.levels.warn)
        this.warn = console.warn
      else return
      ;['info', 'debug', 'verbose'].some(function($) {
        return (
          !(a.logLevel >= a.constructor.levels[$]) || ((a[$] = console.log), !1)
        )
      })
    }
    return _createClass$3(o, [{ key: 'noop', value: function() {} }]), o
  })()
_defineProperty$4(Logger, 'logIcons', ['', '', '', '']),
  _defineProperty$4(Logger, 'componentIcons', ['', '', '', '', '']),
  _defineProperty$4(Logger, 'eventIcons', ['', '', '', '', '', '']),
  _defineProperty$4(Logger, 'levels', {
    none: 0,
    error: 1,
    warn: 2,
    info: 3,
    debug: 4,
    verbose: 5,
  })
var KeyEventType = { keydown: 0, keypress: 1, keyup: 2 },
  ModifierFlagsDictionary = {
    Shift: ['shiftKey'],
    Meta: ['metaKey'],
    Control: ['ctrlKey'],
    Alt: ['altKey'],
  },
  ShiftedKeysDictionary = {
    '`': ['~'],
    1: ['!'],
    2: ['@', '"'],
    3: ['#', ''],
    4: ['$'],
    5: ['%'],
    6: ['^'],
    7: ['&'],
    8: ['*'],
    9: ['('],
    0: [')'],
    '-': ['_'],
    '=': ['plus'],
    ';': [':'],
    "'": ['"', '@'],
    ',': ['<'],
    '.': ['>'],
    '/': ['?'],
    '\\': ['|'],
    '[': ['{'],
    ']': ['}'],
    '#': ['~'],
  }
function resolveShiftedAlias(o) {
  return ShiftedKeysDictionary[o] || [o.length === 1 ? o.toUpperCase() : o]
}
function hasKey(o, a) {
  return o.hasOwnProperty(a)
}
function invertArrayDictionary(o) {
  var a = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}
  return Object.keys(o).reduce(function(s, $) {
    var j = o[$]
    return (
      j.forEach(function(_e) {
        hasKey(s, _e) || (s[_e] = []), s[_e].push($)
      }),
      a.includeOriginal &&
        (!hasKey(s, $) && (s[$] = []),
        (s[$] = [].concat(
          _toConsumableArray$2(s[$]),
          _toConsumableArray$2(j)
        ))),
      s
    )
  }, {})
}
var UnshiftedKeysDictionary = invertArrayDictionary(ShiftedKeysDictionary)
function resolveUnshiftedAlias(o) {
  return UnshiftedKeysDictionary[o] || [o.length === 1 ? o.toLowerCase() : o]
}
var KeyOSAndLayoutAliasesDictionary = {},
  KeyOSAndLayoutAliasesDictionary$1 = invertArrayDictionary(
    KeyOSAndLayoutAliasesDictionary,
    { includeOriginal: !0 }
  )
function isString$2(o) {
  return typeof o == 'string'
}
function stripSuperfluousWhitespace(o) {
  return isString$2(o) ? o.trim().replace(/\s+/g, ' ') : o
}
var MousetrapToReactKeyNamesDictionary = {
    tab: 'Tab',
    capslock: 'CapsLock',
    shift: 'Shift',
    meta: 'Meta',
    alt: 'Alt',
    ctrl: 'Control',
    space: ' ',
    spacebar: ' ',
    escape: 'Escape',
    esc: 'Escape',
    left: 'ArrowLeft',
    right: 'ArrowRight',
    up: 'ArrowUp',
    down: 'ArrowDown',
    return: 'Enter',
    del: 'Delete',
    command: 'Meta',
    option: 'Alt',
    enter: 'Enter',
    backspace: 'Backspace',
    ins: 'Insert',
    pageup: 'PageUp',
    pagedown: 'PageDown',
    end: 'End',
    home: 'Home',
    contextmenu: 'ContextMenu',
    numlock: 'Clear',
  },
  KeyShorthandDictionary = { cmd: 'Meta' }
function standardizeKeyName(o) {
  var a = o.toLowerCase()
  return (
    MousetrapToReactKeyNamesDictionary[a] ||
    KeyShorthandDictionary[a] ||
    (o.match(/^f\d+$/) ? o.toUpperCase() : o)
  )
}
var translateToKey = {
    8: 'Backspace',
    9: 'Tab',
    12: 'Clear',
    13: 'Enter',
    16: 'Shift',
    17: 'Control',
    18: 'Alt',
    19: 'Pause',
    20: 'CapsLock',
    27: 'Escape',
    32: ' ',
    33: 'PageUp',
    34: 'PageDown',
    35: 'End',
    36: 'Home',
    37: 'ArrowLeft',
    38: 'ArrowUp',
    39: 'ArrowRight',
    40: 'ArrowDown',
    45: 'Insert',
    46: 'Delete',
    112: 'F1',
    113: 'F2',
    114: 'F3',
    115: 'F4',
    116: 'F5',
    117: 'F6',
    118: 'F7',
    119: 'F8',
    120: 'F9',
    121: 'F10',
    122: 'F11',
    123: 'F12',
    144: 'NumLock',
    145: 'ScrollLock',
    224: 'Meta',
  },
  NonPrintableKeysDictionary = dictionaryFrom(Object.values(translateToKey), !0)
function isNonPrintableKeyName(o) {
  return !!NonPrintableKeysDictionary[o]
}
function isCustomKeyName(o) {
  return Configuration.option('_customKeyNamesDict')[o]
}
function isValidKey(o) {
  return (
    isNonPrintableKeyName(o) ||
    String.fromCharCode(o.charCodeAt(0)) === o ||
    isCustomKeyName(o)
  )
}
var InvalidKeyNameError = (function(o) {
  function a() {
    var s, $
    _classCallCheck$2(this, a)
    for (var j = arguments.length, _e = Array(j), et = 0; et < j; et++)
      _e[et] = arguments[et]
    return (
      ($ = _possibleConstructorReturn$1(
        this,
        (s = _getPrototypeOf(a)).call.apply(s, [this].concat(_e))
      )),
      _defineProperty$4(
        _assertThisInitialized$2(_assertThisInitialized$2($)),
        'name',
        'InvalidKeyNameError'
      ),
      $
    )
  }
  return _inherits$1(a, o), a
})(_wrapNativeSuper(Error))
function normalizedCombinationId(o) {
  return o.sort().join('+')
}
var KeySequenceParser = (function() {
  function o() {
    _classCallCheck$2(this, o)
  }
  return (
    _createClass$3(o, null, [
      {
        key: 'parse',
        value: function(s) {
          var $ =
              1 < arguments.length && arguments[1] !== void 0
                ? arguments[1]
                : {},
            j = stripSuperfluousWhitespace(s),
            _e = j.split(' ')
          try {
            var et = _e.slice(0, _e.length - 1),
              tt = _e[_e.length - 1],
              rt = et
                .map(function(at) {
                  var st = parseCombination(at, $)
                  return normalizedCombinationId(Object.keys(st))
                })
                .join(' '),
              nt = parseCombination(tt, $),
              it = normalizedCombinationId(Object.keys(nt)),
              ot = {
                id: it,
                keyDictionary: nt,
                keyEventType: $.keyEventType,
                size: Object.keys(nt).length,
              }
            return {
              sequence: { prefix: rt, size: et.length + 1 },
              combination: ot,
            }
          } catch {
            return { sequence: null, combination: null }
          }
        },
      },
    ]),
    o
  )
})()
function parseCombination(o) {
  var a = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}
  return o
    .replace(/^\+|(\s|[^+]\+)\+/, '$1plus')
    .split('+')
    .reduce(function(s, $) {
      var j = standardizeKeyName($)
      if (a.ensureValidKeys && !isValidKey(j)) throw new InvalidKeyNameError()
      return (s[j] = !0), s
    }, {})
}
var AltedKeysDictionary = {
    '`': ['`'],
    1: [''],
    2: [''],
    3: [''],
    4: [''],
    5: [''],
    6: [''],
    7: [''],
    8: [''],
    9: [''],
    0: [''],
    '-': [''],
    '=': [''],
    a: [''],
    b: [''],
    c: [''],
    d: [''],
    e: [''],
    f: [''],
    g: [''],
    h: [''],
    i: [''],
    j: [''],
    k: [''],
    l: [''],
    m: [''],
    n: [''],
    o: [''],
    p: [''],
    q: [''],
    r: [''],
    s: [''],
    t: [''],
    u: [''],
    v: [''],
    w: [''],
    x: [''],
    y: [''],
    z: [''],
    '[': [''],
    ']': [''],
    '\\': [''],
    "'": [''],
    ';': [''],
    ',': [''],
    '.': [''],
    '/': [''],
  },
  UnaltedKeysDictionary = invertArrayDictionary(AltedKeysDictionary)
function resolveUnaltedAlias(o) {
  return UnaltedKeysDictionary[o] || [o]
}
function resolveAltedAlias(o) {
  return AltedKeysDictionary[o] || [o]
}
var AltShiftedKeysDictionary = {
    '`': ['`'],
    1: [''],
    2: [''],
    3: [''],
    4: [''],
    5: [''],
    6: [''],
    7: [''],
    8: [''],
    9: [''],
    0: [''],
    '-': [''],
    '=': [''],
    a: [''],
    b: [''],
    c: [''],
    d: [''],
    e: [''],
    f: [''],
    g: [''],
    h: [''],
    i: [''],
    j: [''],
    k: [''],
    l: [''],
    m: [''],
    n: [''],
    o: [''],
    p: [''],
    q: [''],
    r: [''],
    s: [''],
    t: [''],
    u: [''],
    v: [''],
    w: [''],
    x: [''],
    y: [''],
    z: [''],
    '[': [''],
    ']': [''],
    '\\': [''],
    "'": [''],
    ';': [''],
    ',': [''],
    '.': [''],
  },
  UnaltShiftedKeysDictionary = invertArrayDictionary(AltShiftedKeysDictionary)
function resolveUnaltShiftedAlias(o) {
  return UnaltShiftedKeysDictionary[o] || resolveUnshiftedAlias(o)
}
function resolveAltShiftedAlias(o) {
  return AltShiftedKeysDictionary[o] || [o]
}
var KeyCombinationSerializer = (function() {
    function o() {
      _classCallCheck$2(this, o)
    }
    return (
      _createClass$3(o, null, [
        {
          key: 'serialize',
          value: function(s) {
            var $ = s.Shift,
              j = s.Alt,
              _e = {},
              et = Object.keys(s).sort()
            return (
              et.forEach(function(tt) {
                var rt = []
                if ($)
                  if (j) {
                    var nt = resolveUnaltShiftedAlias(tt),
                      it = resolveAltShiftedAlias(tt)
                    rt = [].concat(
                      _toConsumableArray$2(rt),
                      [tt],
                      _toConsumableArray$2(nt),
                      _toConsumableArray$2(it)
                    )
                  } else {
                    var ot = resolveUnshiftedAlias(tt),
                      at = resolveShiftedAlias(tt)
                    rt = [].concat(
                      _toConsumableArray$2(rt),
                      [tt],
                      _toConsumableArray$2(ot),
                      _toConsumableArray$2(at)
                    )
                  }
                else if (j) {
                  var st = resolveUnaltedAlias(tt),
                    ut = resolveAltedAlias(tt)
                  rt = [].concat(
                    _toConsumableArray$2(rt),
                    [tt],
                    _toConsumableArray$2(st),
                    _toConsumableArray$2(ut)
                  )
                } else {
                  rt.push(tt)
                  var ct = KeyOSAndLayoutAliasesDictionary$1[tt]
                  ct &&
                    (rt = [].concat(
                      _toConsumableArray$2(rt),
                      _toConsumableArray$2(ct)
                    ))
                }
                var dt = Object.keys(_e)
                0 < dt.length
                  ? dt.forEach(function(ft) {
                      rt.forEach(function(mt) {
                        _e[ft + '+'.concat(mt)] = _objectSpread$1(
                          {},
                          _e[ft],
                          _defineProperty$4({}, mt, !0)
                        )
                      }),
                        delete _e[ft]
                    })
                  : rt.forEach(function(ft) {
                      _e[ft] = _defineProperty$4({}, ft, !0)
                    })
              }),
              Object.values(_e).map(function(tt) {
                return Object.keys(tt)
                  .sort()
                  .join('+')
              })
            )
          },
        },
        {
          key: 'isValidKeySerialization',
          value: function(s) {
            return (
              0 < s.length &&
              !!KeySequenceParser.parse(s, { ensureValidKeys: !0 }).combination
            )
          },
        },
      ]),
      o
    )
  })(),
  KeyEventSequenceIndex = { previous: 0, current: 1 }
function resolveKeyAlias(o) {
  return KeyOSAndLayoutAliasesDictionary$1[o] || [o]
}
function applicableAliasFunctions(o) {
  if (o.Shift)
    return o.Alt
      ? [resolveAltShiftedAlias, resolveUnaltShiftedAlias]
      : [resolveShiftedAlias, resolveUnshiftedAlias]
  if (o.Alt) return [resolveAltedAlias, resolveUnaltedAlias]
  var a = function(s) {
    return [s]
  }
  return [a, a]
}
function isUndefined$2(o) {
  return typeof o > 'u'
}
var KeyEventState = { unseen: 0, seen: 1, simulated: 2 },
  KeyEventStateArrayManager = (function() {
    function o() {
      _classCallCheck$2(this, o)
    }
    return (
      _createClass$3(o, null, [
        {
          key: 'newRecord',
          value: function(s, $) {
            var j = [
              KeyEventState.unseen,
              KeyEventState.unseen,
              KeyEventState.unseen,
            ]
            if (!isUndefined$2(s)) for (var _e = 0; _e <= s; _e++) j[_e] = $
            return j
          },
        },
        {
          key: 'setBit',
          value: function(s, $, j) {
            return (s[$] = j), s
          },
        },
        {
          key: 'clone',
          value: function(s) {
            for (var $ = this.newRecord(), j = 0; j < s.length; j++) $[j] = s[j]
            return $
          },
        },
      ]),
      o
    )
  })()
function isObject$3(o) {
  return !Array.isArray(o) && _typeof$6(o) === 'object' && o !== null
}
function isEmpty$5(o) {
  return isObject$3(o) ? Object.keys(o).length === 0 : !o || o.length === 0
}
function size(o) {
  return isObject$3(o) ? Object.keys(o).length : o.length
}
var KeyCombination = (function() {
  function o() {
    var a = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}
    _classCallCheck$2(this, o),
      (this._keys = a),
      (this._includesKeyUp = !1),
      this._update()
  }
  return (
    _createClass$3(o, [
      {
        key: 'getIds',
        value: function() {
          return this._ids
        },
      },
      {
        key: 'getKeyAliases',
        value: function() {
          return this._keyAliases
        },
      },
      {
        key: 'getNormalizedKeyName',
        value: function(s) {
          var $ = this._keys[s]
          if ($) return s
          var j = this._keyAliases[s]
          return j || s
        },
      },
      {
        key: 'getNumberOfKeys',
        value: function() {
          return size(this._keys)
        },
      },
      {
        key: 'any',
        value: function() {
          return 0 < Object.keys(this._getKeyStates()).length
        },
      },
      {
        key: 'isEnding',
        value: function() {
          return this._includesKeyUp
        },
      },
      {
        key: 'hasEnded',
        value: function() {
          return isEmpty$5(this.keysStillPressedDict())
        },
      },
      {
        key: 'addKey',
        value: function(s, $) {
          this._setKeyState(s, [
            KeyEventStateArrayManager.newRecord(),
            KeyEventStateArrayManager.newRecord(KeyEventType.keydown, $),
          ])
        },
      },
      {
        key: 'setKeyState',
        value: function(s, $, j) {
          var _e = this._getKeyState(s)
          if (this.isKeyIncluded(s)) {
            var et = KeyEventStateArrayManager.clone(_e[1]),
              tt = KeyEventStateArrayManager.clone(et)
            KeyEventStateArrayManager.setBit(tt, $, j),
              this._setKeyState(s, [et, tt])
          } else this.addKey(s, j)
          $ === KeyEventType.keyup && (this._includesKeyUp = !0)
        },
      },
      {
        key: 'forEachKey',
        value: function(s) {
          return Object.keys(this._keys).forEach(s)
        },
      },
      {
        key: 'some',
        value: function(s) {
          return Object.keys(this._keys).some(s)
        },
      },
      {
        key: 'getKeyDictionary',
        value: function() {
          return dictionaryFrom(Object.keys(this._getKeyStates()), !0)
        },
      },
      {
        key: 'keysStillPressedDict',
        value: function() {
          var s = this
          return Object.keys(this._keys).reduce(function($, j) {
            return s.isKeyStillPressed(j) && ($[j] = s._getKeyState(j)), $
          }, {})
        },
      },
      {
        key: 'isKeyIncluded',
        value: function(s) {
          return !!this._getKeyState(s)
        },
      },
      {
        key: 'isKeyStillPressed',
        value: function(s) {
          return (
            this.isEventTriggered(s, KeyEventType.keypress) &&
            !this.isKeyReleased(s)
          )
        },
      },
      {
        key: 'isKeyReleased',
        value: function(s) {
          return this.isEventTriggered(s, KeyEventType.keyup)
        },
      },
      {
        key: 'isEventTriggered',
        value: function(s, $) {
          return this._getKeyStateType(s, KeyEventSequenceIndex.current, $)
        },
      },
      {
        key: 'wasEventPreviouslyTriggered',
        value: function(s, $) {
          return this._getKeyStateType(s, KeyEventSequenceIndex.previous, $)
        },
      },
      {
        key: 'isKeyPressSimulated',
        value: function(s) {
          return this._isKeyEventSimulated(s, KeyEventType.keypress)
        },
      },
      {
        key: 'isKeyUpSimulated',
        value: function(s) {
          return this._isKeyEventSimulated(s, KeyEventType.keyup)
        },
      },
      {
        key: 'describe',
        value: function() {
          return this.getIds()[0]
        },
      },
      {
        key: 'toJSON',
        value: function() {
          return {
            keys: this._getKeyStates(),
            ids: this.getIds(),
            keyAliases: this.getKeyAliases(),
          }
        },
      },
      {
        key: '_getKeyStateType',
        value: function(s, $, j) {
          var _e = this._getKeyState(s)
          return _e && _e[$][j]
        },
      },
      {
        key: '_update',
        value: function() {
          ;(this._ids = KeyCombinationSerializer.serialize(this._keys)),
            (this._keyAliases = buildKeyAliases(this._keys))
        },
      },
      {
        key: '_isKeyEventSimulated',
        value: function(s, $) {
          return this.isEventTriggered(s, $) === KeyEventState.simulated
        },
      },
      {
        key: '_getKeyStates',
        value: function() {
          return this._keys
        },
      },
      {
        key: '_getKeyState',
        value: function(s) {
          var $ = this._keys[s]
          if ($) return $
          var j = this._keyAliases[s]
          if (j) return this._keys[j]
        },
      },
      {
        key: '_setKeyState',
        value: function(s, $) {
          var j = this.getNormalizedKeyName(s)
          ;(this._keys[j] = $), this._update()
        },
      },
    ]),
    o
  )
})()
function buildKeyAliases(o) {
  return Object.keys(o).reduce(function(a, s) {
    return (
      resolveKeyAlias(s).forEach(function($) {
        applicableAliasFunctions(o).forEach(function(j) {
          j($).forEach(function(_e) {
            ;(_e !== s || s !== $) && (a[_e] = s)
          })
        })
      }),
      a
    )
  }, {})
}
var KeyHistory = (function() {
    function o(a) {
      var s = a.maxLength,
        $ =
          1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : null
      _classCallCheck$2(this, o),
        (this._records = []),
        (this._maxLength = s),
        $ ? this._push($) : this._push(new KeyCombination())
    }
    return (
      _createClass$3(o, [
        {
          key: 'getMostRecentCombinations',
          value: function(s) {
            return this._records.slice(-s, -1)
          },
        },
        {
          key: 'any',
          value: function() {
            return this._records.some(function(s) {
              return s.any()
            })
          },
        },
        {
          key: 'getLength',
          value: function() {
            return this._records.length
          },
        },
        {
          key: 'getCurrentCombination',
          value: function() {
            return this._records[this.getLength() - 1]
          },
        },
        {
          key: 'addKeyToCurrentCombination',
          value: function(s, $, j) {
            this._ensureInitialKeyCombination(),
              this.getCurrentCombination().setKeyState(s, $, j)
          },
        },
        {
          key: 'setMaxLength',
          value: function(s) {
            ;(this._maxLength = s), this._trimHistory()
          },
        },
        {
          key: 'startNewKeyCombination',
          value: function(s, $) {
            this._ensureInitialKeyCombination()
            var j = new KeyCombination(
              this.getCurrentCombination().keysStillPressedDict()
            )
            j.addKey(s, $), this._push(j)
          },
        },
        {
          key: 'toJSON',
          value: function() {
            return this._records.map(function(s) {
              return s.toJSON()
            })
          },
        },
        {
          key: '_ensureInitialKeyCombination',
          value: function() {
            this.getLength() === 0 && this._push(new KeyCombination())
          },
        },
        {
          key: '_push',
          value: function(s) {
            this._trimHistory(), this._records.push(s)
          },
        },
        {
          key: '_trimHistory',
          value: function() {
            for (; this.getLength() > this._maxLength; ) this._shift()
          },
        },
        {
          key: '_shift',
          value: function() {
            this._records.shift()
          },
        },
      ]),
      o
    )
  })(),
  Registry = (function() {
    function o() {
      _classCallCheck$2(this, o), (this._registry = {})
    }
    return (
      _createClass$3(o, [
        {
          key: 'get',
          value: function(s) {
            return this._registry[s]
          },
        },
        {
          key: 'set',
          value: function(s, $) {
            this._registry[s] = $
          },
        },
        {
          key: 'remove',
          value: function(s) {
            delete this._registry[s]
          },
        },
        {
          key: 'toJSON',
          value: function() {
            return this._registry
          },
        },
      ]),
      o
    )
  })()
function arrayFrom(o) {
  return Array.isArray(o) ? o : o ? [o] : []
}
function without(o) {
  var a = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : [],
    s = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {},
    $ = dictionaryFrom(arrayFrom(a))
  return Array.isArray(o)
    ? o.reduce(function(j, _e) {
        return (
          ($[_e] && (s.stringifyFirst || $[_e].value === _e)) || j.push(_e), j
        )
      }, [])
    : isObject$3(o)
    ? Object.keys(o).reduce(function(j, _e) {
        return $[_e] || (j[_e] = o[_e]), j
      }, {})
    : o
}
var ComponentTree = (function(o) {
  function a() {
    return (
      _classCallCheck$2(this, a),
      _possibleConstructorReturn$1(
        this,
        _getPrototypeOf(a).apply(this, arguments)
      )
    )
  }
  return (
    _inherits$1(a, o),
    _createClass$3(a, [
      {
        key: 'add',
        value: function($, j) {
          _get(_getPrototypeOf(a.prototype), 'set', this).call(this, $, {
            childIds: [],
            parentId: null,
            keyMap: j,
          })
        },
      },
      {
        key: 'update',
        value: function($, j) {
          var _e = _get(_getPrototypeOf(a.prototype), 'get', this).call(this, $)
          _get(_getPrototypeOf(a.prototype), 'set', this).call(
            this,
            $,
            _objectSpread$1({}, _e, { keyMap: j })
          )
        },
      },
      {
        key: 'setParent',
        value: function($, j) {
          ;(this.get($).parentId = j), this._addChildId(j, $)
        },
      },
      {
        key: 'remove',
        value: function($) {
          var j = this._getParentId($)
          this._removeChildId(j, $),
            _get(_getPrototypeOf(a.prototype), 'remove', this).call(this, $)
        },
      },
      {
        key: '_getParentId',
        value: function($) {
          var j = this.get($)
          return j && j.parentId
        },
      },
      {
        key: '_addChildId',
        value: function($, j) {
          this.get($).childIds.push(j)
        },
      },
      {
        key: '_removeChildId',
        value: function($, j) {
          var _e = this.get($)
          _e && (_e.childIds = without(_e.childIds, j))
        },
      },
    ]),
    a
  )
})(Registry)
function removeAtIndex(o, a) {
  return [].concat(
    _toConsumableArray$2(o.slice(0, a)),
    _toConsumableArray$2(o.slice(a + 1))
  )
}
var ComponentOptionsListIterator = (function() {
    function o(a) {
      _classCallCheck$2(this, o), (this._list = a), (this._position = -1)
    }
    return (
      _createClass$3(o, [
        {
          key: 'getPosition',
          value: function() {
            return this._position
          },
        },
        {
          key: 'getComponent',
          value: function() {
            return this._list.getAtPosition(this.getPosition())
          },
        },
        {
          key: 'next',
          value: function() {
            return this.getPosition() + 1 < this._list.getLength()
              ? (this._position++, this.getComponent())
              : null
          },
        },
      ]),
      o
    )
  })(),
  ComponentOptionsList = (function() {
    function o() {
      _classCallCheck$2(this, o),
        (this._list = []),
        (this._idToIndex = {}),
        (this._longestSequence = 1),
        (this._longestSequenceComponentId = null),
        (this._keyMapEventRecord = KeyEventStateArrayManager.newRecord())
    }
    return (
      _createClass$3(o, [
        {
          key: 'getNewIterator',
          value: function() {
            return new ComponentOptionsListIterator(this)
          },
        },
        {
          key: 'add',
          value: function(s, $, j, _e) {
            if (this.containsId(s)) return this.update(s, $, j, _e)
            var et = this._build(s, $, j, _e)
            this._list.push(et)
            var tt = this._getLastIndex()
            return (this._idToIndex[s] = tt)
          },
        },
        {
          key: 'containsId',
          value: function(s) {
            return !!this.get(s)
          },
        },
        {
          key: 'get',
          value: function(s) {
            return this.getAtPosition(this.getIndexById(s))
          },
        },
        {
          key: 'getIndexById',
          value: function(s) {
            return this._idToIndex[s]
          },
        },
        {
          key: 'update',
          value: function(s, $, j, _e) {
            var et = this._isUpdatingComponentWithLongestSequence(s),
              tt = this.getLongestSequence(),
              rt = this._build(s, $, j, _e)
            et &&
              rt.sequenceLength !== tt &&
              (rt.sequenceLength > tt
                ? (this._longestSequence = rt.sequenceLength)
                : this._recalculateLongestSequence()),
              (this._list[this.getIndexById(s)] = rt)
          },
        },
        {
          key: 'remove',
          value: function(s) {
            var $ = this._isUpdatingComponentWithLongestSequence(s)
            this.removeAtPosition(this.getIndexById(s)),
              $ && this._recalculateLongestSequence()
          },
        },
        {
          key: 'any',
          value: function() {
            return this.getLength() !== 0
          },
        },
        {
          key: 'isRoot',
          value: function(s) {
            return this.getIndexById(s) >= this.getLength() - 1
          },
        },
        {
          key: 'getLongestSequence',
          value: function() {
            return this._longestSequence
          },
        },
        {
          key: 'anyActionsForEventType',
          value: function(s) {
            return !!this._keyMapEventRecord[s]
          },
        },
        {
          key: 'getLength',
          value: function() {
            return this._list.length
          },
        },
        {
          key: 'getAtPosition',
          value: function(s) {
            return this._list[s]
          },
        },
        {
          key: 'removeAtPosition',
          value: function(s) {
            this._list = removeAtIndex(this._list, s)
            for (var $ = s; $ < this.getLength(); )
              (this._idToIndex[this.getAtPosition($).componentId] = $), $++
          },
        },
        {
          key: 'toJSON',
          value: function() {
            return this._list
          },
        },
        {
          key: '_getLastIndex',
          value: function() {
            return this.getLength() - 1
          },
        },
        {
          key: '_build',
          value: function(s, $, j, _e) {
            var et = this._applyHardSequences($, j),
              tt = et.keyMap,
              rt = et.handlers,
              nt = this._buildActionDictionary(
                _objectSpread$1({}, $, tt),
                _e,
                s
              )
            return { actions: nt, handlers: rt, componentId: s, options: _e }
          },
        },
        {
          key: '_isUpdatingComponentWithLongestSequence',
          value: function(s) {
            return s === this._getLongestSequenceComponentId()
          },
        },
        {
          key: '_getLongestSequenceComponentId',
          value: function() {
            return this._longestSequenceComponentId
          },
        },
        {
          key: '_recalculateLongestSequence',
          value: function() {
            for (var s = this.getNewIterator(); s.next(); ) {
              var $ = s.getComponent(),
                j = $.longestSequence,
                _e = $.componentId
              j > this.getLongestSequence() &&
                ((this._longestSequenceComponentId = _e),
                (this._longestSequence = j))
            }
          },
        },
        {
          key: '_applyHardSequences',
          value: function(s, $) {
            return Configuration.option('enableHardSequences')
              ? Object.keys($).reduce(
                  function(j, _e) {
                    var et = !!s[_e]
                    return (
                      !et &&
                        KeyCombinationSerializer.isValidKeySerialization(_e) &&
                        (j.keyMap[_e] = _e),
                      (j.handlers[_e] = $[_e]),
                      j
                    )
                  },
                  { keyMap: {}, handlers: {} }
                )
              : { keyMap: s, handlers: $ }
          },
        },
        {
          key: '_buildActionDictionary',
          value: function(s, $, j) {
            var _e = this
            return Object.keys(s).reduce(function(et, tt) {
              var rt = s[tt],
                nt = (function() {
                  return isObject$3(rt) && hasKey(rt, 'sequences')
                    ? arrayFrom(rt.sequences)
                    : arrayFrom(rt)
                })()
              return (
                nt.forEach(function(it) {
                  var ot = normalizeActionOptions(it, $),
                    at = ot.keySequence,
                    st = ot.keyEventType
                  _e._addActionOptions(et, j, tt, at, st)
                }),
                et
              )
            }, {})
          },
        },
        {
          key: '_addActionOptions',
          value: function(s, $, j, _e, et) {
            var tt = KeySequenceParser.parse(_e, { keyEventType: et }),
              rt = tt.sequence,
              nt = tt.combination
            rt.size > this.getLongestSequence() &&
              ((this._longestSequence = rt.size),
              (this._longestSequenceComponentId = $)),
              (this._keyMapEventRecord[et] = KeyEventState.seen),
              s[j] || (s[j] = []),
              s[j].push(
                _objectSpread$1(
                  { prefix: rt.prefix, actionName: j, sequenceLength: rt.size },
                  nt
                )
              )
          },
        },
      ]),
      o
    )
  })()
function normalizeActionOptions(o, a) {
  if (isObject$3(o)) {
    var s = o.sequence,
      $ = o.action
    return {
      keySequence: s,
      keyEventType: isUndefined$2($)
        ? KeyEventType[a.defaultKeyEvent]
        : KeyEventType[$],
    }
  }
  return { keySequence: o, keyEventType: KeyEventType[a.defaultKeyEvent] }
}
function indexFromEnd(o, a) {
  return o[o.length - (a + 1)]
}
for (
  var KeysWithKeyUpHiddenByCmd = {
      Enter: !0,
      Backspace: !0,
      ArrowRight: !0,
      ArrowLeft: !0,
      ArrowUp: !0,
      ArrowDown: !0,
      CapsLock: !0,
    },
    i$2 = 1;
  13 > i$2;
  i$2++
)
  KeysWithKeyUpHiddenByCmd['F'.concat(i$2)] = !0
function keyupIsHiddenByCmd(o) {
  return o.length === 1 || hasKey(KeysWithKeyUpHiddenByCmd, o)
}
var KeyCombinationMatcher = (function() {
  function o() {
    _classCallCheck$2(this, o), (this._actionConfigs = {}), (this._order = null)
  }
  return (
    _createClass$3(o, [
      {
        key: 'addMatch',
        value: function(s, $) {
          if (this._includesMatcherForCombination(s.id)) {
            var j = s.keyEventType,
              _e = s.actionName,
              et = s.id
            this._addHandlerToActionConfig(et, {
              keyEventType: j,
              actionName: _e,
              handler: $,
            })
          } else this._addNewActionConfig(s, $)
        },
      },
      {
        key: 'findMatch',
        value: function(s, $, j) {
          this._order || this._setOrder()
          var _e = !0,
            et = !1,
            tt = void 0
          try {
            for (
              var rt, nt = this._order[Symbol.iterator]();
              !(_e = (rt = nt.next()).done);
              _e = !0
            ) {
              var it = rt.value,
                ot = this._actionConfigs[it]
              if (this._matchesActionConfig(s, $, j, ot)) return ot
            }
          } catch (at) {
            ;(et = !0), (tt = at)
          } finally {
            try {
              _e || nt.return == null || nt.return()
            } finally {
              if (et) throw tt
            }
          }
          return null
        },
      },
      {
        key: 'toJSON',
        value: function() {
          return { actionConfigs: this._actionConfigs, order: this._order }
        },
      },
      {
        key: '_matchesActionConfig',
        value: function(s, $, j, _e) {
          if (!canBeMatched(s, _e)) return !1
          var et = _e.events[j]
          if (!et) return !1
          var tt = !1,
            rt = Object.keys(_e.keyDictionary).every(function(nt) {
              return (
                !!s.isEventTriggered(nt, j) &&
                ($ &&
                  $ === s.getNormalizedKeyName(nt) &&
                  (tt = !s.wasEventPreviouslyTriggered(nt, j)),
                !0)
              )
            })
          return rt && tt
        },
      },
      {
        key: '_setOrder',
        value: function() {
          var s = Object.values(this._actionConfigs).reduce(function($, j) {
            var _e = j.id,
              et = j.size
            return $[et] || ($[et] = []), $[et].push(_e), $
          }, {})
          this._order = Object.keys(s)
            .sort(function($, j) {
              return j - $
            })
            .reduce(function($, j) {
              return $.concat(s[j])
            }, [])
        },
      },
      {
        key: '_addNewActionConfig',
        value: function(s, $) {
          var j = s.prefix,
            _e = s.sequenceLength,
            et = s.id,
            tt = s.keyDictionary,
            rt = s.size,
            nt = s.keyEventType,
            it = s.actionName
          this._setCombinationMatcher(et, {
            prefix: j,
            sequenceLength: _e,
            id: et,
            keyDictionary: tt,
            size: rt,
            events: {},
          }),
            this._addHandlerToActionConfig(et, {
              keyEventType: nt,
              actionName: it,
              handler: $,
            })
        },
      },
      {
        key: '_addHandlerToActionConfig',
        value: function(s, $) {
          var j = $.keyEventType,
            _e = $.actionName,
            et = $.handler,
            tt = this._getCombinationMatcher(s)
          this._setCombinationMatcher(
            s,
            _objectSpread$1({}, tt, {
              events: _objectSpread$1(
                {},
                tt.events,
                _defineProperty$4({}, j, { actionName: _e, handler: et })
              ),
            })
          )
        },
      },
      {
        key: '_setCombinationMatcher',
        value: function(s, $) {
          this._actionConfigs[s] = $
        },
      },
      {
        key: '_getCombinationMatcher',
        value: function(s) {
          return this._actionConfigs[s]
        },
      },
      {
        key: '_includesMatcherForCombination',
        value: function(s) {
          return !!this._getCombinationMatcher(s)
        },
      },
    ]),
    o
  )
})()
function canBeMatched(o, a) {
  var s = size(a.keyDictionary)
  return Configuration.option('allowCombinationSubmatches') ||
    keyUpIsBeingHidden(o)
    ? o.getNumberOfKeys() >= s
    : o.getNumberOfKeys() === s
}
function keyUpIsBeingHidden(o) {
  return (
    !!o.isKeyStillPressed('Meta') &&
    o.some(function(a) {
      return keyupIsHiddenByCmd(a)
    })
  )
}
var KeyHistoryMatcher = (function() {
    function o() {
      _classCallCheck$2(this, o),
        (this._combinationMatchers = {}),
        (this._eventRecord = KeyEventStateArrayManager.newRecord())
    }
    return (
      _createClass$3(o, [
        {
          key: 'addMatch',
          value: function(s, $) {
            var j = this._getOrCreateCombinationMatcher(s.prefix)
            j.addMatch(s, $),
              KeyEventStateArrayManager.setBit(
                this._eventRecord,
                s.keyEventType,
                KeyEventState.seen
              ),
              (!this._longestSequence ||
                this._longestSequence < s.sequenceLength) &&
                (this._longestSequence = s.sequenceLength)
          },
        },
        {
          key: 'findMatch',
          value: function(s, $, j) {
            var _e = this._findCombinationMatcher(s)
            return _e
              ? _e.findMatch(
                  s.getCurrentCombination(),
                  s.getCurrentCombination().getNormalizedKeyName($),
                  j
                )
              : null
          },
        },
        {
          key: 'hasMatchesForEventType',
          value: function(s) {
            return !!this._eventRecord[s]
          },
        },
        {
          key: 'getLongestSequence',
          value: function() {
            return this._longestSequence
          },
        },
        {
          key: 'toJSON',
          value: function() {
            var s = this
            return Object.keys(this._combinationMatchers).reduce(function(
              $,
              j
            ) {
              var _e = s._combinationMatchers[j]
              return ($[j] = _e.toJSON()), $
            },
            {})
          },
        },
        {
          key: '_getOrCreateCombinationMatcher',
          value: function(s) {
            return (
              this._combinationMatchers[s] ||
                (this._combinationMatchers[s] = new KeyCombinationMatcher()),
              this._combinationMatchers[s]
            )
          },
        },
        {
          key: '_findCombinationMatcher',
          value: function(s) {
            var $ = s.getMostRecentCombinations(this.getLongestSequence())
            if ($.length === 0) return this._combinationMatchers['']
            for (
              var j = $.map(function(ut) {
                  return ut.getIds()
                }),
                _e = j.map(function(ut) {
                  return ut.length
                }),
                et = Array(j.length).fill(0),
                tt = !1;
              !tt;

            ) {
              var rt = et.map(function(ut, ct) {
                  return j[ct][ut]
                }),
                nt = rt.join(' ')
              if (this._combinationMatchers[nt])
                return this._combinationMatchers[nt]
              for (var it = 0, ot = !0; ot && it < et.length; ) {
                var at = indexFromEnd(et, it),
                  st = (at + 1) % (indexFromEnd(_e, it) || 1)
                ;(et[et.length - (it + 1)] = st), (ot = st == 0), ot && it++
              }
              tt = it === et.length
            }
          },
        },
      ]),
      o
    )
  })(),
  ActionResolver = (function() {
    function o(a) {
      _classCallCheck$2(this, o),
        (this._keyMapMatchers = []),
        (this._unmatchedHandlerStatus = []),
        (this._handlersDictionary = {}),
        (this._keySequencesDictionary = {})
      for (var s = a.getNewIterator(); s.next(); ) {
        var $ = s.getComponent(),
          j = $.handlers
        this._unmatchedHandlerStatus.push([Object.keys(j).length, {}]),
          this._keyMapMatchers.push(new KeyHistoryMatcher())
      }
      ;(this._componentList = a),
        (this._componentListIterator = a.getNewIterator())
    }
    return (
      _createClass$3(o, [
        {
          key: 'getKeyHistoryMatcher',
          value: function(s) {
            if (this._componentHasUnmatchedHandlers(s))
              for (; this._componentListIterator.next(); )
                this._addHandlersFromComponent(),
                  this._addActionsFromComponent()
            return this._getKeyHistoryMatcher(s)
          },
        },
        {
          key: 'componentHasActionsBoundToEventType',
          value: function(s, $) {
            return this.getKeyHistoryMatcher(s).hasMatchesForEventType($)
          },
        },
        {
          key: 'findMatchingKeySequenceInComponent',
          value: function(s, $, j, _e) {
            return this.componentHasActionsBoundToEventType(s, _e)
              ? this.getKeyHistoryMatcher(s).findMatch($, j, _e)
              : null
          },
        },
        {
          key: '_getKeyHistoryMatcher',
          value: function(s) {
            return this._keyMapMatchers[s]
          },
        },
        {
          key: '_addActionsFromComponent',
          value: function() {
            var s = this,
              $ = this._componentListIterator.getComponent(),
              j = $.actions
            Object.keys(j).forEach(function(_e) {
              var et = s._getHandlers(_e)
              if (et) {
                var tt = et[0],
                  rt = s._componentList.getAtPosition(tt).handlers[_e],
                  nt = s._getKeyHistoryMatcher(tt),
                  it = j[_e]
                it.forEach(function(ot) {
                  var at = [ot.prefix, ot.id].join(' ')
                  s._isClosestHandlerFound(at, ot) ||
                    (nt.addMatch(ot, rt),
                    s._addKeySequence(at, [tt, ot.keyEventType]))
                }),
                  et.forEach(function(ot) {
                    var at = s._getUnmatchedHandlerStatus(ot)
                    at[1][_e] || ((at[1][_e] = !0), at[0]--)
                  })
              }
            })
          },
        },
        {
          key: '_getHandlers',
          value: function(s) {
            return this._handlersDictionary[s]
          },
        },
        {
          key: '_addHandlersFromComponent',
          value: function() {
            var s = this,
              $ = this._componentListIterator.getComponent(),
              j = $.handlers
            Object.keys(j).forEach(function(_e) {
              s._addHandler(_e)
            })
          },
        },
        {
          key: '_addHandler',
          value: function(s) {
            this._handlersDictionary[s] || (this._handlersDictionary[s] = []),
              this._handlersDictionary[s].push(
                this._componentListIterator.getPosition()
              )
          },
        },
        {
          key: '_addKeySequence',
          value: function(s, $) {
            this._keySequencesDictionary[s] ||
              (this._keySequencesDictionary[s] = []),
              this._keySequencesDictionary[s].push($)
          },
        },
        {
          key: '_componentHasUnmatchedHandlers',
          value: function(s) {
            return 0 < this._getUnmatchedHandlerStatus(s)[0]
          },
        },
        {
          key: '_getUnmatchedHandlerStatus',
          value: function(s) {
            return this._unmatchedHandlerStatus[s]
          },
        },
        {
          key: '_isClosestHandlerFound',
          value: function(s, $) {
            return (
              this._keySequencesDictionary[s] &&
              this._keySequencesDictionary[s].some(function(j) {
                return j[1] === $.keyEventType
              })
            )
          },
        },
      ]),
      o
    )
  })()
function copyAttributes(o, a, s) {
  return (
    s.forEach(function($) {
      hasKey(o, $) && (a[$] = o[$])
    }),
    a
  )
}
function describeKeyEventType(o) {
  switch (parseInt(o, 10)) {
    case 0:
      return 'keydown'
    case 1:
      return 'keypress'
    default:
      return 'keyup'
  }
}
function hasKeyPressEvent(o) {
  return !isNonPrintableKeyName(o)
}
function stateFromEvent(o) {
  return o.simulated ? KeyEventState.simulated : KeyEventState.seen
}
var SEQUENCE_ATTRIBUTES = ['sequence', 'action'],
  KEYMAP_ATTRIBUTES = ['name', 'description', 'group'],
  AbstractKeyEventStrategy = (function() {
    function o() {
      var a =
          0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {},
        s = 1 < arguments.length ? arguments[1] : void 0
      _classCallCheck$2(this, o),
        (this.logger = a.logger || new Logger('warn')),
        (this.componentId = -1),
        (this.keyEventManager = s),
        (this._componentTree = new ComponentTree()),
        (this.rootComponentId = null),
        this._reset(),
        this.resetKeyHistory()
    }
    return (
      _createClass$3(o, [
        {
          key: '_reset',
          value: function() {
            ;(this.componentList = new ComponentOptionsList()),
              this._initHandlerResolutionState()
          },
        },
        {
          key: '_newKeyHistory',
          value: function() {
            return new KeyHistory({
              maxLength: this.componentList.getLongestSequence(),
            })
          },
        },
        {
          key: 'getKeyHistory',
          value: function() {
            return this._keyHistory
              ? this._keyHistory
              : ((this._keyHistory = this._newKeyHistory()), this._keyHistory)
          },
        },
        {
          key: '_initHandlerResolutionState',
          value: function() {
            this._actionResolver = null
          },
        },
        {
          key: 'resetKeyHistory',
          value: function() {
            var s =
              0 < arguments.length && arguments[0] !== void 0
                ? arguments[0]
                : {}
            ;(this.keypressEventsToSimulate = []),
              (this.keyupEventsToSimulate = []),
              (this._keyHistory =
                this.getKeyHistory().any() && !s.force
                  ? new KeyHistory(
                      { maxLength: this.componentList.getLongestSequence() },
                      new KeyCombination(
                        this.getCurrentCombination().keysStillPressedDict()
                      )
                    )
                  : this._newKeyHistory())
          },
        },
        {
          key: 'getApplicationKeyMap',
          value: function() {
            return this.rootComponentId === null
              ? {}
              : this._buildApplicationKeyMap([this.rootComponentId], {})
          },
        },
        {
          key: '_buildApplicationKeyMap',
          value: function(s, $) {
            var j = this
            return (
              s.forEach(function(_e) {
                var et = j._componentTree.get(_e),
                  tt = et.childIds,
                  rt = et.keyMap
                rt &&
                  Object.keys(rt).forEach(function(nt) {
                    var it = rt[nt]
                    ;($[nt] = {}),
                      isObject$3(it)
                        ? hasKey(it, 'sequences')
                          ? (copyAttributes(it, $[nt], KEYMAP_ATTRIBUTES),
                            ($[nt].sequences = j._createSequenceFromConfig(
                              it.sequences
                            )))
                          : (copyAttributes(it, $[nt], KEYMAP_ATTRIBUTES),
                            ($[nt].sequences = [
                              copyAttributes(it, {}, SEQUENCE_ATTRIBUTES),
                            ]))
                        : ($[nt].sequences = j._createSequenceFromConfig(it))
                  }),
                  j._buildApplicationKeyMap(tt, $)
              }),
              $
            )
          },
        },
        {
          key: '_createSequenceFromConfig',
          value: function(s) {
            return arrayFrom(s).map(function($) {
              return isObject$3($)
                ? copyAttributes($, {}, SEQUENCE_ATTRIBUTES)
                : { sequence: $ }
            })
          },
        },
        {
          key: 'registerKeyMap',
          value: function(s) {
            return (
              (this.componentId += 1),
              this._componentTree.add(this.componentId, s),
              this.componentId
            )
          },
        },
        {
          key: 'reregisterKeyMap',
          value: function(s, $) {
            this._componentTree.update(s, $)
          },
        },
        {
          key: 'registerComponentMount',
          value: function(s, $) {
            isUndefined$2($)
              ? (this.rootComponentId = s)
              : this._componentTree.setParent(s, $)
          },
        },
        {
          key: 'deregisterKeyMap',
          value: function(s) {
            this._componentTree.remove(s),
              s === this.rootComponentId && (this.rootComponentId = null)
          },
        },
        {
          key: '_addComponent',
          value: function(s) {
            var $ =
                1 < arguments.length && arguments[1] !== void 0
                  ? arguments[1]
                  : {},
              j =
                2 < arguments.length && arguments[2] !== void 0
                  ? arguments[2]
                  : {},
              _e = 3 < arguments.length ? arguments[3] : void 0
            this.componentList.add(s, $, j, _e),
              this.getKeyHistory().setMaxLength(
                this.componentList.getLongestSequence()
              )
          },
        },
        {
          key: '_allKeysAreReleased',
          value: function() {
            return this.getCurrentCombination().hasEnded()
          },
        },
        {
          key: 'getCurrentCombination',
          value: function() {
            return this.getKeyHistory().getCurrentCombination()
          },
        },
        {
          key: '_shouldSimulate',
          value: function(s, $) {
            var j = hasKeyPressEvent($),
              _e = this.getCurrentCombination()
            return s === KeyEventType.keypress
              ? !j || (j && _e.isKeyStillPressed('Meta'))
              : s === KeyEventType.keyup &&
                  keyupIsHiddenByCmd($) &&
                  _e.isKeyReleased('Meta')
          },
        },
        {
          key: '_cloneAndMergeEvent',
          value: function(s, $) {
            var j = Object.keys(ModifierFlagsDictionary).reduce(function(
              _e,
              et
            ) {
              return (_e[et] = s[et]), _e
            },
            {})
            return _objectSpread$1({}, j, $)
          },
        },
        {
          key: '_callClosestMatchingHandler',
          value: function(s, $, j, _e, et) {
            for (
              this._actionResolver ||
              (this._actionResolver = new ActionResolver(this.componentList));
              et <= _e;

            ) {
              this._actionResolver.getKeyHistoryMatcher(et)
              var tt = this._actionResolver.findMatchingKeySequenceInComponent(
                et,
                this.getKeyHistory(),
                $,
                j
              )
              if ((this.getCurrentCombination(), tt)) {
                var rt = tt.events[j]
                return (
                  Configuration.option('allowCombinationSubmatches') &&
                    KeyCombinationSerializer.serialize(tt.keyDictionary),
                  rt.handler(s),
                  this._stopEventPropagationAfterHandlingIfEnabled(s, et),
                  !0
                )
              }
              this._actionResolver.componentHasActionsBoundToEventType(et, j),
                et++
            }
          },
        },
        {
          key: '_stopEventPropagationAfterHandlingIfEnabled',
          value: function(s, $) {
            return (
              !!Configuration.option('stopEventPropagationAfterHandling') &&
              (this._stopEventPropagation(s, $), !0)
            )
          },
        },
        {
          key: '_stopEventPropagation',
          value: function() {
            throw new Error(
              '_stopEventPropagation must be overridden by a subclass'
            )
          },
        },
        {
          key: '_checkForModifierFlagDiscrepancies',
          value: function(s, $, j) {
            var _e = this
            Object.keys(ModifierFlagsDictionary).forEach(function(et) {
              if ($ !== et || j !== KeyEventType.keyup) {
                var tt = _e.getCurrentCombination(),
                  rt = tt.isKeyStillPressed(et)
                ModifierFlagsDictionary[et].forEach(function(nt) {
                  s[nt] === !1 &&
                    rt &&
                    tt.setKeyState(et, KeyEventType.keyup, stateFromEvent(s))
                })
              }
            })
          },
        },
        { key: '_logPrefix', value: function() {} },
      ]),
      o
    )
  })(),
  KeyEventCounter = (function() {
    function o() {
      _classCallCheck$2(this, o)
    }
    return (
      _createClass$3(o, null, [
        {
          key: 'getId',
          value: function() {
            return isUndefined$2(this._id) && (this._id = 0), this._id
          },
        },
        {
          key: 'incrementId',
          value: function() {
            this._id = this.getId() + 1
          },
        },
      ]),
      o
    )
  })()
function getEventCharCode(o) {
  var a,
    s = o.keyCode
  return (
    'charCode' in o
      ? ((a = o.charCode), a === 0 && s === 13 && (a = 13))
      : (a = s),
    a === 10 && (a = 13),
    32 <= a || a === 13 ? a : 0
  )
}
var normalizeKey = {
  Esc: 'Escape',
  Spacebar: ' ',
  Left: 'ArrowLeft',
  Up: 'ArrowUp',
  Right: 'ArrowRight',
  Down: 'ArrowDown',
  Del: 'Delete',
  Win: 'OS',
  Menu: 'ContextMenu',
  Apps: 'ContextMenu',
  Scroll: 'ScrollLock',
  MozPrintableKey: 'Unidentified',
}
function reactsGetEventKey(o) {
  if (o.key) {
    var a = normalizeKey[o.key] || o.key
    if (a !== 'Unidentified') return a
  }
  if (o.type === 'keypress') {
    var s = getEventCharCode(o)
    return s === 13 ? 'Enter' : String.fromCharCode(s)
  }
  return o.type === 'keydown' || o.type === 'keyup'
    ? translateToKey[o.keyCode] || 'Unidentified'
    : ''
}
function getKeyName(o) {
  var a = (function() {
    var s = Configuration.option('customKeyCodes'),
      $ = o.keyCode || o.charCode
    return hasKey(s, $) ? s[$] : o.nativeEvent ? o.key : reactsGetEventKey(o)
  })()
  return a === '+' ? 'plus' : a
}
function isCmdKey(o) {
  return o === 'Meta'
}
var EventResponse = { unseen: 0, ignored: 1, seen: 2, recorded: 3, handled: 4 },
  EventPropagator = (function() {
    function o(a, s) {
      var $ = s.logger,
        j = s.logPrefix
      _classCallCheck$2(this, o),
        (this._componentList = a),
        (this._previousPropagation = null),
        (this.logger = $),
        (this._logPrefix = j),
        this._reset()
    }
    return (
      _createClass$3(o, [
        {
          key: '_reset',
          value: function() {
            ;(this._previousPosition = -1),
              (this._position = -1),
              (this._actionHandled = !1),
              (this._ignoreEvent = !1),
              (this._observeIgnoredEvents = !1),
              (this._stopping = !1),
              (this._componentId = null),
              (this._key = null),
              (this._type = null)
          },
        },
        {
          key: 'isFirstPropagationStep',
          value: function() {
            var s = this.getPreviousPosition()
            return s === -1 || s >= this._position
          },
        },
        {
          key: 'isForKey',
          value: function(s) {
            return this._key === s
          },
        },
        {
          key: 'isForEventType',
          value: function(s) {
            return this._type === s
          },
        },
        {
          key: 'startNewPropagationStep',
          value: function(s, $, j, _e) {
            return (
              (this._position = this._componentList.getIndexById(s)),
              (this._componentId = s),
              this.isFirstPropagationStep() &&
                (KeyEventCounter.incrementId(),
                (this._key = $.key),
                (this._type = _e)),
              !(
                $.repeat &&
                Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')
              ) || (this.ignoreEvent($), !1)
            )
          },
        },
        {
          key: 'finishPropagationStep',
          value: function() {
            this.isStopped() || this._componentList.isRoot(this._componentId)
              ? ((this._previousPropagation = this._clone()), this._reset())
              : (this._previousPosition = this._position)
          },
        },
        {
          key: 'getPreviousPropagation',
          value: function() {
            return (
              this._previousPropagation ||
                (this._previousPropagation = this._clone({ copyState: !1 })),
              this._previousPropagation
            )
          },
        },
        {
          key: 'getPreviousPosition',
          value: function() {
            return this._previousPosition
          },
        },
        {
          key: 'observeIgnoredEvents',
          value: function() {
            this._observeIgnoredEvents = !0
          },
        },
        {
          key: 'ignoreEvent',
          value: function(s) {
            return (
              this.setIgnoreEvent(!0),
              !!(
                this.isIgnoringEvent() &&
                Configuration.option('stopEventPropagationAfterIgnoring')
              ) && (this.stop(s), this.finishPropagationStep(), !0)
            )
          },
        },
        {
          key: 'setIgnoreEvent',
          value: function(s) {
            this._ignoreEvent = s
          },
        },
        {
          key: 'isIgnoringEvent',
          value: function() {
            return !this._observeIgnoredEvents && this._ignoreEvent
          },
        },
        {
          key: 'isStopped',
          value: function() {
            return this._stopping
          },
        },
        {
          key: 'stop',
          value: function(s) {
            return (
              !this.isStopped() &&
              ((this._stopping = !0), s.simulated || s.stopPropagation(), !0)
            )
          },
        },
        {
          key: 'isPendingPropagation',
          value: function() {
            var s = this.getPreviousPosition()
            return s !== -1 && s + 1 < this._position
          },
        },
        {
          key: 'isHandled',
          value: function() {
            return this._actionHandled
          },
        },
        {
          key: 'setHandled',
          value: function() {
            this._actionHandled = !0
          },
        },
        {
          key: '_clone',
          value: function() {
            var s =
                0 < arguments.length && arguments[0] !== void 0
                  ? arguments[0]
                  : {},
              $ = s.copyState,
              j = new o(this._componentList, {
                logger: this.logger,
                logPrefix: this._logPrefix,
              })
            return ($ === void 0 || $) && Object.assign(j, this), j
          },
        },
      ]),
      o
    )
  })(),
  FocusOnlyKeyEventStrategy = (function(o) {
    function a() {
      var s,
        $ = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {},
        j = 1 < arguments.length ? arguments[1] : void 0
      return (
        _classCallCheck$2(this, a),
        (s = _possibleConstructorReturn$1(
          this,
          _getPrototypeOf(a).call(this, $, j)
        )),
        (s.focusTreeId = 0),
        s
      )
    }
    return (
      _inherits$1(a, o),
      _createClass$3(a, [
        {
          key: '_reset',
          value: function() {
            _get(_getPrototypeOf(a.prototype), '_reset', this).call(this),
              (this.keypressEventsToSimulate = []),
              (this.focusTreeId += 1),
              (this.eventPropagator = new EventPropagator(this.componentList, {
                logger: this.logger,
                logPrefix: this._logPrefix.bind(this),
              }))
          },
        },
        {
          key: 'enableHotKeys',
          value: function($) {
            var j =
                1 < arguments.length && arguments[1] !== void 0
                  ? arguments[1]
                  : {},
              _e =
                2 < arguments.length && arguments[2] !== void 0
                  ? arguments[2]
                  : {},
              et = 3 < arguments.length ? arguments[3] : void 0
            if (
              (this.resetOnNextFocus &&
                (this._reset(), (this.resetOnNextFocus = !1)),
              !this.componentList.containsId($))
            )
              return this._addComponent($, j, _e, et), this.focusTreeId
          },
        },
        {
          key: 'updateEnabledHotKeys',
          value: function($, j) {
            var _e =
                2 < arguments.length && arguments[2] !== void 0
                  ? arguments[2]
                  : {},
              et =
                3 < arguments.length && arguments[3] !== void 0
                  ? arguments[3]
                  : {},
              tt = 4 < arguments.length ? arguments[4] : void 0
            $ === this.focusTreeId &&
              this.componentList.containsId(j) &&
              (this.componentList.update(j, _e, et, tt),
              this.getKeyHistory().setMaxLength(
                this.componentList.getLongestSequence()
              ),
              this._initHandlerResolutionState())
          },
        },
        {
          key: 'disableHotKeys',
          value: function($, j) {
            this.resetOnNextFocus || (this.resetOnNextFocus = !0)
            var _e = this.eventPropagator.isPendingPropagation()
            return _e
          },
        },
        {
          key: 'handleKeydown',
          value: function($, j, _e) {
            var et =
                3 < arguments.length && arguments[3] !== void 0
                  ? arguments[3]
                  : {},
              tt = getKeyName($)
            if (j !== this.focusTreeId)
              return this.eventPropagator.ignoreEvent($), !0
            var rt = this.eventPropagator.startNewPropagationStep(
              _e,
              $,
              tt,
              KeyEventType.keydown
            )
            if (rt) {
              var nt = this._howToHandleKeyEvent(
                $,
                j,
                _e,
                tt,
                et,
                KeyEventType.keydown
              )
              if (nt === EventResponse.handled) {
                var it = stateFromEvent($),
                  ot = this.getCurrentCombination()
                ot.isKeyIncluded(tt) || ot.isEnding()
                  ? this._startAndLogNewKeyCombination(tt, j, _e, it)
                  : this._addToAndLogCurrentKeyCombination(
                      tt,
                      KeyEventType.keydown,
                      j,
                      _e,
                      it
                    ),
                  this._callHandlerIfActionNotHandled(
                    $,
                    tt,
                    KeyEventType.keydown,
                    _e,
                    j
                  )
              }
              return (
                this._simulateKeyPressForNonPrintableKeys($, tt, j, _e, et),
                this.eventPropagator.finishPropagationStep(),
                !1
              )
            }
          },
        },
        {
          key: '_howToHandleKeyEvent',
          value: function($, j, _e, et, tt, rt) {
            if (this.eventPropagator.isFirstPropagationStep()) {
              if (
                tt.ignoreEventsCondition($) &&
                this.eventPropagator.ignoreEvent($)
              )
                return this._eventIsToBeIgnored($, _e, et, rt)
              this._checkForModifierFlagDiscrepancies($, et, rt)
            } else if (this.eventPropagator.isIgnoringEvent())
              return this._eventIsToBeIgnored($, _e, et, rt)
            return EventResponse.handled
          },
        },
        {
          key: '_eventIsToBeIgnored',
          value: function($, j, _e, et) {
            return EventResponse.ignored
          },
        },
        {
          key: 'handleKeyPress',
          value: function($, j, _e, et) {
            var tt = getKeyName($),
              rt = this.getCurrentCombination()
            if (rt.isKeyPressSimulated(tt))
              return this.eventPropagator.ignoreEvent($), !0
            var nt = this.eventPropagator.startNewPropagationStep(
              _e,
              $,
              tt,
              KeyEventType.keypress
            )
            if (nt) {
              var it = j !== this.focusTreeId,
                ot = this._howToHandleKeyEvent(
                  $,
                  j,
                  _e,
                  tt,
                  et,
                  KeyEventType.keypress
                )
              return (
                this.eventPropagator.isFirstPropagationStep(_e) &&
                  rt.isKeyIncluded(tt) &&
                  this._addToAndLogCurrentKeyCombination(
                    tt,
                    KeyEventType.keypress,
                    j,
                    _e,
                    stateFromEvent($)
                  ),
                ot === EventResponse.handled &&
                  this._callHandlerIfActionNotHandled(
                    $,
                    tt,
                    KeyEventType.keypress,
                    _e,
                    j
                  ),
                this.eventPropagator.finishPropagationStep(),
                it
              )
            }
          },
        },
        {
          key: 'handleKeyUp',
          value: function($, j, _e, et) {
            var tt = getKeyName($),
              rt = this.getCurrentCombination()
            if (rt.isKeyUpSimulated(tt))
              return this.eventPropagator.ignoreEvent($), !0
            var nt = this.eventPropagator.startNewPropagationStep(
              _e,
              $,
              tt,
              KeyEventType.keyup
            )
            if (nt) {
              var it = j !== this.focusTreeId,
                ot = this._howToHandleKeyEvent(
                  $,
                  j,
                  _e,
                  tt,
                  et,
                  KeyEventType.keyup
                )
              return (
                this.eventPropagator.isFirstPropagationStep(_e) &&
                  rt.isKeyIncluded(tt) &&
                  this._addToAndLogCurrentKeyCombination(
                    tt,
                    KeyEventType.keyup,
                    j,
                    _e,
                    stateFromEvent($)
                  ),
                ot === EventResponse.handled &&
                  this._callHandlerIfActionNotHandled(
                    $,
                    tt,
                    KeyEventType.keyup,
                    _e,
                    j
                  ),
                this._simulateKeyUpEventsHiddenByCmd($, tt, j, _e, et),
                this.eventPropagator.finishPropagationStep(),
                it
              )
            }
          },
        },
        {
          key: 'closeHangingKeyCombination',
          value: function($, j) {
            var _e = this.getCurrentCombination()
            _e.isKeyIncluded($) &&
              !_e.isEventTriggered($, j) &&
              _e.setKeyState($, j, KeyEventState.simulated)
          },
        },
        {
          key: '_simulateKeyPressForNonPrintableKeys',
          value: function($, j, _e, et, tt) {
            this._handleEventSimulation(
              'keypressEventsToSimulate',
              'simulatePendingKeyPressEvents',
              this._shouldSimulate(KeyEventType.keypress, j),
              {
                event: $,
                key: j,
                focusTreeId: _e,
                componentId: et,
                options: tt,
              }
            )
          },
        },
        {
          key: '_simulateKeyUpEventsHiddenByCmd',
          value: function($, j, _e, et, tt) {
            var rt = this
            isCmdKey(j) &&
              this.getCurrentCombination().forEachKey(function(nt) {
                isCmdKey(nt) ||
                  rt._handleEventSimulation(
                    'keyupEventsToSimulate',
                    'simulatePendingKeyUpEvents',
                    rt._shouldSimulate(KeyEventType.keyup, nt),
                    {
                      event: $,
                      key: nt,
                      focusTreeId: _e,
                      componentId: et,
                      options: tt,
                    }
                  )
              })
          },
        },
        {
          key: '_stopEventPropagation',
          value: function($, j) {
            this.eventPropagator.stop($)
          },
        },
        {
          key: 'getEventPropagator',
          value: function() {
            return this.eventPropagator
          },
        },
        {
          key: '_startAndLogNewKeyCombination',
          value: function($, j, _e, et) {
            this.getKeyHistory().startNewKeyCombination($, et)
          },
        },
        {
          key: '_addToAndLogCurrentKeyCombination',
          value: function($, j, _e, et, tt) {
            this.getKeyHistory().addKeyToCurrentCombination($, j, tt)
          },
        },
        {
          key: '_handleEventSimulation',
          value: function($, j, _e, et) {
            var tt = et.event,
              rt = et.key,
              nt = et.focusTreeId,
              it = et.componentId,
              ot = et.options
            if (_e && Configuration.option('simulateMissingKeyPressEvents')) {
              var at = this._cloneAndMergeEvent(tt, { key: rt, simulated: !0 })
              this[$].push({
                event: at,
                focusTreeId: nt,
                componentId: it,
                options: ot,
              })
            }
            ;(this.componentList.isRoot(it) ||
              this.eventPropagator.isStopped()) &&
              !this.keyEventManager.isGlobalListenersBound() &&
              this[j]()
          },
        },
        {
          key: 'simulatePendingKeyPressEvents',
          value: function() {
            this._simulatePendingKeyEvents(
              'keypressEventsToSimulate',
              'handleKeyPress'
            )
          },
        },
        {
          key: 'simulatePendingKeyUpEvents',
          value: function() {
            this._simulatePendingKeyEvents(
              'keyupEventsToSimulate',
              'handleKeyUp'
            )
          },
        },
        {
          key: '_simulatePendingKeyEvents',
          value: function($, j) {
            var _e = this
            0 < this[$].length && KeyEventCounter.incrementId(),
              this[$].forEach(function(et) {
                var tt = et.event,
                  rt = et.focusTreeId,
                  nt = et.componentId,
                  it = et.options
                _e[j](tt, rt, nt, it)
              }),
              (this[$] = [])
          },
        },
        {
          key: '_callHandlerIfActionNotHandled',
          value: function($, j, _e, et, tt) {
            if (
              (this.getCurrentCombination().describe(),
              !!this.componentList.anyActionsForEventType(_e) &&
                !this.eventPropagator.isHandled())
            ) {
              var rt = this.eventPropagator.getPreviousPosition(),
                nt = this.componentList.getIndexById(et),
                it = this._callClosestMatchingHandler(
                  $,
                  j,
                  _e,
                  nt,
                  rt === -1 ? 0 : rt
                )
              it && this.eventPropagator.setHandled()
            }
          },
        },
        {
          key: '_logPrefix',
          value: function($) {
            var j =
                1 < arguments.length && arguments[1] !== void 0
                  ? arguments[1]
                  : {},
              _e = Logger.logIcons,
              et = Logger.eventIcons,
              tt = Logger.componentIcons,
              rt = 'HotKeys ('
            if (j.focusTreeId !== !1) {
              var nt = isUndefined$2(j.focusTreeId)
                ? this.focusTreeId
                : j.focusTreeId
              rt += 'F'.concat(nt).concat(_e[nt % _e.length], '-')
            }
            if (j.eventId !== !1) {
              var it = isUndefined$2(j.eventId)
                ? KeyEventCounter.getId()
                : j.eventId
              rt += 'E'.concat(it).concat(et[it % et.length], '-')
            }
            rt += 'C'.concat($).concat(tt[$ % tt.length])
            var ot = this.componentList.getIndexById($)
            return (
              isUndefined$2(ot) ||
                (rt += '-P'.concat(ot).concat(tt[ot % tt.length], ':')),
              ''.concat(rt, ')')
            )
          },
        },
      ]),
      a
    )
  })(AbstractKeyEventStrategy)
function contains$1(o, a) {
  var s = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : {}
  return Array.isArray(o) || isString$2(o)
    ? s.stringifyFirst
      ? !isUndefined$2(
          o.find(function($) {
            return $.toString() === a.toString()
          })
        )
      : o.indexOf(a) !== -1
    : isObject$3(o)
    ? hasKey(o, a)
    : s.stringifyFirst
    ? o.toString() === a.toString()
    : o === a
}
function capitalize$3(o) {
  return o.replace(/\b\w/g, function(a) {
    return a.toUpperCase()
  })
}
function normalizeEventName(o) {
  return ''.concat(capitalize$3(o.slice(0, 3))).concat(capitalize$3(o.slice(3)))
}
var GlobalKeyEventStrategy = (function(o) {
  function a() {
    var s,
      $ = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {},
      j = 1 < arguments.length ? arguments[1] : void 0
    return (
      _classCallCheck$2(this, a),
      (s = _possibleConstructorReturn$1(
        this,
        _getPrototypeOf(a).call(this, $, j)
      )),
      (s.listenersBound = !1),
      (s.eventOptions = {
        ignoreEventsCondition: Configuration.option('ignoreEventsCondition'),
      }),
      (s.listeners = {}),
      s
    )
  }
  return (
    _inherits$1(a, o),
    _createClass$3(a, [
      {
        key: 'enableHotKeys',
        value: function($) {
          var j =
              1 < arguments.length && arguments[1] !== void 0
                ? arguments[1]
                : {},
            _e =
              2 < arguments.length && arguments[2] !== void 0
                ? arguments[2]
                : {},
            et = 3 < arguments.length ? arguments[3] : void 0,
            tt = 4 < arguments.length ? arguments[4] : void 0
          ;(this.eventOptions = tt),
            this._addComponent($, j, _e, et),
            this._updateDocumentHandlers(),
            this._initHandlerResolutionState()
        },
      },
      {
        key: 'updateEnabledHotKeys',
        value: function($) {
          var j =
              1 < arguments.length && arguments[1] !== void 0
                ? arguments[1]
                : {},
            _e =
              2 < arguments.length && arguments[2] !== void 0
                ? arguments[2]
                : {},
            et = 3 < arguments.length ? arguments[3] : void 0,
            tt = 4 < arguments.length ? arguments[4] : void 0
          ;(this.eventOptions = tt),
            this.componentList.update($, j, _e, et),
            this.getKeyHistory().setMaxLength(
              this.componentList.getLongestSequence()
            ),
            this._updateDocumentHandlers(),
            this._initHandlerResolutionState()
        },
      },
      {
        key: 'disableHotKeys',
        value: function($) {
          this.componentList.remove($),
            this.getKeyHistory().setMaxLength(
              this.componentList.getLongestSequence()
            ),
            this._updateDocumentHandlers(),
            this._initHandlerResolutionState()
        },
      },
      {
        key: '_updateDocumentHandlers',
        value: function() {
          var $ = this,
            j = this._listenersShouldBeBound()
          !this.listenersBound && j
            ? (Object.values(KeyEventType).forEach(function(_e) {
                var et = describeKeyEventType(_e)
                document['on'.concat(et)] = function(tt) {
                  $.keyEventManager[
                    'handleGlobal'.concat(normalizeEventName(et))
                  ](tt)
                }
              }),
              (this.listenersBound = !0))
            : this.listenersBound &&
              !j &&
              (Object.values(KeyEventType).forEach(function(_e) {
                var et = describeKeyEventType(_e)
                delete document['on'.concat(et)]
              }),
              (this.listenersBound = !1))
        },
      },
      {
        key: '_listenersShouldBeBound',
        value: function() {
          return this.componentList.any() || this.listeners.keyCombination
        },
      },
      {
        key: 'handleKeydown',
        value: function($) {
          var j = getKeyName($)
          if (
            $.repeat &&
            Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')
          )
            return !0
          this._checkForModifierFlagDiscrepancies($, j, KeyEventType.keydown)
          var _e = this._howReactAppRespondedTo($, j, KeyEventType.keydown)
          if (
            !(
              _e === EventResponse.unseen &&
              this.eventOptions.ignoreEventsCondition($)
            )
          ) {
            if (_e !== EventResponse.ignored) {
              var et = stateFromEvent($),
                tt = this.getCurrentCombination()
              tt.isKeyIncluded(j) || tt.isEnding()
                ? this._startAndLogNewKeyCombination(j, et)
                : this._addToAndLogCurrentKeyCombination(
                    j,
                    KeyEventType.keydown,
                    et
                  )
            }
            contains$1([EventResponse.ignored, EventResponse.handled], _e) ||
              this._callHandlerIfExists($, j, KeyEventType.keydown),
              this._simulateKeyPressForNonPrintableKeys($, j)
          }
        },
      },
      {
        key: '_howReactAppRespondedTo',
        value: function($, j, _e) {
          var et = this.keyEventManager.reactAppHistoryWithEvent(j, _e)
          return (
            et === EventResponse.handled ||
              et === EventResponse.ignored ||
              et === EventResponse.seen ||
              KeyEventCounter.incrementId(),
            et
          )
        },
      },
      {
        key: 'handleKeyPress',
        value: function($) {
          var j = getKeyName($)
          if (
            $.repeat &&
            Configuration.option('ignoreRepeatedEventsWhenKeyHeldDown')
          )
            return !0
          var _e = this.getCurrentCombination()
          if (_e.isKeyPressSimulated(j)) return !0
          var et = this._howReactAppRespondedTo($, j, KeyEventType.keypress)
          return (
            _e.isKeyIncluded(j) &&
              this._addToAndLogCurrentKeyCombination(
                j,
                KeyEventType.keypress,
                stateFromEvent($)
              ),
            et === EventResponse.unseen &&
            (this.keyEventManager.closeHangingKeyCombination(
              j,
              KeyEventType.keypress
            ),
            this.eventOptions.ignoreEventsCondition($))
              ? void 0
              : void (
                  !contains$1(
                    [EventResponse.ignored, EventResponse.handled],
                    et
                  ) && this._callHandlerIfExists($, j, KeyEventType.keypress)
                )
          )
        },
      },
      {
        key: 'handleKeyUp',
        value: function($) {
          var j = getKeyName($),
            _e = this.getCurrentCombination()
          if (_e.isKeyUpSimulated(j)) return !0
          var et = this._howReactAppRespondedTo($, j, KeyEventType.keyup)
          _e.isKeyIncluded(j) &&
            this._addToAndLogCurrentKeyCombination(
              j,
              KeyEventType.keyup,
              stateFromEvent($)
            ),
            et === EventResponse.unseen
              ? (this.keyEventManager.closeHangingKeyCombination(
                  j,
                  KeyEventType.keyup
                ),
                this.eventOptions.ignoreEventsCondition($) ||
                  (!contains$1(
                    [EventResponse.ignored, EventResponse.handled],
                    et
                  ) &&
                    this._callHandlerIfExists($, j, KeyEventType.keyup)))
              : !contains$1(
                  [EventResponse.ignored, EventResponse.handled],
                  et
                ) && this._callHandlerIfExists($, j, KeyEventType.keyup),
            this._simulateKeyUpEventsHiddenByCmd($, j),
            this.listeners.keyCombination &&
              this._allKeysAreReleased() &&
              this.listeners.keyCombination({
                keys: _e.getKeyDictionary(),
                id: _e.describe(),
              })
        },
      },
      {
        key: '_simulateKeyPressForNonPrintableKeys',
        value: function($, j) {
          this.keyEventManager.simulatePendingKeyPressEvents(),
            this._handleEventSimulation(
              'handleKeyPress',
              this._shouldSimulate(KeyEventType.keypress, j),
              { event: $, key: j }
            )
        },
      },
      {
        key: '_simulateKeyUpEventsHiddenByCmd',
        value: function($, j) {
          var _e = this
          isCmdKey(j) &&
            (this.keyEventManager.simulatePendingKeyUpEvents(),
            this.getCurrentCombination().forEachKey(function(et) {
              isCmdKey(et) ||
                _e._handleEventSimulation(
                  'handleKeyUp',
                  _e._shouldSimulate(KeyEventType.keyup, et),
                  { event: $, key: et }
                )
            }))
        },
      },
      {
        key: '_startAndLogNewKeyCombination',
        value: function($, j) {
          this.getKeyHistory().startNewKeyCombination($, j)
        },
      },
      {
        key: '_addToAndLogCurrentKeyCombination',
        value: function($, j, _e) {
          this.getKeyHistory().addKeyToCurrentCombination($, j, _e)
        },
      },
      {
        key: '_handleEventSimulation',
        value: function($, j, _e) {
          var et = _e.event,
            tt = _e.key
          if (j && Configuration.option('simulateMissingKeyPressEvents')) {
            var rt = this._cloneAndMergeEvent(et, { key: tt, simulated: !0 })
            this[$](rt)
          }
        },
      },
      {
        key: '_callHandlerIfExists',
        value: function($, j, _e) {
          return (
            this.getCurrentCombination().describe(),
            this.componentList.anyActionsForEventType(_e)
              ? void this._callClosestMatchingHandler($, j, _e)
              : void 0
          )
        },
      },
      {
        key: '_callClosestMatchingHandler',
        value: function($, j, _e) {
          for (var et, tt = this.componentList.getNewIterator(); tt.next(); )
            if (
              ((et = _get(
                _getPrototypeOf(a.prototype),
                '_callClosestMatchingHandler',
                this
              ).call(this, $, j, _e, tt.getPosition(), 0)),
              et)
            )
              return
        },
      },
      {
        key: '_stopEventPropagation',
        value: function($, j) {
          $.simulated || $.stopPropagation()
        },
      },
      {
        key: 'addKeyCombinationListener',
        value: function($) {
          var j = this,
            _e = function() {
              delete j.listeners.keyCombination
            }
          return (
            (this.listeners.keyCombination = function(et) {
              $(et), _e()
            }),
            this._updateDocumentHandlers(),
            _e
          )
        },
      },
      {
        key: '_logPrefix',
        value: function($) {
          var j =
              1 < arguments.length && arguments[1] !== void 0
                ? arguments[1]
                : {},
            _e = Logger.eventIcons,
            et = Logger.componentIcons,
            tt = 'HotKeys (GLOBAL'
          if (j.eventId !== !1) {
            var rt = isUndefined$2(j.eventId)
              ? KeyEventCounter.getId()
              : j.eventId
            tt = ''
              .concat(tt, '-E')
              .concat(rt)
              .concat(_e[rt % _e.length])
          }
          return isUndefined$2($)
            ? ''.concat(tt, '):')
            : ''
                .concat(tt, '-C')
                .concat($)
                .concat(et[$ % et.length], '):')
        },
      },
    ]),
    a
  )
})(AbstractKeyEventStrategy)
function isFromFocusOnlyComponent(o) {
  return !isUndefined$2(o)
}
var KeyEventManager = (function() {
  function o() {
    var a = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}
    _classCallCheck$2(this, o),
      (this.logger = a.logger || new Logger(Configuration.option('logLevel'))),
      (this._focusOnlyEventStrategy = new FocusOnlyKeyEventStrategy(
        { configuration: a, logger: this.logger },
        this
      )),
      (this._globalEventStrategy = new GlobalKeyEventStrategy(
        { configuration: a, logger: this.logger },
        this
      )),
      (this.mountedComponentsCount = 0)
  }
  return (
    _createClass$3(o, null, [
      {
        key: 'getInstance',
        value: function() {
          var s =
            0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}
          return this.instance || (this.instance = new o(s)), this.instance
        },
      },
      {
        key: 'clear',
        value: function() {
          delete this.instance
        },
      },
    ]),
    _createClass$3(o, [
      {
        key: 'getApplicationKeyMap',
        value: function() {
          return Object.assign(
            this._globalEventStrategy.getApplicationKeyMap(),
            this._focusOnlyEventStrategy.getApplicationKeyMap()
          )
        },
      },
      {
        key: 'registerKeyMap',
        value: function() {
          var s =
            0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}
          return this._focusOnlyEventStrategy.registerKeyMap(s)
        },
      },
      {
        key: 'reregisterKeyMap',
        value: function(s) {
          var $ =
            1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {}
          this._focusOnlyEventStrategy.reregisterKeyMap(s, $)
        },
      },
      {
        key: 'deregisterKeyMap',
        value: function(s) {
          this._focusOnlyEventStrategy.deregisterKeyMap(s)
        },
      },
      {
        key: 'registerComponentMount',
        value: function(s, $) {
          return (
            this._incrementComponentCount(),
            this._focusOnlyEventStrategy.registerComponentMount(s, $)
          )
        },
      },
      {
        key: 'registerComponentUnmount',
        value: function() {
          this._decrementComponentCount()
        },
      },
      {
        key: '_incrementComponentCount',
        value: function() {
          var s = this,
            $ = this.mountedComponentsCount
          ;(this.mountedComponentsCount += 1),
            $ === 0 &&
              this.mountedComponentsCount === 1 &&
              (window.onblur = function() {
                return s._clearKeyHistory()
              })
        },
      },
      {
        key: '_decrementComponentCount',
        value: function() {
          var s = this.mountedComponentsCount
          ;(this.mountedComponentsCount -= 1),
            s === 1 && this.mountedComponentsCount === 0 && delete window.onblur
        },
      },
      {
        key: '_clearKeyHistory',
        value: function() {
          this._focusOnlyEventStrategy.resetKeyHistory({ force: !0 }),
            this._globalEventStrategy.resetKeyHistory({ force: !0 })
        },
      },
      {
        key: 'registerGlobalKeyMap',
        value: function() {
          var s =
            0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}
          return this._globalEventStrategy.registerKeyMap(s)
        },
      },
      {
        key: 'registerGlobalComponentUnmount',
        value: function() {
          this._decrementComponentCount()
        },
      },
      {
        key: 'registerGlobalComponentMount',
        value: function(s, $) {
          return (
            this._incrementComponentCount(),
            this._globalEventStrategy.registerComponentMount(s, $)
          )
        },
      },
      {
        key: 'reregisterGlobalKeyMap',
        value: function(s, $) {
          this._globalEventStrategy.reregisterKeyMap(s, $)
        },
      },
      {
        key: 'deregisterGlobalKeyMap',
        value: function(s) {
          this._globalEventStrategy.deregisterKeyMap(s)
        },
      },
      {
        key: 'addKeyCombinationListener',
        value: function(s) {
          return this._globalEventStrategy.addKeyCombinationListener(s)
        },
      },
      {
        key: 'enableHotKeys',
        value: function(s) {
          var $ =
              1 < arguments.length && arguments[1] !== void 0
                ? arguments[1]
                : {},
            j =
              2 < arguments.length && arguments[2] !== void 0
                ? arguments[2]
                : {},
            _e = 3 < arguments.length ? arguments[3] : void 0
          return this._focusOnlyEventStrategy.enableHotKeys(s, $, j, _e)
        },
      },
      {
        key: 'updateEnabledHotKeys',
        value: function(s, $) {
          var j =
              2 < arguments.length && arguments[2] !== void 0
                ? arguments[2]
                : {},
            _e =
              3 < arguments.length && arguments[3] !== void 0
                ? arguments[3]
                : {},
            et = 4 < arguments.length ? arguments[4] : void 0
          return this._focusOnlyEventStrategy.updateEnabledHotKeys(
            s,
            $,
            j,
            _e,
            et
          )
        },
      },
      {
        key: 'disableHotKeys',
        value: function(s, $) {
          return this._focusOnlyEventStrategy.disableHotKeys(s, $)
        },
      },
      {
        key: 'handleKeydown',
        value: function(s, $, j, _e) {
          if (isFromFocusOnlyComponent($))
            return this._focusOnlyEventStrategy.handleKeydown(s, $, j, _e)
        },
      },
      {
        key: 'handleKeyPress',
        value: function(s, $, j, _e) {
          if (isFromFocusOnlyComponent($))
            return this._focusOnlyEventStrategy.handleKeyPress(s, $, j, _e)
        },
      },
      {
        key: 'handleKeyUp',
        value: function(s, $, j, _e) {
          if (isFromFocusOnlyComponent($))
            return this._focusOnlyEventStrategy.handleKeyUp(s, $, j, _e)
        },
      },
      {
        key: 'enableGlobalHotKeys',
        value: function(s) {
          var $ =
              1 < arguments.length && arguments[1] !== void 0
                ? arguments[1]
                : {},
            j =
              2 < arguments.length && arguments[2] !== void 0
                ? arguments[2]
                : {},
            _e = 3 < arguments.length ? arguments[3] : void 0,
            et = 4 < arguments.length ? arguments[4] : void 0
          return this._globalEventStrategy.enableHotKeys(s, $, j, _e, et)
        },
      },
      {
        key: 'updateEnabledGlobalHotKeys',
        value: function(s) {
          var $ =
              1 < arguments.length && arguments[1] !== void 0
                ? arguments[1]
                : {},
            j =
              2 < arguments.length && arguments[2] !== void 0
                ? arguments[2]
                : {},
            _e = 3 < arguments.length ? arguments[3] : void 0,
            et = 4 < arguments.length ? arguments[4] : void 0
          return this._globalEventStrategy.updateEnabledHotKeys(s, $, j, _e, et)
        },
      },
      {
        key: 'disableGlobalHotKeys',
        value: function(s) {
          return this._globalEventStrategy.disableHotKeys(s)
        },
      },
      {
        key: 'handleGlobalKeyDown',
        value: function(s) {
          return this._globalEventStrategy.handleKeydown(s)
        },
      },
      {
        key: 'handleGlobalKeyPress',
        value: function(s) {
          return this._globalEventStrategy.handleKeyPress(s)
        },
      },
      {
        key: 'handleGlobalKeyUp',
        value: function(s) {
          return this._globalEventStrategy.handleKeyUp(s)
        },
      },
      {
        key: 'ignoreEvent',
        value: function(s) {
          this._focusOnlyEventStrategy.getEventPropagator().ignoreEvent(s)
        },
      },
      {
        key: 'observeIgnoredEvents',
        value: function(s) {
          this._focusOnlyEventStrategy
            .getEventPropagator()
            .observeIgnoredEvents(s)
        },
      },
      {
        key: 'closeHangingKeyCombination',
        value: function(s, $) {
          this._focusOnlyEventStrategy.closeHangingKeyCombination(s, $)
        },
      },
      {
        key: 'reactAppHistoryWithEvent',
        value: function(s, $) {
          var j = this._focusOnlyEventStrategy.eventPropagator.getPreviousPropagation()
          return j.isForKey(s) && j.isForEventType($)
            ? j.isHandled()
              ? EventResponse.handled
              : j.isIgnoringEvent()
              ? EventResponse.ignored
              : EventResponse.seen
            : EventResponse.unseen
        },
      },
      {
        key: 'simulatePendingKeyPressEvents',
        value: function() {
          this._focusOnlyEventStrategy.simulatePendingKeyPressEvents()
        },
      },
      {
        key: 'simulatePendingKeyUpEvents',
        value: function() {
          this._focusOnlyEventStrategy.simulatePendingKeyUpEvents()
        },
      },
      {
        key: 'isGlobalListenersBound',
        value: function() {
          return this._globalEventStrategy.listenersBound
        },
      },
    ]),
    o
  )
})()
function backwardsCompatibleContext(o, a) {
  var s = a.deprecatedAPI,
    $ = s.contextTypes,
    j = s.childContextTypes,
    _e = a.newAPI.contextType
  if (typeof React$5.createContext > 'u')
    (o.contextTypes = $),
      (o.childContextTypes = j),
      (o.prototype.getChildContext = function() {
        return this._childContext
      })
  else {
    var et = React$5.createContext(_e)
    ;(o.contextType = et),
      (o.prototype._originalRender = o.prototype.render),
      (o.prototype.render = function() {
        var tt = this._originalRender()
        return tt
          ? React$5.createElement(
              et.Provider,
              { value: this._childContext },
              tt
            )
          : null
      })
  }
  return o
}
function withHotKeys(o) {
  function a(et, tt) {
    return _objectSpread$1({}, j[et] || {}, tt[et] || {})
  }
  function s(et) {
    return a('handlers', et)
  }
  function $(et) {
    return a('keyMap', et)
  }
  var j = 1 < arguments.length && arguments[1] !== void 0 ? arguments[1] : {},
    _e = (function(et) {
      function tt(rt) {
        var nt
        return (
          _classCallCheck$2(this, tt),
          (nt = _possibleConstructorReturn$1(
            this,
            _getPrototypeOf(tt).call(this, rt)
          )),
          (nt._handleFocus = nt._handleFocus.bind(
            _assertThisInitialized$2(_assertThisInitialized$2(nt))
          )),
          (nt._handleBlur = nt._handleBlur.bind(
            _assertThisInitialized$2(_assertThisInitialized$2(nt))
          )),
          (nt._handleKeyDown = nt._handleKeyDown.bind(
            _assertThisInitialized$2(_assertThisInitialized$2(nt))
          )),
          (nt._handleKeyPress = nt._handleKeyPress.bind(
            _assertThisInitialized$2(_assertThisInitialized$2(nt))
          )),
          (nt._handleKeyUp = nt._handleKeyUp.bind(
            _assertThisInitialized$2(_assertThisInitialized$2(nt))
          )),
          (nt._componentIsFocused = nt._componentIsFocused.bind(
            _assertThisInitialized$2(_assertThisInitialized$2(nt))
          )),
          (nt._id = KeyEventManager.getInstance().registerKeyMap(rt.keyMap)),
          (nt._childContext = { hotKeysParentId: nt._id }),
          nt
        )
      }
      return (
        _inherits$1(tt, et),
        _createClass$3(tt, [
          {
            key: 'render',
            value: function() {
              var nt = this.props
              nt.keyMap, nt.handlers, nt.allowChanges, nt.root
              var it = _objectWithoutProperties$2(nt, [
                  'keyMap',
                  'handlers',
                  'allowChanges',
                  'root',
                ]),
                ot = {
                  onFocus: this._wrapFunction('onFocus', this._handleFocus),
                  onBlur: this._wrapFunction('onBlur', this._handleBlur),
                  tabIndex: Configuration.option('defaultTabIndex'),
                }
              return (
                this._shouldBindKeyListeners() &&
                  ((ot.onKeyDown = this._handleKeyDown),
                  (ot.onKeyPress = this._handleKeyPress),
                  (ot.onKeyUp = this._handleKeyUp)),
                React$5.createElement(o, _extends$4({ hotKeys: ot }, it))
              )
            },
          },
          {
            key: '_shouldBindKeyListeners',
            value: function() {
              var nt = $(this.props)
              return (
                !isEmpty$5(nt) ||
                this.props.root ||
                (Configuration.option('enableHardSequences') &&
                  this._handlersIncludeHardSequences(nt, s(this.props)))
              )
            },
          },
          {
            key: '_handlersIncludeHardSequences',
            value: function(nt, it) {
              return Object.keys(it).some(function(ot) {
                return (
                  !nt[ot] &&
                  KeyCombinationSerializer.isValidKeySerialization(ot)
                )
              })
            },
          },
          {
            key: '_wrapFunction',
            value: function(nt, it) {
              var ot = this
              return typeof this.props[nt] == 'function'
                ? function(at) {
                    ot.props[nt](at), it(at)
                  }
                : it
            },
          },
          {
            key: '_focusTreeIdsPush',
            value: function(nt) {
              this._focusTreeIds || (this._focusTreeIds = []),
                this._focusTreeIds.push(nt)
            },
          },
          {
            key: '_focusTreeIdsShift',
            value: function() {
              this._focusTreeIds && this._focusTreeIds.shift()
            },
          },
          {
            key: '_getFocusTreeId',
            value: function() {
              if (this._focusTreeIds) return this._focusTreeIds[0]
            },
          },
          {
            key: 'componentDidUpdate',
            value: function() {
              var nt = KeyEventManager.getInstance()
              if (
                (nt.reregisterKeyMap(this._id, this.props.keyMap),
                this._componentIsFocused() &&
                  (this.props.allowChanges ||
                    !Configuration.option(
                      'ignoreKeymapAndHandlerChangesByDefault'
                    )))
              ) {
                var it = this.props,
                  ot = it.keyMap,
                  at = it.handlers
                nt.updateEnabledHotKeys(
                  this._getFocusTreeId(),
                  this._id,
                  ot,
                  at,
                  this._getComponentOptions()
                )
              }
            },
          },
          {
            key: '_componentIsFocused',
            value: function() {
              return this._focused === !0
            },
          },
          {
            key: 'componentDidMount',
            value: function() {
              var nt = KeyEventManager.getInstance(),
                it = this.context.hotKeysParentId
              nt.registerComponentMount(this._id, it)
            },
          },
          {
            key: '_handleFocus',
            value: function() {
              if (this.props.onFocus) {
                var nt
                ;(nt = this.props).onFocus.apply(nt, arguments)
              }
              var it = KeyEventManager.getInstance().enableHotKeys(
                this._id,
                $(this.props),
                s(this.props),
                this._getComponentOptions()
              )
              isUndefined$2(it) || this._focusTreeIdsPush(it),
                (this._focused = !0)
            },
          },
          {
            key: 'componentWillUnmount',
            value: function() {
              var nt = KeyEventManager.getInstance()
              nt.deregisterKeyMap(this._id),
                nt.registerComponentUnmount(),
                this._handleBlur()
            },
          },
          {
            key: '_handleBlur',
            value: function() {
              if (this.props.onBlur) {
                var nt
                ;(nt = this.props).onBlur.apply(nt, arguments)
              }
              var it = KeyEventManager.getInstance().disableHotKeys(
                this._getFocusTreeId(),
                this._id
              )
              it || this._focusTreeIdsShift(), (this._focused = !1)
            },
          },
          {
            key: '_handleKeyDown',
            value: function(nt) {
              var it = KeyEventManager.getInstance().handleKeydown(
                nt,
                this._getFocusTreeId(),
                this._id,
                this._getEventOptions()
              )
              it && this._focusTreeIdsShift()
            },
          },
          {
            key: '_handleKeyPress',
            value: function(nt) {
              var it = KeyEventManager.getInstance().handleKeyPress(
                nt,
                this._getFocusTreeId(),
                this._id,
                this._getEventOptions()
              )
              it && this._focusTreeIdsShift()
            },
          },
          {
            key: '_handleKeyUp',
            value: function(nt) {
              var it = KeyEventManager.getInstance().handleKeyUp(
                nt,
                this._getFocusTreeId(),
                this._id,
                this._getEventOptions()
              )
              it && this._focusTreeIdsShift()
            },
          },
          {
            key: '_getComponentOptions',
            value: function() {
              return {
                defaultKeyEvent: Configuration.option('defaultKeyEvent'),
              }
            },
          },
          {
            key: '_getEventOptions',
            value: function() {
              return {
                ignoreEventsCondition: Configuration.option(
                  'ignoreEventsCondition'
                ),
              }
            },
          },
        ]),
        tt
      )
    })(reactExports.PureComponent)
  return (
    _defineProperty$4(_e, 'propTypes', {
      keyMap: PropTypes$1.object,
      handlers: PropTypes$1.object,
      onFocus: PropTypes$1.func,
      onBlur: PropTypes$1.func,
      allowChanges: PropTypes$1.bool,
      root: PropTypes$1.bool,
    }),
    backwardsCompatibleContext(_e, {
      deprecatedAPI: {
        contextTypes: { hotKeysParentId: PropTypes$1.number },
        childContextTypes: { hotKeysParentId: PropTypes$1.number },
      },
      newAPI: { contextType: { hotKeysParentId: void 0 } },
    })
  )
}
var HotKeysWrapper = (function(o) {
    function a() {
      return (
        _classCallCheck$2(this, a),
        _possibleConstructorReturn$1(
          this,
          _getPrototypeOf(a).apply(this, arguments)
        )
      )
    }
    return (
      _inherits$1(a, o),
      _createClass$3(a, [
        {
          key: 'render',
          value: function() {
            var $ = this.props,
              j = $.hotKeys,
              _e = $.innerRef,
              et = $.component,
              tt = _objectWithoutProperties$2($, [
                'hotKeys',
                'innerRef',
                'component',
              ]),
              rt = et || Configuration.option('defaultComponent')
            return React$5.createElement(
              rt,
              _objectSpread$1({}, j, { ref: _e }, tt)
            )
          },
        },
      ]),
      a
    )
  })(reactExports.Component),
  HotKeys = withHotKeys(HotKeysWrapper)
HotKeys.propTypes = {
  innerRef: PropTypes$1.oneOfType([PropTypes$1.object, PropTypes$1.func]),
}
var GlobalHotKeys = (function(o) {
  function a(s) {
    var $
    return (
      _classCallCheck$2(this, a),
      ($ = _possibleConstructorReturn$1(
        this,
        _getPrototypeOf(a).call(this, s)
      )),
      ($._id = KeyEventManager.getInstance().registerGlobalKeyMap(s.keyMap)),
      ($._childContext = { globalHotKeysParentId: $._id }),
      $
    )
  }
  return (
    _inherits$1(a, o),
    _createClass$3(a, [
      {
        key: 'render',
        value: function() {
          return this.props.children || null
        },
      },
      {
        key: 'componentDidUpdate',
        value: function() {
          var $ = KeyEventManager.getInstance()
          if (
            ($.reregisterGlobalKeyMap(this._id, this.props.keyMap),
            this.props.allowChanges ||
              !Configuration.option('ignoreKeymapAndHandlerChangesByDefault'))
          ) {
            var j = this.props,
              _e = j.keyMap,
              et = j.handlers
            $.updateEnabledGlobalHotKeys(
              this._id,
              _e,
              et,
              this._getComponentOptions(),
              this._getEventOptions()
            )
          }
        },
      },
      {
        key: 'componentDidMount',
        value: function() {
          var $ = this.props,
            j = $.keyMap,
            _e = $.handlers,
            et = this.context.globalHotKeysParentId,
            tt = KeyEventManager.getInstance()
          tt.registerGlobalComponentMount(this._id, et),
            tt.enableGlobalHotKeys(
              this._id,
              j,
              _e,
              this._getComponentOptions(),
              this._getEventOptions()
            )
        },
      },
      {
        key: 'componentWillUnmount',
        value: function() {
          var $ = KeyEventManager.getInstance()
          $.deregisterGlobalKeyMap(this._id),
            $.disableGlobalHotKeys(this._id),
            $.registerGlobalComponentUnmount()
        },
      },
      {
        key: '_getComponentOptions',
        value: function() {
          return { defaultKeyEvent: Configuration.option('defaultKeyEvent') }
        },
      },
      {
        key: '_getEventOptions',
        value: function() {
          return {
            ignoreEventsCondition: Configuration.option(
              'ignoreEventsCondition'
            ),
          }
        },
      },
    ]),
    a
  )
})(reactExports.Component)
_defineProperty$4(GlobalHotKeys, 'propTypes', {
  keyMap: PropTypes$1.object,
  handlers: PropTypes$1.object,
  allowChanges: PropTypes$1.bool,
})
var GlobalHotKeys$1 = backwardsCompatibleContext(GlobalHotKeys, {
  deprecatedAPI: {
    contextTypes: { globalHotKeysParentId: PropTypes$1.number },
    childContextTypes: { globalHotKeysParentId: PropTypes$1.number },
  },
  newAPI: { contextType: { globalHotKeysParentId: void 0 } },
})
function withHotKeysIgnoreOverride(o) {
  var a,
    s,
    $ =
      1 < arguments.length && arguments[1] !== void 0
        ? arguments[1]
        : { only: [], except: [] },
    j = 2 < arguments.length ? arguments[2] : void 0
  return (
    (s = a = (function(_e) {
      function et(tt) {
        var rt
        return (
          _classCallCheck$2(this, et),
          (rt = _possibleConstructorReturn$1(
            this,
            _getPrototypeOf(et).call(this, tt)
          )),
          (rt._handleKeyEvent = rt._handleKeyEvent.bind(
            _assertThisInitialized$2(_assertThisInitialized$2(rt))
          )),
          (rt._reloadDictionaries = rt._reloadDictionaries.bind(
            _assertThisInitialized$2(_assertThisInitialized$2(rt))
          )),
          rt
        )
      }
      return (
        _inherits$1(et, _e),
        _createClass$3(et, [
          {
            key: 'render',
            value: function() {
              var rt = this.props
              rt.only, rt.except
              var nt = _objectWithoutProperties$2(rt, ['only', 'except']),
                it = {
                  onKeyDown: this._handleKeyEvent,
                  onKeyPress: this._handleKeyEvent,
                  onKeyUp: this._handleKeyEvent,
                  onFocus: this._reloadDictionaries,
                }
              return React$5.createElement(o, _extends$4({ hotKeys: it }, nt))
            },
          },
          {
            key: '_reloadDictionaries',
            value: function() {
              var rt = this.props,
                nt = rt.only,
                it = rt.except
              ;(this._onlyDict = keyDictionary(nt)),
                (this._exceptDict = keyDictionary(it))
            },
          },
          {
            key: '_shouldIgnoreEvent',
            value: function(rt) {
              var nt = rt.key
              return isEmpty$5(this._onlyDict)
                ? !!isEmpty$5(this._exceptDict) || !hasKey(this._exceptDict, nt)
                : isEmpty$5(this._exceptDict)
                ? hasKey(this._onlyDict, nt)
                : hasKey(this._onlyDict, nt) && !hasKey(this._exceptDict, nt)
            },
          },
          {
            key: '_handleKeyEvent',
            value: function(rt) {
              this._shouldIgnoreEvent(rt) &&
                KeyEventManager.getInstance()[j](rt)
            },
          },
        ]),
        et
      )
    })(reactExports.PureComponent)),
    _defineProperty$4(a, 'propTypes', {
      only: PropTypes$1.oneOfType([
        PropTypes$1.string,
        PropTypes$1.arrayOf(PropTypes$1.string),
      ]),
      except: PropTypes$1.oneOfType([
        PropTypes$1.string,
        PropTypes$1.arrayOf(PropTypes$1.string),
      ]),
    }),
    _defineProperty$4(a, 'defaultProps', $),
    s
  )
}
function keyDictionary(o) {
  return arrayFrom(o).reduce(function(a, s) {
    var $ = standardizeKeyName(s)
    if (!isValidKey($)) throw new InvalidKeyNameError(s)
    return (
      [
        resolveAltShiftedAlias,
        resolveUnaltShiftedAlias,
        resolveShiftedAlias,
        resolveUnshiftedAlias,
        resolveAltedAlias,
        resolveUnaltedAlias,
      ].forEach(function(j) {
        a[j($)] = !0
      }),
      a
    )
  }, {})
}
var IgnoreKeys = (function(o) {
    function a() {
      return (
        _classCallCheck$2(this, a),
        _possibleConstructorReturn$1(
          this,
          _getPrototypeOf(a).apply(this, arguments)
        )
      )
    }
    return (
      _inherits$1(a, o),
      _createClass$3(a, [
        {
          key: 'render',
          value: function() {
            var $ = this.props,
              j = $.hotKeys,
              _e = _objectWithoutProperties$2($, ['hotKeys']),
              et = _e.component || Configuration.option('defaultComponent')
            return React$5.createElement(et, _objectSpread$1({}, j, _e))
          },
        },
      ]),
      a
    )
  })(reactExports.Component),
  IgnoreKeys$1 = withHotKeysIgnoreOverride(IgnoreKeys, {}, 'ignoreEvent'),
  ObserveKeys = (function(o) {
    function a() {
      return (
        _classCallCheck$2(this, a),
        _possibleConstructorReturn$1(
          this,
          _getPrototypeOf(a).apply(this, arguments)
        )
      )
    }
    return (
      _inherits$1(a, o),
      _createClass$3(a, [
        {
          key: 'render',
          value: function() {
            var $ = this.props,
              j = $.hotKeys,
              _e = _objectWithoutProperties$2($, ['hotKeys']),
              et = _e.component || Configuration.option('defaultComponent')
            return React$5.createElement(et, _objectSpread$1({}, j, _e))
          },
        },
      ]),
      a
    )
  })(reactExports.Component),
  ObserveKeys$1 = withHotKeysIgnoreOverride(
    ObserveKeys,
    {},
    'observeIgnoredEvents'
  )
function withIgnoreKeys(o) {
  var a =
    1 < arguments.length && arguments[1] !== void 0
      ? arguments[1]
      : { only: [], except: [] }
  return withHotKeysIgnoreOverride(o, a, 'ignoreEvent')
}
function withObserveKeys(o) {
  var a =
    1 < arguments.length && arguments[1] !== void 0
      ? arguments[1]
      : { only: [], except: [] }
  return withHotKeysIgnoreOverride(o, a, 'observeIgnoredEvents')
}
function configure$1() {
  var o = 0 < arguments.length && arguments[0] !== void 0 ? arguments[0] : {}
  Configuration.init(o)
}
function getApplicationKeyMap() {
  return KeyEventManager.getInstance().getApplicationKeyMap()
}
function recordKeyCombination(o) {
  var a = KeyEventManager.getInstance()
  return a.addKeyCombinationListener(o)
}
const reactHotkeys_production_min = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        GlobalHotKeys: GlobalHotKeys$1,
        HotKeys,
        IgnoreKeys: IgnoreKeys$1,
        ObserveKeys: ObserveKeys$1,
        configure: configure$1,
        getApplicationKeyMap,
        recordKeyCombination,
        withHotKeys,
        withIgnoreKeys,
        withObserveKeys,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  require$$0$5 = getAugmentedNamespace(reactHotkeys_production_min)
index_es.exports = require$$0$5
var index_esExports = index_es.exports
function commonjsRequire(o) {
  throw new Error(
    'Could not dynamically require "' +
      o +
      '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.'
  )
}
var localforage$1 = { exports: {} }
;(function(o, a) {
  var s = {}
  /*!
    localForage -- Offline Storage, Improved
    Version 1.10.0
    https://localforage.github.io/localForage
    (c) 2013-2017 Mozilla, Apache License 2.0
*/ ;(function(
    $
  ) {
    o.exports = $()
  })(function() {
    return (function $(j, _e, et) {
      function tt(it, ot) {
        if (!_e[it]) {
          if (!j[it]) {
            var at = typeof commonjsRequire == 'function' && commonjsRequire
            if (!ot && at) return at(it, !0)
            if (rt) return rt(it, !0)
            var st = new Error("Cannot find module '" + it + "'")
            throw ((st.code = 'MODULE_NOT_FOUND'), st)
          }
          var ut = (_e[it] = { exports: {} })
          j[it][0].call(
            ut.exports,
            function(ct) {
              var dt = j[it][1][ct]
              return tt(dt || ct)
            },
            ut,
            ut.exports,
            $,
            j,
            _e,
            et
          )
        }
        return _e[it].exports
      }
      for (
        var rt = typeof commonjsRequire == 'function' && commonjsRequire,
          nt = 0;
        nt < et.length;
        nt++
      )
        tt(et[nt])
      return tt
    })(
      {
        1: [
          function($, j, _e) {
            ;(function(et) {
              var tt = et.MutationObserver || et.WebKitMutationObserver,
                rt
              if (tt) {
                var nt = 0,
                  it = new tt(ct),
                  ot = et.document.createTextNode('')
                it.observe(ot, { characterData: !0 }),
                  (rt = function() {
                    ot.data = nt = ++nt % 2
                  })
              } else if (!et.setImmediate && typeof et.MessageChannel < 'u') {
                var at = new et.MessageChannel()
                ;(at.port1.onmessage = ct),
                  (rt = function() {
                    at.port2.postMessage(0)
                  })
              } else
                'document' in et &&
                'onreadystatechange' in et.document.createElement('script')
                  ? (rt = function() {
                      var ft = et.document.createElement('script')
                      ;(ft.onreadystatechange = function() {
                        ct(),
                          (ft.onreadystatechange = null),
                          ft.parentNode.removeChild(ft),
                          (ft = null)
                      }),
                        et.document.documentElement.appendChild(ft)
                    })
                  : (rt = function() {
                      setTimeout(ct, 0)
                    })
              var st,
                ut = []
              function ct() {
                st = !0
                for (var ft, mt, vt = ut.length; vt; ) {
                  for (mt = ut, ut = [], ft = -1; ++ft < vt; ) mt[ft]()
                  vt = ut.length
                }
                st = !1
              }
              j.exports = dt
              function dt(ft) {
                ut.push(ft) === 1 && !st && rt()
              }
            }.call(
              this,
              typeof s < 'u'
                ? s
                : typeof self < 'u'
                ? self
                : typeof window < 'u'
                ? window
                : {}
            ))
          },
          {},
        ],
        2: [
          function($, j, _e) {
            var et = $(1)
            function tt() {}
            var rt = {},
              nt = ['REJECTED'],
              it = ['FULFILLED'],
              ot = ['PENDING']
            j.exports = at
            function at(ht) {
              if (typeof ht != 'function')
                throw new TypeError('resolver must be a function')
              ;(this.state = ot),
                (this.queue = []),
                (this.outcome = void 0),
                ht !== tt && dt(this, ht)
            }
            ;(at.prototype.catch = function(ht) {
              return this.then(null, ht)
            }),
              (at.prototype.then = function(ht, At) {
                if (
                  (typeof ht != 'function' && this.state === it) ||
                  (typeof At != 'function' && this.state === nt)
                )
                  return this
                var wt = new this.constructor(tt)
                if (this.state !== ot) {
                  var Ct = this.state === it ? ht : At
                  ut(wt, Ct, this.outcome)
                } else this.queue.push(new st(wt, ht, At))
                return wt
              })
            function st(ht, At, wt) {
              ;(this.promise = ht),
                typeof At == 'function' &&
                  ((this.onFulfilled = At),
                  (this.callFulfilled = this.otherCallFulfilled)),
                typeof wt == 'function' &&
                  ((this.onRejected = wt),
                  (this.callRejected = this.otherCallRejected))
            }
            ;(st.prototype.callFulfilled = function(ht) {
              rt.resolve(this.promise, ht)
            }),
              (st.prototype.otherCallFulfilled = function(ht) {
                ut(this.promise, this.onFulfilled, ht)
              }),
              (st.prototype.callRejected = function(ht) {
                rt.reject(this.promise, ht)
              }),
              (st.prototype.otherCallRejected = function(ht) {
                ut(this.promise, this.onRejected, ht)
              })
            function ut(ht, At, wt) {
              et(function() {
                var Ct
                try {
                  Ct = At(wt)
                } catch (Dt) {
                  return rt.reject(ht, Dt)
                }
                Ct === ht
                  ? rt.reject(
                      ht,
                      new TypeError('Cannot resolve promise with itself')
                    )
                  : rt.resolve(ht, Ct)
              })
            }
            ;(rt.resolve = function(ht, At) {
              var wt = ft(ct, At)
              if (wt.status === 'error') return rt.reject(ht, wt.value)
              var Ct = wt.value
              if (Ct) dt(ht, Ct)
              else {
                ;(ht.state = it), (ht.outcome = At)
                for (var Dt = -1, jt = ht.queue.length; ++Dt < jt; )
                  ht.queue[Dt].callFulfilled(At)
              }
              return ht
            }),
              (rt.reject = function(ht, At) {
                ;(ht.state = nt), (ht.outcome = At)
                for (var wt = -1, Ct = ht.queue.length; ++wt < Ct; )
                  ht.queue[wt].callRejected(At)
                return ht
              })
            function ct(ht) {
              var At = ht && ht.then
              if (
                ht &&
                (typeof ht == 'object' || typeof ht == 'function') &&
                typeof At == 'function'
              )
                return function() {
                  At.apply(ht, arguments)
                }
            }
            function dt(ht, At) {
              var wt = !1
              function Ct(St) {
                wt || ((wt = !0), rt.reject(ht, St))
              }
              function Dt(St) {
                wt || ((wt = !0), rt.resolve(ht, St))
              }
              function jt() {
                At(Dt, Ct)
              }
              var Et = ft(jt)
              Et.status === 'error' && Ct(Et.value)
            }
            function ft(ht, At) {
              var wt = {}
              try {
                ;(wt.value = ht(At)), (wt.status = 'success')
              } catch (Ct) {
                ;(wt.status = 'error'), (wt.value = Ct)
              }
              return wt
            }
            at.resolve = mt
            function mt(ht) {
              return ht instanceof this ? ht : rt.resolve(new this(tt), ht)
            }
            at.reject = vt
            function vt(ht) {
              var At = new this(tt)
              return rt.reject(At, ht)
            }
            at.all = yt
            function yt(ht) {
              var At = this
              if (Object.prototype.toString.call(ht) !== '[object Array]')
                return this.reject(new TypeError('must be an array'))
              var wt = ht.length,
                Ct = !1
              if (!wt) return this.resolve([])
              for (
                var Dt = new Array(wt), jt = 0, Et = -1, St = new this(tt);
                ++Et < wt;

              )
                Bt(ht[Et], Et)
              return St
              function Bt(Mt, Ut) {
                At.resolve(Mt).then(Wt, function(Tt) {
                  Ct || ((Ct = !0), rt.reject(St, Tt))
                })
                function Wt(Tt) {
                  ;(Dt[Ut] = Tt),
                    ++jt === wt && !Ct && ((Ct = !0), rt.resolve(St, Dt))
                }
              }
            }
            at.race = pt
            function pt(ht) {
              var At = this
              if (Object.prototype.toString.call(ht) !== '[object Array]')
                return this.reject(new TypeError('must be an array'))
              var wt = ht.length,
                Ct = !1
              if (!wt) return this.resolve([])
              for (var Dt = -1, jt = new this(tt); ++Dt < wt; ) Et(ht[Dt])
              return jt
              function Et(St) {
                At.resolve(St).then(
                  function(Bt) {
                    Ct || ((Ct = !0), rt.resolve(jt, Bt))
                  },
                  function(Bt) {
                    Ct || ((Ct = !0), rt.reject(jt, Bt))
                  }
                )
              }
            }
          },
          { 1: 1 },
        ],
        3: [
          function($, j, _e) {
            ;(function(et) {
              typeof et.Promise != 'function' && (et.Promise = $(2))
            }.call(
              this,
              typeof s < 'u'
                ? s
                : typeof self < 'u'
                ? self
                : typeof window < 'u'
                ? window
                : {}
            ))
          },
          { 2: 2 },
        ],
        4: [
          function($, j, _e) {
            var et =
              typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
                ? function(Zt) {
                    return typeof Zt
                  }
                : function(Zt) {
                    return Zt &&
                      typeof Symbol == 'function' &&
                      Zt.constructor === Symbol &&
                      Zt !== Symbol.prototype
                      ? 'symbol'
                      : typeof Zt
                  }
            function tt(Zt, or) {
              if (!(Zt instanceof or))
                throw new TypeError('Cannot call a class as a function')
            }
            function rt() {
              try {
                if (typeof indexedDB < 'u') return indexedDB
                if (typeof webkitIndexedDB < 'u') return webkitIndexedDB
                if (typeof mozIndexedDB < 'u') return mozIndexedDB
                if (typeof OIndexedDB < 'u') return OIndexedDB
                if (typeof msIndexedDB < 'u') return msIndexedDB
              } catch {
                return
              }
            }
            var nt = rt()
            function it() {
              try {
                if (!nt || !nt.open) return !1
                var Zt =
                    typeof openDatabase < 'u' &&
                    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&
                    !/Chrome/.test(navigator.userAgent) &&
                    !/BlackBerry/.test(navigator.platform),
                  or =
                    typeof fetch == 'function' &&
                    fetch.toString().indexOf('[native code') !== -1
                return (
                  (!Zt || or) &&
                  typeof indexedDB < 'u' &&
                  typeof IDBKeyRange < 'u'
                )
              } catch {
                return !1
              }
            }
            function ot(Zt, or) {
              ;(Zt = Zt || []), (or = or || {})
              try {
                return new Blob(Zt, or)
              } catch (cr) {
                if (cr.name !== 'TypeError') throw cr
                for (
                  var er =
                      typeof BlobBuilder < 'u'
                        ? BlobBuilder
                        : typeof MSBlobBuilder < 'u'
                        ? MSBlobBuilder
                        : typeof MozBlobBuilder < 'u'
                        ? MozBlobBuilder
                        : WebKitBlobBuilder,
                    dr = new er(),
                    hr = 0;
                  hr < Zt.length;
                  hr += 1
                )
                  dr.append(Zt[hr])
                return dr.getBlob(or.type)
              }
            }
            typeof Promise > 'u' && $(3)
            var at = Promise
            function st(Zt, or) {
              or &&
                Zt.then(
                  function(er) {
                    or(null, er)
                  },
                  function(er) {
                    or(er)
                  }
                )
            }
            function ut(Zt, or, er) {
              typeof or == 'function' && Zt.then(or),
                typeof er == 'function' && Zt.catch(er)
            }
            function ct(Zt) {
              return (
                typeof Zt != 'string' &&
                  (console.warn(Zt + ' used as a key, but it is not a string.'),
                  (Zt = String(Zt))),
                Zt
              )
            }
            function dt() {
              if (
                arguments.length &&
                typeof arguments[arguments.length - 1] == 'function'
              )
                return arguments[arguments.length - 1]
            }
            var ft = 'local-forage-detect-blob-support',
              mt = void 0,
              vt = {},
              yt = Object.prototype.toString,
              pt = 'readonly',
              ht = 'readwrite'
            function At(Zt) {
              for (
                var or = Zt.length,
                  er = new ArrayBuffer(or),
                  dr = new Uint8Array(er),
                  hr = 0;
                hr < or;
                hr++
              )
                dr[hr] = Zt.charCodeAt(hr)
              return er
            }
            function wt(Zt) {
              return new at(function(or) {
                var er = Zt.transaction(ft, ht),
                  dr = ot([''])
                er.objectStore(ft).put(dr, 'key'),
                  (er.onabort = function(hr) {
                    hr.preventDefault(), hr.stopPropagation(), or(!1)
                  }),
                  (er.oncomplete = function() {
                    var hr = navigator.userAgent.match(/Chrome\/(\d+)/),
                      cr = navigator.userAgent.match(/Edge\//)
                    or(cr || !hr || parseInt(hr[1], 10) >= 43)
                  })
              }).catch(function() {
                return !1
              })
            }
            function Ct(Zt) {
              return typeof mt == 'boolean'
                ? at.resolve(mt)
                : wt(Zt).then(function(or) {
                    return (mt = or), mt
                  })
            }
            function Dt(Zt) {
              var or = vt[Zt.name],
                er = {}
              ;(er.promise = new at(function(dr, hr) {
                ;(er.resolve = dr), (er.reject = hr)
              })),
                or.deferredOperations.push(er),
                or.dbReady
                  ? (or.dbReady = or.dbReady.then(function() {
                      return er.promise
                    }))
                  : (or.dbReady = er.promise)
            }
            function jt(Zt) {
              var or = vt[Zt.name],
                er = or.deferredOperations.pop()
              if (er) return er.resolve(), er.promise
            }
            function Et(Zt, or) {
              var er = vt[Zt.name],
                dr = er.deferredOperations.pop()
              if (dr) return dr.reject(or), dr.promise
            }
            function St(Zt, or) {
              return new at(function(er, dr) {
                if (((vt[Zt.name] = vt[Zt.name] || Pt()), Zt.db))
                  if (or) Dt(Zt), Zt.db.close()
                  else return er(Zt.db)
                var hr = [Zt.name]
                or && hr.push(Zt.version)
                var cr = nt.open.apply(nt, hr)
                or &&
                  (cr.onupgradeneeded = function(xr) {
                    var Cr = cr.result
                    try {
                      Cr.createObjectStore(Zt.storeName),
                        xr.oldVersion <= 1 && Cr.createObjectStore(ft)
                    } catch (Ir) {
                      if (Ir.name === 'ConstraintError')
                        console.warn(
                          'The database "' +
                            Zt.name +
                            '" has been upgraded from version ' +
                            xr.oldVersion +
                            ' to version ' +
                            xr.newVersion +
                            ', but the storage "' +
                            Zt.storeName +
                            '" already exists.'
                        )
                      else throw Ir
                    }
                  }),
                  (cr.onerror = function(xr) {
                    xr.preventDefault(), dr(cr.error)
                  }),
                  (cr.onsuccess = function() {
                    var xr = cr.result
                    ;(xr.onversionchange = function(Cr) {
                      Cr.target.close()
                    }),
                      er(xr),
                      jt(Zt)
                  })
              })
            }
            function Bt(Zt) {
              return St(Zt, !1)
            }
            function Mt(Zt) {
              return St(Zt, !0)
            }
            function Ut(Zt, or) {
              if (!Zt.db) return !0
              var er = !Zt.db.objectStoreNames.contains(Zt.storeName),
                dr = Zt.version < Zt.db.version,
                hr = Zt.version > Zt.db.version
              if (
                (dr &&
                  (Zt.version !== or &&
                    console.warn(
                      'The database "' +
                        Zt.name +
                        `" can't be downgraded from version ` +
                        Zt.db.version +
                        ' to version ' +
                        Zt.version +
                        '.'
                    ),
                  (Zt.version = Zt.db.version)),
                hr || er)
              ) {
                if (er) {
                  var cr = Zt.db.version + 1
                  cr > Zt.version && (Zt.version = cr)
                }
                return !0
              }
              return !1
            }
            function Wt(Zt) {
              return new at(function(or, er) {
                var dr = new FileReader()
                ;(dr.onerror = er),
                  (dr.onloadend = function(hr) {
                    var cr = btoa(hr.target.result || '')
                    or({
                      __local_forage_encoded_blob: !0,
                      data: cr,
                      type: Zt.type,
                    })
                  }),
                  dr.readAsBinaryString(Zt)
              })
            }
            function Tt(Zt) {
              var or = At(atob(Zt.data))
              return ot([or], { type: Zt.type })
            }
            function kt(Zt) {
              return Zt && Zt.__local_forage_encoded_blob
            }
            function Ot(Zt) {
              var or = this,
                er = or._initReady().then(function() {
                  var dr = vt[or._dbInfo.name]
                  if (dr && dr.dbReady) return dr.dbReady
                })
              return ut(er, Zt, Zt), er
            }
            function Nt(Zt) {
              Dt(Zt)
              for (
                var or = vt[Zt.name], er = or.forages, dr = 0;
                dr < er.length;
                dr++
              ) {
                var hr = er[dr]
                hr._dbInfo.db && (hr._dbInfo.db.close(), (hr._dbInfo.db = null))
              }
              return (
                (Zt.db = null),
                Bt(Zt)
                  .then(function(cr) {
                    return (Zt.db = cr), Ut(Zt) ? Mt(Zt) : cr
                  })
                  .then(function(cr) {
                    Zt.db = or.db = cr
                    for (var xr = 0; xr < er.length; xr++)
                      er[xr]._dbInfo.db = cr
                  })
                  .catch(function(cr) {
                    throw (Et(Zt, cr), cr)
                  })
              )
            }
            function $t(Zt, or, er, dr) {
              dr === void 0 && (dr = 1)
              try {
                var hr = Zt.db.transaction(Zt.storeName, or)
                er(null, hr)
              } catch (cr) {
                if (
                  dr > 0 &&
                  (!Zt.db ||
                    cr.name === 'InvalidStateError' ||
                    cr.name === 'NotFoundError')
                )
                  return at
                    .resolve()
                    .then(function() {
                      if (
                        !Zt.db ||
                        (cr.name === 'NotFoundError' &&
                          !Zt.db.objectStoreNames.contains(Zt.storeName) &&
                          Zt.version <= Zt.db.version)
                      )
                        return Zt.db && (Zt.version = Zt.db.version + 1), Mt(Zt)
                    })
                    .then(function() {
                      return Nt(Zt).then(function() {
                        $t(Zt, or, er, dr - 1)
                      })
                    })
                    .catch(er)
                er(cr)
              }
            }
            function Pt() {
              return {
                forages: [],
                db: null,
                dbReady: null,
                deferredOperations: [],
              }
            }
            function Ft(Zt) {
              var or = this,
                er = { db: null }
              if (Zt) for (var dr in Zt) er[dr] = Zt[dr]
              var hr = vt[er.name]
              hr || ((hr = Pt()), (vt[er.name] = hr)),
                hr.forages.push(or),
                or._initReady || ((or._initReady = or.ready), (or.ready = Ot))
              var cr = []
              function xr() {
                return at.resolve()
              }
              for (var Cr = 0; Cr < hr.forages.length; Cr++) {
                var Ir = hr.forages[Cr]
                Ir !== or && cr.push(Ir._initReady().catch(xr))
              }
              var $r = hr.forages.slice(0)
              return at
                .all(cr)
                .then(function() {
                  return (er.db = hr.db), Bt(er)
                })
                .then(function(Pr) {
                  return (
                    (er.db = Pr),
                    Ut(er, or._defaultConfig.version) ? Mt(er) : Pr
                  )
                })
                .then(function(Pr) {
                  ;(er.db = hr.db = Pr), (or._dbInfo = er)
                  for (var Dr = 0; Dr < $r.length; Dr++) {
                    var Lr = $r[Dr]
                    Lr !== or &&
                      ((Lr._dbInfo.db = er.db),
                      (Lr._dbInfo.version = er.version))
                  }
                })
            }
            function Vt(Zt, or) {
              var er = this
              Zt = ct(Zt)
              var dr = new at(function(hr, cr) {
                er.ready()
                  .then(function() {
                    $t(er._dbInfo, pt, function(xr, Cr) {
                      if (xr) return cr(xr)
                      try {
                        var Ir = Cr.objectStore(er._dbInfo.storeName),
                          $r = Ir.get(Zt)
                        ;($r.onsuccess = function() {
                          var Pr = $r.result
                          Pr === void 0 && (Pr = null),
                            kt(Pr) && (Pr = Tt(Pr)),
                            hr(Pr)
                        }),
                          ($r.onerror = function() {
                            cr($r.error)
                          })
                      } catch (Pr) {
                        cr(Pr)
                      }
                    })
                  })
                  .catch(cr)
              })
              return st(dr, or), dr
            }
            function Xt(Zt, or) {
              var er = this,
                dr = new at(function(hr, cr) {
                  er.ready()
                    .then(function() {
                      $t(er._dbInfo, pt, function(xr, Cr) {
                        if (xr) return cr(xr)
                        try {
                          var Ir = Cr.objectStore(er._dbInfo.storeName),
                            $r = Ir.openCursor(),
                            Pr = 1
                          ;($r.onsuccess = function() {
                            var Dr = $r.result
                            if (Dr) {
                              var Lr = Dr.value
                              kt(Lr) && (Lr = Tt(Lr))
                              var Hr = Zt(Lr, Dr.key, Pr++)
                              Hr !== void 0 ? hr(Hr) : Dr.continue()
                            } else hr()
                          }),
                            ($r.onerror = function() {
                              cr($r.error)
                            })
                        } catch (Dr) {
                          cr(Dr)
                        }
                      })
                    })
                    .catch(cr)
                })
              return st(dr, or), dr
            }
            function Yt(Zt, or, er) {
              var dr = this
              Zt = ct(Zt)
              var hr = new at(function(cr, xr) {
                var Cr
                dr.ready()
                  .then(function() {
                    return (
                      (Cr = dr._dbInfo),
                      yt.call(or) === '[object Blob]'
                        ? Ct(Cr.db).then(function(Ir) {
                            return Ir ? or : Wt(or)
                          })
                        : or
                    )
                  })
                  .then(function(Ir) {
                    $t(dr._dbInfo, ht, function($r, Pr) {
                      if ($r) return xr($r)
                      try {
                        var Dr = Pr.objectStore(dr._dbInfo.storeName)
                        Ir === null && (Ir = void 0)
                        var Lr = Dr.put(Ir, Zt)
                        ;(Pr.oncomplete = function() {
                          Ir === void 0 && (Ir = null), cr(Ir)
                        }),
                          (Pr.onabort = Pr.onerror = function() {
                            var Hr = Lr.error ? Lr.error : Lr.transaction.error
                            xr(Hr)
                          })
                      } catch (Hr) {
                        xr(Hr)
                      }
                    })
                  })
                  .catch(xr)
              })
              return st(hr, er), hr
            }
            function xt(Zt, or) {
              var er = this
              Zt = ct(Zt)
              var dr = new at(function(hr, cr) {
                er.ready()
                  .then(function() {
                    $t(er._dbInfo, ht, function(xr, Cr) {
                      if (xr) return cr(xr)
                      try {
                        var Ir = Cr.objectStore(er._dbInfo.storeName),
                          $r = Ir.delete(Zt)
                        ;(Cr.oncomplete = function() {
                          hr()
                        }),
                          (Cr.onerror = function() {
                            cr($r.error)
                          }),
                          (Cr.onabort = function() {
                            var Pr = $r.error ? $r.error : $r.transaction.error
                            cr(Pr)
                          })
                      } catch (Pr) {
                        cr(Pr)
                      }
                    })
                  })
                  .catch(cr)
              })
              return st(dr, or), dr
            }
            function It(Zt) {
              var or = this,
                er = new at(function(dr, hr) {
                  or.ready()
                    .then(function() {
                      $t(or._dbInfo, ht, function(cr, xr) {
                        if (cr) return hr(cr)
                        try {
                          var Cr = xr.objectStore(or._dbInfo.storeName),
                            Ir = Cr.clear()
                          ;(xr.oncomplete = function() {
                            dr()
                          }),
                            (xr.onabort = xr.onerror = function() {
                              var $r = Ir.error
                                ? Ir.error
                                : Ir.transaction.error
                              hr($r)
                            })
                        } catch ($r) {
                          hr($r)
                        }
                      })
                    })
                    .catch(hr)
                })
              return st(er, Zt), er
            }
            function Kt(Zt) {
              var or = this,
                er = new at(function(dr, hr) {
                  or.ready()
                    .then(function() {
                      $t(or._dbInfo, pt, function(cr, xr) {
                        if (cr) return hr(cr)
                        try {
                          var Cr = xr.objectStore(or._dbInfo.storeName),
                            Ir = Cr.count()
                          ;(Ir.onsuccess = function() {
                            dr(Ir.result)
                          }),
                            (Ir.onerror = function() {
                              hr(Ir.error)
                            })
                        } catch ($r) {
                          hr($r)
                        }
                      })
                    })
                    .catch(hr)
                })
              return st(er, Zt), er
            }
            function Qt(Zt, or) {
              var er = this,
                dr = new at(function(hr, cr) {
                  if (Zt < 0) {
                    hr(null)
                    return
                  }
                  er.ready()
                    .then(function() {
                      $t(er._dbInfo, pt, function(xr, Cr) {
                        if (xr) return cr(xr)
                        try {
                          var Ir = Cr.objectStore(er._dbInfo.storeName),
                            $r = !1,
                            Pr = Ir.openKeyCursor()
                          ;(Pr.onsuccess = function() {
                            var Dr = Pr.result
                            if (!Dr) {
                              hr(null)
                              return
                            }
                            Zt === 0 || $r
                              ? hr(Dr.key)
                              : (($r = !0), Dr.advance(Zt))
                          }),
                            (Pr.onerror = function() {
                              cr(Pr.error)
                            })
                        } catch (Dr) {
                          cr(Dr)
                        }
                      })
                    })
                    .catch(cr)
                })
              return st(dr, or), dr
            }
            function Ht(Zt) {
              var or = this,
                er = new at(function(dr, hr) {
                  or.ready()
                    .then(function() {
                      $t(or._dbInfo, pt, function(cr, xr) {
                        if (cr) return hr(cr)
                        try {
                          var Cr = xr.objectStore(or._dbInfo.storeName),
                            Ir = Cr.openKeyCursor(),
                            $r = []
                          ;(Ir.onsuccess = function() {
                            var Pr = Ir.result
                            if (!Pr) {
                              dr($r)
                              return
                            }
                            $r.push(Pr.key), Pr.continue()
                          }),
                            (Ir.onerror = function() {
                              hr(Ir.error)
                            })
                        } catch (Pr) {
                          hr(Pr)
                        }
                      })
                    })
                    .catch(hr)
                })
              return st(er, Zt), er
            }
            function Lt(Zt, or) {
              or = dt.apply(this, arguments)
              var er = this.config()
              ;(Zt = (typeof Zt != 'function' && Zt) || {}),
                Zt.name ||
                  ((Zt.name = Zt.name || er.name),
                  (Zt.storeName = Zt.storeName || er.storeName))
              var dr = this,
                hr
              if (!Zt.name) hr = at.reject('Invalid arguments')
              else {
                var cr = Zt.name === er.name && dr._dbInfo.db,
                  xr = cr
                    ? at.resolve(dr._dbInfo.db)
                    : Bt(Zt).then(function(Cr) {
                        var Ir = vt[Zt.name],
                          $r = Ir.forages
                        Ir.db = Cr
                        for (var Pr = 0; Pr < $r.length; Pr++)
                          $r[Pr]._dbInfo.db = Cr
                        return Cr
                      })
                Zt.storeName
                  ? (hr = xr.then(function(Cr) {
                      if (Cr.objectStoreNames.contains(Zt.storeName)) {
                        var Ir = Cr.version + 1
                        Dt(Zt)
                        var $r = vt[Zt.name],
                          Pr = $r.forages
                        Cr.close()
                        for (var Dr = 0; Dr < Pr.length; Dr++) {
                          var Lr = Pr[Dr]
                          ;(Lr._dbInfo.db = null), (Lr._dbInfo.version = Ir)
                        }
                        var Hr = new at(function(zr, Xr) {
                          var Zr = nt.open(Zt.name, Ir)
                          ;(Zr.onerror = function(un) {
                            var jn = Zr.result
                            jn.close(), Xr(un)
                          }),
                            (Zr.onupgradeneeded = function() {
                              var un = Zr.result
                              un.deleteObjectStore(Zt.storeName)
                            }),
                            (Zr.onsuccess = function() {
                              var un = Zr.result
                              un.close(), zr(un)
                            })
                        })
                        return Hr.then(function(zr) {
                          $r.db = zr
                          for (var Xr = 0; Xr < Pr.length; Xr++) {
                            var Zr = Pr[Xr]
                            ;(Zr._dbInfo.db = zr), jt(Zr._dbInfo)
                          }
                        }).catch(function(zr) {
                          throw ((
                            Et(Zt, zr) || at.resolve()
                          ).catch(function() {}),
                          zr)
                        })
                      }
                    }))
                  : (hr = xr.then(function(Cr) {
                      Dt(Zt)
                      var Ir = vt[Zt.name],
                        $r = Ir.forages
                      Cr.close()
                      for (var Pr = 0; Pr < $r.length; Pr++) {
                        var Dr = $r[Pr]
                        Dr._dbInfo.db = null
                      }
                      var Lr = new at(function(Hr, zr) {
                        var Xr = nt.deleteDatabase(Zt.name)
                        ;(Xr.onerror = function() {
                          var Zr = Xr.result
                          Zr && Zr.close(), zr(Xr.error)
                        }),
                          (Xr.onblocked = function() {
                            console.warn(
                              'dropInstance blocked for database "' +
                                Zt.name +
                                '" until all open connections are closed'
                            )
                          }),
                          (Xr.onsuccess = function() {
                            var Zr = Xr.result
                            Zr && Zr.close(), Hr(Zr)
                          })
                      })
                      return Lr.then(function(Hr) {
                        Ir.db = Hr
                        for (var zr = 0; zr < $r.length; zr++) {
                          var Xr = $r[zr]
                          jt(Xr._dbInfo)
                        }
                      }).catch(function(Hr) {
                        throw ((
                          Et(Zt, Hr) || at.resolve()
                        ).catch(function() {}),
                        Hr)
                      })
                    }))
              }
              return st(hr, or), hr
            }
            var tr = {
              _driver: 'asyncStorage',
              _initStorage: Ft,
              _support: it(),
              iterate: Xt,
              getItem: Vt,
              setItem: Yt,
              removeItem: xt,
              clear: It,
              length: Kt,
              key: Qt,
              keys: Ht,
              dropInstance: Lt,
            }
            function lr() {
              return typeof openDatabase == 'function'
            }
            var yr =
                'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
              mr = '~~local_forage_type~',
              Er = /^~~local_forage_type~([^~]+)~/,
              ur = '__lfsc__:',
              _r = ur.length,
              Rr = 'arbf',
              nr = 'blob',
              fr = 'si08',
              gr = 'ui08',
              br = 'uic8',
              Sr = 'si16',
              zt = 'si32',
              bt = 'ur16',
              Rt = 'ui32',
              qt = 'fl32',
              rr = 'fl64',
              ar = _r + Rr.length,
              ir = Object.prototype.toString
            function Tr(Zt) {
              var or = Zt.length * 0.75,
                er = Zt.length,
                dr,
                hr = 0,
                cr,
                xr,
                Cr,
                Ir
              Zt[Zt.length - 1] === '=' &&
                (or--, Zt[Zt.length - 2] === '=' && or--)
              var $r = new ArrayBuffer(or),
                Pr = new Uint8Array($r)
              for (dr = 0; dr < er; dr += 4)
                (cr = yr.indexOf(Zt[dr])),
                  (xr = yr.indexOf(Zt[dr + 1])),
                  (Cr = yr.indexOf(Zt[dr + 2])),
                  (Ir = yr.indexOf(Zt[dr + 3])),
                  (Pr[hr++] = (cr << 2) | (xr >> 4)),
                  (Pr[hr++] = ((xr & 15) << 4) | (Cr >> 2)),
                  (Pr[hr++] = ((Cr & 3) << 6) | (Ir & 63))
              return $r
            }
            function vr(Zt) {
              var or = new Uint8Array(Zt),
                er = '',
                dr
              for (dr = 0; dr < or.length; dr += 3)
                (er += yr[or[dr] >> 2]),
                  (er += yr[((or[dr] & 3) << 4) | (or[dr + 1] >> 4)]),
                  (er += yr[((or[dr + 1] & 15) << 2) | (or[dr + 2] >> 6)]),
                  (er += yr[or[dr + 2] & 63])
              return (
                or.length % 3 === 2
                  ? (er = er.substring(0, er.length - 1) + '=')
                  : or.length % 3 === 1 &&
                    (er = er.substring(0, er.length - 2) + '=='),
                er
              )
            }
            function Ar(Zt, or) {
              var er = ''
              if (
                (Zt && (er = ir.call(Zt)),
                Zt &&
                  (er === '[object ArrayBuffer]' ||
                    (Zt.buffer &&
                      ir.call(Zt.buffer) === '[object ArrayBuffer]')))
              ) {
                var dr,
                  hr = ur
                Zt instanceof ArrayBuffer
                  ? ((dr = Zt), (hr += Rr))
                  : ((dr = Zt.buffer),
                    er === '[object Int8Array]'
                      ? (hr += fr)
                      : er === '[object Uint8Array]'
                      ? (hr += gr)
                      : er === '[object Uint8ClampedArray]'
                      ? (hr += br)
                      : er === '[object Int16Array]'
                      ? (hr += Sr)
                      : er === '[object Uint16Array]'
                      ? (hr += bt)
                      : er === '[object Int32Array]'
                      ? (hr += zt)
                      : er === '[object Uint32Array]'
                      ? (hr += Rt)
                      : er === '[object Float32Array]'
                      ? (hr += qt)
                      : er === '[object Float64Array]'
                      ? (hr += rr)
                      : or(new Error('Failed to get type for BinaryArray'))),
                  or(hr + vr(dr))
              } else if (er === '[object Blob]') {
                var cr = new FileReader()
                ;(cr.onload = function() {
                  var xr = mr + Zt.type + '~' + vr(this.result)
                  or(ur + nr + xr)
                }),
                  cr.readAsArrayBuffer(Zt)
              } else
                try {
                  or(JSON.stringify(Zt))
                } catch (xr) {
                  console.error(
                    "Couldn't convert value into a JSON string: ",
                    Zt
                  ),
                    or(null, xr)
                }
            }
            function Nr(Zt) {
              if (Zt.substring(0, _r) !== ur) return JSON.parse(Zt)
              var or = Zt.substring(ar),
                er = Zt.substring(_r, ar),
                dr
              if (er === nr && Er.test(or)) {
                var hr = or.match(Er)
                ;(dr = hr[1]), (or = or.substring(hr[0].length))
              }
              var cr = Tr(or)
              switch (er) {
                case Rr:
                  return cr
                case nr:
                  return ot([cr], { type: dr })
                case fr:
                  return new Int8Array(cr)
                case gr:
                  return new Uint8Array(cr)
                case br:
                  return new Uint8ClampedArray(cr)
                case Sr:
                  return new Int16Array(cr)
                case bt:
                  return new Uint16Array(cr)
                case zt:
                  return new Int32Array(cr)
                case Rt:
                  return new Uint32Array(cr)
                case qt:
                  return new Float32Array(cr)
                case rr:
                  return new Float64Array(cr)
                default:
                  throw new Error('Unkown type: ' + er)
              }
            }
            var Or = {
              serialize: Ar,
              deserialize: Nr,
              stringToBuffer: Tr,
              bufferToString: vr,
            }
            function Fr(Zt, or, er, dr) {
              Zt.executeSql(
                'CREATE TABLE IF NOT EXISTS ' +
                  or.storeName +
                  ' (id INTEGER PRIMARY KEY, key unique, value)',
                [],
                er,
                dr
              )
            }
            function Qr(Zt) {
              var or = this,
                er = { db: null }
              if (Zt)
                for (var dr in Zt)
                  er[dr] =
                    typeof Zt[dr] != 'string' ? Zt[dr].toString() : Zt[dr]
              var hr = new at(function(cr, xr) {
                try {
                  er.db = openDatabase(
                    er.name,
                    String(er.version),
                    er.description,
                    er.size
                  )
                } catch (Cr) {
                  return xr(Cr)
                }
                er.db.transaction(function(Cr) {
                  Fr(
                    Cr,
                    er,
                    function() {
                      ;(or._dbInfo = er), cr()
                    },
                    function(Ir, $r) {
                      xr($r)
                    }
                  )
                }, xr)
              })
              return (er.serializer = Or), hr
            }
            function qr(Zt, or, er, dr, hr, cr) {
              Zt.executeSql(
                er,
                dr,
                hr,
                function(xr, Cr) {
                  Cr.code === Cr.SYNTAX_ERR
                    ? xr.executeSql(
                        "SELECT name FROM sqlite_master WHERE type='table' AND name = ?",
                        [or.storeName],
                        function(Ir, $r) {
                          $r.rows.length
                            ? cr(Ir, Cr)
                            : Fr(
                                Ir,
                                or,
                                function() {
                                  Ir.executeSql(er, dr, hr, cr)
                                },
                                cr
                              )
                        },
                        cr
                      )
                    : cr(xr, Cr)
                },
                cr
              )
            }
            function tn(Zt, or) {
              var er = this
              Zt = ct(Zt)
              var dr = new at(function(hr, cr) {
                er.ready()
                  .then(function() {
                    var xr = er._dbInfo
                    xr.db.transaction(function(Cr) {
                      qr(
                        Cr,
                        xr,
                        'SELECT * FROM ' +
                          xr.storeName +
                          ' WHERE key = ? LIMIT 1',
                        [Zt],
                        function(Ir, $r) {
                          var Pr = $r.rows.length ? $r.rows.item(0).value : null
                          Pr && (Pr = xr.serializer.deserialize(Pr)), hr(Pr)
                        },
                        function(Ir, $r) {
                          cr($r)
                        }
                      )
                    })
                  })
                  .catch(cr)
              })
              return st(dr, or), dr
            }
            function en(Zt, or) {
              var er = this,
                dr = new at(function(hr, cr) {
                  er.ready()
                    .then(function() {
                      var xr = er._dbInfo
                      xr.db.transaction(function(Cr) {
                        qr(
                          Cr,
                          xr,
                          'SELECT * FROM ' + xr.storeName,
                          [],
                          function(Ir, $r) {
                            for (
                              var Pr = $r.rows, Dr = Pr.length, Lr = 0;
                              Lr < Dr;
                              Lr++
                            ) {
                              var Hr = Pr.item(Lr),
                                zr = Hr.value
                              if (
                                (zr && (zr = xr.serializer.deserialize(zr)),
                                (zr = Zt(zr, Hr.key, Lr + 1)),
                                zr !== void 0)
                              ) {
                                hr(zr)
                                return
                              }
                            }
                            hr()
                          },
                          function(Ir, $r) {
                            cr($r)
                          }
                        )
                      })
                    })
                    .catch(cr)
                })
              return st(dr, or), dr
            }
            function ln(Zt, or, er, dr) {
              var hr = this
              Zt = ct(Zt)
              var cr = new at(function(xr, Cr) {
                hr.ready()
                  .then(function() {
                    or === void 0 && (or = null)
                    var Ir = or,
                      $r = hr._dbInfo
                    $r.serializer.serialize(or, function(Pr, Dr) {
                      Dr
                        ? Cr(Dr)
                        : $r.db.transaction(
                            function(Lr) {
                              qr(
                                Lr,
                                $r,
                                'INSERT OR REPLACE INTO ' +
                                  $r.storeName +
                                  ' (key, value) VALUES (?, ?)',
                                [Zt, Pr],
                                function() {
                                  xr(Ir)
                                },
                                function(Hr, zr) {
                                  Cr(zr)
                                }
                              )
                            },
                            function(Lr) {
                              if (Lr.code === Lr.QUOTA_ERR) {
                                if (dr > 0) {
                                  xr(ln.apply(hr, [Zt, Ir, er, dr - 1]))
                                  return
                                }
                                Cr(Lr)
                              }
                            }
                          )
                    })
                  })
                  .catch(Cr)
              })
              return st(cr, er), cr
            }
            function yn(Zt, or, er) {
              return ln.apply(this, [Zt, or, er, 1])
            }
            function Bn(Zt, or) {
              var er = this
              Zt = ct(Zt)
              var dr = new at(function(hr, cr) {
                er.ready()
                  .then(function() {
                    var xr = er._dbInfo
                    xr.db.transaction(function(Cr) {
                      qr(
                        Cr,
                        xr,
                        'DELETE FROM ' + xr.storeName + ' WHERE key = ?',
                        [Zt],
                        function() {
                          hr()
                        },
                        function(Ir, $r) {
                          cr($r)
                        }
                      )
                    })
                  })
                  .catch(cr)
              })
              return st(dr, or), dr
            }
            function xn(Zt) {
              var or = this,
                er = new at(function(dr, hr) {
                  or.ready()
                    .then(function() {
                      var cr = or._dbInfo
                      cr.db.transaction(function(xr) {
                        qr(
                          xr,
                          cr,
                          'DELETE FROM ' + cr.storeName,
                          [],
                          function() {
                            dr()
                          },
                          function(Cr, Ir) {
                            hr(Ir)
                          }
                        )
                      })
                    })
                    .catch(hr)
                })
              return st(er, Zt), er
            }
            function vn(Zt) {
              var or = this,
                er = new at(function(dr, hr) {
                  or.ready()
                    .then(function() {
                      var cr = or._dbInfo
                      cr.db.transaction(function(xr) {
                        qr(
                          xr,
                          cr,
                          'SELECT COUNT(key) as c FROM ' + cr.storeName,
                          [],
                          function(Cr, Ir) {
                            var $r = Ir.rows.item(0).c
                            dr($r)
                          },
                          function(Cr, Ir) {
                            hr(Ir)
                          }
                        )
                      })
                    })
                    .catch(hr)
                })
              return st(er, Zt), er
            }
            function on(Zt, or) {
              var er = this,
                dr = new at(function(hr, cr) {
                  er.ready()
                    .then(function() {
                      var xr = er._dbInfo
                      xr.db.transaction(function(Cr) {
                        qr(
                          Cr,
                          xr,
                          'SELECT key FROM ' +
                            xr.storeName +
                            ' WHERE id = ? LIMIT 1',
                          [Zt + 1],
                          function(Ir, $r) {
                            var Pr = $r.rows.length ? $r.rows.item(0).key : null
                            hr(Pr)
                          },
                          function(Ir, $r) {
                            cr($r)
                          }
                        )
                      })
                    })
                    .catch(cr)
                })
              return st(dr, or), dr
            }
            function Cn(Zt) {
              var or = this,
                er = new at(function(dr, hr) {
                  or.ready()
                    .then(function() {
                      var cr = or._dbInfo
                      cr.db.transaction(function(xr) {
                        qr(
                          xr,
                          cr,
                          'SELECT key FROM ' + cr.storeName,
                          [],
                          function(Cr, Ir) {
                            for (var $r = [], Pr = 0; Pr < Ir.rows.length; Pr++)
                              $r.push(Ir.rows.item(Pr).key)
                            dr($r)
                          },
                          function(Cr, Ir) {
                            hr(Ir)
                          }
                        )
                      })
                    })
                    .catch(hr)
                })
              return st(er, Zt), er
            }
            function dn(Zt) {
              return new at(function(or, er) {
                Zt.transaction(
                  function(dr) {
                    dr.executeSql(
                      "SELECT name FROM sqlite_master WHERE type='table' AND name <> '__WebKitDatabaseInfoTable__'",
                      [],
                      function(hr, cr) {
                        for (var xr = [], Cr = 0; Cr < cr.rows.length; Cr++)
                          xr.push(cr.rows.item(Cr).name)
                        or({ db: Zt, storeNames: xr })
                      },
                      function(hr, cr) {
                        er(cr)
                      }
                    )
                  },
                  function(dr) {
                    er(dr)
                  }
                )
              })
            }
            function An(Zt, or) {
              or = dt.apply(this, arguments)
              var er = this.config()
              ;(Zt = (typeof Zt != 'function' && Zt) || {}),
                Zt.name ||
                  ((Zt.name = Zt.name || er.name),
                  (Zt.storeName = Zt.storeName || er.storeName))
              var dr = this,
                hr
              return (
                Zt.name
                  ? (hr = new at(function(cr) {
                      var xr
                      Zt.name === er.name
                        ? (xr = dr._dbInfo.db)
                        : (xr = openDatabase(Zt.name, '', '', 0)),
                        Zt.storeName
                          ? cr({ db: xr, storeNames: [Zt.storeName] })
                          : cr(dn(xr))
                    }).then(function(cr) {
                      return new at(function(xr, Cr) {
                        cr.db.transaction(
                          function(Ir) {
                            function $r(Hr) {
                              return new at(function(zr, Xr) {
                                Ir.executeSql(
                                  'DROP TABLE IF EXISTS ' + Hr,
                                  [],
                                  function() {
                                    zr()
                                  },
                                  function(Zr, un) {
                                    Xr(un)
                                  }
                                )
                              })
                            }
                            for (
                              var Pr = [], Dr = 0, Lr = cr.storeNames.length;
                              Dr < Lr;
                              Dr++
                            )
                              Pr.push($r(cr.storeNames[Dr]))
                            at.all(Pr)
                              .then(function() {
                                xr()
                              })
                              .catch(function(Hr) {
                                Cr(Hr)
                              })
                          },
                          function(Ir) {
                            Cr(Ir)
                          }
                        )
                      })
                    }))
                  : (hr = at.reject('Invalid arguments')),
                st(hr, or),
                hr
              )
            }
            var Jr = {
              _driver: 'webSQLStorage',
              _initStorage: Qr,
              _support: lr(),
              iterate: en,
              getItem: tn,
              setItem: yn,
              removeItem: Bn,
              clear: xn,
              length: vn,
              key: on,
              keys: Cn,
              dropInstance: An,
            }
            function En() {
              try {
                return (
                  typeof localStorage < 'u' &&
                  'setItem' in localStorage &&
                  !!localStorage.setItem
                )
              } catch {
                return !1
              }
            }
            function Pn(Zt, or) {
              var er = Zt.name + '/'
              return (
                Zt.storeName !== or.storeName && (er += Zt.storeName + '/'), er
              )
            }
            function pn() {
              var Zt = '_localforage_support_test'
              try {
                return (
                  localStorage.setItem(Zt, !0), localStorage.removeItem(Zt), !1
                )
              } catch {
                return !0
              }
            }
            function Tn() {
              return !pn() || localStorage.length > 0
            }
            function _n(Zt) {
              var or = this,
                er = {}
              if (Zt) for (var dr in Zt) er[dr] = Zt[dr]
              return (
                (er.keyPrefix = Pn(Zt, or._defaultConfig)),
                Tn()
                  ? ((or._dbInfo = er), (er.serializer = Or), at.resolve())
                  : at.reject()
              )
            }
            function hn(Zt) {
              var or = this,
                er = or.ready().then(function() {
                  for (
                    var dr = or._dbInfo.keyPrefix, hr = localStorage.length - 1;
                    hr >= 0;
                    hr--
                  ) {
                    var cr = localStorage.key(hr)
                    cr.indexOf(dr) === 0 && localStorage.removeItem(cr)
                  }
                })
              return st(er, Zt), er
            }
            function wn(Zt, or) {
              var er = this
              Zt = ct(Zt)
              var dr = er.ready().then(function() {
                var hr = er._dbInfo,
                  cr = localStorage.getItem(hr.keyPrefix + Zt)
                return cr && (cr = hr.serializer.deserialize(cr)), cr
              })
              return st(dr, or), dr
            }
            function Kr(Zt, or) {
              var er = this,
                dr = er.ready().then(function() {
                  for (
                    var hr = er._dbInfo,
                      cr = hr.keyPrefix,
                      xr = cr.length,
                      Cr = localStorage.length,
                      Ir = 1,
                      $r = 0;
                    $r < Cr;
                    $r++
                  ) {
                    var Pr = localStorage.key($r)
                    if (Pr.indexOf(cr) === 0) {
                      var Dr = localStorage.getItem(Pr)
                      if (
                        (Dr && (Dr = hr.serializer.deserialize(Dr)),
                        (Dr = Zt(Dr, Pr.substring(xr), Ir++)),
                        Dr !== void 0)
                      )
                        return Dr
                    }
                  }
                })
              return st(dr, or), dr
            }
            function Vr(Zt, or) {
              var er = this,
                dr = er.ready().then(function() {
                  var hr = er._dbInfo,
                    cr
                  try {
                    cr = localStorage.key(Zt)
                  } catch {
                    cr = null
                  }
                  return cr && (cr = cr.substring(hr.keyPrefix.length)), cr
                })
              return st(dr, or), dr
            }
            function In(Zt) {
              var or = this,
                er = or.ready().then(function() {
                  for (
                    var dr = or._dbInfo,
                      hr = localStorage.length,
                      cr = [],
                      xr = 0;
                    xr < hr;
                    xr++
                  ) {
                    var Cr = localStorage.key(xr)
                    Cr.indexOf(dr.keyPrefix) === 0 &&
                      cr.push(Cr.substring(dr.keyPrefix.length))
                  }
                  return cr
                })
              return st(er, Zt), er
            }
            function Sn(Zt) {
              var or = this,
                er = or.keys().then(function(dr) {
                  return dr.length
                })
              return st(er, Zt), er
            }
            function an(Zt, or) {
              var er = this
              Zt = ct(Zt)
              var dr = er.ready().then(function() {
                var hr = er._dbInfo
                localStorage.removeItem(hr.keyPrefix + Zt)
              })
              return st(dr, or), dr
            }
            function jr(Zt, or, er) {
              var dr = this
              Zt = ct(Zt)
              var hr = dr.ready().then(function() {
                or === void 0 && (or = null)
                var cr = or
                return new at(function(xr, Cr) {
                  var Ir = dr._dbInfo
                  Ir.serializer.serialize(or, function($r, Pr) {
                    if (Pr) Cr(Pr)
                    else
                      try {
                        localStorage.setItem(Ir.keyPrefix + Zt, $r), xr(cr)
                      } catch (Dr) {
                        ;(Dr.name === 'QuotaExceededError' ||
                          Dr.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&
                          Cr(Dr),
                          Cr(Dr)
                      }
                  })
                })
              })
              return st(hr, er), hr
            }
            function rn(Zt, or) {
              if (
                ((or = dt.apply(this, arguments)),
                (Zt = (typeof Zt != 'function' && Zt) || {}),
                !Zt.name)
              ) {
                var er = this.config()
                ;(Zt.name = Zt.name || er.name),
                  (Zt.storeName = Zt.storeName || er.storeName)
              }
              var dr = this,
                hr
              return (
                Zt.name
                  ? (hr = new at(function(cr) {
                      Zt.storeName
                        ? cr(Pn(Zt, dr._defaultConfig))
                        : cr(Zt.name + '/')
                    }).then(function(cr) {
                      for (var xr = localStorage.length - 1; xr >= 0; xr--) {
                        var Cr = localStorage.key(xr)
                        Cr.indexOf(cr) === 0 && localStorage.removeItem(Cr)
                      }
                    }))
                  : (hr = at.reject('Invalid arguments')),
                st(hr, or),
                hr
              )
            }
            var bn = {
                _driver: 'localStorageWrapper',
                _initStorage: _n,
                _support: En(),
                iterate: Kr,
                getItem: wn,
                setItem: jr,
                removeItem: an,
                clear: hn,
                length: Sn,
                key: Vr,
                keys: In,
                dropInstance: rn,
              },
              ao = function(or, er) {
                return (
                  or === er ||
                  (typeof or == 'number' &&
                    typeof er == 'number' &&
                    isNaN(or) &&
                    isNaN(er))
                )
              },
              so = function(or, er) {
                for (var dr = or.length, hr = 0; hr < dr; ) {
                  if (ao(or[hr], er)) return !0
                  hr++
                }
                return !1
              },
              Xn =
                Array.isArray ||
                function(Zt) {
                  return Object.prototype.toString.call(Zt) === '[object Array]'
                },
              Ln = {},
              Zn = {},
              nn = { INDEXEDDB: tr, WEBSQL: Jr, LOCALSTORAGE: bn },
              lo = [
                nn.INDEXEDDB._driver,
                nn.WEBSQL._driver,
                nn.LOCALSTORAGE._driver,
              ],
              Wn = ['dropInstance'],
              Gn = [
                'clear',
                'getItem',
                'iterate',
                'key',
                'keys',
                'length',
                'removeItem',
                'setItem',
              ].concat(Wn),
              uo = {
                description: '',
                driver: lo.slice(),
                name: 'localforage',
                size: 4980736,
                storeName: 'keyvaluepairs',
                version: 1,
              }
            function co(Zt, or) {
              Zt[or] = function() {
                var er = arguments
                return Zt.ready().then(function() {
                  return Zt[or].apply(Zt, er)
                })
              }
            }
            function On() {
              for (var Zt = 1; Zt < arguments.length; Zt++) {
                var or = arguments[Zt]
                if (or)
                  for (var er in or)
                    or.hasOwnProperty(er) &&
                      (Xn(or[er])
                        ? (arguments[0][er] = or[er].slice())
                        : (arguments[0][er] = or[er]))
              }
              return arguments[0]
            }
            var fo = (function() {
                function Zt(or) {
                  tt(this, Zt)
                  for (var er in nn)
                    if (nn.hasOwnProperty(er)) {
                      var dr = nn[er],
                        hr = dr._driver
                      ;(this[er] = hr), Ln[hr] || this.defineDriver(dr)
                    }
                  ;(this._defaultConfig = On({}, uo)),
                    (this._config = On({}, this._defaultConfig, or)),
                    (this._driverSet = null),
                    (this._initDriver = null),
                    (this._ready = !1),
                    (this._dbInfo = null),
                    this._wrapLibraryMethodsWithReady(),
                    this.setDriver(this._config.driver).catch(function() {})
                }
                return (
                  (Zt.prototype.config = function(er) {
                    if ((typeof er > 'u' ? 'undefined' : et(er)) === 'object') {
                      if (this._ready)
                        return new Error(
                          "Can't call config() after localforage has been used."
                        )
                      for (var dr in er) {
                        if (
                          (dr === 'storeName' &&
                            (er[dr] = er[dr].replace(/\W/g, '_')),
                          dr === 'version' && typeof er[dr] != 'number')
                        )
                          return new Error('Database version must be a number.')
                        this._config[dr] = er[dr]
                      }
                      return 'driver' in er && er.driver
                        ? this.setDriver(this._config.driver)
                        : !0
                    } else
                      return typeof er == 'string'
                        ? this._config[er]
                        : this._config
                  }),
                  (Zt.prototype.defineDriver = function(er, dr, hr) {
                    var cr = new at(function(xr, Cr) {
                      try {
                        var Ir = er._driver,
                          $r = new Error(
                            'Custom driver not compliant; see https://mozilla.github.io/localForage/#definedriver'
                          )
                        if (!er._driver) {
                          Cr($r)
                          return
                        }
                        for (
                          var Pr = Gn.concat('_initStorage'),
                            Dr = 0,
                            Lr = Pr.length;
                          Dr < Lr;
                          Dr++
                        ) {
                          var Hr = Pr[Dr],
                            zr = !so(Wn, Hr)
                          if ((zr || er[Hr]) && typeof er[Hr] != 'function') {
                            Cr($r)
                            return
                          }
                        }
                        var Xr = function() {
                          for (
                            var jn = function(mo) {
                                return function() {
                                  var go = new Error(
                                      'Method ' +
                                        mo +
                                        ' is not implemented by the current driver'
                                    ),
                                    Jn = at.reject(go)
                                  return (
                                    st(Jn, arguments[arguments.length - 1]), Jn
                                  )
                                }
                              },
                              qn = 0,
                              ho = Wn.length;
                            qn < ho;
                            qn++
                          ) {
                            var Vn = Wn[qn]
                            er[Vn] || (er[Vn] = jn(Vn))
                          }
                        }
                        Xr()
                        var Zr = function(jn) {
                          Ln[Ir] &&
                            console.info(
                              'Redefining LocalForage driver: ' + Ir
                            ),
                            (Ln[Ir] = er),
                            (Zn[Ir] = jn),
                            xr()
                        }
                        '_support' in er
                          ? er._support && typeof er._support == 'function'
                            ? er._support().then(Zr, Cr)
                            : Zr(!!er._support)
                          : Zr(!0)
                      } catch (un) {
                        Cr(un)
                      }
                    })
                    return ut(cr, dr, hr), cr
                  }),
                  (Zt.prototype.driver = function() {
                    return this._driver || null
                  }),
                  (Zt.prototype.getDriver = function(er, dr, hr) {
                    var cr = Ln[er]
                      ? at.resolve(Ln[er])
                      : at.reject(new Error('Driver not found.'))
                    return ut(cr, dr, hr), cr
                  }),
                  (Zt.prototype.getSerializer = function(er) {
                    var dr = at.resolve(Or)
                    return ut(dr, er), dr
                  }),
                  (Zt.prototype.ready = function(er) {
                    var dr = this,
                      hr = dr._driverSet.then(function() {
                        return (
                          dr._ready === null && (dr._ready = dr._initDriver()),
                          dr._ready
                        )
                      })
                    return ut(hr, er, er), hr
                  }),
                  (Zt.prototype.setDriver = function(er, dr, hr) {
                    var cr = this
                    Xn(er) || (er = [er])
                    var xr = this._getSupportedDrivers(er)
                    function Cr() {
                      cr._config.driver = cr.driver()
                    }
                    function Ir(Dr) {
                      return (
                        cr._extend(Dr),
                        Cr(),
                        (cr._ready = cr._initStorage(cr._config)),
                        cr._ready
                      )
                    }
                    function $r(Dr) {
                      return function() {
                        var Lr = 0
                        function Hr() {
                          for (; Lr < Dr.length; ) {
                            var zr = Dr[Lr]
                            return (
                              Lr++,
                              (cr._dbInfo = null),
                              (cr._ready = null),
                              cr
                                .getDriver(zr)
                                .then(Ir)
                                .catch(Hr)
                            )
                          }
                          Cr()
                          var Xr = new Error(
                            'No available storage method found.'
                          )
                          return (cr._driverSet = at.reject(Xr)), cr._driverSet
                        }
                        return Hr()
                      }
                    }
                    var Pr =
                      this._driverSet !== null
                        ? this._driverSet.catch(function() {
                            return at.resolve()
                          })
                        : at.resolve()
                    return (
                      (this._driverSet = Pr.then(function() {
                        var Dr = xr[0]
                        return (
                          (cr._dbInfo = null),
                          (cr._ready = null),
                          cr.getDriver(Dr).then(function(Lr) {
                            ;(cr._driver = Lr._driver),
                              Cr(),
                              cr._wrapLibraryMethodsWithReady(),
                              (cr._initDriver = $r(xr))
                          })
                        )
                      }).catch(function() {
                        Cr()
                        var Dr = new Error('No available storage method found.')
                        return (cr._driverSet = at.reject(Dr)), cr._driverSet
                      })),
                      ut(this._driverSet, dr, hr),
                      this._driverSet
                    )
                  }),
                  (Zt.prototype.supports = function(er) {
                    return !!Zn[er]
                  }),
                  (Zt.prototype._extend = function(er) {
                    On(this, er)
                  }),
                  (Zt.prototype._getSupportedDrivers = function(er) {
                    for (var dr = [], hr = 0, cr = er.length; hr < cr; hr++) {
                      var xr = er[hr]
                      this.supports(xr) && dr.push(xr)
                    }
                    return dr
                  }),
                  (Zt.prototype._wrapLibraryMethodsWithReady = function() {
                    for (var er = 0, dr = Gn.length; er < dr; er++)
                      co(this, Gn[er])
                  }),
                  (Zt.prototype.createInstance = function(er) {
                    return new Zt(er)
                  }),
                  Zt
                )
              })(),
              po = new fo()
            j.exports = po
          },
          { 3: 3 },
        ],
      },
      {},
      [4]
    )(4)
  })
})(localforage$1)
var localforageExports = localforage$1.exports
const localforage = getDefaultExportFromCjs(localforageExports)
var rngBrowser = { exports: {} },
  getRandomValues =
    (typeof crypto < 'u' &&
      crypto.getRandomValues &&
      crypto.getRandomValues.bind(crypto)) ||
    (typeof msCrypto < 'u' &&
      typeof window.msCrypto.getRandomValues == 'function' &&
      msCrypto.getRandomValues.bind(msCrypto))
if (getRandomValues) {
  var rnds8 = new Uint8Array(16)
  rngBrowser.exports = function() {
    return getRandomValues(rnds8), rnds8
  }
} else {
  var rnds = new Array(16)
  rngBrowser.exports = function() {
    for (var a = 0, s; a < 16; a++)
      a & 3 || (s = Math.random() * 4294967296),
        (rnds[a] = (s >>> ((a & 3) << 3)) & 255)
    return rnds
  }
}
var rngBrowserExports = rngBrowser.exports,
  byteToHex = []
for (var i$1 = 0; i$1 < 256; ++i$1)
  byteToHex[i$1] = (i$1 + 256).toString(16).substr(1)
function bytesToUuid$2(o, a) {
  var s = a || 0,
    $ = byteToHex
  return [
    $[o[s++]],
    $[o[s++]],
    $[o[s++]],
    $[o[s++]],
    '-',
    $[o[s++]],
    $[o[s++]],
    '-',
    $[o[s++]],
    $[o[s++]],
    '-',
    $[o[s++]],
    $[o[s++]],
    '-',
    $[o[s++]],
    $[o[s++]],
    $[o[s++]],
    $[o[s++]],
    $[o[s++]],
    $[o[s++]],
  ].join('')
}
var bytesToUuid_1 = bytesToUuid$2,
  rng$1 = rngBrowserExports,
  bytesToUuid$1 = bytesToUuid_1,
  _nodeId,
  _clockseq,
  _lastMSecs = 0,
  _lastNSecs = 0
function v1$1(o, a, s) {
  var $ = (a && s) || 0,
    j = a || []
  o = o || {}
  var _e = o.node || _nodeId,
    et = o.clockseq !== void 0 ? o.clockseq : _clockseq
  if (_e == null || et == null) {
    var tt = rng$1()
    _e == null &&
      (_e = _nodeId = [tt[0] | 1, tt[1], tt[2], tt[3], tt[4], tt[5]]),
      et == null && (et = _clockseq = ((tt[6] << 8) | tt[7]) & 16383)
  }
  var rt = o.msecs !== void 0 ? o.msecs : new Date().getTime(),
    nt = o.nsecs !== void 0 ? o.nsecs : _lastNSecs + 1,
    it = rt - _lastMSecs + (nt - _lastNSecs) / 1e4
  if (
    (it < 0 && o.clockseq === void 0 && (et = (et + 1) & 16383),
    (it < 0 || rt > _lastMSecs) && o.nsecs === void 0 && (nt = 0),
    nt >= 1e4)
  )
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec")
  ;(_lastMSecs = rt), (_lastNSecs = nt), (_clockseq = et), (rt += 122192928e5)
  var ot = ((rt & 268435455) * 1e4 + nt) % 4294967296
  ;(j[$++] = (ot >>> 24) & 255),
    (j[$++] = (ot >>> 16) & 255),
    (j[$++] = (ot >>> 8) & 255),
    (j[$++] = ot & 255)
  var at = ((rt / 4294967296) * 1e4) & 268435455
  ;(j[$++] = (at >>> 8) & 255),
    (j[$++] = at & 255),
    (j[$++] = ((at >>> 24) & 15) | 16),
    (j[$++] = (at >>> 16) & 255),
    (j[$++] = (et >>> 8) | 128),
    (j[$++] = et & 255)
  for (var st = 0; st < 6; ++st) j[$ + st] = _e[st]
  return a || bytesToUuid$1(j)
}
var v1_1 = v1$1,
  rng = rngBrowserExports,
  bytesToUuid = bytesToUuid_1
function v4$1(o, a, s) {
  var $ = (a && s) || 0
  typeof o == 'string' &&
    ((a = o === 'binary' ? new Array(16) : null), (o = null)),
    (o = o || {})
  var j = o.random || (o.rng || rng)()
  if (((j[6] = (j[6] & 15) | 64), (j[8] = (j[8] & 63) | 128), a))
    for (var _e = 0; _e < 16; ++_e) a[$ + _e] = j[_e]
  return a || bytesToUuid(j)
}
var v4_1 = v4$1,
  v1 = v1_1,
  v4 = v4_1,
  uuid = v4
uuid.v1 = v1
uuid.v4 = v4
var uuid_1 = uuid
function formatMuiErrorMessage$1(o) {
  let a = 'https://mui.com/production-error/?code=' + o
  for (let s = 1; s < arguments.length; s += 1)
    a += '&args[]=' + encodeURIComponent(arguments[s])
  return 'Minified MUI error #' + o + '; visit ' + a + ' for the full message.'
}
const formatMuiErrorMessage = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: formatMuiErrorMessage$1 },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  THEME_ID = '$$material'
function memoize$3(o) {
  var a = Object.create(null)
  return function(s) {
    return a[s] === void 0 && (a[s] = o(s)), a[s]
  }
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,
  isPropValid = memoize$3(function(o) {
    return (
      reactPropsRegex.test(o) ||
      (o.charCodeAt(0) === 111 &&
        o.charCodeAt(1) === 110 &&
        o.charCodeAt(2) < 91)
    )
  }),
  isDevelopment$2 = !1
function sheetForTag(o) {
  if (o.sheet) return o.sheet
  for (var a = 0; a < document.styleSheets.length; a++)
    if (document.styleSheets[a].ownerNode === o) return document.styleSheets[a]
}
function createStyleElement(o) {
  var a = document.createElement('style')
  return (
    a.setAttribute('data-emotion', o.key),
    o.nonce !== void 0 && a.setAttribute('nonce', o.nonce),
    a.appendChild(document.createTextNode('')),
    a.setAttribute('data-s', ''),
    a
  )
}
var StyleSheet = (function() {
    function o(s) {
      var $ = this
      ;(this._insertTag = function(j) {
        var _e
        $.tags.length === 0
          ? $.insertionPoint
            ? (_e = $.insertionPoint.nextSibling)
            : $.prepend
            ? (_e = $.container.firstChild)
            : (_e = $.before)
          : (_e = $.tags[$.tags.length - 1].nextSibling),
          $.container.insertBefore(j, _e),
          $.tags.push(j)
      }),
        (this.isSpeedy = s.speedy === void 0 ? !isDevelopment$2 : s.speedy),
        (this.tags = []),
        (this.ctr = 0),
        (this.nonce = s.nonce),
        (this.key = s.key),
        (this.container = s.container),
        (this.prepend = s.prepend),
        (this.insertionPoint = s.insertionPoint),
        (this.before = null)
    }
    var a = o.prototype
    return (
      (a.hydrate = function($) {
        $.forEach(this._insertTag)
      }),
      (a.insert = function($) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
          this._insertTag(createStyleElement(this))
        var j = this.tags[this.tags.length - 1]
        if (this.isSpeedy) {
          var _e = sheetForTag(j)
          try {
            _e.insertRule($, _e.cssRules.length)
          } catch {}
        } else j.appendChild(document.createTextNode($))
        this.ctr++
      }),
      (a.flush = function() {
        this.tags.forEach(function($) {
          var j
          return (j = $.parentNode) == null ? void 0 : j.removeChild($)
        }),
          (this.tags = []),
          (this.ctr = 0)
      }),
      o
    )
  })(),
  MS = '-ms-',
  MOZ = '-moz-',
  WEBKIT = '-webkit-',
  COMMENT$1 = 'comm',
  RULESET = 'rule',
  DECLARATION = 'decl',
  IMPORT = '@import',
  KEYFRAMES = '@keyframes',
  LAYER = '@layer',
  abs = Math.abs,
  from = String.fromCharCode,
  assign$1 = Object.assign
function hash$2(o, a) {
  return charat(o, 0) ^ 45
    ? (((((((a << 2) ^ charat(o, 0)) << 2) ^ charat(o, 1)) << 2) ^
        charat(o, 2)) <<
        2) ^
        charat(o, 3)
    : 0
}
function trim$1(o) {
  return o.trim()
}
function match(o, a) {
  return (o = a.exec(o)) ? o[0] : o
}
function replace$1(o, a, s) {
  return o.replace(a, s)
}
function indexof(o, a) {
  return o.indexOf(a)
}
function charat(o, a) {
  return o.charCodeAt(a) | 0
}
function substr(o, a, s) {
  return o.slice(a, s)
}
function strlen(o) {
  return o.length
}
function sizeof(o) {
  return o.length
}
function append(o, a) {
  return a.push(o), o
}
function combine(o, a) {
  return o.map(a).join('')
}
var line = 1,
  column = 1,
  length = 0,
  position$1 = 0,
  character = 0,
  characters = ''
function node(o, a, s, $, j, _e, et) {
  return {
    value: o,
    root: a,
    parent: s,
    type: $,
    props: j,
    children: _e,
    line,
    column,
    length: et,
    return: '',
  }
}
function copy$2(o, a) {
  return assign$1(
    node('', null, null, '', null, null, 0),
    o,
    { length: -o.length },
    a
  )
}
function char() {
  return character
}
function prev() {
  return (
    (character = position$1 > 0 ? charat(characters, --position$1) : 0),
    column--,
    character === 10 && ((column = 1), line--),
    character
  )
}
function next() {
  return (
    (character = position$1 < length ? charat(characters, position$1++) : 0),
    column++,
    character === 10 && ((column = 1), line++),
    character
  )
}
function peek$2() {
  return charat(characters, position$1)
}
function caret() {
  return position$1
}
function slice$3(o, a) {
  return substr(characters, o, a)
}
function token(o) {
  switch (o) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4
    case 58:
      return 3
    case 34:
    case 39:
    case 40:
    case 91:
      return 2
    case 41:
    case 93:
      return 1
  }
  return 0
}
function alloc$1(o) {
  return (
    (line = column = 1),
    (length = strlen((characters = o))),
    (position$1 = 0),
    []
  )
}
function dealloc(o) {
  return (characters = ''), o
}
function delimit(o) {
  return trim$1(
    slice$3(position$1 - 1, delimiter(o === 91 ? o + 2 : o === 40 ? o + 1 : o))
  )
}
function whitespace(o) {
  for (; (character = peek$2()) && character < 33; ) next()
  return token(o) > 2 || token(character) > 3 ? '' : ' '
}
function escaping(o, a) {
  for (
    ;
    --a &&
    next() &&
    !(
      character < 48 ||
      character > 102 ||
      (character > 57 && character < 65) ||
      (character > 70 && character < 97)
    );

  );
  return slice$3(o, caret() + (a < 6 && peek$2() == 32 && next() == 32))
}
function delimiter(o) {
  for (; next(); )
    switch (character) {
      case o:
        return position$1
      case 34:
      case 39:
        o !== 34 && o !== 39 && delimiter(character)
        break
      case 40:
        o === 41 && delimiter(o)
        break
      case 92:
        next()
        break
    }
  return position$1
}
function commenter(o, a) {
  for (; next() && o + character !== 57; )
    if (o + character === 84 && peek$2() === 47) break
  return '/*' + slice$3(a, position$1 - 1) + '*' + from(o === 47 ? o : next())
}
function identifier(o) {
  for (; !token(peek$2()); ) next()
  return slice$3(o, position$1)
}
function compile(o) {
  return dealloc(
    parse$5('', null, null, null, [''], (o = alloc$1(o)), 0, [0], o)
  )
}
function parse$5(o, a, s, $, j, _e, et, tt, rt) {
  for (
    var nt = 0,
      it = 0,
      ot = et,
      at = 0,
      st = 0,
      ut = 0,
      ct = 1,
      dt = 1,
      ft = 1,
      mt = 0,
      vt = '',
      yt = j,
      pt = _e,
      ht = $,
      At = vt;
    dt;

  )
    switch (((ut = mt), (mt = next()))) {
      case 40:
        if (ut != 108 && charat(At, ot - 1) == 58) {
          indexof((At += replace$1(delimit(mt), '&', '&\f')), '&\f') != -1 &&
            (ft = -1)
          break
        }
      case 34:
      case 39:
      case 91:
        At += delimit(mt)
        break
      case 9:
      case 10:
      case 13:
      case 32:
        At += whitespace(ut)
        break
      case 92:
        At += escaping(caret() - 1, 7)
        continue
      case 47:
        switch (peek$2()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), a, s), rt)
            break
          default:
            At += '/'
        }
        break
      case 123 * ct:
        tt[nt++] = strlen(At) * ft
      case 125 * ct:
      case 59:
      case 0:
        switch (mt) {
          case 0:
          case 125:
            dt = 0
          case 59 + it:
            ft == -1 && (At = replace$1(At, /\f/g, '')),
              st > 0 &&
                strlen(At) - ot &&
                append(
                  st > 32
                    ? declaration(At + ';', $, s, ot - 1)
                    : declaration(replace$1(At, ' ', '') + ';', $, s, ot - 2),
                  rt
                )
            break
          case 59:
            At += ';'
          default:
            if (
              (append(
                (ht = ruleset(
                  At,
                  a,
                  s,
                  nt,
                  it,
                  j,
                  tt,
                  vt,
                  (yt = []),
                  (pt = []),
                  ot
                )),
                _e
              ),
              mt === 123)
            )
              if (it === 0) parse$5(At, a, ht, ht, yt, _e, ot, tt, pt)
              else
                switch (at === 99 && charat(At, 3) === 110 ? 100 : at) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$5(
                      o,
                      ht,
                      ht,
                      $ &&
                        append(
                          ruleset(o, ht, ht, 0, 0, j, tt, vt, j, (yt = []), ot),
                          pt
                        ),
                      j,
                      pt,
                      ot,
                      tt,
                      $ ? yt : pt
                    )
                    break
                  default:
                    parse$5(At, ht, ht, ht, [''], pt, 0, tt, pt)
                }
        }
        ;(nt = it = st = 0), (ct = ft = 1), (vt = At = ''), (ot = et)
        break
      case 58:
        ;(ot = 1 + strlen(At)), (st = ut)
      default:
        if (ct < 1) {
          if (mt == 123) --ct
          else if (mt == 125 && ct++ == 0 && prev() == 125) continue
        }
        switch (((At += from(mt)), mt * ct)) {
          case 38:
            ft = it > 0 ? 1 : ((At += '\f'), -1)
            break
          case 44:
            ;(tt[nt++] = (strlen(At) - 1) * ft), (ft = 1)
            break
          case 64:
            peek$2() === 45 && (At += delimit(next())),
              (at = peek$2()),
              (it = ot = strlen((vt = At += identifier(caret())))),
              mt++
            break
          case 45:
            ut === 45 && strlen(At) == 2 && (ct = 0)
        }
    }
  return _e
}
function ruleset(o, a, s, $, j, _e, et, tt, rt, nt, it) {
  for (
    var ot = j - 1,
      at = j === 0 ? _e : [''],
      st = sizeof(at),
      ut = 0,
      ct = 0,
      dt = 0;
    ut < $;
    ++ut
  )
    for (
      var ft = 0, mt = substr(o, ot + 1, (ot = abs((ct = et[ut])))), vt = o;
      ft < st;
      ++ft
    )
      (vt = trim$1(
        ct > 0 ? at[ft] + ' ' + mt : replace$1(mt, /&\f/g, at[ft])
      )) && (rt[dt++] = vt)
  return node(o, a, s, j === 0 ? RULESET : tt, rt, nt, it)
}
function comment(o, a, s) {
  return node(o, a, s, COMMENT$1, from(char()), substr(o, 2, -2), 0)
}
function declaration(o, a, s, $) {
  return node(o, a, s, DECLARATION, substr(o, 0, $), substr(o, $ + 1, -1), $)
}
function serialize(o, a) {
  for (var s = '', $ = sizeof(o), j = 0; j < $; j++) s += a(o[j], j, o, a) || ''
  return s
}
function stringify$2(o, a, s, $) {
  switch (o.type) {
    case LAYER:
      if (o.children.length) break
    case IMPORT:
    case DECLARATION:
      return (o.return = o.return || o.value)
    case COMMENT$1:
      return ''
    case KEYFRAMES:
      return (o.return = o.value + '{' + serialize(o.children, $) + '}')
    case RULESET:
      o.value = o.props.join(',')
  }
  return strlen((s = serialize(o.children, $)))
    ? (o.return = o.value + '{' + s + '}')
    : ''
}
function middleware(o) {
  var a = sizeof(o)
  return function(s, $, j, _e) {
    for (var et = '', tt = 0; tt < a; tt++) et += o[tt](s, $, j, _e) || ''
    return et
  }
}
function rulesheet(o) {
  return function(a) {
    a.root || ((a = a.return) && o(a))
  }
}
var identifierWithPointTracking = function(a, s, $) {
    for (
      var j = 0, _e = 0;
      (j = _e),
        (_e = peek$2()),
        j === 38 && _e === 12 && (s[$] = 1),
        !token(_e);

    )
      next()
    return slice$3(a, position$1)
  },
  toRules = function(a, s) {
    var $ = -1,
      j = 44
    do
      switch (token(j)) {
        case 0:
          j === 38 && peek$2() === 12 && (s[$] = 1),
            (a[$] += identifierWithPointTracking(position$1 - 1, s, $))
          break
        case 2:
          a[$] += delimit(j)
          break
        case 4:
          if (j === 44) {
            ;(a[++$] = peek$2() === 58 ? '&\f' : ''), (s[$] = a[$].length)
            break
          }
        default:
          a[$] += from(j)
      }
    while ((j = next()))
    return a
  },
  getRules = function(a, s) {
    return dealloc(toRules(alloc$1(a), s))
  },
  fixedElements = new WeakMap(),
  compat = function(a) {
    if (!(a.type !== 'rule' || !a.parent || a.length < 1)) {
      for (
        var s = a.value,
          $ = a.parent,
          j = a.column === $.column && a.line === $.line;
        $.type !== 'rule';

      )
        if ((($ = $.parent), !$)) return
      if (
        !(
          a.props.length === 1 &&
          s.charCodeAt(0) !== 58 &&
          !fixedElements.get($)
        ) &&
        !j
      ) {
        fixedElements.set(a, !0)
        for (
          var _e = [], et = getRules(s, _e), tt = $.props, rt = 0, nt = 0;
          rt < et.length;
          rt++
        )
          for (var it = 0; it < tt.length; it++, nt++)
            a.props[nt] = _e[rt]
              ? et[rt].replace(/&\f/g, tt[it])
              : tt[it] + ' ' + et[rt]
      }
    }
  },
  removeLabel = function(a) {
    if (a.type === 'decl') {
      var s = a.value
      s.charCodeAt(0) === 108 &&
        s.charCodeAt(2) === 98 &&
        ((a.return = ''), (a.value = ''))
    }
  }
function prefix$1(o, a) {
  switch (hash$2(o, a)) {
    case 5103:
      return WEBKIT + 'print-' + o + o
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + o + o
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + o + MOZ + o + MS + o + o
    case 6828:
    case 4268:
      return WEBKIT + o + MS + o + o
    case 6165:
      return WEBKIT + o + MS + 'flex-' + o + o
    case 5187:
      return (
        WEBKIT +
        o +
        replace$1(o, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') +
        o
      )
    case 5443:
      return (
        WEBKIT + o + MS + 'flex-item-' + replace$1(o, /flex-|-self/, '') + o
      )
    case 4675:
      return (
        WEBKIT +
        o +
        MS +
        'flex-line-pack' +
        replace$1(o, /align-content|flex-|-self/, '') +
        o
      )
    case 5548:
      return WEBKIT + o + MS + replace$1(o, 'shrink', 'negative') + o
    case 5292:
      return WEBKIT + o + MS + replace$1(o, 'basis', 'preferred-size') + o
    case 6060:
      return (
        WEBKIT +
        'box-' +
        replace$1(o, '-grow', '') +
        WEBKIT +
        o +
        MS +
        replace$1(o, 'grow', 'positive') +
        o
      )
    case 4554:
      return (
        WEBKIT + replace$1(o, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + o
      )
    case 6187:
      return (
        replace$1(
          replace$1(
            replace$1(o, /(zoom-|grab)/, WEBKIT + '$1'),
            /(image-set)/,
            WEBKIT + '$1'
          ),
          o,
          ''
        ) + o
      )
    case 5495:
    case 3959:
      return replace$1(o, /(image-set\([^]*)/, WEBKIT + '$1$`$1')
    case 4968:
      return (
        replace$1(
          replace$1(
            o,
            /(.+:)(flex-)?(.*)/,
            WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'
          ),
          /s.+-b[^;]+/,
          'justify'
        ) +
        WEBKIT +
        o +
        o
      )
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(o, /(.+)-inline(.+)/, WEBKIT + '$1$2') + o
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(o) - 1 - a > 6)
        switch (charat(o, a + 1)) {
          case 109:
            if (charat(o, a + 4) !== 45) break
          case 102:
            return (
              replace$1(
                o,
                /(.+:)(.+)-([^]+)/,
                '$1' +
                  WEBKIT +
                  '$2-$3$1' +
                  MOZ +
                  (charat(o, a + 3) == 108 ? '$3' : '$2-$3')
              ) + o
            )
          case 115:
            return ~indexof(o, 'stretch')
              ? prefix$1(replace$1(o, 'stretch', 'fill-available'), a) + o
              : o
        }
      break
    case 4949:
      if (charat(o, a + 1) !== 115) break
    case 6444:
      switch (charat(o, strlen(o) - 3 - (~indexof(o, '!important') && 10))) {
        case 107:
          return replace$1(o, ':', ':' + WEBKIT) + o
        case 101:
          return (
            replace$1(
              o,
              /(.+:)([^;!]+)(;|!.+)?/,
              '$1' +
                WEBKIT +
                (charat(o, 14) === 45 ? 'inline-' : '') +
                'box$3$1' +
                WEBKIT +
                '$2$3$1' +
                MS +
                '$2box$3'
            ) + o
          )
      }
      break
    case 5936:
      switch (charat(o, a + 11)) {
        case 114:
          return WEBKIT + o + MS + replace$1(o, /[svh]\w+-[tblr]{2}/, 'tb') + o
        case 108:
          return (
            WEBKIT + o + MS + replace$1(o, /[svh]\w+-[tblr]{2}/, 'tb-rl') + o
          )
        case 45:
          return WEBKIT + o + MS + replace$1(o, /[svh]\w+-[tblr]{2}/, 'lr') + o
      }
      return WEBKIT + o + MS + o + o
  }
  return o
}
var prefixer = function(a, s, $, j) {
    if (a.length > -1 && !a.return)
      switch (a.type) {
        case DECLARATION:
          a.return = prefix$1(a.value, a.length)
          break
        case KEYFRAMES:
          return serialize(
            [copy$2(a, { value: replace$1(a.value, '@', '@' + WEBKIT) })],
            j
          )
        case RULESET:
          if (a.length)
            return combine(a.props, function(_e) {
              switch (match(_e, /(::plac\w+|:read-\w+)/)) {
                case ':read-only':
                case ':read-write':
                  return serialize(
                    [
                      copy$2(a, {
                        props: [replace$1(_e, /:(read-\w+)/, ':' + MOZ + '$1')],
                      }),
                    ],
                    j
                  )
                case '::placeholder':
                  return serialize(
                    [
                      copy$2(a, {
                        props: [
                          replace$1(
                            _e,
                            /:(plac\w+)/,
                            ':' + WEBKIT + 'input-$1'
                          ),
                        ],
                      }),
                      copy$2(a, {
                        props: [replace$1(_e, /:(plac\w+)/, ':' + MOZ + '$1')],
                      }),
                      copy$2(a, {
                        props: [replace$1(_e, /:(plac\w+)/, MS + 'input-$1')],
                      }),
                    ],
                    j
                  )
              }
              return ''
            })
      }
  },
  defaultStylisPlugins = [prefixer],
  createCache = function(a) {
    var s = a.key
    if (s === 'css') {
      var $ = document.querySelectorAll('style[data-emotion]:not([data-s])')
      Array.prototype.forEach.call($, function(ct) {
        var dt = ct.getAttribute('data-emotion')
        dt.indexOf(' ') !== -1 &&
          (document.head.appendChild(ct), ct.setAttribute('data-s', ''))
      })
    }
    var j = a.stylisPlugins || defaultStylisPlugins,
      _e = {},
      et,
      tt = []
    ;(et = a.container || document.head),
      Array.prototype.forEach.call(
        document.querySelectorAll('style[data-emotion^="' + s + ' "]'),
        function(ct) {
          for (
            var dt = ct.getAttribute('data-emotion').split(' '), ft = 1;
            ft < dt.length;
            ft++
          )
            _e[dt[ft]] = !0
          tt.push(ct)
        }
      )
    var rt,
      nt = [compat, removeLabel]
    {
      var it,
        ot = [
          stringify$2,
          rulesheet(function(ct) {
            it.insert(ct)
          }),
        ],
        at = middleware(nt.concat(j, ot)),
        st = function(dt) {
          return serialize(compile(dt), at)
        }
      rt = function(dt, ft, mt, vt) {
        ;(it = mt),
          st(dt ? dt + '{' + ft.styles + '}' : ft.styles),
          vt && (ut.inserted[ft.name] = !0)
      }
    }
    var ut = {
      key: s,
      sheet: new StyleSheet({
        key: s,
        container: et,
        nonce: a.nonce,
        speedy: a.speedy,
        prepend: a.prepend,
        insertionPoint: a.insertionPoint,
      }),
      nonce: a.nonce,
      inserted: _e,
      registered: {},
      insert: rt,
    }
    return ut.sheet.hydrate(tt), ut
  },
  isBrowser$1 = !0
function getRegisteredStyles(o, a, s) {
  var $ = ''
  return (
    s.split(' ').forEach(function(j) {
      o[j] !== void 0 ? a.push(o[j] + ';') : ($ += j + ' ')
    }),
    $
  )
}
var registerStyles = function(a, s, $) {
    var j = a.key + '-' + s.name
    ;($ === !1 || isBrowser$1 === !1) &&
      a.registered[j] === void 0 &&
      (a.registered[j] = s.styles)
  },
  insertStyles = function(a, s, $) {
    registerStyles(a, s, $)
    var j = a.key + '-' + s.name
    if (a.inserted[s.name] === void 0) {
      var _e = s
      do a.insert(s === _e ? '.' + j : '', _e, a.sheet, !0), (_e = _e.next)
      while (_e !== void 0)
    }
  }
function murmur2(o) {
  for (var a = 0, s, $ = 0, j = o.length; j >= 4; ++$, j -= 4)
    (s =
      (o.charCodeAt($) & 255) |
      ((o.charCodeAt(++$) & 255) << 8) |
      ((o.charCodeAt(++$) & 255) << 16) |
      ((o.charCodeAt(++$) & 255) << 24)),
      (s = (s & 65535) * 1540483477 + (((s >>> 16) * 59797) << 16)),
      (s ^= s >>> 24),
      (a =
        ((s & 65535) * 1540483477 + (((s >>> 16) * 59797) << 16)) ^
        ((a & 65535) * 1540483477 + (((a >>> 16) * 59797) << 16)))
  switch (j) {
    case 3:
      a ^= (o.charCodeAt($ + 2) & 255) << 16
    case 2:
      a ^= (o.charCodeAt($ + 1) & 255) << 8
    case 1:
      ;(a ^= o.charCodeAt($) & 255),
        (a = (a & 65535) * 1540483477 + (((a >>> 16) * 59797) << 16))
  }
  return (
    (a ^= a >>> 13),
    (a = (a & 65535) * 1540483477 + (((a >>> 16) * 59797) << 16)),
    ((a ^ (a >>> 15)) >>> 0).toString(36)
  )
}
var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1,
  },
  isDevelopment$1 = !1,
  hyphenateRegex = /[A-Z]|^ms/g,
  animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
  isCustomProperty = function(a) {
    return a.charCodeAt(1) === 45
  },
  isProcessableValue = function(a) {
    return a != null && typeof a != 'boolean'
  },
  processStyleName = memoize$3(function(o) {
    return isCustomProperty(o)
      ? o
      : o.replace(hyphenateRegex, '-$&').toLowerCase()
  }),
  processStyleValue = function(a, s) {
    switch (a) {
      case 'animation':
      case 'animationName':
        if (typeof s == 'string')
          return s.replace(animationRegex, function($, j, _e) {
            return (cursor = { name: j, styles: _e, next: cursor }), j
          })
    }
    return unitlessKeys[a] !== 1 &&
      !isCustomProperty(a) &&
      typeof s == 'number' &&
      s !== 0
      ? s + 'px'
      : s
  },
  noComponentSelectorMessage =
    'Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.'
function handleInterpolation(o, a, s) {
  if (s == null) return ''
  var $ = s
  if ($.__emotion_styles !== void 0) return $
  switch (typeof s) {
    case 'boolean':
      return ''
    case 'object': {
      var j = s
      if (j.anim === 1)
        return (
          (cursor = { name: j.name, styles: j.styles, next: cursor }), j.name
        )
      var _e = s
      if (_e.styles !== void 0) {
        var et = _e.next
        if (et !== void 0)
          for (; et !== void 0; )
            (cursor = { name: et.name, styles: et.styles, next: cursor }),
              (et = et.next)
        var tt = _e.styles + ';'
        return tt
      }
      return createStringFromObject(o, a, s)
    }
    case 'function': {
      if (o !== void 0) {
        var rt = cursor,
          nt = s(o)
        return (cursor = rt), handleInterpolation(o, a, nt)
      }
      break
    }
  }
  var it = s
  if (a == null) return it
  var ot = a[it]
  return ot !== void 0 ? ot : it
}
function createStringFromObject(o, a, s) {
  var $ = ''
  if (Array.isArray(s))
    for (var j = 0; j < s.length; j++)
      $ += handleInterpolation(o, a, s[j]) + ';'
  else
    for (var _e in s) {
      var et = s[_e]
      if (typeof et != 'object') {
        var tt = et
        a != null && a[tt] !== void 0
          ? ($ += _e + '{' + a[tt] + '}')
          : isProcessableValue(tt) &&
            ($ += processStyleName(_e) + ':' + processStyleValue(_e, tt) + ';')
      } else {
        if (_e === 'NO_COMPONENT_SELECTOR' && isDevelopment$1)
          throw new Error(noComponentSelectorMessage)
        if (
          Array.isArray(et) &&
          typeof et[0] == 'string' &&
          (a == null || a[et[0]] === void 0)
        )
          for (var rt = 0; rt < et.length; rt++)
            isProcessableValue(et[rt]) &&
              ($ +=
                processStyleName(_e) +
                ':' +
                processStyleValue(_e, et[rt]) +
                ';')
        else {
          var nt = handleInterpolation(o, a, et)
          switch (_e) {
            case 'animation':
            case 'animationName': {
              $ += processStyleName(_e) + ':' + nt + ';'
              break
            }
            default:
              $ += _e + '{' + nt + '}'
          }
        }
      }
    }
  return $
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
  cursor
function serializeStyles(o, a, s) {
  if (
    o.length === 1 &&
    typeof o[0] == 'object' &&
    o[0] !== null &&
    o[0].styles !== void 0
  )
    return o[0]
  var $ = !0,
    j = ''
  cursor = void 0
  var _e = o[0]
  if (_e == null || _e.raw === void 0)
    ($ = !1), (j += handleInterpolation(s, a, _e))
  else {
    var et = _e
    j += et[0]
  }
  for (var tt = 1; tt < o.length; tt++)
    if (((j += handleInterpolation(s, a, o[tt])), $)) {
      var rt = _e
      j += rt[tt]
    }
  labelPattern.lastIndex = 0
  for (var nt = '', it; (it = labelPattern.exec(j)) !== null; )
    nt += '-' + it[1]
  var ot = murmur2(j) + nt
  return { name: ot, styles: j, next: cursor }
}
var syncFallback = function(a) {
    return a()
  },
  useInsertionEffect = React$6.useInsertionEffect
    ? React$6.useInsertionEffect
    : !1,
  useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback,
  useInsertionEffectWithLayoutFallback =
    useInsertionEffect || reactExports.useLayoutEffect,
  EmotionCacheContext = reactExports.createContext(
    typeof HTMLElement < 'u' ? createCache({ key: 'css' }) : null
  ),
  CacheProvider = EmotionCacheContext.Provider,
  withEmotionCache = function(a) {
    return reactExports.forwardRef(function(s, $) {
      var j = reactExports.useContext(EmotionCacheContext)
      return a(s, j, $)
    })
  },
  ThemeContext$1 = reactExports.createContext({}),
  _extends$3 = { exports: {} },
  hasRequired_extends
function require_extends() {
  return (
    hasRequired_extends ||
      ((hasRequired_extends = 1),
      (function(o) {
        function a() {
          return (
            (o.exports = a = Object.assign
              ? Object.assign.bind()
              : function(s) {
                  for (var $ = 1; $ < arguments.length; $++) {
                    var j = arguments[$]
                    for (var _e in j)
                      ({}.hasOwnProperty.call(j, _e) && (s[_e] = j[_e]))
                  }
                  return s
                }),
            (o.exports.__esModule = !0),
            (o.exports.default = o.exports),
            a.apply(null, arguments)
          )
        }
        ;(o.exports = a),
          (o.exports.__esModule = !0),
          (o.exports.default = o.exports)
      })(_extends$3)),
    _extends$3.exports
  )
}
require_extends()
var Global = withEmotionCache(function(o, a) {
  var s = o.styles,
    $ = serializeStyles([s], void 0, reactExports.useContext(ThemeContext$1)),
    j = reactExports.useRef()
  return (
    useInsertionEffectWithLayoutFallback(
      function() {
        var _e = a.key + '-global',
          et = new a.sheet.constructor({
            key: _e,
            nonce: a.sheet.nonce,
            container: a.sheet.container,
            speedy: a.sheet.isSpeedy,
          }),
          tt = !1,
          rt = document.querySelector(
            'style[data-emotion="' + _e + ' ' + $.name + '"]'
          )
        return (
          a.sheet.tags.length && (et.before = a.sheet.tags[0]),
          rt !== null &&
            ((tt = !0), rt.setAttribute('data-emotion', _e), et.hydrate([rt])),
          (j.current = [et, tt]),
          function() {
            et.flush()
          }
        )
      },
      [a]
    ),
    useInsertionEffectWithLayoutFallback(
      function() {
        var _e = j.current,
          et = _e[0],
          tt = _e[1]
        if (tt) {
          _e[1] = !1
          return
        }
        if (
          ($.next !== void 0 && insertStyles(a, $.next, !0), et.tags.length)
        ) {
          var rt = et.tags[et.tags.length - 1].nextElementSibling
          ;(et.before = rt), et.flush()
        }
        a.insert('', $, et, !1)
      },
      [a, $.name]
    ),
    null
  )
})
function css$2() {
  for (var o = arguments.length, a = new Array(o), s = 0; s < o; s++)
    a[s] = arguments[s]
  return serializeStyles(a)
}
var keyframes = function() {
    var a = css$2.apply(void 0, arguments),
      s = 'animation-' + a.name
    return {
      name: s,
      styles: '@keyframes ' + s + '{' + a.styles + '}',
      anim: 1,
      toString: function() {
        return '_EMO_' + this.name + '_' + this.styles + '_EMO_'
      },
    }
  },
  testOmitPropsOnStringTag = isPropValid,
  testOmitPropsOnComponent = function(a) {
    return a !== 'theme'
  },
  getDefaultShouldForwardProp = function(a) {
    return typeof a == 'string' && a.charCodeAt(0) > 96
      ? testOmitPropsOnStringTag
      : testOmitPropsOnComponent
  },
  composeShouldForwardProps = function(a, s, $) {
    var j
    if (s) {
      var _e = s.shouldForwardProp
      j =
        a.__emotion_forwardProp && _e
          ? function(et) {
              return a.__emotion_forwardProp(et) && _e(et)
            }
          : _e
    }
    return typeof j != 'function' && $ && (j = a.__emotion_forwardProp), j
  },
  isDevelopment = !1,
  Insertion = function(a) {
    var s = a.cache,
      $ = a.serialized,
      j = a.isStringTag
    return (
      registerStyles(s, $, j),
      useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(s, $, j)
      }),
      null
    )
  },
  createStyled$3 = function o(a, s) {
    var $ = a.__emotion_real === a,
      j = ($ && a.__emotion_base) || a,
      _e,
      et
    s !== void 0 && ((_e = s.label), (et = s.target))
    var tt = composeShouldForwardProps(a, s, $),
      rt = tt || getDefaultShouldForwardProp(j),
      nt = !rt('as')
    return function() {
      var it = arguments,
        ot =
          $ && a.__emotion_styles !== void 0 ? a.__emotion_styles.slice(0) : []
      if (
        (_e !== void 0 && ot.push('label:' + _e + ';'),
        it[0] == null || it[0].raw === void 0)
      )
        ot.push.apply(ot, it)
      else {
        ot.push(it[0][0])
        for (var at = it.length, st = 1; st < at; st++)
          ot.push(it[st], it[0][st])
      }
      var ut = withEmotionCache(function(ct, dt, ft) {
        var mt = (nt && ct.as) || j,
          vt = '',
          yt = [],
          pt = ct
        if (ct.theme == null) {
          pt = {}
          for (var ht in ct) pt[ht] = ct[ht]
          pt.theme = reactExports.useContext(ThemeContext$1)
        }
        typeof ct.className == 'string'
          ? (vt = getRegisteredStyles(dt.registered, yt, ct.className))
          : ct.className != null && (vt = ct.className + ' ')
        var At = serializeStyles(ot.concat(yt), dt.registered, pt)
        ;(vt += dt.key + '-' + At.name), et !== void 0 && (vt += ' ' + et)
        var wt = nt && tt === void 0 ? getDefaultShouldForwardProp(mt) : rt,
          Ct = {}
        for (var Dt in ct) (nt && Dt === 'as') || (wt(Dt) && (Ct[Dt] = ct[Dt]))
        return (
          (Ct.className = vt),
          ft && (Ct.ref = ft),
          reactExports.createElement(
            reactExports.Fragment,
            null,
            reactExports.createElement(Insertion, {
              cache: dt,
              serialized: At,
              isStringTag: typeof mt == 'string',
            }),
            reactExports.createElement(mt, Ct)
          )
        )
      })
      return (
        (ut.displayName =
          _e !== void 0
            ? _e
            : 'Styled(' +
              (typeof j == 'string'
                ? j
                : j.displayName || j.name || 'Component') +
              ')'),
        (ut.defaultProps = a.defaultProps),
        (ut.__emotion_real = ut),
        (ut.__emotion_base = j),
        (ut.__emotion_styles = ot),
        (ut.__emotion_forwardProp = tt),
        Object.defineProperty(ut, 'toString', {
          value: function() {
            return et === void 0 && isDevelopment
              ? 'NO_COMPONENT_SELECTOR'
              : '.' + et
          },
        }),
        (ut.withComponent = function(ct, dt) {
          return o(
            ct,
            _extends$5({}, s, dt, {
              shouldForwardProp: composeShouldForwardProps(ut, dt, !0),
            })
          ).apply(void 0, ot)
        }),
        ut
      )
    }
  },
  tags = [
    'a',
    'abbr',
    'address',
    'area',
    'article',
    'aside',
    'audio',
    'b',
    'base',
    'bdi',
    'bdo',
    'big',
    'blockquote',
    'body',
    'br',
    'button',
    'canvas',
    'caption',
    'cite',
    'code',
    'col',
    'colgroup',
    'data',
    'datalist',
    'dd',
    'del',
    'details',
    'dfn',
    'dialog',
    'div',
    'dl',
    'dt',
    'em',
    'embed',
    'fieldset',
    'figcaption',
    'figure',
    'footer',
    'form',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'head',
    'header',
    'hgroup',
    'hr',
    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'keygen',
    'label',
    'legend',
    'li',
    'link',
    'main',
    'map',
    'mark',
    'marquee',
    'menu',
    'menuitem',
    'meta',
    'meter',
    'nav',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'output',
    'p',
    'param',
    'picture',
    'pre',
    'progress',
    'q',
    'rp',
    'rt',
    'ruby',
    's',
    'samp',
    'script',
    'section',
    'select',
    'small',
    'source',
    'span',
    'strong',
    'style',
    'sub',
    'summary',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'time',
    'title',
    'tr',
    'track',
    'u',
    'ul',
    'var',
    'video',
    'wbr',
    'circle',
    'clipPath',
    'defs',
    'ellipse',
    'foreignObject',
    'g',
    'image',
    'line',
    'linearGradient',
    'mask',
    'path',
    'pattern',
    'polygon',
    'polyline',
    'radialGradient',
    'rect',
    'stop',
    'svg',
    'text',
    'tspan',
  ],
  newStyled = createStyled$3.bind()
tags.forEach(function(o) {
  newStyled[o] = newStyled(o)
})
let cache$1
typeof document == 'object' &&
  (cache$1 = createCache({ key: 'css', prepend: !0 }))
function StyledEngineProvider(o) {
  const { injectFirst: a, children: s } = o
  return a && cache$1
    ? jsxRuntimeExports.jsx(CacheProvider, { value: cache$1, children: s })
    : s
}
function isEmpty$4(o) {
  return o == null || Object.keys(o).length === 0
}
function GlobalStyles$2(o) {
  const { styles: a, defaultTheme: s = {} } = o,
    $ = typeof a == 'function' ? j => a(isEmpty$4(j) ? s : j) : a
  return jsxRuntimeExports.jsx(Global, { styles: $ })
}
function styled$2(o, a) {
  return newStyled(o, a)
}
const internal_processStyles = (o, a) => {
    Array.isArray(o.__emotion_styles) &&
      (o.__emotion_styles = a(o.__emotion_styles))
  },
  styledEngine = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        GlobalStyles: GlobalStyles$2,
        StyledEngineProvider,
        ThemeContext: ThemeContext$1,
        css: css$2,
        default: styled$2,
        internal_processStyles,
        keyframes,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function isPlainObject$1(o) {
  if (typeof o != 'object' || o === null) return !1
  const a = Object.getPrototypeOf(o)
  return (
    (a === null ||
      a === Object.prototype ||
      Object.getPrototypeOf(a) === null) &&
    !(Symbol.toStringTag in o) &&
    !(Symbol.iterator in o)
  )
}
function deepClone(o) {
  if (!isPlainObject$1(o)) return o
  const a = {}
  return (
    Object.keys(o).forEach(s => {
      a[s] = deepClone(o[s])
    }),
    a
  )
}
function deepmerge$1(o, a, s = { clone: !0 }) {
  const $ = s.clone ? _extends$5({}, o) : o
  return (
    isPlainObject$1(o) &&
      isPlainObject$1(a) &&
      Object.keys(a).forEach(j => {
        isPlainObject$1(a[j]) &&
        Object.prototype.hasOwnProperty.call(o, j) &&
        isPlainObject$1(o[j])
          ? ($[j] = deepmerge$1(o[j], a[j], s))
          : s.clone
          ? ($[j] = isPlainObject$1(a[j]) ? deepClone(a[j]) : a[j])
          : ($[j] = a[j])
      }),
    $
  )
}
const deepmerge = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: deepmerge$1, isPlainObject: isPlainObject$1 },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  _excluded$1n = ['values', 'unit', 'step'],
  sortBreakpointsValues = o => {
    const a = Object.keys(o).map(s => ({ key: s, val: o[s] })) || []
    return (
      a.sort((s, $) => s.val - $.val),
      a.reduce((s, $) => _extends$5({}, s, { [$.key]: $.val }), {})
    )
  }
function createBreakpoints(o) {
  const {
      values: a = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
      unit: s = 'px',
      step: $ = 5,
    } = o,
    j = _objectWithoutPropertiesLoose$3(o, _excluded$1n),
    _e = sortBreakpointsValues(a),
    et = Object.keys(_e)
  function tt(at) {
    return `@media (min-width:${typeof a[at] == 'number' ? a[at] : at}${s})`
  }
  function rt(at) {
    return `@media (max-width:${(typeof a[at] == 'number' ? a[at] : at) -
      $ / 100}${s})`
  }
  function nt(at, st) {
    const ut = et.indexOf(st)
    return `@media (min-width:${
      typeof a[at] == 'number' ? a[at] : at
    }${s}) and (max-width:${(ut !== -1 && typeof a[et[ut]] == 'number'
      ? a[et[ut]]
      : st) -
      $ / 100}${s})`
  }
  function it(at) {
    return et.indexOf(at) + 1 < et.length
      ? nt(at, et[et.indexOf(at) + 1])
      : tt(at)
  }
  function ot(at) {
    const st = et.indexOf(at)
    return st === 0
      ? tt(et[1])
      : st === et.length - 1
      ? rt(et[st])
      : nt(at, et[et.indexOf(at) + 1]).replace('@media', '@media not all and')
  }
  return _extends$5(
    {
      keys: et,
      values: _e,
      up: tt,
      down: rt,
      between: nt,
      only: it,
      not: ot,
      unit: s,
    },
    j
  )
}
const shape = { borderRadius: 4 }
function merge$1(o, a) {
  return a ? deepmerge$1(o, a, { clone: !1 }) : o
}
const values$1 = { xs: 0, sm: 600, md: 900, lg: 1200, xl: 1536 },
  defaultBreakpoints = {
    keys: ['xs', 'sm', 'md', 'lg', 'xl'],
    up: o => `@media (min-width:${values$1[o]}px)`,
  }
function handleBreakpoints(o, a, s) {
  const $ = o.theme || {}
  if (Array.isArray(a)) {
    const _e = $.breakpoints || defaultBreakpoints
    return a.reduce(
      (et, tt, rt) => ((et[_e.up(_e.keys[rt])] = s(a[rt])), et),
      {}
    )
  }
  if (typeof a == 'object') {
    const _e = $.breakpoints || defaultBreakpoints
    return Object.keys(a).reduce((et, tt) => {
      if (Object.keys(_e.values || values$1).indexOf(tt) !== -1) {
        const rt = _e.up(tt)
        et[rt] = s(a[tt], tt)
      } else {
        const rt = tt
        et[rt] = a[rt]
      }
      return et
    }, {})
  }
  return s(a)
}
function createEmptyBreakpointObject(o = {}) {
  var a
  return (
    ((a = o.keys) == null
      ? void 0
      : a.reduce(($, j) => {
          const _e = o.up(j)
          return ($[_e] = {}), $
        }, {})) || {}
  )
}
function removeUnusedBreakpoints(o, a) {
  return o.reduce((s, $) => {
    const j = s[$]
    return (!j || Object.keys(j).length === 0) && delete s[$], s
  }, a)
}
function mergeBreakpointsInOrder(o, ...a) {
  const s = createEmptyBreakpointObject(o),
    $ = [s, ...a].reduce((j, _e) => deepmerge$1(j, _e), {})
  return removeUnusedBreakpoints(Object.keys(s), $)
}
function computeBreakpointsBase(o, a) {
  if (typeof o != 'object') return {}
  const s = {},
    $ = Object.keys(a)
  return (
    Array.isArray(o)
      ? $.forEach((j, _e) => {
          _e < o.length && (s[j] = !0)
        })
      : $.forEach(j => {
          o[j] != null && (s[j] = !0)
        }),
    s
  )
}
function resolveBreakpointValues({ values: o, breakpoints: a, base: s }) {
  const $ = s || computeBreakpointsBase(o, a),
    j = Object.keys($)
  if (j.length === 0) return o
  let _e
  return j.reduce(
    (et, tt, rt) => (
      Array.isArray(o)
        ? ((et[tt] = o[rt] != null ? o[rt] : o[_e]), (_e = rt))
        : typeof o == 'object'
        ? ((et[tt] = o[tt] != null ? o[tt] : o[_e]), (_e = tt))
        : (et[tt] = o),
      et
    ),
    {}
  )
}
function capitalize$2(o) {
  if (typeof o != 'string') throw new Error(formatMuiErrorMessage$1(7))
  return o.charAt(0).toUpperCase() + o.slice(1)
}
const capitalize$1 = Object.freeze(
  Object.defineProperty(
    { __proto__: null, default: capitalize$2 },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function getPath(o, a, s = !0) {
  if (!a || typeof a != 'string') return null
  if (o && o.vars && s) {
    const $ = `vars.${a}`
      .split('.')
      .reduce((j, _e) => (j && j[_e] ? j[_e] : null), o)
    if ($ != null) return $
  }
  return a.split('.').reduce(($, j) => ($ && $[j] != null ? $[j] : null), o)
}
function getStyleValue$1(o, a, s, $ = s) {
  let j
  return (
    typeof o == 'function'
      ? (j = o(s))
      : Array.isArray(o)
      ? (j = o[s] || $)
      : (j = getPath(o, s) || $),
    a && (j = a(j, $, o)),
    j
  )
}
function style$2(o) {
  const { prop: a, cssProperty: s = o.prop, themeKey: $, transform: j } = o,
    _e = et => {
      if (et[a] == null) return null
      const tt = et[a],
        rt = et.theme,
        nt = getPath(rt, $) || {}
      return handleBreakpoints(et, tt, ot => {
        let at = getStyleValue$1(nt, j, ot)
        return (
          ot === at &&
            typeof ot == 'string' &&
            (at = getStyleValue$1(
              nt,
              j,
              `${a}${ot === 'default' ? '' : capitalize$2(ot)}`,
              ot
            )),
          s === !1 ? at : { [s]: at }
        )
      })
    }
  return (_e.propTypes = {}), (_e.filterProps = [a]), _e
}
function memoize$2(o) {
  const a = {}
  return s => (a[s] === void 0 && (a[s] = o(s)), a[s])
}
const properties = { m: 'margin', p: 'padding' },
  directions = {
    t: 'Top',
    r: 'Right',
    b: 'Bottom',
    l: 'Left',
    x: ['Left', 'Right'],
    y: ['Top', 'Bottom'],
  },
  aliases = { marginX: 'mx', marginY: 'my', paddingX: 'px', paddingY: 'py' },
  getCssProperties = memoize$2(o => {
    if (o.length > 2)
      if (aliases[o]) o = aliases[o]
      else return [o]
    const [a, s] = o.split(''),
      $ = properties[a],
      j = directions[s] || ''
    return Array.isArray(j) ? j.map(_e => $ + _e) : [$ + j]
  }),
  marginKeys = [
    'm',
    'mt',
    'mr',
    'mb',
    'ml',
    'mx',
    'my',
    'margin',
    'marginTop',
    'marginRight',
    'marginBottom',
    'marginLeft',
    'marginX',
    'marginY',
    'marginInline',
    'marginInlineStart',
    'marginInlineEnd',
    'marginBlock',
    'marginBlockStart',
    'marginBlockEnd',
  ],
  paddingKeys = [
    'p',
    'pt',
    'pr',
    'pb',
    'pl',
    'px',
    'py',
    'padding',
    'paddingTop',
    'paddingRight',
    'paddingBottom',
    'paddingLeft',
    'paddingX',
    'paddingY',
    'paddingInline',
    'paddingInlineStart',
    'paddingInlineEnd',
    'paddingBlock',
    'paddingBlockStart',
    'paddingBlockEnd',
  ]
;[...marginKeys, ...paddingKeys]
function createUnaryUnit(o, a, s, $) {
  var j
  const _e = (j = getPath(o, a, !1)) != null ? j : s
  return typeof _e == 'number'
    ? et => (typeof et == 'string' ? et : _e * et)
    : Array.isArray(_e)
    ? et => (typeof et == 'string' ? et : _e[et])
    : typeof _e == 'function'
    ? _e
    : () => {}
}
function createUnarySpacing(o) {
  return createUnaryUnit(o, 'spacing', 8)
}
function getValue(o, a) {
  if (typeof a == 'string' || a == null) return a
  const s = Math.abs(a),
    $ = o(s)
  return a >= 0 ? $ : typeof $ == 'number' ? -$ : `-${$}`
}
function getStyleFromPropValue(o, a) {
  return s => o.reduce(($, j) => (($[j] = getValue(a, s)), $), {})
}
function resolveCssProperty(o, a, s, $) {
  if (a.indexOf(s) === -1) return null
  const j = getCssProperties(s),
    _e = getStyleFromPropValue(j, $),
    et = o[s]
  return handleBreakpoints(o, et, _e)
}
function style$1(o, a) {
  const s = createUnarySpacing(o.theme)
  return Object.keys(o)
    .map($ => resolveCssProperty(o, a, $, s))
    .reduce(merge$1, {})
}
function margin(o) {
  return style$1(o, marginKeys)
}
margin.propTypes = {}
margin.filterProps = marginKeys
function padding(o) {
  return style$1(o, paddingKeys)
}
padding.propTypes = {}
padding.filterProps = paddingKeys
function createSpacing(o = 8) {
  if (o.mui) return o
  const a = createUnarySpacing({ spacing: o }),
    s = (...$) =>
      ($.length === 0 ? [1] : $)
        .map(_e => {
          const et = a(_e)
          return typeof et == 'number' ? `${et}px` : et
        })
        .join(' ')
  return (s.mui = !0), s
}
function compose(...o) {
  const a = o.reduce(
      ($, j) => (
        j.filterProps.forEach(_e => {
          $[_e] = j
        }),
        $
      ),
      {}
    ),
    s = $ =>
      Object.keys($).reduce((j, _e) => (a[_e] ? merge$1(j, a[_e]($)) : j), {})
  return (
    (s.propTypes = {}),
    (s.filterProps = o.reduce(($, j) => $.concat(j.filterProps), [])),
    s
  )
}
function borderTransform(o) {
  return typeof o != 'number' ? o : `${o}px solid`
}
function createBorderStyle(o, a) {
  return style$2({ prop: o, themeKey: 'borders', transform: a })
}
const border = createBorderStyle('border', borderTransform),
  borderTop = createBorderStyle('borderTop', borderTransform),
  borderRight = createBorderStyle('borderRight', borderTransform),
  borderBottom = createBorderStyle('borderBottom', borderTransform),
  borderLeft = createBorderStyle('borderLeft', borderTransform),
  borderColor = createBorderStyle('borderColor'),
  borderTopColor = createBorderStyle('borderTopColor'),
  borderRightColor = createBorderStyle('borderRightColor'),
  borderBottomColor = createBorderStyle('borderBottomColor'),
  borderLeftColor = createBorderStyle('borderLeftColor'),
  outline = createBorderStyle('outline', borderTransform),
  outlineColor = createBorderStyle('outlineColor'),
  borderRadius = o => {
    if (o.borderRadius !== void 0 && o.borderRadius !== null) {
      const a = createUnaryUnit(o.theme, 'shape.borderRadius', 4),
        s = $ => ({ borderRadius: getValue(a, $) })
      return handleBreakpoints(o, o.borderRadius, s)
    }
    return null
  }
borderRadius.propTypes = {}
borderRadius.filterProps = ['borderRadius']
compose(
  border,
  borderTop,
  borderRight,
  borderBottom,
  borderLeft,
  borderColor,
  borderTopColor,
  borderRightColor,
  borderBottomColor,
  borderLeftColor,
  borderRadius,
  outline,
  outlineColor
)
const gap = o => {
  if (o.gap !== void 0 && o.gap !== null) {
    const a = createUnaryUnit(o.theme, 'spacing', 8),
      s = $ => ({ gap: getValue(a, $) })
    return handleBreakpoints(o, o.gap, s)
  }
  return null
}
gap.propTypes = {}
gap.filterProps = ['gap']
const columnGap = o => {
  if (o.columnGap !== void 0 && o.columnGap !== null) {
    const a = createUnaryUnit(o.theme, 'spacing', 8),
      s = $ => ({ columnGap: getValue(a, $) })
    return handleBreakpoints(o, o.columnGap, s)
  }
  return null
}
columnGap.propTypes = {}
columnGap.filterProps = ['columnGap']
const rowGap = o => {
  if (o.rowGap !== void 0 && o.rowGap !== null) {
    const a = createUnaryUnit(o.theme, 'spacing', 8),
      s = $ => ({ rowGap: getValue(a, $) })
    return handleBreakpoints(o, o.rowGap, s)
  }
  return null
}
rowGap.propTypes = {}
rowGap.filterProps = ['rowGap']
const gridColumn = style$2({ prop: 'gridColumn' }),
  gridRow = style$2({ prop: 'gridRow' }),
  gridAutoFlow = style$2({ prop: 'gridAutoFlow' }),
  gridAutoColumns = style$2({ prop: 'gridAutoColumns' }),
  gridAutoRows = style$2({ prop: 'gridAutoRows' }),
  gridTemplateColumns = style$2({ prop: 'gridTemplateColumns' }),
  gridTemplateRows = style$2({ prop: 'gridTemplateRows' }),
  gridTemplateAreas = style$2({ prop: 'gridTemplateAreas' }),
  gridArea = style$2({ prop: 'gridArea' })
compose(
  gap,
  columnGap,
  rowGap,
  gridColumn,
  gridRow,
  gridAutoFlow,
  gridAutoColumns,
  gridAutoRows,
  gridTemplateColumns,
  gridTemplateRows,
  gridTemplateAreas,
  gridArea
)
function paletteTransform(o, a) {
  return a === 'grey' ? a : o
}
const color = style$2({
    prop: 'color',
    themeKey: 'palette',
    transform: paletteTransform,
  }),
  bgcolor = style$2({
    prop: 'bgcolor',
    cssProperty: 'backgroundColor',
    themeKey: 'palette',
    transform: paletteTransform,
  }),
  backgroundColor = style$2({
    prop: 'backgroundColor',
    themeKey: 'palette',
    transform: paletteTransform,
  })
compose(color, bgcolor, backgroundColor)
function sizingTransform(o) {
  return o <= 1 && o !== 0 ? `${o * 100}%` : o
}
const width = style$2({ prop: 'width', transform: sizingTransform }),
  maxWidth = o => {
    if (o.maxWidth !== void 0 && o.maxWidth !== null) {
      const a = s => {
        var $, j
        const _e =
          (($ = o.theme) == null ||
          ($ = $.breakpoints) == null ||
          ($ = $.values) == null
            ? void 0
            : $[s]) || values$1[s]
        return _e
          ? ((j = o.theme) == null || (j = j.breakpoints) == null
              ? void 0
              : j.unit) !== 'px'
            ? { maxWidth: `${_e}${o.theme.breakpoints.unit}` }
            : { maxWidth: _e }
          : { maxWidth: sizingTransform(s) }
      }
      return handleBreakpoints(o, o.maxWidth, a)
    }
    return null
  }
maxWidth.filterProps = ['maxWidth']
const minWidth = style$2({ prop: 'minWidth', transform: sizingTransform }),
  height = style$2({ prop: 'height', transform: sizingTransform }),
  maxHeight = style$2({ prop: 'maxHeight', transform: sizingTransform }),
  minHeight = style$2({ prop: 'minHeight', transform: sizingTransform })
style$2({ prop: 'size', cssProperty: 'width', transform: sizingTransform })
style$2({ prop: 'size', cssProperty: 'height', transform: sizingTransform })
const boxSizing = style$2({ prop: 'boxSizing' })
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing)
const defaultSxConfig = {
  border: { themeKey: 'borders', transform: borderTransform },
  borderTop: { themeKey: 'borders', transform: borderTransform },
  borderRight: { themeKey: 'borders', transform: borderTransform },
  borderBottom: { themeKey: 'borders', transform: borderTransform },
  borderLeft: { themeKey: 'borders', transform: borderTransform },
  borderColor: { themeKey: 'palette' },
  borderTopColor: { themeKey: 'palette' },
  borderRightColor: { themeKey: 'palette' },
  borderBottomColor: { themeKey: 'palette' },
  borderLeftColor: { themeKey: 'palette' },
  outline: { themeKey: 'borders', transform: borderTransform },
  outlineColor: { themeKey: 'palette' },
  borderRadius: { themeKey: 'shape.borderRadius', style: borderRadius },
  color: { themeKey: 'palette', transform: paletteTransform },
  bgcolor: {
    themeKey: 'palette',
    cssProperty: 'backgroundColor',
    transform: paletteTransform,
  },
  backgroundColor: { themeKey: 'palette', transform: paletteTransform },
  p: { style: padding },
  pt: { style: padding },
  pr: { style: padding },
  pb: { style: padding },
  pl: { style: padding },
  px: { style: padding },
  py: { style: padding },
  padding: { style: padding },
  paddingTop: { style: padding },
  paddingRight: { style: padding },
  paddingBottom: { style: padding },
  paddingLeft: { style: padding },
  paddingX: { style: padding },
  paddingY: { style: padding },
  paddingInline: { style: padding },
  paddingInlineStart: { style: padding },
  paddingInlineEnd: { style: padding },
  paddingBlock: { style: padding },
  paddingBlockStart: { style: padding },
  paddingBlockEnd: { style: padding },
  m: { style: margin },
  mt: { style: margin },
  mr: { style: margin },
  mb: { style: margin },
  ml: { style: margin },
  mx: { style: margin },
  my: { style: margin },
  margin: { style: margin },
  marginTop: { style: margin },
  marginRight: { style: margin },
  marginBottom: { style: margin },
  marginLeft: { style: margin },
  marginX: { style: margin },
  marginY: { style: margin },
  marginInline: { style: margin },
  marginInlineStart: { style: margin },
  marginInlineEnd: { style: margin },
  marginBlock: { style: margin },
  marginBlockStart: { style: margin },
  marginBlockEnd: { style: margin },
  displayPrint: {
    cssProperty: !1,
    transform: o => ({ '@media print': { display: o } }),
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  gap: { style: gap },
  rowGap: { style: rowGap },
  columnGap: { style: columnGap },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  position: {},
  zIndex: { themeKey: 'zIndex' },
  top: {},
  right: {},
  bottom: {},
  left: {},
  boxShadow: { themeKey: 'shadows' },
  width: { transform: sizingTransform },
  maxWidth: { style: maxWidth },
  minWidth: { transform: sizingTransform },
  height: { transform: sizingTransform },
  maxHeight: { transform: sizingTransform },
  minHeight: { transform: sizingTransform },
  boxSizing: {},
  fontFamily: { themeKey: 'typography' },
  fontSize: { themeKey: 'typography' },
  fontStyle: { themeKey: 'typography' },
  fontWeight: { themeKey: 'typography' },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: { cssProperty: !1, themeKey: 'typography' },
}
function objectsHaveSameKeys(...o) {
  const a = o.reduce(($, j) => $.concat(Object.keys(j)), []),
    s = new Set(a)
  return o.every($ => s.size === Object.keys($).length)
}
function callIfFn(o, a) {
  return typeof o == 'function' ? o(a) : o
}
function unstable_createStyleFunctionSx() {
  function o(s, $, j, _e) {
    const et = { [s]: $, theme: j },
      tt = _e[s]
    if (!tt) return { [s]: $ }
    const { cssProperty: rt = s, themeKey: nt, transform: it, style: ot } = tt
    if ($ == null) return null
    if (nt === 'typography' && $ === 'inherit') return { [s]: $ }
    const at = getPath(j, nt) || {}
    return ot
      ? ot(et)
      : handleBreakpoints(et, $, ut => {
          let ct = getStyleValue$1(at, it, ut)
          return (
            ut === ct &&
              typeof ut == 'string' &&
              (ct = getStyleValue$1(
                at,
                it,
                `${s}${ut === 'default' ? '' : capitalize$2(ut)}`,
                ut
              )),
            rt === !1 ? ct : { [rt]: ct }
          )
        })
  }
  function a(s) {
    var $
    const { sx: j, theme: _e = {} } = s || {}
    if (!j) return null
    const et = ($ = _e.unstable_sxConfig) != null ? $ : defaultSxConfig
    function tt(rt) {
      let nt = rt
      if (typeof rt == 'function') nt = rt(_e)
      else if (typeof rt != 'object') return rt
      if (!nt) return null
      const it = createEmptyBreakpointObject(_e.breakpoints),
        ot = Object.keys(it)
      let at = it
      return (
        Object.keys(nt).forEach(st => {
          const ut = callIfFn(nt[st], _e)
          if (ut != null)
            if (typeof ut == 'object')
              if (et[st]) at = merge$1(at, o(st, ut, _e, et))
              else {
                const ct = handleBreakpoints({ theme: _e }, ut, dt => ({
                  [st]: dt,
                }))
                objectsHaveSameKeys(ct, ut)
                  ? (at[st] = a({ sx: ut, theme: _e }))
                  : (at = merge$1(at, ct))
              }
            else at = merge$1(at, o(st, ut, _e, et))
        }),
        removeUnusedBreakpoints(ot, at)
      )
    }
    return Array.isArray(j) ? j.map(tt) : tt(j)
  }
  return a
}
const styleFunctionSx$1 = unstable_createStyleFunctionSx()
styleFunctionSx$1.filterProps = ['sx']
function applyStyles$2(o, a) {
  const s = this
  return s.vars && typeof s.getColorSchemeSelector == 'function'
    ? {
        [s.getColorSchemeSelector(o).replace(/(\[[^\]]+\])/, '*:where($1)')]: a,
      }
    : s.palette.mode === o
    ? a
    : {}
}
const _excluded$1m = ['breakpoints', 'palette', 'spacing', 'shape']
function createTheme$2(o = {}, ...a) {
  const {
      breakpoints: s = {},
      palette: $ = {},
      spacing: j,
      shape: _e = {},
    } = o,
    et = _objectWithoutPropertiesLoose$3(o, _excluded$1m),
    tt = createBreakpoints(s),
    rt = createSpacing(j)
  let nt = deepmerge$1(
    {
      breakpoints: tt,
      direction: 'ltr',
      components: {},
      palette: _extends$5({ mode: 'light' }, $),
      spacing: rt,
      shape: _extends$5({}, shape, _e),
    },
    et
  )
  return (
    (nt.applyStyles = applyStyles$2),
    (nt = a.reduce((it, ot) => deepmerge$1(it, ot), nt)),
    (nt.unstable_sxConfig = _extends$5(
      {},
      defaultSxConfig,
      et == null ? void 0 : et.unstable_sxConfig
    )),
    (nt.unstable_sx = function(ot) {
      return styleFunctionSx$1({ sx: ot, theme: this })
    }),
    nt
  )
}
const createTheme$1 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      default: createTheme$2,
      private_createBreakpoints: createBreakpoints,
      unstable_applyStyles: applyStyles$2,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function isObjectEmpty$1(o) {
  return Object.keys(o).length === 0
}
function useTheme$4(o = null) {
  const a = reactExports.useContext(ThemeContext$1)
  return !a || isObjectEmpty$1(a) ? o : a
}
const systemDefaultTheme$2 = createTheme$2()
function useTheme$3(o = systemDefaultTheme$2) {
  return useTheme$4(o)
}
function GlobalStyles$1({ styles: o, themeId: a, defaultTheme: s = {} }) {
  const $ = useTheme$3(s),
    j = typeof o == 'function' ? o((a && $[a]) || $) : o
  return jsxRuntimeExports.jsx(GlobalStyles$2, { styles: j })
}
const _excluded$1l = ['sx'],
  splitProps = o => {
    var a, s
    const $ = { systemProps: {}, otherProps: {} },
      j =
        (a =
          o == null || (s = o.theme) == null ? void 0 : s.unstable_sxConfig) !=
        null
          ? a
          : defaultSxConfig
    return (
      Object.keys(o).forEach(_e => {
        j[_e] ? ($.systemProps[_e] = o[_e]) : ($.otherProps[_e] = o[_e])
      }),
      $
    )
  }
function extendSxProp(o) {
  const { sx: a } = o,
    s = _objectWithoutPropertiesLoose$3(o, _excluded$1l),
    { systemProps: $, otherProps: j } = splitProps(s)
  let _e
  return (
    Array.isArray(a)
      ? (_e = [$, ...a])
      : typeof a == 'function'
      ? (_e = (...et) => {
          const tt = a(...et)
          return isPlainObject$1(tt) ? _extends$5({}, $, tt) : $
        })
      : (_e = _extends$5({}, $, a)),
    _extends$5({}, j, { sx: _e })
  )
}
const styleFunctionSx = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        default: styleFunctionSx$1,
        extendSxProp,
        unstable_createStyleFunctionSx,
        unstable_defaultSxConfig: defaultSxConfig,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  defaultGenerator = o => o,
  createClassNameGenerator = () => {
    let o = defaultGenerator
    return {
      configure(a) {
        o = a
      },
      generate(a) {
        return o(a)
      },
      reset() {
        o = defaultGenerator
      },
    }
  },
  ClassNameGenerator = createClassNameGenerator()
function r$2(o) {
  var a,
    s,
    $ = ''
  if (typeof o == 'string' || typeof o == 'number') $ += o
  else if (typeof o == 'object')
    if (Array.isArray(o)) {
      var j = o.length
      for (a = 0; a < j; a++)
        o[a] && (s = r$2(o[a])) && ($ && ($ += ' '), ($ += s))
    } else for (s in o) o[s] && ($ && ($ += ' '), ($ += s))
  return $
}
function clsx$1() {
  for (var o, a, s = 0, $ = '', j = arguments.length; s < j; s++)
    (o = arguments[s]) && (a = r$2(o)) && ($ && ($ += ' '), ($ += a))
  return $
}
const _excluded$1k = ['className', 'component']
function createBox(o = {}) {
  const {
      themeId: a,
      defaultTheme: s,
      defaultClassName: $ = 'MuiBox-root',
      generateClassName: j,
    } = o,
    _e = styled$2('div', {
      shouldForwardProp: tt => tt !== 'theme' && tt !== 'sx' && tt !== 'as',
    })(styleFunctionSx$1)
  return reactExports.forwardRef(function(rt, nt) {
    const it = useTheme$3(s),
      ot = extendSxProp(rt),
      { className: at, component: st = 'div' } = ot,
      ut = _objectWithoutPropertiesLoose$3(ot, _excluded$1k)
    return jsxRuntimeExports.jsx(
      _e,
      _extends$5(
        {
          as: st,
          ref: nt,
          className: clsx$1(at, j ? j($) : $),
          theme: (a && it[a]) || it,
        },
        ut
      )
    )
  })
}
const globalStateClasses = {
  active: 'active',
  checked: 'checked',
  completed: 'completed',
  disabled: 'disabled',
  error: 'error',
  expanded: 'expanded',
  focused: 'focused',
  focusVisible: 'focusVisible',
  open: 'open',
  readOnly: 'readOnly',
  required: 'required',
  selected: 'selected',
}
function generateUtilityClass(o, a, s = 'Mui') {
  const $ = globalStateClasses[a]
  return $ ? `${s}-${$}` : `${ClassNameGenerator.generate(o)}-${a}`
}
function generateUtilityClasses(o, a, s = 'Mui') {
  const $ = {}
  return (
    a.forEach(j => {
      $[j] = generateUtilityClass(o, j, s)
    }),
    $
  )
}
var reactIs$1 = { exports: {} },
  reactIs_production_min$1 = {}
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b$1 = Symbol.for('react.element'),
  c$2 = Symbol.for('react.portal'),
  d$1 = Symbol.for('react.fragment'),
  e$1 = Symbol.for('react.strict_mode'),
  f$1 = Symbol.for('react.profiler'),
  g$4 = Symbol.for('react.provider'),
  h$1 = Symbol.for('react.context'),
  k$1 = Symbol.for('react.server_context'),
  l$1 = Symbol.for('react.forward_ref'),
  m$1 = Symbol.for('react.suspense'),
  n$1 = Symbol.for('react.suspense_list'),
  p$1 = Symbol.for('react.memo'),
  q$1 = Symbol.for('react.lazy'),
  t$1 = Symbol.for('react.offscreen'),
  u
u = Symbol.for('react.module.reference')
function v$1(o) {
  if (typeof o == 'object' && o !== null) {
    var a = o.$$typeof
    switch (a) {
      case b$1:
        switch (((o = o.type), o)) {
          case d$1:
          case f$1:
          case e$1:
          case m$1:
          case n$1:
            return o
          default:
            switch (((o = o && o.$$typeof), o)) {
              case k$1:
              case h$1:
              case l$1:
              case q$1:
              case p$1:
              case g$4:
                return o
              default:
                return a
            }
        }
      case c$2:
        return a
    }
  }
}
reactIs_production_min$1.ContextConsumer = h$1
reactIs_production_min$1.ContextProvider = g$4
reactIs_production_min$1.Element = b$1
reactIs_production_min$1.ForwardRef = l$1
reactIs_production_min$1.Fragment = d$1
reactIs_production_min$1.Lazy = q$1
reactIs_production_min$1.Memo = p$1
reactIs_production_min$1.Portal = c$2
reactIs_production_min$1.Profiler = f$1
reactIs_production_min$1.StrictMode = e$1
reactIs_production_min$1.Suspense = m$1
reactIs_production_min$1.SuspenseList = n$1
reactIs_production_min$1.isAsyncMode = function() {
  return !1
}
reactIs_production_min$1.isConcurrentMode = function() {
  return !1
}
reactIs_production_min$1.isContextConsumer = function(o) {
  return v$1(o) === h$1
}
reactIs_production_min$1.isContextProvider = function(o) {
  return v$1(o) === g$4
}
reactIs_production_min$1.isElement = function(o) {
  return typeof o == 'object' && o !== null && o.$$typeof === b$1
}
reactIs_production_min$1.isForwardRef = function(o) {
  return v$1(o) === l$1
}
reactIs_production_min$1.isFragment = function(o) {
  return v$1(o) === d$1
}
reactIs_production_min$1.isLazy = function(o) {
  return v$1(o) === q$1
}
reactIs_production_min$1.isMemo = function(o) {
  return v$1(o) === p$1
}
reactIs_production_min$1.isPortal = function(o) {
  return v$1(o) === c$2
}
reactIs_production_min$1.isProfiler = function(o) {
  return v$1(o) === f$1
}
reactIs_production_min$1.isStrictMode = function(o) {
  return v$1(o) === e$1
}
reactIs_production_min$1.isSuspense = function(o) {
  return v$1(o) === m$1
}
reactIs_production_min$1.isSuspenseList = function(o) {
  return v$1(o) === n$1
}
reactIs_production_min$1.isValidElementType = function(o) {
  return (
    typeof o == 'string' ||
    typeof o == 'function' ||
    o === d$1 ||
    o === f$1 ||
    o === e$1 ||
    o === m$1 ||
    o === n$1 ||
    o === t$1 ||
    (typeof o == 'object' &&
      o !== null &&
      (o.$$typeof === q$1 ||
        o.$$typeof === p$1 ||
        o.$$typeof === g$4 ||
        o.$$typeof === h$1 ||
        o.$$typeof === l$1 ||
        o.$$typeof === u ||
        o.getModuleId !== void 0))
  )
}
reactIs_production_min$1.typeOf = v$1
reactIs$1.exports = reactIs_production_min$1
var reactIsExports$1 = reactIs$1.exports
const fnNameMatchRegex = /^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/
function getFunctionName(o) {
  const a = `${o}`.match(fnNameMatchRegex)
  return (a && a[1]) || ''
}
function getFunctionComponentName(o, a = '') {
  return o.displayName || o.name || getFunctionName(o) || a
}
function getWrappedName(o, a, s) {
  const $ = getFunctionComponentName(a)
  return o.displayName || ($ !== '' ? `${s}(${$})` : s)
}
function getDisplayName$1(o) {
  if (o != null) {
    if (typeof o == 'string') return o
    if (typeof o == 'function') return getFunctionComponentName(o, 'Component')
    if (typeof o == 'object')
      switch (o.$$typeof) {
        case reactIsExports$1.ForwardRef:
          return getWrappedName(o, o.render, 'ForwardRef')
        case reactIsExports$1.Memo:
          return getWrappedName(o, o.type, 'memo')
        default:
          return
      }
  }
}
const getDisplayName = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: getDisplayName$1, getFunctionName },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  _excluded$1j = ['ownerState'],
  _excluded2$7 = ['variants'],
  _excluded3$3 = [
    'name',
    'slot',
    'skipVariantsResolver',
    'skipSx',
    'overridesResolver',
  ]
function isEmpty$3(o) {
  return Object.keys(o).length === 0
}
function isStringTag$1(o) {
  return typeof o == 'string' && o.charCodeAt(0) > 96
}
function shouldForwardProp$1(o) {
  return o !== 'ownerState' && o !== 'theme' && o !== 'sx' && o !== 'as'
}
const systemDefaultTheme$1 = createTheme$2(),
  lowercaseFirstLetter$1 = o => o && o.charAt(0).toLowerCase() + o.slice(1)
function resolveTheme$1({ defaultTheme: o, theme: a, themeId: s }) {
  return isEmpty$3(a) ? o : a[s] || a
}
function defaultOverridesResolver$1(o) {
  return o ? (a, s) => s[o] : null
}
function processStyleArg$1(o, a) {
  let { ownerState: s } = a,
    $ = _objectWithoutPropertiesLoose$3(a, _excluded$1j)
  const j = typeof o == 'function' ? o(_extends$5({ ownerState: s }, $)) : o
  if (Array.isArray(j))
    return j.flatMap(_e =>
      processStyleArg$1(_e, _extends$5({ ownerState: s }, $))
    )
  if (j && typeof j == 'object' && Array.isArray(j.variants)) {
    const { variants: _e = [] } = j
    let tt = _objectWithoutPropertiesLoose$3(j, _excluded2$7)
    return (
      _e.forEach(rt => {
        let nt = !0
        typeof rt.props == 'function'
          ? (nt = rt.props(_extends$5({ ownerState: s }, $, s)))
          : Object.keys(rt.props).forEach(it => {
              ;(s == null ? void 0 : s[it]) !== rt.props[it] &&
                $[it] !== rt.props[it] &&
                (nt = !1)
            }),
          nt &&
            (Array.isArray(tt) || (tt = [tt]),
            tt.push(
              typeof rt.style == 'function'
                ? rt.style(_extends$5({ ownerState: s }, $, s))
                : rt.style
            ))
      }),
      tt
    )
  }
  return j
}
function createStyled$2(o = {}) {
  const {
      themeId: a,
      defaultTheme: s = systemDefaultTheme$1,
      rootShouldForwardProp: $ = shouldForwardProp$1,
      slotShouldForwardProp: j = shouldForwardProp$1,
    } = o,
    _e = et =>
      styleFunctionSx$1(
        _extends$5({}, et, {
          theme: resolveTheme$1(
            _extends$5({}, et, { defaultTheme: s, themeId: a })
          ),
        })
      )
  return (
    (_e.__mui_systemSx = !0),
    (et, tt = {}) => {
      internal_processStyles(et, pt =>
        pt.filter(ht => !(ht != null && ht.__mui_systemSx))
      )
      const {
          name: rt,
          slot: nt,
          skipVariantsResolver: it,
          skipSx: ot,
          overridesResolver: at = defaultOverridesResolver$1(
            lowercaseFirstLetter$1(nt)
          ),
        } = tt,
        st = _objectWithoutPropertiesLoose$3(tt, _excluded3$3),
        ut = it !== void 0 ? it : (nt && nt !== 'Root' && nt !== 'root') || !1,
        ct = ot || !1
      let dt,
        ft = shouldForwardProp$1
      nt === 'Root' || nt === 'root'
        ? (ft = $)
        : nt
        ? (ft = j)
        : isStringTag$1(et) && (ft = void 0)
      const mt = styled$2(
          et,
          _extends$5({ shouldForwardProp: ft, label: dt }, st)
        ),
        vt = pt =>
          (typeof pt == 'function' && pt.__emotion_real !== pt) ||
          isPlainObject$1(pt)
            ? ht =>
                processStyleArg$1(
                  pt,
                  _extends$5({}, ht, {
                    theme: resolveTheme$1({
                      theme: ht.theme,
                      defaultTheme: s,
                      themeId: a,
                    }),
                  })
                )
            : pt,
        yt = (pt, ...ht) => {
          let At = vt(pt)
          const wt = ht ? ht.map(vt) : []
          rt &&
            at &&
            wt.push(jt => {
              const Et = resolveTheme$1(
                _extends$5({}, jt, { defaultTheme: s, themeId: a })
              )
              if (
                !Et.components ||
                !Et.components[rt] ||
                !Et.components[rt].styleOverrides
              )
                return null
              const St = Et.components[rt].styleOverrides,
                Bt = {}
              return (
                Object.entries(St).forEach(([Mt, Ut]) => {
                  Bt[Mt] = processStyleArg$1(
                    Ut,
                    _extends$5({}, jt, { theme: Et })
                  )
                }),
                at(jt, Bt)
              )
            }),
            rt &&
              !ut &&
              wt.push(jt => {
                var Et
                const St = resolveTheme$1(
                    _extends$5({}, jt, { defaultTheme: s, themeId: a })
                  ),
                  Bt =
                    St == null ||
                    (Et = St.components) == null ||
                    (Et = Et[rt]) == null
                      ? void 0
                      : Et.variants
                return processStyleArg$1(
                  { variants: Bt },
                  _extends$5({}, jt, { theme: St })
                )
              }),
            ct || wt.push(_e)
          const Ct = wt.length - ht.length
          if (Array.isArray(pt) && Ct > 0) {
            const jt = new Array(Ct).fill('')
            ;(At = [...pt, ...jt]), (At.raw = [...pt.raw, ...jt])
          }
          const Dt = mt(At, ...wt)
          return et.muiName && (Dt.muiName = et.muiName), Dt
        }
      return mt.withConfig && (yt.withConfig = mt.withConfig), yt
    }
  )
}
const styled$1 = createStyled$2()
function resolveProps(o, a) {
  const s = _extends$5({}, a)
  return (
    Object.keys(o).forEach($ => {
      if ($.toString().match(/^(components|slots)$/))
        s[$] = _extends$5({}, o[$], s[$])
      else if ($.toString().match(/^(componentsProps|slotProps)$/)) {
        const j = o[$] || {},
          _e = a[$]
        ;(s[$] = {}),
          !_e || !Object.keys(_e)
            ? (s[$] = j)
            : !j || !Object.keys(j)
            ? (s[$] = _e)
            : ((s[$] = _extends$5({}, _e)),
              Object.keys(j).forEach(et => {
                s[$][et] = resolveProps(j[et], _e[et])
              }))
      } else s[$] === void 0 && (s[$] = o[$])
    }),
    s
  )
}
function getThemeProps$1(o) {
  const { theme: a, name: s, props: $ } = o
  return !a ||
    !a.components ||
    !a.components[s] ||
    !a.components[s].defaultProps
    ? $
    : resolveProps(a.components[s].defaultProps, $)
}
function useThemeProps({ props: o, name: a, defaultTheme: s, themeId: $ }) {
  let j = useTheme$3(s)
  return $ && (j = j[$] || j), getThemeProps$1({ theme: j, name: a, props: o })
}
const useEnhancedEffect$1 =
  typeof window < 'u' ? reactExports.useLayoutEffect : reactExports.useEffect
function clamp$2(o, a = Number.MIN_SAFE_INTEGER, s = Number.MAX_SAFE_INTEGER) {
  return Math.max(a, Math.min(o, s))
}
const clamp$1 = Object.freeze(
  Object.defineProperty(
    { __proto__: null, default: clamp$2 },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function clampWrapper$1(o, a = 0, s = 1) {
  return clamp$2(o, a, s)
}
function hexToRgb$1(o) {
  o = o.slice(1)
  const a = new RegExp(`.{1,${o.length >= 6 ? 2 : 1}}`, 'g')
  let s = o.match(a)
  return (
    s && s[0].length === 1 && (s = s.map($ => $ + $)),
    s
      ? `rgb${s.length === 4 ? 'a' : ''}(${s
          .map(($, j) =>
            j < 3
              ? parseInt($, 16)
              : Math.round((parseInt($, 16) / 255) * 1e3) / 1e3
          )
          .join(', ')})`
      : ''
  )
}
function decomposeColor$1(o) {
  if (o.type) return o
  if (o.charAt(0) === '#') return decomposeColor$1(hexToRgb$1(o))
  const a = o.indexOf('('),
    s = o.substring(0, a)
  if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(s) === -1)
    throw new Error(formatMuiErrorMessage$1(9, o))
  let $ = o.substring(a + 1, o.length - 1),
    j
  if (s === 'color') {
    if (
      (($ = $.split(' ')),
      (j = $.shift()),
      $.length === 4 && $[3].charAt(0) === '/' && ($[3] = $[3].slice(1)),
      ['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(
        j
      ) === -1)
    )
      throw new Error(formatMuiErrorMessage$1(10, j))
  } else $ = $.split(',')
  return (
    ($ = $.map(_e => parseFloat(_e))), { type: s, values: $, colorSpace: j }
  )
}
function recomposeColor$1(o) {
  const { type: a, colorSpace: s } = o
  let { values: $ } = o
  return (
    a.indexOf('rgb') !== -1
      ? ($ = $.map((j, _e) => (_e < 3 ? parseInt(j, 10) : j)))
      : a.indexOf('hsl') !== -1 && (($[1] = `${$[1]}%`), ($[2] = `${$[2]}%`)),
    a.indexOf('color') !== -1
      ? ($ = `${s} ${$.join(' ')}`)
      : ($ = `${$.join(', ')}`),
    `${a}(${$})`
  )
}
function hslToRgb$2(o) {
  o = decomposeColor$1(o)
  const { values: a } = o,
    s = a[0],
    $ = a[1] / 100,
    j = a[2] / 100,
    _e = $ * Math.min(j, 1 - j),
    et = (nt, it = (nt + s / 30) % 12) =>
      j - _e * Math.max(Math.min(it - 3, 9 - it, 1), -1)
  let tt = 'rgb'
  const rt = [
    Math.round(et(0) * 255),
    Math.round(et(8) * 255),
    Math.round(et(4) * 255),
  ]
  return (
    o.type === 'hsla' && ((tt += 'a'), rt.push(a[3])),
    recomposeColor$1({ type: tt, values: rt })
  )
}
function getLuminance$1(o) {
  o = decomposeColor$1(o)
  let a =
    o.type === 'hsl' || o.type === 'hsla'
      ? decomposeColor$1(hslToRgb$2(o)).values
      : o.values
  return (
    (a = a.map(
      s => (
        o.type !== 'color' && (s /= 255),
        s <= 0.03928 ? s / 12.92 : ((s + 0.055) / 1.055) ** 2.4
      )
    )),
    Number((0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2]).toFixed(3))
  )
}
function darken$2(o, a) {
  if (
    ((o = decomposeColor$1(o)),
    (a = clampWrapper$1(a)),
    o.type.indexOf('hsl') !== -1)
  )
    o.values[2] *= 1 - a
  else if (o.type.indexOf('rgb') !== -1 || o.type.indexOf('color') !== -1)
    for (let s = 0; s < 3; s += 1) o.values[s] *= 1 - a
  return recomposeColor$1(o)
}
function lighten$2(o, a) {
  if (
    ((o = decomposeColor$1(o)),
    (a = clampWrapper$1(a)),
    o.type.indexOf('hsl') !== -1)
  )
    o.values[2] += (100 - o.values[2]) * a
  else if (o.type.indexOf('rgb') !== -1)
    for (let s = 0; s < 3; s += 1) o.values[s] += (255 - o.values[s]) * a
  else if (o.type.indexOf('color') !== -1)
    for (let s = 0; s < 3; s += 1) o.values[s] += (1 - o.values[s]) * a
  return recomposeColor$1(o)
}
function emphasize$1(o, a = 0.15) {
  return getLuminance$1(o) > 0.5 ? darken$2(o, a) : lighten$2(o, a)
}
function createChainedFunction$1(...o) {
  return o.reduce(
    (a, s) =>
      s == null
        ? a
        : function(...j) {
            a.apply(this, j), s.apply(this, j)
          },
    () => {}
  )
}
function debounce$4(o, a = 166) {
  let s
  function $(...j) {
    const _e = () => {
      o.apply(this, j)
    }
    clearTimeout(s), (s = setTimeout(_e, a))
  }
  return (
    ($.clear = () => {
      clearTimeout(s)
    }),
    $
  )
}
function deprecatedPropType(o, a) {
  return () => null
}
function isMuiElement(o, a) {
  var s, $
  return (
    reactExports.isValidElement(o) &&
    a.indexOf(
      (s = o.type.muiName) != null
        ? s
        : ($ = o.type) == null ||
          ($ = $._payload) == null ||
          ($ = $.value) == null
        ? void 0
        : $.muiName
    ) !== -1
  )
}
function ownerDocument(o) {
  return (o && o.ownerDocument) || document
}
function ownerWindow(o) {
  return ownerDocument(o).defaultView || window
}
function requirePropFactory(o, a) {
  return () => null
}
function setRef(o, a) {
  typeof o == 'function' ? o(a) : o && (o.current = a)
}
let globalId = 0
function useGlobalId(o) {
  const [a, s] = reactExports.useState(o),
    $ = o || a
  return (
    reactExports.useEffect(() => {
      a == null && ((globalId += 1), s(`mui-${globalId}`))
    }, [a]),
    $
  )
}
const maybeReactUseId = React$6.useId
function useId(o) {
  if (maybeReactUseId !== void 0) {
    const a = maybeReactUseId()
    return o ?? a
  }
  return useGlobalId(o)
}
function unsupportedProp(o, a, s, $, j) {
  return null
}
function useControlled({
  controlled: o,
  default: a,
  name: s,
  state: $ = 'value',
}) {
  const { current: j } = reactExports.useRef(o !== void 0),
    [_e, et] = reactExports.useState(a),
    tt = j ? o : _e,
    rt = reactExports.useCallback(nt => {
      j || et(nt)
    }, [])
  return [tt, rt]
}
function useEventCallback$1(o) {
  const a = reactExports.useRef(o)
  return (
    useEnhancedEffect$1(() => {
      a.current = o
    }),
    reactExports.useRef((...s) => (0, a.current)(...s)).current
  )
}
function useForkRef(...o) {
  return reactExports.useMemo(
    () =>
      o.every(a => a == null)
        ? null
        : a => {
            o.forEach(s => {
              setRef(s, a)
            })
          },
    o
  )
}
const UNINITIALIZED = {}
function useLazyRef(o, a) {
  const s = reactExports.useRef(UNINITIALIZED)
  return s.current === UNINITIALIZED && (s.current = o(a)), s
}
const EMPTY$1 = []
function useOnMount(o) {
  reactExports.useEffect(o, EMPTY$1)
}
class Timeout {
  constructor() {
    ;(this.currentId = null),
      (this.clear = () => {
        this.currentId !== null &&
          (clearTimeout(this.currentId), (this.currentId = null))
      }),
      (this.disposeEffect = () => this.clear)
  }
  static create() {
    return new Timeout()
  }
  start(a, s) {
    this.clear(),
      (this.currentId = setTimeout(() => {
        ;(this.currentId = null), s()
      }, a))
  }
}
function useTimeout() {
  const o = useLazyRef(Timeout.create).current
  return useOnMount(o.disposeEffect), o
}
let hadKeyboardEvent = !0,
  hadFocusVisibleRecently = !1
const hadFocusVisibleRecentlyTimeout = new Timeout(),
  inputTypesWhitelist = {
    text: !0,
    search: !0,
    url: !0,
    tel: !0,
    email: !0,
    password: !0,
    number: !0,
    date: !0,
    month: !0,
    week: !0,
    time: !0,
    datetime: !0,
    'datetime-local': !0,
  }
function focusTriggersKeyboardModality(o) {
  const { type: a, tagName: s } = o
  return !!(
    (s === 'INPUT' && inputTypesWhitelist[a] && !o.readOnly) ||
    (s === 'TEXTAREA' && !o.readOnly) ||
    o.isContentEditable
  )
}
function handleKeyDown(o) {
  o.metaKey || o.altKey || o.ctrlKey || (hadKeyboardEvent = !0)
}
function handlePointerDown() {
  hadKeyboardEvent = !1
}
function handleVisibilityChange() {
  this.visibilityState === 'hidden' &&
    hadFocusVisibleRecently &&
    (hadKeyboardEvent = !0)
}
function prepare(o) {
  o.addEventListener('keydown', handleKeyDown, !0),
    o.addEventListener('mousedown', handlePointerDown, !0),
    o.addEventListener('pointerdown', handlePointerDown, !0),
    o.addEventListener('touchstart', handlePointerDown, !0),
    o.addEventListener('visibilitychange', handleVisibilityChange, !0)
}
function isFocusVisible(o) {
  const { target: a } = o
  try {
    return a.matches(':focus-visible')
  } catch {}
  return hadKeyboardEvent || focusTriggersKeyboardModality(a)
}
function useIsFocusVisible() {
  const o = reactExports.useCallback(j => {
      j != null && prepare(j.ownerDocument)
    }, []),
    a = reactExports.useRef(!1)
  function s() {
    return a.current
      ? ((hadFocusVisibleRecently = !0),
        hadFocusVisibleRecentlyTimeout.start(100, () => {
          hadFocusVisibleRecently = !1
        }),
        (a.current = !1),
        !0)
      : !1
  }
  function $(j) {
    return isFocusVisible(j) ? ((a.current = !0), !0) : !1
  }
  return { isFocusVisibleRef: a, onFocus: $, onBlur: s, ref: o }
}
function getScrollbarSize(o) {
  const a = o.documentElement.clientWidth
  return Math.abs(window.innerWidth - a)
}
let cachedType
function detectScrollType() {
  if (cachedType) return cachedType
  const o = document.createElement('div'),
    a = document.createElement('div')
  return (
    (a.style.width = '10px'),
    (a.style.height = '1px'),
    o.appendChild(a),
    (o.dir = 'rtl'),
    (o.style.fontSize = '14px'),
    (o.style.width = '4px'),
    (o.style.height = '1px'),
    (o.style.position = 'absolute'),
    (o.style.top = '-1000px'),
    (o.style.overflow = 'scroll'),
    document.body.appendChild(o),
    (cachedType = 'reverse'),
    o.scrollLeft > 0
      ? (cachedType = 'default')
      : ((o.scrollLeft = 1), o.scrollLeft === 0 && (cachedType = 'negative')),
    document.body.removeChild(o),
    cachedType
  )
}
function getNormalizedScrollLeft(o, a) {
  const s = o.scrollLeft
  if (a !== 'rtl') return s
  switch (detectScrollType()) {
    case 'negative':
      return o.scrollWidth - o.clientWidth + s
    case 'reverse':
      return o.scrollWidth - o.clientWidth - s
    default:
      return s
  }
}
const visuallyHidden = {
  border: 0,
  clip: 'rect(0 0 0 0)',
  height: '1px',
  margin: '-1px',
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  whiteSpace: 'nowrap',
  width: '1px',
}
function composeClasses(o, a, s = void 0) {
  const $ = {}
  return (
    Object.keys(o).forEach(j => {
      $[j] = o[j]
        .reduce((_e, et) => {
          if (et) {
            const tt = a(et)
            tt !== '' && _e.push(tt), s && s[et] && _e.push(s[et])
          }
          return _e
        }, [])
        .join(' ')
    }),
    $
  )
}
function isHostComponent(o) {
  return typeof o == 'string'
}
function appendOwnerState(o, a, s) {
  return o === void 0 || isHostComponent(o)
    ? a
    : _extends$5({}, a, { ownerState: _extends$5({}, a.ownerState, s) })
}
function extractEventHandlers(o, a = []) {
  if (o === void 0) return {}
  const s = {}
  return (
    Object.keys(o)
      .filter(
        $ => $.match(/^on[A-Z]/) && typeof o[$] == 'function' && !a.includes($)
      )
      .forEach($ => {
        s[$] = o[$]
      }),
    s
  )
}
function omitEventHandlers(o) {
  if (o === void 0) return {}
  const a = {}
  return (
    Object.keys(o)
      .filter(s => !(s.match(/^on[A-Z]/) && typeof o[s] == 'function'))
      .forEach(s => {
        a[s] = o[s]
      }),
    a
  )
}
function mergeSlotProps(o) {
  const {
    getSlotProps: a,
    additionalProps: s,
    externalSlotProps: $,
    externalForwardedProps: j,
    className: _e,
  } = o
  if (!a) {
    const st = clsx$1(
        s == null ? void 0 : s.className,
        _e,
        j == null ? void 0 : j.className,
        $ == null ? void 0 : $.className
      ),
      ut = _extends$5(
        {},
        s == null ? void 0 : s.style,
        j == null ? void 0 : j.style,
        $ == null ? void 0 : $.style
      ),
      ct = _extends$5({}, s, j, $)
    return (
      st.length > 0 && (ct.className = st),
      Object.keys(ut).length > 0 && (ct.style = ut),
      { props: ct, internalRef: void 0 }
    )
  }
  const et = extractEventHandlers(_extends$5({}, j, $)),
    tt = omitEventHandlers($),
    rt = omitEventHandlers(j),
    nt = a(et),
    it = clsx$1(
      nt == null ? void 0 : nt.className,
      s == null ? void 0 : s.className,
      _e,
      j == null ? void 0 : j.className,
      $ == null ? void 0 : $.className
    ),
    ot = _extends$5(
      {},
      nt == null ? void 0 : nt.style,
      s == null ? void 0 : s.style,
      j == null ? void 0 : j.style,
      $ == null ? void 0 : $.style
    ),
    at = _extends$5({}, nt, s, rt, tt)
  return (
    it.length > 0 && (at.className = it),
    Object.keys(ot).length > 0 && (at.style = ot),
    { props: at, internalRef: nt.ref }
  )
}
function resolveComponentProps(o, a, s) {
  return typeof o == 'function' ? o(a, s) : o
}
const _excluded$1i = [
  'elementType',
  'externalSlotProps',
  'ownerState',
  'skipResolvingSlotProps',
]
function useSlotProps(o) {
  var a
  const {
      elementType: s,
      externalSlotProps: $,
      ownerState: j,
      skipResolvingSlotProps: _e = !1,
    } = o,
    et = _objectWithoutPropertiesLoose$3(o, _excluded$1i),
    tt = _e ? {} : resolveComponentProps($, j),
    { props: rt, internalRef: nt } = mergeSlotProps(
      _extends$5({}, et, { externalSlotProps: tt })
    ),
    it = useForkRef(
      nt,
      tt == null ? void 0 : tt.ref,
      (a = o.additionalProps) == null ? void 0 : a.ref
    )
  return appendOwnerState(s, _extends$5({}, rt, { ref: it }), j)
}
const ThemeContext = reactExports.createContext(null)
function useTheme$2() {
  return reactExports.useContext(ThemeContext)
}
const hasSymbol = typeof Symbol == 'function' && Symbol.for,
  nested = hasSymbol ? Symbol.for('mui.nested') : '__THEME_NESTED__'
function mergeOuterLocalTheme(o, a) {
  return typeof a == 'function' ? a(o) : _extends$5({}, o, a)
}
function ThemeProvider$2(o) {
  const { children: a, theme: s } = o,
    $ = useTheme$2(),
    j = reactExports.useMemo(() => {
      const _e = $ === null ? s : mergeOuterLocalTheme($, s)
      return _e != null && (_e[nested] = $ !== null), _e
    }, [s, $])
  return jsxRuntimeExports.jsx(ThemeContext.Provider, { value: j, children: a })
}
const _excluded$1h = ['value'],
  RtlContext = reactExports.createContext()
function RtlProvider(o) {
  let { value: a } = o,
    s = _objectWithoutPropertiesLoose$3(o, _excluded$1h)
  return jsxRuntimeExports.jsx(
    RtlContext.Provider,
    _extends$5({ value: a ?? !0 }, s)
  )
}
const useRtl = () => {
    const o = reactExports.useContext(RtlContext)
    return o ?? !1
  },
  PropsContext = reactExports.createContext(void 0)
function DefaultPropsProvider({ value: o, children: a }) {
  return jsxRuntimeExports.jsx(PropsContext.Provider, { value: o, children: a })
}
function getThemeProps(o) {
  const { theme: a, name: s, props: $ } = o
  if (!a || !a.components || !a.components[s]) return $
  const j = a.components[s]
  return j.defaultProps
    ? resolveProps(j.defaultProps, $)
    : !j.styleOverrides && !j.variants
    ? resolveProps(j, $)
    : $
}
function useDefaultProps$1({ props: o, name: a }) {
  const s = reactExports.useContext(PropsContext)
  return getThemeProps({ props: o, name: a, theme: { components: s } })
}
const EMPTY_THEME = {}
function useThemeScoping(o, a, s, $ = !1) {
  return reactExports.useMemo(() => {
    const j = (o && a[o]) || a
    if (typeof s == 'function') {
      const _e = s(j),
        et = o ? _extends$5({}, a, { [o]: _e }) : _e
      return $ ? () => et : et
    }
    return o ? _extends$5({}, a, { [o]: s }) : _extends$5({}, a, s)
  }, [o, a, s, $])
}
function ThemeProvider$1(o) {
  const { children: a, theme: s, themeId: $ } = o,
    j = useTheme$4(EMPTY_THEME),
    _e = useTheme$2() || EMPTY_THEME,
    et = useThemeScoping($, j, s),
    tt = useThemeScoping($, _e, s, !0),
    rt = et.direction === 'rtl'
  return jsxRuntimeExports.jsx(ThemeProvider$2, {
    theme: tt,
    children: jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
      value: et,
      children: jsxRuntimeExports.jsx(RtlProvider, {
        value: rt,
        children: jsxRuntimeExports.jsx(DefaultPropsProvider, {
          value: et == null ? void 0 : et.components,
          children: a,
        }),
      }),
    }),
  })
}
const _excluded$1g = [
    'component',
    'direction',
    'spacing',
    'divider',
    'children',
    'className',
    'useFlexGap',
  ],
  defaultTheme$2 = createTheme$2(),
  defaultCreateStyledComponent = styled$1('div', {
    name: 'MuiStack',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })
function useThemePropsDefault(o) {
  return useThemeProps({
    props: o,
    name: 'MuiStack',
    defaultTheme: defaultTheme$2,
  })
}
function joinChildren(o, a) {
  const s = reactExports.Children.toArray(o).filter(Boolean)
  return s.reduce(
    ($, j, _e) => (
      $.push(j),
      _e < s.length - 1 &&
        $.push(reactExports.cloneElement(a, { key: `separator-${_e}` })),
      $
    ),
    []
  )
}
const getSideFromDirection = o =>
    ({
      row: 'Left',
      'row-reverse': 'Right',
      column: 'Top',
      'column-reverse': 'Bottom',
    }[o]),
  style = ({ ownerState: o, theme: a }) => {
    let s = _extends$5(
      { display: 'flex', flexDirection: 'column' },
      handleBreakpoints(
        { theme: a },
        resolveBreakpointValues({
          values: o.direction,
          breakpoints: a.breakpoints.values,
        }),
        $ => ({ flexDirection: $ })
      )
    )
    if (o.spacing) {
      const $ = createUnarySpacing(a),
        j = Object.keys(a.breakpoints.values).reduce(
          (rt, nt) => (
            ((typeof o.spacing == 'object' && o.spacing[nt] != null) ||
              (typeof o.direction == 'object' && o.direction[nt] != null)) &&
              (rt[nt] = !0),
            rt
          ),
          {}
        ),
        _e = resolveBreakpointValues({ values: o.direction, base: j }),
        et = resolveBreakpointValues({ values: o.spacing, base: j })
      typeof _e == 'object' &&
        Object.keys(_e).forEach((rt, nt, it) => {
          if (!_e[rt]) {
            const at = nt > 0 ? _e[it[nt - 1]] : 'column'
            _e[rt] = at
          }
        }),
        (s = deepmerge$1(
          s,
          handleBreakpoints({ theme: a }, et, (rt, nt) =>
            o.useFlexGap
              ? { gap: getValue($, rt) }
              : {
                  '& > :not(style):not(style)': { margin: 0 },
                  '& > :not(style) ~ :not(style)': {
                    [`margin${getSideFromDirection(
                      nt ? _e[nt] : o.direction
                    )}`]: getValue($, rt),
                  },
                }
          )
        ))
    }
    return (s = mergeBreakpointsInOrder(a.breakpoints, s)), s
  }
function createStack(o = {}) {
  const {
      createStyledComponent: a = defaultCreateStyledComponent,
      useThemeProps: s = useThemePropsDefault,
      componentName: $ = 'MuiStack',
    } = o,
    j = () =>
      composeClasses({ root: ['root'] }, rt => generateUtilityClass($, rt), {}),
    _e = a(style)
  return reactExports.forwardRef(function(rt, nt) {
    const it = s(rt),
      ot = extendSxProp(it),
      {
        component: at = 'div',
        direction: st = 'column',
        spacing: ut = 0,
        divider: ct,
        children: dt,
        className: ft,
        useFlexGap: mt = !1,
      } = ot,
      vt = _objectWithoutPropertiesLoose$3(ot, _excluded$1g),
      yt = { direction: st, spacing: ut, useFlexGap: mt },
      pt = j()
    return jsxRuntimeExports.jsx(
      _e,
      _extends$5(
        { as: at, ownerState: yt, ref: nt, className: clsx$1(pt.root, ft) },
        vt,
        { children: ct ? joinChildren(dt, ct) : dt }
      )
    )
  })
}
function createMixins(o, a) {
  return _extends$5(
    {
      toolbar: {
        minHeight: 56,
        [o.up('xs')]: { '@media (orientation: landscape)': { minHeight: 48 } },
        [o.up('sm')]: { minHeight: 64 },
      },
    },
    a
  )
}
var colorManipulator = {},
  interopRequireDefault = { exports: {} }
;(function(o) {
  function a(s) {
    return s && s.__esModule ? s : { default: s }
  }
  ;(o.exports = a), (o.exports.__esModule = !0), (o.exports.default = o.exports)
})(interopRequireDefault)
var interopRequireDefaultExports = interopRequireDefault.exports
const require$$1$2 = getAugmentedNamespace(formatMuiErrorMessage),
  require$$2$1 = getAugmentedNamespace(clamp$1)
var _interopRequireDefault$h = interopRequireDefaultExports
Object.defineProperty(colorManipulator, '__esModule', { value: !0 })
var alpha_1 = (colorManipulator.alpha = alpha)
colorManipulator.blend = blend$1
colorManipulator.colorChannel = void 0
var darken_1 = (colorManipulator.darken = darken$1)
colorManipulator.decomposeColor = decomposeColor
colorManipulator.emphasize = emphasize
var getContrastRatio_1 = (colorManipulator.getContrastRatio = getContrastRatio)
colorManipulator.getLuminance = getLuminance
colorManipulator.hexToRgb = hexToRgb
colorManipulator.hslToRgb = hslToRgb$1
var lighten_1 = (colorManipulator.lighten = lighten$1)
colorManipulator.private_safeAlpha = private_safeAlpha
colorManipulator.private_safeColorChannel = void 0
colorManipulator.private_safeDarken = private_safeDarken
colorManipulator.private_safeEmphasize = private_safeEmphasize
colorManipulator.private_safeLighten = private_safeLighten
colorManipulator.recomposeColor = recomposeColor
colorManipulator.rgbToHex = rgbToHex$1
var _formatMuiErrorMessage2 = _interopRequireDefault$h(require$$1$2),
  _clamp = _interopRequireDefault$h(require$$2$1)
function clampWrapper(o, a = 0, s = 1) {
  return (0, _clamp.default)(o, a, s)
}
function hexToRgb(o) {
  o = o.slice(1)
  const a = new RegExp(`.{1,${o.length >= 6 ? 2 : 1}}`, 'g')
  let s = o.match(a)
  return (
    s && s[0].length === 1 && (s = s.map($ => $ + $)),
    s
      ? `rgb${s.length === 4 ? 'a' : ''}(${s
          .map(($, j) =>
            j < 3
              ? parseInt($, 16)
              : Math.round((parseInt($, 16) / 255) * 1e3) / 1e3
          )
          .join(', ')})`
      : ''
  )
}
function intToHex(o) {
  const a = o.toString(16)
  return a.length === 1 ? `0${a}` : a
}
function decomposeColor(o) {
  if (o.type) return o
  if (o.charAt(0) === '#') return decomposeColor(hexToRgb(o))
  const a = o.indexOf('('),
    s = o.substring(0, a)
  if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(s) === -1)
    throw new Error((0, _formatMuiErrorMessage2.default)(9, o))
  let $ = o.substring(a + 1, o.length - 1),
    j
  if (s === 'color') {
    if (
      (($ = $.split(' ')),
      (j = $.shift()),
      $.length === 4 && $[3].charAt(0) === '/' && ($[3] = $[3].slice(1)),
      ['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(
        j
      ) === -1)
    )
      throw new Error((0, _formatMuiErrorMessage2.default)(10, j))
  } else $ = $.split(',')
  return (
    ($ = $.map(_e => parseFloat(_e))), { type: s, values: $, colorSpace: j }
  )
}
const colorChannel = o => {
  const a = decomposeColor(o)
  return a.values
    .slice(0, 3)
    .map((s, $) => (a.type.indexOf('hsl') !== -1 && $ !== 0 ? `${s}%` : s))
    .join(' ')
}
colorManipulator.colorChannel = colorChannel
const private_safeColorChannel = (o, a) => {
  try {
    return colorChannel(o)
  } catch {
    return o
  }
}
colorManipulator.private_safeColorChannel = private_safeColorChannel
function recomposeColor(o) {
  const { type: a, colorSpace: s } = o
  let { values: $ } = o
  return (
    a.indexOf('rgb') !== -1
      ? ($ = $.map((j, _e) => (_e < 3 ? parseInt(j, 10) : j)))
      : a.indexOf('hsl') !== -1 && (($[1] = `${$[1]}%`), ($[2] = `${$[2]}%`)),
    a.indexOf('color') !== -1
      ? ($ = `${s} ${$.join(' ')}`)
      : ($ = `${$.join(', ')}`),
    `${a}(${$})`
  )
}
function rgbToHex$1(o) {
  if (o.indexOf('#') === 0) return o
  const { values: a } = decomposeColor(o)
  return `#${a
    .map((s, $) => intToHex($ === 3 ? Math.round(255 * s) : s))
    .join('')}`
}
function hslToRgb$1(o) {
  o = decomposeColor(o)
  const { values: a } = o,
    s = a[0],
    $ = a[1] / 100,
    j = a[2] / 100,
    _e = $ * Math.min(j, 1 - j),
    et = (nt, it = (nt + s / 30) % 12) =>
      j - _e * Math.max(Math.min(it - 3, 9 - it, 1), -1)
  let tt = 'rgb'
  const rt = [
    Math.round(et(0) * 255),
    Math.round(et(8) * 255),
    Math.round(et(4) * 255),
  ]
  return (
    o.type === 'hsla' && ((tt += 'a'), rt.push(a[3])),
    recomposeColor({ type: tt, values: rt })
  )
}
function getLuminance(o) {
  o = decomposeColor(o)
  let a =
    o.type === 'hsl' || o.type === 'hsla'
      ? decomposeColor(hslToRgb$1(o)).values
      : o.values
  return (
    (a = a.map(
      s => (
        o.type !== 'color' && (s /= 255),
        s <= 0.03928 ? s / 12.92 : ((s + 0.055) / 1.055) ** 2.4
      )
    )),
    Number((0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2]).toFixed(3))
  )
}
function getContrastRatio(o, a) {
  const s = getLuminance(o),
    $ = getLuminance(a)
  return (Math.max(s, $) + 0.05) / (Math.min(s, $) + 0.05)
}
function alpha(o, a) {
  return (
    (o = decomposeColor(o)),
    (a = clampWrapper(a)),
    (o.type === 'rgb' || o.type === 'hsl') && (o.type += 'a'),
    o.type === 'color' ? (o.values[3] = `/${a}`) : (o.values[3] = a),
    recomposeColor(o)
  )
}
function private_safeAlpha(o, a, s) {
  try {
    return alpha(o, a)
  } catch {
    return o
  }
}
function darken$1(o, a) {
  if (
    ((o = decomposeColor(o)),
    (a = clampWrapper(a)),
    o.type.indexOf('hsl') !== -1)
  )
    o.values[2] *= 1 - a
  else if (o.type.indexOf('rgb') !== -1 || o.type.indexOf('color') !== -1)
    for (let s = 0; s < 3; s += 1) o.values[s] *= 1 - a
  return recomposeColor(o)
}
function private_safeDarken(o, a, s) {
  try {
    return darken$1(o, a)
  } catch {
    return o
  }
}
function lighten$1(o, a) {
  if (
    ((o = decomposeColor(o)),
    (a = clampWrapper(a)),
    o.type.indexOf('hsl') !== -1)
  )
    o.values[2] += (100 - o.values[2]) * a
  else if (o.type.indexOf('rgb') !== -1)
    for (let s = 0; s < 3; s += 1) o.values[s] += (255 - o.values[s]) * a
  else if (o.type.indexOf('color') !== -1)
    for (let s = 0; s < 3; s += 1) o.values[s] += (1 - o.values[s]) * a
  return recomposeColor(o)
}
function private_safeLighten(o, a, s) {
  try {
    return lighten$1(o, a)
  } catch {
    return o
  }
}
function emphasize(o, a = 0.15) {
  return getLuminance(o) > 0.5 ? darken$1(o, a) : lighten$1(o, a)
}
function private_safeEmphasize(o, a, s) {
  try {
    return emphasize(o, a)
  } catch {
    return o
  }
}
function blend$1(o, a, s, $ = 1) {
  const j = (rt, nt) =>
      Math.round((rt ** (1 / $) * (1 - s) + nt ** (1 / $) * s) ** $),
    _e = decomposeColor(o),
    et = decomposeColor(a),
    tt = [
      j(_e.values[0], et.values[0]),
      j(_e.values[1], et.values[1]),
      j(_e.values[2], et.values[2]),
    ]
  return recomposeColor({ type: 'rgb', values: tt })
}
const common$2 = { black: '#000', white: '#fff' },
  grey = {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e9e',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121',
    A100: '#f5f5f5',
    A200: '#eeeeee',
    A400: '#bdbdbd',
    A700: '#616161',
  },
  purple = {
    50: '#f3e5f5',
    100: '#e1bee7',
    200: '#ce93d8',
    300: '#ba68c8',
    400: '#ab47bc',
    500: '#9c27b0',
    600: '#8e24aa',
    700: '#7b1fa2',
    800: '#6a1b9a',
    900: '#4a148c',
    A100: '#ea80fc',
    A200: '#e040fb',
    A400: '#d500f9',
    A700: '#aa00ff',
  },
  red = {
    50: '#ffebee',
    100: '#ffcdd2',
    200: '#ef9a9a',
    300: '#e57373',
    400: '#ef5350',
    500: '#f44336',
    600: '#e53935',
    700: '#d32f2f',
    800: '#c62828',
    900: '#b71c1c',
    A100: '#ff8a80',
    A200: '#ff5252',
    A400: '#ff1744',
    A700: '#d50000',
  },
  orange = {
    50: '#fff3e0',
    100: '#ffe0b2',
    200: '#ffcc80',
    300: '#ffb74d',
    400: '#ffa726',
    500: '#ff9800',
    600: '#fb8c00',
    700: '#f57c00',
    800: '#ef6c00',
    900: '#e65100',
    A100: '#ffd180',
    A200: '#ffab40',
    A400: '#ff9100',
    A700: '#ff6d00',
  },
  blue = {
    50: '#e3f2fd',
    100: '#bbdefb',
    200: '#90caf9',
    300: '#64b5f6',
    400: '#42a5f5',
    500: '#2196f3',
    600: '#1e88e5',
    700: '#1976d2',
    800: '#1565c0',
    900: '#0d47a1',
    A100: '#82b1ff',
    A200: '#448aff',
    A400: '#2979ff',
    A700: '#2962ff',
  },
  lightBlue = {
    50: '#e1f5fe',
    100: '#b3e5fc',
    200: '#81d4fa',
    300: '#4fc3f7',
    400: '#29b6f6',
    500: '#03a9f4',
    600: '#039be5',
    700: '#0288d1',
    800: '#0277bd',
    900: '#01579b',
    A100: '#80d8ff',
    A200: '#40c4ff',
    A400: '#00b0ff',
    A700: '#0091ea',
  },
  green = {
    50: '#e8f5e9',
    100: '#c8e6c9',
    200: '#a5d6a7',
    300: '#81c784',
    400: '#66bb6a',
    500: '#4caf50',
    600: '#43a047',
    700: '#388e3c',
    800: '#2e7d32',
    900: '#1b5e20',
    A100: '#b9f6ca',
    A200: '#69f0ae',
    A400: '#00e676',
    A700: '#00c853',
  },
  _excluded$1f = ['mode', 'contrastThreshold', 'tonalOffset'],
  light = {
    text: {
      primary: 'rgba(0, 0, 0, 0.87)',
      secondary: 'rgba(0, 0, 0, 0.6)',
      disabled: 'rgba(0, 0, 0, 0.38)',
    },
    divider: 'rgba(0, 0, 0, 0.12)',
    background: { paper: common$2.white, default: common$2.white },
    action: {
      active: 'rgba(0, 0, 0, 0.54)',
      hover: 'rgba(0, 0, 0, 0.04)',
      hoverOpacity: 0.04,
      selected: 'rgba(0, 0, 0, 0.08)',
      selectedOpacity: 0.08,
      disabled: 'rgba(0, 0, 0, 0.26)',
      disabledBackground: 'rgba(0, 0, 0, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(0, 0, 0, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.12,
    },
  },
  dark = {
    text: {
      primary: common$2.white,
      secondary: 'rgba(255, 255, 255, 0.7)',
      disabled: 'rgba(255, 255, 255, 0.5)',
      icon: 'rgba(255, 255, 255, 0.5)',
    },
    divider: 'rgba(255, 255, 255, 0.12)',
    background: { paper: '#121212', default: '#121212' },
    action: {
      active: common$2.white,
      hover: 'rgba(255, 255, 255, 0.08)',
      hoverOpacity: 0.08,
      selected: 'rgba(255, 255, 255, 0.16)',
      selectedOpacity: 0.16,
      disabled: 'rgba(255, 255, 255, 0.3)',
      disabledBackground: 'rgba(255, 255, 255, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(255, 255, 255, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.24,
    },
  }
function addLightOrDark(o, a, s, $) {
  const j = $.light || $,
    _e = $.dark || $ * 1.5
  o[a] ||
    (o.hasOwnProperty(s)
      ? (o[a] = o[s])
      : a === 'light'
      ? (o.light = lighten_1(o.main, j))
      : a === 'dark' && (o.dark = darken_1(o.main, _e)))
}
function getDefaultPrimary(o = 'light') {
  return o === 'dark'
    ? { main: blue[200], light: blue[50], dark: blue[400] }
    : { main: blue[700], light: blue[400], dark: blue[800] }
}
function getDefaultSecondary(o = 'light') {
  return o === 'dark'
    ? { main: purple[200], light: purple[50], dark: purple[400] }
    : { main: purple[500], light: purple[300], dark: purple[700] }
}
function getDefaultError(o = 'light') {
  return o === 'dark'
    ? { main: red[500], light: red[300], dark: red[700] }
    : { main: red[700], light: red[400], dark: red[800] }
}
function getDefaultInfo(o = 'light') {
  return o === 'dark'
    ? { main: lightBlue[400], light: lightBlue[300], dark: lightBlue[700] }
    : { main: lightBlue[700], light: lightBlue[500], dark: lightBlue[900] }
}
function getDefaultSuccess(o = 'light') {
  return o === 'dark'
    ? { main: green[400], light: green[300], dark: green[700] }
    : { main: green[800], light: green[500], dark: green[900] }
}
function getDefaultWarning(o = 'light') {
  return o === 'dark'
    ? { main: orange[400], light: orange[300], dark: orange[700] }
    : { main: '#ed6c02', light: orange[500], dark: orange[900] }
}
function createPalette(o) {
  const {
      mode: a = 'light',
      contrastThreshold: s = 3,
      tonalOffset: $ = 0.2,
    } = o,
    j = _objectWithoutPropertiesLoose$3(o, _excluded$1f),
    _e = o.primary || getDefaultPrimary(a),
    et = o.secondary || getDefaultSecondary(a),
    tt = o.error || getDefaultError(a),
    rt = o.info || getDefaultInfo(a),
    nt = o.success || getDefaultSuccess(a),
    it = o.warning || getDefaultWarning(a)
  function ot(ct) {
    return getContrastRatio_1(ct, dark.text.primary) >= s
      ? dark.text.primary
      : light.text.primary
  }
  const at = ({
      color: ct,
      name: dt,
      mainShade: ft = 500,
      lightShade: mt = 300,
      darkShade: vt = 700,
    }) => {
      if (
        ((ct = _extends$5({}, ct)),
        !ct.main && ct[ft] && (ct.main = ct[ft]),
        !ct.hasOwnProperty('main'))
      )
        throw new Error(formatMuiErrorMessage$1(11, dt ? ` (${dt})` : '', ft))
      if (typeof ct.main != 'string')
        throw new Error(
          formatMuiErrorMessage$1(
            12,
            dt ? ` (${dt})` : '',
            JSON.stringify(ct.main)
          )
        )
      return (
        addLightOrDark(ct, 'light', mt, $),
        addLightOrDark(ct, 'dark', vt, $),
        ct.contrastText || (ct.contrastText = ot(ct.main)),
        ct
      )
    },
    st = { dark, light }
  return deepmerge$1(
    _extends$5(
      {
        common: _extends$5({}, common$2),
        mode: a,
        primary: at({ color: _e, name: 'primary' }),
        secondary: at({
          color: et,
          name: 'secondary',
          mainShade: 'A400',
          lightShade: 'A200',
          darkShade: 'A700',
        }),
        error: at({ color: tt, name: 'error' }),
        warning: at({ color: it, name: 'warning' }),
        info: at({ color: rt, name: 'info' }),
        success: at({ color: nt, name: 'success' }),
        grey,
        contrastThreshold: s,
        getContrastText: ot,
        augmentColor: at,
        tonalOffset: $,
      },
      st[a]
    ),
    j
  )
}
const _excluded$1e = [
  'fontFamily',
  'fontSize',
  'fontWeightLight',
  'fontWeightRegular',
  'fontWeightMedium',
  'fontWeightBold',
  'htmlFontSize',
  'allVariants',
  'pxToRem',
]
function round$3(o) {
  return Math.round(o * 1e5) / 1e5
}
const caseAllCaps = { textTransform: 'uppercase' },
  defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif'
function createTypography(o, a) {
  const s = typeof a == 'function' ? a(o) : a,
    {
      fontFamily: $ = defaultFontFamily,
      fontSize: j = 14,
      fontWeightLight: _e = 300,
      fontWeightRegular: et = 400,
      fontWeightMedium: tt = 500,
      fontWeightBold: rt = 700,
      htmlFontSize: nt = 16,
      allVariants: it,
      pxToRem: ot,
    } = s,
    at = _objectWithoutPropertiesLoose$3(s, _excluded$1e),
    st = j / 14,
    ut = ot || (ft => `${(ft / nt) * st}rem`),
    ct = (ft, mt, vt, yt, pt) =>
      _extends$5(
        { fontFamily: $, fontWeight: ft, fontSize: ut(mt), lineHeight: vt },
        $ === defaultFontFamily
          ? { letterSpacing: `${round$3(yt / mt)}em` }
          : {},
        pt,
        it
      ),
    dt = {
      h1: ct(_e, 96, 1.167, -1.5),
      h2: ct(_e, 60, 1.2, -0.5),
      h3: ct(et, 48, 1.167, 0),
      h4: ct(et, 34, 1.235, 0.25),
      h5: ct(et, 24, 1.334, 0),
      h6: ct(tt, 20, 1.6, 0.15),
      subtitle1: ct(et, 16, 1.75, 0.15),
      subtitle2: ct(tt, 14, 1.57, 0.1),
      body1: ct(et, 16, 1.5, 0.15),
      body2: ct(et, 14, 1.43, 0.15),
      button: ct(tt, 14, 1.75, 0.4, caseAllCaps),
      caption: ct(et, 12, 1.66, 0.4),
      overline: ct(et, 12, 2.66, 1, caseAllCaps),
      inherit: {
        fontFamily: 'inherit',
        fontWeight: 'inherit',
        fontSize: 'inherit',
        lineHeight: 'inherit',
        letterSpacing: 'inherit',
      },
    }
  return deepmerge$1(
    _extends$5(
      {
        htmlFontSize: nt,
        pxToRem: ut,
        fontFamily: $,
        fontSize: j,
        fontWeightLight: _e,
        fontWeightRegular: et,
        fontWeightMedium: tt,
        fontWeightBold: rt,
      },
      dt
    ),
    at,
    { clone: !1 }
  )
}
const shadowKeyUmbraOpacity = 0.2,
  shadowKeyPenumbraOpacity = 0.14,
  shadowAmbientShadowOpacity = 0.12
function createShadow(...o) {
  return [
    `${o[0]}px ${o[1]}px ${o[2]}px ${o[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`,
    `${o[4]}px ${o[5]}px ${o[6]}px ${o[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`,
    `${o[8]}px ${o[9]}px ${o[10]}px ${o[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`,
  ].join(',')
}
const shadows = [
    'none',
    createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0),
    createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0),
    createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0),
    createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0),
    createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0),
    createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0),
    createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1),
    createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2),
    createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2),
    createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3),
    createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3),
    createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4),
    createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4),
    createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4),
    createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5),
    createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5),
    createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5),
    createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6),
    createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6),
    createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7),
    createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7),
    createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7),
    createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8),
    createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8),
  ],
  _excluded$1d = ['duration', 'easing', 'delay'],
  easing = {
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
    easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
    sharp: 'cubic-bezier(0.4, 0, 0.6, 1)',
  },
  duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195,
  }
function formatMs(o) {
  return `${Math.round(o)}ms`
}
function getAutoHeightDuration(o) {
  if (!o) return 0
  const a = o / 36
  return Math.round((4 + 15 * a ** 0.25 + a / 5) * 10)
}
function createTransitions(o) {
  const a = _extends$5({}, easing, o.easing),
    s = _extends$5({}, duration, o.duration)
  return _extends$5(
    {
      getAutoHeightDuration,
      create: (j = ['all'], _e = {}) => {
        const {
          duration: et = s.standard,
          easing: tt = a.easeInOut,
          delay: rt = 0,
        } = _e
        return (
          _objectWithoutPropertiesLoose$3(_e, _excluded$1d),
          (Array.isArray(j) ? j : [j])
            .map(
              nt =>
                `${nt} ${typeof et == 'string' ? et : formatMs(et)} ${tt} ${
                  typeof rt == 'string' ? rt : formatMs(rt)
                }`
            )
            .join(',')
        )
      },
    },
    o,
    { easing: a, duration: s }
  )
}
const zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500,
  },
  _excluded$1c = [
    'breakpoints',
    'mixins',
    'spacing',
    'palette',
    'transitions',
    'typography',
    'shape',
  ]
function createTheme(o = {}, ...a) {
  const {
      mixins: s = {},
      palette: $ = {},
      transitions: j = {},
      typography: _e = {},
    } = o,
    et = _objectWithoutPropertiesLoose$3(o, _excluded$1c)
  if (o.vars) throw new Error(formatMuiErrorMessage$1(18))
  const tt = createPalette($),
    rt = createTheme$2(o)
  let nt = deepmerge$1(rt, {
    mixins: createMixins(rt.breakpoints, s),
    palette: tt,
    shadows: shadows.slice(),
    typography: createTypography(tt, _e),
    transitions: createTransitions(j),
    zIndex: _extends$5({}, zIndex),
  })
  return (
    (nt = deepmerge$1(nt, et)),
    (nt = a.reduce((it, ot) => deepmerge$1(it, ot), nt)),
    (nt.unstable_sxConfig = _extends$5(
      {},
      defaultSxConfig,
      et == null ? void 0 : et.unstable_sxConfig
    )),
    (nt.unstable_sx = function(ot) {
      return styleFunctionSx$1({ sx: ot, theme: this })
    }),
    nt
  )
}
const defaultTheme$1 = createTheme()
function useTheme$1() {
  const o = useTheme$3(defaultTheme$1)
  return o[THEME_ID] || o
}
var createStyled$1 = {},
  objectWithoutPropertiesLoose = { exports: {} },
  hasRequiredObjectWithoutPropertiesLoose
function requireObjectWithoutPropertiesLoose() {
  return (
    hasRequiredObjectWithoutPropertiesLoose ||
      ((hasRequiredObjectWithoutPropertiesLoose = 1),
      (function(o) {
        function a(s, $) {
          if (s == null) return {}
          var j = {}
          for (var _e in s)
            if ({}.hasOwnProperty.call(s, _e)) {
              if ($.includes(_e)) continue
              j[_e] = s[_e]
            }
          return j
        }
        ;(o.exports = a),
          (o.exports.__esModule = !0),
          (o.exports.default = o.exports)
      })(objectWithoutPropertiesLoose)),
    objectWithoutPropertiesLoose.exports
  )
}
const require$$1$1 = getAugmentedNamespace(styledEngine),
  require$$4 = getAugmentedNamespace(deepmerge),
  require$$5 = getAugmentedNamespace(capitalize$1),
  require$$6 = getAugmentedNamespace(getDisplayName),
  require$$7 = getAugmentedNamespace(createTheme$1),
  require$$8 = getAugmentedNamespace(styleFunctionSx)
var _interopRequireDefault$g = interopRequireDefaultExports
Object.defineProperty(createStyled$1, '__esModule', { value: !0 })
var _default$3 = (createStyled$1.default = createStyled)
createStyled$1.shouldForwardProp = shouldForwardProp
createStyled$1.systemDefaultTheme = void 0
var _extends2 = _interopRequireDefault$g(require_extends()),
  _objectWithoutPropertiesLoose2 = _interopRequireDefault$g(
    requireObjectWithoutPropertiesLoose()
  ),
  _styledEngine$1 = _interopRequireWildcard$2(require$$1$1),
  _deepmerge = require$$4
_interopRequireDefault$g(require$$5)
_interopRequireDefault$g(require$$6)
var _createTheme = _interopRequireDefault$g(require$$7),
  _styleFunctionSx = _interopRequireDefault$g(require$$8)
const _excluded$1b = ['ownerState'],
  _excluded2$6 = ['variants'],
  _excluded3$2 = [
    'name',
    'slot',
    'skipVariantsResolver',
    'skipSx',
    'overridesResolver',
  ]
function _getRequireWildcardCache$1(o) {
  if (typeof WeakMap != 'function') return null
  var a = new WeakMap(),
    s = new WeakMap()
  return (_getRequireWildcardCache$1 = function($) {
    return $ ? s : a
  })(o)
}
function _interopRequireWildcard$2(o, a) {
  if (o && o.__esModule) return o
  if (o === null || (typeof o != 'object' && typeof o != 'function'))
    return { default: o }
  var s = _getRequireWildcardCache$1(a)
  if (s && s.has(o)) return s.get(o)
  var $ = { __proto__: null },
    j = Object.defineProperty && Object.getOwnPropertyDescriptor
  for (var _e in o)
    if (_e !== 'default' && Object.prototype.hasOwnProperty.call(o, _e)) {
      var et = j ? Object.getOwnPropertyDescriptor(o, _e) : null
      et && (et.get || et.set)
        ? Object.defineProperty($, _e, et)
        : ($[_e] = o[_e])
    }
  return ($.default = o), s && s.set(o, $), $
}
function isEmpty$2(o) {
  return Object.keys(o).length === 0
}
function isStringTag(o) {
  return typeof o == 'string' && o.charCodeAt(0) > 96
}
function shouldForwardProp(o) {
  return o !== 'ownerState' && o !== 'theme' && o !== 'sx' && o !== 'as'
}
const systemDefaultTheme = (createStyled$1.systemDefaultTheme = (0,
  _createTheme.default)()),
  lowercaseFirstLetter = o => o && o.charAt(0).toLowerCase() + o.slice(1)
function resolveTheme({ defaultTheme: o, theme: a, themeId: s }) {
  return isEmpty$2(a) ? o : a[s] || a
}
function defaultOverridesResolver(o) {
  return o ? (a, s) => s[o] : null
}
function processStyleArg(o, a) {
  let { ownerState: s } = a,
    $ = (0, _objectWithoutPropertiesLoose2.default)(a, _excluded$1b)
  const j =
    typeof o == 'function' ? o((0, _extends2.default)({ ownerState: s }, $)) : o
  if (Array.isArray(j))
    return j.flatMap(_e =>
      processStyleArg(_e, (0, _extends2.default)({ ownerState: s }, $))
    )
  if (j && typeof j == 'object' && Array.isArray(j.variants)) {
    const { variants: _e = [] } = j
    let tt = (0, _objectWithoutPropertiesLoose2.default)(j, _excluded2$6)
    return (
      _e.forEach(rt => {
        let nt = !0
        typeof rt.props == 'function'
          ? (nt = rt.props((0, _extends2.default)({ ownerState: s }, $, s)))
          : Object.keys(rt.props).forEach(it => {
              ;(s == null ? void 0 : s[it]) !== rt.props[it] &&
                $[it] !== rt.props[it] &&
                (nt = !1)
            }),
          nt &&
            (Array.isArray(tt) || (tt = [tt]),
            tt.push(
              typeof rt.style == 'function'
                ? rt.style((0, _extends2.default)({ ownerState: s }, $, s))
                : rt.style
            ))
      }),
      tt
    )
  }
  return j
}
function createStyled(o = {}) {
  const {
      themeId: a,
      defaultTheme: s = systemDefaultTheme,
      rootShouldForwardProp: $ = shouldForwardProp,
      slotShouldForwardProp: j = shouldForwardProp,
    } = o,
    _e = et =>
      (0, _styleFunctionSx.default)(
        (0, _extends2.default)({}, et, {
          theme: resolveTheme(
            (0, _extends2.default)({}, et, { defaultTheme: s, themeId: a })
          ),
        })
      )
  return (
    (_e.__mui_systemSx = !0),
    (et, tt = {}) => {
      ;(0, _styledEngine$1.internal_processStyles)(et, pt =>
        pt.filter(ht => !(ht != null && ht.__mui_systemSx))
      )
      const {
          name: rt,
          slot: nt,
          skipVariantsResolver: it,
          skipSx: ot,
          overridesResolver: at = defaultOverridesResolver(
            lowercaseFirstLetter(nt)
          ),
        } = tt,
        st = (0, _objectWithoutPropertiesLoose2.default)(tt, _excluded3$2),
        ut = it !== void 0 ? it : (nt && nt !== 'Root' && nt !== 'root') || !1,
        ct = ot || !1
      let dt,
        ft = shouldForwardProp
      nt === 'Root' || nt === 'root'
        ? (ft = $)
        : nt
        ? (ft = j)
        : isStringTag(et) && (ft = void 0)
      const mt = (0, _styledEngine$1.default)(
          et,
          (0, _extends2.default)({ shouldForwardProp: ft, label: dt }, st)
        ),
        vt = pt =>
          (typeof pt == 'function' && pt.__emotion_real !== pt) ||
          (0, _deepmerge.isPlainObject)(pt)
            ? ht =>
                processStyleArg(
                  pt,
                  (0, _extends2.default)({}, ht, {
                    theme: resolveTheme({
                      theme: ht.theme,
                      defaultTheme: s,
                      themeId: a,
                    }),
                  })
                )
            : pt,
        yt = (pt, ...ht) => {
          let At = vt(pt)
          const wt = ht ? ht.map(vt) : []
          rt &&
            at &&
            wt.push(jt => {
              const Et = resolveTheme(
                (0, _extends2.default)({}, jt, { defaultTheme: s, themeId: a })
              )
              if (
                !Et.components ||
                !Et.components[rt] ||
                !Et.components[rt].styleOverrides
              )
                return null
              const St = Et.components[rt].styleOverrides,
                Bt = {}
              return (
                Object.entries(St).forEach(([Mt, Ut]) => {
                  Bt[Mt] = processStyleArg(
                    Ut,
                    (0, _extends2.default)({}, jt, { theme: Et })
                  )
                }),
                at(jt, Bt)
              )
            }),
            rt &&
              !ut &&
              wt.push(jt => {
                var Et
                const St = resolveTheme(
                    (0, _extends2.default)({}, jt, {
                      defaultTheme: s,
                      themeId: a,
                    })
                  ),
                  Bt =
                    St == null ||
                    (Et = St.components) == null ||
                    (Et = Et[rt]) == null
                      ? void 0
                      : Et.variants
                return processStyleArg(
                  { variants: Bt },
                  (0, _extends2.default)({}, jt, { theme: St })
                )
              }),
            ct || wt.push(_e)
          const Ct = wt.length - ht.length
          if (Array.isArray(pt) && Ct > 0) {
            const jt = new Array(Ct).fill('')
            ;(At = [...pt, ...jt]), (At.raw = [...pt.raw, ...jt])
          }
          const Dt = mt(At, ...wt)
          return et.muiName && (Dt.muiName = et.muiName), Dt
        }
      return mt.withConfig && (yt.withConfig = mt.withConfig), yt
    }
  )
}
function slotShouldForwardProp(o) {
  return o !== 'ownerState' && o !== 'theme' && o !== 'sx' && o !== 'as'
}
const rootShouldForwardProp = o => slotShouldForwardProp(o) && o !== 'classes',
  styled = _default$3({
    themeId: THEME_ID,
    defaultTheme: defaultTheme$1,
    rootShouldForwardProp,
  }),
  _excluded$1a = ['theme']
function ThemeProvider(o) {
  let { theme: a } = o,
    s = _objectWithoutPropertiesLoose$3(o, _excluded$1a)
  const $ = a[THEME_ID]
  return jsxRuntimeExports.jsx(
    ThemeProvider$1,
    _extends$5({}, s, { themeId: $ ? THEME_ID : void 0, theme: $ || a })
  )
}
const getOverlayAlpha = o => {
  let a
  return (
    o < 1 ? (a = 5.11916 * o ** 2) : (a = 4.5 * Math.log(o + 1) + 2),
    (a / 100).toFixed(2)
  )
}
function isOverflowing(o) {
  const a = ownerDocument(o)
  return a.body === o
    ? ownerWindow(o).innerWidth > a.documentElement.clientWidth
    : o.scrollHeight > o.clientHeight
}
function ariaHidden(o, a) {
  a ? o.setAttribute('aria-hidden', 'true') : o.removeAttribute('aria-hidden')
}
function getPaddingRight(o) {
  return parseInt(ownerWindow(o).getComputedStyle(o).paddingRight, 10) || 0
}
function isAriaHiddenForbiddenOnElement(o) {
  const s =
      [
        'TEMPLATE',
        'SCRIPT',
        'STYLE',
        'LINK',
        'MAP',
        'META',
        'NOSCRIPT',
        'PICTURE',
        'COL',
        'COLGROUP',
        'PARAM',
        'SLOT',
        'SOURCE',
        'TRACK',
      ].indexOf(o.tagName) !== -1,
    $ = o.tagName === 'INPUT' && o.getAttribute('type') === 'hidden'
  return s || $
}
function ariaHiddenSiblings(o, a, s, $, j) {
  const _e = [a, s, ...$]
  ;[].forEach.call(o.children, et => {
    const tt = _e.indexOf(et) === -1,
      rt = !isAriaHiddenForbiddenOnElement(et)
    tt && rt && ariaHidden(et, j)
  })
}
function findIndexOf(o, a) {
  let s = -1
  return o.some(($, j) => (a($) ? ((s = j), !0) : !1)), s
}
function handleContainer(o, a) {
  const s = [],
    $ = o.container
  if (!a.disableScrollLock) {
    if (isOverflowing($)) {
      const et = getScrollbarSize(ownerDocument($))
      s.push({ value: $.style.paddingRight, property: 'padding-right', el: $ }),
        ($.style.paddingRight = `${getPaddingRight($) + et}px`)
      const tt = ownerDocument($).querySelectorAll('.mui-fixed')
      ;[].forEach.call(tt, rt => {
        s.push({
          value: rt.style.paddingRight,
          property: 'padding-right',
          el: rt,
        }),
          (rt.style.paddingRight = `${getPaddingRight(rt) + et}px`)
      })
    }
    let _e
    if ($.parentNode instanceof DocumentFragment) _e = ownerDocument($).body
    else {
      const et = $.parentElement,
        tt = ownerWindow($)
      _e =
        (et == null ? void 0 : et.nodeName) === 'HTML' &&
        tt.getComputedStyle(et).overflowY === 'scroll'
          ? et
          : $
    }
    s.push(
      { value: _e.style.overflow, property: 'overflow', el: _e },
      { value: _e.style.overflowX, property: 'overflow-x', el: _e },
      { value: _e.style.overflowY, property: 'overflow-y', el: _e }
    ),
      (_e.style.overflow = 'hidden')
  }
  return () => {
    s.forEach(({ value: _e, el: et, property: tt }) => {
      _e ? et.style.setProperty(tt, _e) : et.style.removeProperty(tt)
    })
  }
}
function getHiddenSiblings(o) {
  const a = []
  return (
    [].forEach.call(o.children, s => {
      s.getAttribute('aria-hidden') === 'true' && a.push(s)
    }),
    a
  )
}
class ModalManager {
  constructor() {
    ;(this.containers = void 0),
      (this.modals = void 0),
      (this.modals = []),
      (this.containers = [])
  }
  add(a, s) {
    let $ = this.modals.indexOf(a)
    if ($ !== -1) return $
    ;($ = this.modals.length),
      this.modals.push(a),
      a.modalRef && ariaHidden(a.modalRef, !1)
    const j = getHiddenSiblings(s)
    ariaHiddenSiblings(s, a.mount, a.modalRef, j, !0)
    const _e = findIndexOf(this.containers, et => et.container === s)
    return _e !== -1
      ? (this.containers[_e].modals.push(a), $)
      : (this.containers.push({
          modals: [a],
          container: s,
          restore: null,
          hiddenSiblings: j,
        }),
        $)
  }
  mount(a, s) {
    const $ = findIndexOf(this.containers, _e => _e.modals.indexOf(a) !== -1),
      j = this.containers[$]
    j.restore || (j.restore = handleContainer(j, s))
  }
  remove(a, s = !0) {
    const $ = this.modals.indexOf(a)
    if ($ === -1) return $
    const j = findIndexOf(this.containers, et => et.modals.indexOf(a) !== -1),
      _e = this.containers[j]
    if (
      (_e.modals.splice(_e.modals.indexOf(a), 1),
      this.modals.splice($, 1),
      _e.modals.length === 0)
    )
      _e.restore && _e.restore(),
        a.modalRef && ariaHidden(a.modalRef, s),
        ariaHiddenSiblings(
          _e.container,
          a.mount,
          a.modalRef,
          _e.hiddenSiblings,
          !1
        ),
        this.containers.splice(j, 1)
    else {
      const et = _e.modals[_e.modals.length - 1]
      et.modalRef && ariaHidden(et.modalRef, !1)
    }
    return $
  }
  isTopModal(a) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === a
  }
}
const candidatesSelector = [
  'input',
  'select',
  'textarea',
  'a[href]',
  'button',
  '[tabindex]',
  'audio[controls]',
  'video[controls]',
  '[contenteditable]:not([contenteditable="false"])',
].join(',')
function getTabIndex(o) {
  const a = parseInt(o.getAttribute('tabindex') || '', 10)
  return Number.isNaN(a)
    ? o.contentEditable === 'true' ||
      ((o.nodeName === 'AUDIO' ||
        o.nodeName === 'VIDEO' ||
        o.nodeName === 'DETAILS') &&
        o.getAttribute('tabindex') === null)
      ? 0
      : o.tabIndex
    : a
}
function isNonTabbableRadio(o) {
  if (o.tagName !== 'INPUT' || o.type !== 'radio' || !o.name) return !1
  const a = $ => o.ownerDocument.querySelector(`input[type="radio"]${$}`)
  let s = a(`[name="${o.name}"]:checked`)
  return s || (s = a(`[name="${o.name}"]`)), s !== o
}
function isNodeMatchingSelectorFocusable(o) {
  return !(
    o.disabled ||
    (o.tagName === 'INPUT' && o.type === 'hidden') ||
    isNonTabbableRadio(o)
  )
}
function defaultGetTabbable(o) {
  const a = [],
    s = []
  return (
    Array.from(o.querySelectorAll(candidatesSelector)).forEach(($, j) => {
      const _e = getTabIndex($)
      _e === -1 ||
        !isNodeMatchingSelectorFocusable($) ||
        (_e === 0
          ? a.push($)
          : s.push({ documentOrder: j, tabIndex: _e, node: $ }))
    }),
    s
      .sort(($, j) =>
        $.tabIndex === j.tabIndex
          ? $.documentOrder - j.documentOrder
          : $.tabIndex - j.tabIndex
      )
      .map($ => $.node)
      .concat(a)
  )
}
function defaultIsEnabled() {
  return !0
}
function FocusTrap(o) {
  const {
      children: a,
      disableAutoFocus: s = !1,
      disableEnforceFocus: $ = !1,
      disableRestoreFocus: j = !1,
      getTabbable: _e = defaultGetTabbable,
      isEnabled: et = defaultIsEnabled,
      open: tt,
    } = o,
    rt = reactExports.useRef(!1),
    nt = reactExports.useRef(null),
    it = reactExports.useRef(null),
    ot = reactExports.useRef(null),
    at = reactExports.useRef(null),
    st = reactExports.useRef(!1),
    ut = reactExports.useRef(null),
    ct = useForkRef(a.ref, ut),
    dt = reactExports.useRef(null)
  reactExports.useEffect(() => {
    !tt || !ut.current || (st.current = !s)
  }, [s, tt]),
    reactExports.useEffect(() => {
      if (!tt || !ut.current) return
      const vt = ownerDocument(ut.current)
      return (
        ut.current.contains(vt.activeElement) ||
          (ut.current.hasAttribute('tabIndex') ||
            ut.current.setAttribute('tabIndex', '-1'),
          st.current && ut.current.focus()),
        () => {
          j ||
            (ot.current &&
              ot.current.focus &&
              ((rt.current = !0), ot.current.focus()),
            (ot.current = null))
        }
      )
    }, [tt]),
    reactExports.useEffect(() => {
      if (!tt || !ut.current) return
      const vt = ownerDocument(ut.current),
        yt = At => {
          ;(dt.current = At),
            !($ || !et() || At.key !== 'Tab') &&
              vt.activeElement === ut.current &&
              At.shiftKey &&
              ((rt.current = !0), it.current && it.current.focus())
        },
        pt = () => {
          const At = ut.current
          if (At === null) return
          if (!vt.hasFocus() || !et() || rt.current) {
            rt.current = !1
            return
          }
          if (
            At.contains(vt.activeElement) ||
            ($ &&
              vt.activeElement !== nt.current &&
              vt.activeElement !== it.current)
          )
            return
          if (vt.activeElement !== at.current) at.current = null
          else if (at.current !== null) return
          if (!st.current) return
          let wt = []
          if (
            ((vt.activeElement === nt.current ||
              vt.activeElement === it.current) &&
              (wt = _e(ut.current)),
            wt.length > 0)
          ) {
            var Ct, Dt
            const jt = !!(
                (Ct = dt.current) != null &&
                Ct.shiftKey &&
                ((Dt = dt.current) == null ? void 0 : Dt.key) === 'Tab'
              ),
              Et = wt[0],
              St = wt[wt.length - 1]
            typeof Et != 'string' &&
              typeof St != 'string' &&
              (jt ? St.focus() : Et.focus())
          } else At.focus()
        }
      vt.addEventListener('focusin', pt), vt.addEventListener('keydown', yt, !0)
      const ht = setInterval(() => {
        vt.activeElement && vt.activeElement.tagName === 'BODY' && pt()
      }, 50)
      return () => {
        clearInterval(ht),
          vt.removeEventListener('focusin', pt),
          vt.removeEventListener('keydown', yt, !0)
      }
    }, [s, $, j, et, tt, _e])
  const ft = vt => {
      ot.current === null && (ot.current = vt.relatedTarget),
        (st.current = !0),
        (at.current = vt.target)
      const yt = a.props.onFocus
      yt && yt(vt)
    },
    mt = vt => {
      ot.current === null && (ot.current = vt.relatedTarget), (st.current = !0)
    }
  return jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [
      jsxRuntimeExports.jsx('div', {
        tabIndex: tt ? 0 : -1,
        onFocus: mt,
        ref: nt,
        'data-testid': 'sentinelStart',
      }),
      reactExports.cloneElement(a, { ref: ct, onFocus: ft }),
      jsxRuntimeExports.jsx('div', {
        tabIndex: tt ? 0 : -1,
        onFocus: mt,
        ref: it,
        'data-testid': 'sentinelEnd',
      }),
    ],
  })
}
function getContainer$1(o) {
  return typeof o == 'function' ? o() : o
}
const Portal = reactExports.forwardRef(function(a, s) {
  const { children: $, container: j, disablePortal: _e = !1 } = a,
    [et, tt] = reactExports.useState(null),
    rt = useForkRef(reactExports.isValidElement($) ? $.ref : null, s)
  if (
    (useEnhancedEffect$1(() => {
      _e || tt(getContainer$1(j) || document.body)
    }, [j, _e]),
    useEnhancedEffect$1(() => {
      if (et && !_e)
        return (
          setRef(s, et),
          () => {
            setRef(s, null)
          }
        )
    }, [s, et, _e]),
    _e)
  ) {
    if (reactExports.isValidElement($)) {
      const nt = { ref: rt }
      return reactExports.cloneElement($, nt)
    }
    return jsxRuntimeExports.jsx(reactExports.Fragment, { children: $ })
  }
  return jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: et && reactDomExports.createPortal($, et),
  })
})
function useDefaultProps(o) {
  return useDefaultProps$1(o)
}
const config$1 = { disabled: !1 },
  TransitionGroupContext = React$5.createContext(null)
var forceReflow = function(a) {
    return a.scrollTop
  },
  UNMOUNTED = 'unmounted',
  EXITED = 'exited',
  ENTERING = 'entering',
  ENTERED = 'entered',
  EXITING = 'exiting',
  Transition = (function(o) {
    _inheritsLoose$2(a, o)
    function a($, j) {
      var _e
      _e = o.call(this, $, j) || this
      var et = j,
        tt = et && !et.isMounting ? $.enter : $.appear,
        rt
      return (
        (_e.appearStatus = null),
        $.in
          ? tt
            ? ((rt = EXITED), (_e.appearStatus = ENTERING))
            : (rt = ENTERED)
          : $.unmountOnExit || $.mountOnEnter
          ? (rt = UNMOUNTED)
          : (rt = EXITED),
        (_e.state = { status: rt }),
        (_e.nextCallback = null),
        _e
      )
    }
    a.getDerivedStateFromProps = function(j, _e) {
      var et = j.in
      return et && _e.status === UNMOUNTED ? { status: EXITED } : null
    }
    var s = a.prototype
    return (
      (s.componentDidMount = function() {
        this.updateStatus(!0, this.appearStatus)
      }),
      (s.componentDidUpdate = function(j) {
        var _e = null
        if (j !== this.props) {
          var et = this.state.status
          this.props.in
            ? et !== ENTERING && et !== ENTERED && (_e = ENTERING)
            : (et === ENTERING || et === ENTERED) && (_e = EXITING)
        }
        this.updateStatus(!1, _e)
      }),
      (s.componentWillUnmount = function() {
        this.cancelNextCallback()
      }),
      (s.getTimeouts = function() {
        var j = this.props.timeout,
          _e,
          et,
          tt
        return (
          (_e = et = tt = j),
          j != null &&
            typeof j != 'number' &&
            ((_e = j.exit),
            (et = j.enter),
            (tt = j.appear !== void 0 ? j.appear : et)),
          { exit: _e, enter: et, appear: tt }
        )
      }),
      (s.updateStatus = function(j, _e) {
        if ((j === void 0 && (j = !1), _e !== null))
          if ((this.cancelNextCallback(), _e === ENTERING)) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var et = this.props.nodeRef
                ? this.props.nodeRef.current
                : ReactDOM.findDOMNode(this)
              et && forceReflow(et)
            }
            this.performEnter(j)
          } else this.performExit()
        else
          this.props.unmountOnExit &&
            this.state.status === EXITED &&
            this.setState({ status: UNMOUNTED })
      }),
      (s.performEnter = function(j) {
        var _e = this,
          et = this.props.enter,
          tt = this.context ? this.context.isMounting : j,
          rt = this.props.nodeRef ? [tt] : [ReactDOM.findDOMNode(this), tt],
          nt = rt[0],
          it = rt[1],
          ot = this.getTimeouts(),
          at = tt ? ot.appear : ot.enter
        if ((!j && !et) || config$1.disabled) {
          this.safeSetState({ status: ENTERED }, function() {
            _e.props.onEntered(nt)
          })
          return
        }
        this.props.onEnter(nt, it),
          this.safeSetState({ status: ENTERING }, function() {
            _e.props.onEntering(nt, it),
              _e.onTransitionEnd(at, function() {
                _e.safeSetState({ status: ENTERED }, function() {
                  _e.props.onEntered(nt, it)
                })
              })
          })
      }),
      (s.performExit = function() {
        var j = this,
          _e = this.props.exit,
          et = this.getTimeouts(),
          tt = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this)
        if (!_e || config$1.disabled) {
          this.safeSetState({ status: EXITED }, function() {
            j.props.onExited(tt)
          })
          return
        }
        this.props.onExit(tt),
          this.safeSetState({ status: EXITING }, function() {
            j.props.onExiting(tt),
              j.onTransitionEnd(et.exit, function() {
                j.safeSetState({ status: EXITED }, function() {
                  j.props.onExited(tt)
                })
              })
          })
      }),
      (s.cancelNextCallback = function() {
        this.nextCallback !== null &&
          (this.nextCallback.cancel(), (this.nextCallback = null))
      }),
      (s.safeSetState = function(j, _e) {
        ;(_e = this.setNextCallback(_e)), this.setState(j, _e)
      }),
      (s.setNextCallback = function(j) {
        var _e = this,
          et = !0
        return (
          (this.nextCallback = function(tt) {
            et && ((et = !1), (_e.nextCallback = null), j(tt))
          }),
          (this.nextCallback.cancel = function() {
            et = !1
          }),
          this.nextCallback
        )
      }),
      (s.onTransitionEnd = function(j, _e) {
        this.setNextCallback(_e)
        var et = this.props.nodeRef
            ? this.props.nodeRef.current
            : ReactDOM.findDOMNode(this),
          tt = j == null && !this.props.addEndListener
        if (!et || tt) {
          setTimeout(this.nextCallback, 0)
          return
        }
        if (this.props.addEndListener) {
          var rt = this.props.nodeRef
              ? [this.nextCallback]
              : [et, this.nextCallback],
            nt = rt[0],
            it = rt[1]
          this.props.addEndListener(nt, it)
        }
        j != null && setTimeout(this.nextCallback, j)
      }),
      (s.render = function() {
        var j = this.state.status
        if (j === UNMOUNTED) return null
        var _e = this.props,
          et = _e.children
        _e.in,
          _e.mountOnEnter,
          _e.unmountOnExit,
          _e.appear,
          _e.enter,
          _e.exit,
          _e.timeout,
          _e.addEndListener,
          _e.onEnter,
          _e.onEntering,
          _e.onEntered,
          _e.onExit,
          _e.onExiting,
          _e.onExited,
          _e.nodeRef
        var tt = _objectWithoutPropertiesLoose$3(_e, [
          'children',
          'in',
          'mountOnEnter',
          'unmountOnExit',
          'appear',
          'enter',
          'exit',
          'timeout',
          'addEndListener',
          'onEnter',
          'onEntering',
          'onEntered',
          'onExit',
          'onExiting',
          'onExited',
          'nodeRef',
        ])
        return React$5.createElement(
          TransitionGroupContext.Provider,
          { value: null },
          typeof et == 'function'
            ? et(j, tt)
            : React$5.cloneElement(React$5.Children.only(et), tt)
        )
      }),
      a
    )
  })(React$5.Component)
Transition.contextType = TransitionGroupContext
Transition.propTypes = {}
function noop$9() {}
Transition.defaultProps = {
  in: !1,
  mountOnEnter: !1,
  unmountOnExit: !1,
  appear: !1,
  enter: !0,
  exit: !0,
  onEnter: noop$9,
  onEntering: noop$9,
  onEntered: noop$9,
  onExit: noop$9,
  onExiting: noop$9,
  onExited: noop$9,
}
Transition.UNMOUNTED = UNMOUNTED
Transition.EXITED = EXITED
Transition.ENTERING = ENTERING
Transition.ENTERED = ENTERED
Transition.EXITING = EXITING
function _assertThisInitialized$1(o) {
  if (o === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return o
}
function getChildMapping(o, a) {
  var s = function(_e) {
      return a && reactExports.isValidElement(_e) ? a(_e) : _e
    },
    $ = Object.create(null)
  return (
    o &&
      reactExports.Children.map(o, function(j) {
        return j
      }).forEach(function(j) {
        $[j.key] = s(j)
      }),
    $
  )
}
function mergeChildMappings(o, a) {
  ;(o = o || {}), (a = a || {})
  function s(it) {
    return it in a ? a[it] : o[it]
  }
  var $ = Object.create(null),
    j = []
  for (var _e in o) _e in a ? j.length && (($[_e] = j), (j = [])) : j.push(_e)
  var et,
    tt = {}
  for (var rt in a) {
    if ($[rt])
      for (et = 0; et < $[rt].length; et++) {
        var nt = $[rt][et]
        tt[$[rt][et]] = s(nt)
      }
    tt[rt] = s(rt)
  }
  for (et = 0; et < j.length; et++) tt[j[et]] = s(j[et])
  return tt
}
function getProp(o, a, s) {
  return s[a] != null ? s[a] : o.props[a]
}
function getInitialChildMapping(o, a) {
  return getChildMapping(o.children, function(s) {
    return reactExports.cloneElement(s, {
      onExited: a.bind(null, s),
      in: !0,
      appear: getProp(s, 'appear', o),
      enter: getProp(s, 'enter', o),
      exit: getProp(s, 'exit', o),
    })
  })
}
function getNextChildMapping(o, a, s) {
  var $ = getChildMapping(o.children),
    j = mergeChildMappings(a, $)
  return (
    Object.keys(j).forEach(function(_e) {
      var et = j[_e]
      if (reactExports.isValidElement(et)) {
        var tt = _e in a,
          rt = _e in $,
          nt = a[_e],
          it = reactExports.isValidElement(nt) && !nt.props.in
        rt && (!tt || it)
          ? (j[_e] = reactExports.cloneElement(et, {
              onExited: s.bind(null, et),
              in: !0,
              exit: getProp(et, 'exit', o),
              enter: getProp(et, 'enter', o),
            }))
          : !rt && tt && !it
          ? (j[_e] = reactExports.cloneElement(et, { in: !1 }))
          : rt &&
            tt &&
            reactExports.isValidElement(nt) &&
            (j[_e] = reactExports.cloneElement(et, {
              onExited: s.bind(null, et),
              in: nt.props.in,
              exit: getProp(et, 'exit', o),
              enter: getProp(et, 'enter', o),
            }))
      }
    }),
    j
  )
}
var values =
    Object.values ||
    function(o) {
      return Object.keys(o).map(function(a) {
        return o[a]
      })
    },
  defaultProps$1 = {
    component: 'div',
    childFactory: function(a) {
      return a
    },
  },
  TransitionGroup = (function(o) {
    _inheritsLoose$2(a, o)
    function a($, j) {
      var _e
      _e = o.call(this, $, j) || this
      var et = _e.handleExited.bind(_assertThisInitialized$1(_e))
      return (
        (_e.state = {
          contextValue: { isMounting: !0 },
          handleExited: et,
          firstRender: !0,
        }),
        _e
      )
    }
    var s = a.prototype
    return (
      (s.componentDidMount = function() {
        ;(this.mounted = !0),
          this.setState({ contextValue: { isMounting: !1 } })
      }),
      (s.componentWillUnmount = function() {
        this.mounted = !1
      }),
      (a.getDerivedStateFromProps = function(j, _e) {
        var et = _e.children,
          tt = _e.handleExited,
          rt = _e.firstRender
        return {
          children: rt
            ? getInitialChildMapping(j, tt)
            : getNextChildMapping(j, et, tt),
          firstRender: !1,
        }
      }),
      (s.handleExited = function(j, _e) {
        var et = getChildMapping(this.props.children)
        j.key in et ||
          (j.props.onExited && j.props.onExited(_e),
          this.mounted &&
            this.setState(function(tt) {
              var rt = _extends$5({}, tt.children)
              return delete rt[j.key], { children: rt }
            }))
      }),
      (s.render = function() {
        var j = this.props,
          _e = j.component,
          et = j.childFactory,
          tt = _objectWithoutPropertiesLoose$3(j, [
            'component',
            'childFactory',
          ]),
          rt = this.state.contextValue,
          nt = values(this.state.children).map(et)
        return (
          delete tt.appear,
          delete tt.enter,
          delete tt.exit,
          _e === null
            ? React$5.createElement(
                TransitionGroupContext.Provider,
                { value: rt },
                nt
              )
            : React$5.createElement(
                TransitionGroupContext.Provider,
                { value: rt },
                React$5.createElement(_e, tt, nt)
              )
        )
      }),
      a
    )
  })(React$5.Component)
TransitionGroup.propTypes = {}
TransitionGroup.defaultProps = defaultProps$1
const reflow = o => o.scrollTop
function getTransitionProps(o, a) {
  var s, $
  const { timeout: j, easing: _e, style: et = {} } = o
  return {
    duration:
      (s = et.transitionDuration) != null
        ? s
        : typeof j == 'number'
        ? j
        : j[a.mode] || 0,
    easing:
      ($ = et.transitionTimingFunction) != null
        ? $
        : typeof _e == 'object'
        ? _e[a.mode]
        : _e,
    delay: et.transitionDelay,
  }
}
const _excluded$19 = [
    'addEndListener',
    'appear',
    'children',
    'easing',
    'in',
    'onEnter',
    'onEntered',
    'onEntering',
    'onExit',
    'onExited',
    'onExiting',
    'style',
    'timeout',
    'TransitionComponent',
  ],
  styles$5 = { entering: { opacity: 1 }, entered: { opacity: 1 } },
  Fade = reactExports.forwardRef(function(a, s) {
    const $ = useTheme$1(),
      j = {
        enter: $.transitions.duration.enteringScreen,
        exit: $.transitions.duration.leavingScreen,
      },
      {
        addEndListener: _e,
        appear: et = !0,
        children: tt,
        easing: rt,
        in: nt,
        onEnter: it,
        onEntered: ot,
        onEntering: at,
        onExit: st,
        onExited: ut,
        onExiting: ct,
        style: dt,
        timeout: ft = j,
        TransitionComponent: mt = Transition,
      } = a,
      vt = _objectWithoutPropertiesLoose$3(a, _excluded$19),
      yt = reactExports.useRef(null),
      pt = useForkRef(yt, tt.ref, s),
      ht = Bt => Mt => {
        if (Bt) {
          const Ut = yt.current
          Mt === void 0 ? Bt(Ut) : Bt(Ut, Mt)
        }
      },
      At = ht(at),
      wt = ht((Bt, Mt) => {
        reflow(Bt)
        const Ut = getTransitionProps(
          { style: dt, timeout: ft, easing: rt },
          { mode: 'enter' }
        )
        ;(Bt.style.webkitTransition = $.transitions.create('opacity', Ut)),
          (Bt.style.transition = $.transitions.create('opacity', Ut)),
          it && it(Bt, Mt)
      }),
      Ct = ht(ot),
      Dt = ht(ct),
      jt = ht(Bt => {
        const Mt = getTransitionProps(
          { style: dt, timeout: ft, easing: rt },
          { mode: 'exit' }
        )
        ;(Bt.style.webkitTransition = $.transitions.create('opacity', Mt)),
          (Bt.style.transition = $.transitions.create('opacity', Mt)),
          st && st(Bt)
      }),
      Et = ht(ut),
      St = Bt => {
        _e && _e(yt.current, Bt)
      }
    return jsxRuntimeExports.jsx(
      mt,
      _extends$5(
        {
          appear: et,
          in: nt,
          nodeRef: yt,
          onEnter: wt,
          onEntered: Ct,
          onEntering: At,
          onExit: jt,
          onExited: Et,
          onExiting: Dt,
          addEndListener: St,
          timeout: ft,
        },
        vt,
        {
          children: (Bt, Mt) =>
            reactExports.cloneElement(
              tt,
              _extends$5(
                {
                  style: _extends$5(
                    {
                      opacity: 0,
                      visibility: Bt === 'exited' && !nt ? 'hidden' : void 0,
                    },
                    styles$5[Bt],
                    dt,
                    tt.props.style
                  ),
                  ref: pt,
                },
                Mt
              )
            ),
        }
      )
    )
  })
function getBackdropUtilityClass(o) {
  return generateUtilityClass('MuiBackdrop', o)
}
generateUtilityClasses('MuiBackdrop', ['root', 'invisible'])
const _excluded$18 = [
    'children',
    'className',
    'component',
    'components',
    'componentsProps',
    'invisible',
    'open',
    'slotProps',
    'slots',
    'TransitionComponent',
    'transitionDuration',
  ],
  useUtilityClasses$_ = o => {
    const { classes: a, invisible: s } = o
    return composeClasses(
      { root: ['root', s && 'invisible'] },
      getBackdropUtilityClass,
      a
    )
  },
  BackdropRoot = styled('div', {
    name: 'MuiBackdrop',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, s.invisible && a.invisible]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      {
        position: 'fixed',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        WebkitTapHighlightColor: 'transparent',
      },
      o.invisible && { backgroundColor: 'transparent' }
    )
  ),
  Backdrop = reactExports.forwardRef(function(a, s) {
    var $, j, _e
    const et = useDefaultProps({ props: a, name: 'MuiBackdrop' }),
      {
        children: tt,
        className: rt,
        component: nt = 'div',
        components: it = {},
        componentsProps: ot = {},
        invisible: at = !1,
        open: st,
        slotProps: ut = {},
        slots: ct = {},
        TransitionComponent: dt = Fade,
        transitionDuration: ft,
      } = et,
      mt = _objectWithoutPropertiesLoose$3(et, _excluded$18),
      vt = _extends$5({}, et, { component: nt, invisible: at }),
      yt = useUtilityClasses$_(vt),
      pt = ($ = ut.root) != null ? $ : ot.root
    return jsxRuntimeExports.jsx(
      dt,
      _extends$5({ in: st, timeout: ft }, mt, {
        children: jsxRuntimeExports.jsx(
          BackdropRoot,
          _extends$5({ 'aria-hidden': !0 }, pt, {
            as: (j = (_e = ct.root) != null ? _e : it.Root) != null ? j : nt,
            className: clsx$1(yt.root, rt, pt == null ? void 0 : pt.className),
            ownerState: _extends$5({}, vt, pt == null ? void 0 : pt.ownerState),
            classes: yt,
            ref: s,
            children: tt,
          })
        ),
      })
    )
  })
function getContainer(o) {
  return typeof o == 'function' ? o() : o
}
function getHasTransition(o) {
  return o ? o.props.hasOwnProperty('in') : !1
}
const defaultManager = new ModalManager()
function useModal(o) {
  const {
      container: a,
      disableEscapeKeyDown: s = !1,
      disableScrollLock: $ = !1,
      manager: j = defaultManager,
      closeAfterTransition: _e = !1,
      onTransitionEnter: et,
      onTransitionExited: tt,
      children: rt,
      onClose: nt,
      open: it,
      rootRef: ot,
    } = o,
    at = reactExports.useRef({}),
    st = reactExports.useRef(null),
    ut = reactExports.useRef(null),
    ct = useForkRef(ut, ot),
    [dt, ft] = reactExports.useState(!it),
    mt = getHasTransition(rt)
  let vt = !0
  ;(o['aria-hidden'] === 'false' || o['aria-hidden'] === !1) && (vt = !1)
  const yt = () => ownerDocument(st.current),
    pt = () => (
      (at.current.modalRef = ut.current),
      (at.current.mount = st.current),
      at.current
    ),
    ht = () => {
      j.mount(pt(), { disableScrollLock: $ }),
        ut.current && (ut.current.scrollTop = 0)
    },
    At = useEventCallback$1(() => {
      const Ut = getContainer(a) || yt().body
      j.add(pt(), Ut), ut.current && ht()
    }),
    wt = reactExports.useCallback(() => j.isTopModal(pt()), [j]),
    Ct = useEventCallback$1(Ut => {
      ;(st.current = Ut),
        Ut && (it && wt() ? ht() : ut.current && ariaHidden(ut.current, vt))
    }),
    Dt = reactExports.useCallback(() => {
      j.remove(pt(), vt)
    }, [vt, j])
  reactExports.useEffect(
    () => () => {
      Dt()
    },
    [Dt]
  ),
    reactExports.useEffect(() => {
      it ? At() : (!mt || !_e) && Dt()
    }, [it, Dt, mt, _e, At])
  const jt = Ut => Wt => {
      var Tt
      ;(Tt = Ut.onKeyDown) == null || Tt.call(Ut, Wt),
        !(Wt.key !== 'Escape' || Wt.which === 229 || !wt()) &&
          (s || (Wt.stopPropagation(), nt && nt(Wt, 'escapeKeyDown')))
    },
    Et = Ut => Wt => {
      var Tt
      ;(Tt = Ut.onClick) == null || Tt.call(Ut, Wt),
        Wt.target === Wt.currentTarget && nt && nt(Wt, 'backdropClick')
    }
  return {
    getRootProps: (Ut = {}) => {
      const Wt = extractEventHandlers(o)
      delete Wt.onTransitionEnter, delete Wt.onTransitionExited
      const Tt = _extends$5({}, Wt, Ut)
      return _extends$5({ role: 'presentation' }, Tt, {
        onKeyDown: jt(Tt),
        ref: ct,
      })
    },
    getBackdropProps: (Ut = {}) => {
      const Wt = Ut
      return _extends$5({ 'aria-hidden': !0 }, Wt, {
        onClick: Et(Wt),
        open: it,
      })
    },
    getTransitionProps: () => {
      const Ut = () => {
          ft(!1), et && et()
        },
        Wt = () => {
          ft(!0), tt && tt(), _e && Dt()
        }
      return {
        onEnter: createChainedFunction$1(
          Ut,
          rt == null ? void 0 : rt.props.onEnter
        ),
        onExited: createChainedFunction$1(
          Wt,
          rt == null ? void 0 : rt.props.onExited
        ),
      }
    },
    rootRef: ct,
    portalRef: Ct,
    isTopModal: wt,
    exited: dt,
    hasTransition: mt,
  }
}
function getModalUtilityClass(o) {
  return generateUtilityClass('MuiModal', o)
}
generateUtilityClasses('MuiModal', ['root', 'hidden', 'backdrop'])
const _excluded$17 = [
    'BackdropComponent',
    'BackdropProps',
    'classes',
    'className',
    'closeAfterTransition',
    'children',
    'container',
    'component',
    'components',
    'componentsProps',
    'disableAutoFocus',
    'disableEnforceFocus',
    'disableEscapeKeyDown',
    'disablePortal',
    'disableRestoreFocus',
    'disableScrollLock',
    'hideBackdrop',
    'keepMounted',
    'onBackdropClick',
    'onClose',
    'onTransitionEnter',
    'onTransitionExited',
    'open',
    'slotProps',
    'slots',
    'theme',
  ],
  useUtilityClasses$Z = o => {
    const { open: a, exited: s, classes: $ } = o
    return composeClasses(
      { root: ['root', !a && s && 'hidden'], backdrop: ['backdrop'] },
      getModalUtilityClass,
      $
    )
  },
  ModalRoot = styled('div', {
    name: 'MuiModal',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, !s.open && s.exited && a.hidden]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        position: 'fixed',
        zIndex: (o.vars || o).zIndex.modal,
        right: 0,
        bottom: 0,
        top: 0,
        left: 0,
      },
      !a.open && a.exited && { visibility: 'hidden' }
    )
  ),
  ModalBackdrop = styled(Backdrop, {
    name: 'MuiModal',
    slot: 'Backdrop',
    overridesResolver: (o, a) => a.backdrop,
  })({ zIndex: -1 }),
  Modal = reactExports.forwardRef(function(a, s) {
    var $, j, _e, et, tt, rt
    const nt = useDefaultProps({ name: 'MuiModal', props: a }),
      {
        BackdropComponent: it = ModalBackdrop,
        BackdropProps: ot,
        className: at,
        closeAfterTransition: st = !1,
        children: ut,
        container: ct,
        component: dt,
        components: ft = {},
        componentsProps: mt = {},
        disableAutoFocus: vt = !1,
        disableEnforceFocus: yt = !1,
        disableEscapeKeyDown: pt = !1,
        disablePortal: ht = !1,
        disableRestoreFocus: At = !1,
        disableScrollLock: wt = !1,
        hideBackdrop: Ct = !1,
        keepMounted: Dt = !1,
        onBackdropClick: jt,
        open: Et,
        slotProps: St,
        slots: Bt,
      } = nt,
      Mt = _objectWithoutPropertiesLoose$3(nt, _excluded$17),
      Ut = _extends$5({}, nt, {
        closeAfterTransition: st,
        disableAutoFocus: vt,
        disableEnforceFocus: yt,
        disableEscapeKeyDown: pt,
        disablePortal: ht,
        disableRestoreFocus: At,
        disableScrollLock: wt,
        hideBackdrop: Ct,
        keepMounted: Dt,
      }),
      {
        getRootProps: Wt,
        getBackdropProps: Tt,
        getTransitionProps: kt,
        portalRef: Ot,
        isTopModal: Nt,
        exited: $t,
        hasTransition: Pt,
      } = useModal(_extends$5({}, Ut, { rootRef: s })),
      Ft = _extends$5({}, Ut, { exited: $t }),
      Vt = useUtilityClasses$Z(Ft),
      Xt = {}
    if ((ut.props.tabIndex === void 0 && (Xt.tabIndex = '-1'), Pt)) {
      const { onEnter: Lt, onExited: tr } = kt()
      ;(Xt.onEnter = Lt), (Xt.onExited = tr)
    }
    const Yt =
        ($ = (j = Bt == null ? void 0 : Bt.root) != null ? j : ft.Root) != null
          ? $
          : ModalRoot,
      xt =
        (_e =
          (et = Bt == null ? void 0 : Bt.backdrop) != null
            ? et
            : ft.Backdrop) != null
          ? _e
          : it,
      It = (tt = St == null ? void 0 : St.root) != null ? tt : mt.root,
      Kt = (rt = St == null ? void 0 : St.backdrop) != null ? rt : mt.backdrop,
      Qt = useSlotProps({
        elementType: Yt,
        externalSlotProps: It,
        externalForwardedProps: Mt,
        getSlotProps: Wt,
        additionalProps: { ref: s, as: dt },
        ownerState: Ft,
        className: clsx$1(
          at,
          It == null ? void 0 : It.className,
          Vt == null ? void 0 : Vt.root,
          !Ft.open && Ft.exited && (Vt == null ? void 0 : Vt.hidden)
        ),
      }),
      Ht = useSlotProps({
        elementType: xt,
        externalSlotProps: Kt,
        additionalProps: ot,
        getSlotProps: Lt =>
          Tt(
            _extends$5({}, Lt, {
              onClick: tr => {
                jt && jt(tr), Lt != null && Lt.onClick && Lt.onClick(tr)
              },
            })
          ),
        className: clsx$1(
          Kt == null ? void 0 : Kt.className,
          ot == null ? void 0 : ot.className,
          Vt == null ? void 0 : Vt.backdrop
        ),
        ownerState: Ft,
      })
    return !Dt && !Et && (!Pt || $t)
      ? null
      : jsxRuntimeExports.jsx(Portal, {
          ref: Ot,
          container: ct,
          disablePortal: ht,
          children: jsxRuntimeExports.jsxs(
            Yt,
            _extends$5({}, Qt, {
              children: [
                !Ct && it
                  ? jsxRuntimeExports.jsx(xt, _extends$5({}, Ht))
                  : null,
                jsxRuntimeExports.jsx(FocusTrap, {
                  disableEnforceFocus: yt,
                  disableAutoFocus: vt,
                  disableRestoreFocus: At,
                  isEnabled: Nt,
                  open: Et,
                  children: reactExports.cloneElement(ut, Xt),
                }),
              ],
            })
          ),
        })
  })
function getSvgIconUtilityClass(o) {
  return generateUtilityClass('MuiSvgIcon', o)
}
generateUtilityClasses('MuiSvgIcon', [
  'root',
  'colorPrimary',
  'colorSecondary',
  'colorAction',
  'colorError',
  'colorDisabled',
  'fontSizeInherit',
  'fontSizeSmall',
  'fontSizeMedium',
  'fontSizeLarge',
])
const _excluded$16 = [
    'children',
    'className',
    'color',
    'component',
    'fontSize',
    'htmlColor',
    'inheritViewBox',
    'titleAccess',
    'viewBox',
  ],
  useUtilityClasses$Y = o => {
    const { color: a, fontSize: s, classes: $ } = o,
      j = {
        root: [
          'root',
          a !== 'inherit' && `color${capitalize$2(a)}`,
          `fontSize${capitalize$2(s)}`,
        ],
      }
    return composeClasses(j, getSvgIconUtilityClass, $)
  },
  SvgIconRoot = styled('svg', {
    name: 'MuiSvgIcon',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        s.color !== 'inherit' && a[`color${capitalize$2(s.color)}`],
        a[`fontSize${capitalize$2(s.fontSize)}`],
      ]
    },
  })(({ theme: o, ownerState: a }) => {
    var s, $, j, _e, et, tt, rt, nt, it, ot, at, st, ut
    return {
      userSelect: 'none',
      width: '1em',
      height: '1em',
      display: 'inline-block',
      fill: a.hasSvgAsChild ? void 0 : 'currentColor',
      flexShrink: 0,
      transition:
        (s = o.transitions) == null || ($ = s.create) == null
          ? void 0
          : $.call(s, 'fill', {
              duration:
                (j = o.transitions) == null || (j = j.duration) == null
                  ? void 0
                  : j.shorter,
            }),
      fontSize: {
        inherit: 'inherit',
        small:
          ((_e = o.typography) == null || (et = _e.pxToRem) == null
            ? void 0
            : et.call(_e, 20)) || '1.25rem',
        medium:
          ((tt = o.typography) == null || (rt = tt.pxToRem) == null
            ? void 0
            : rt.call(tt, 24)) || '1.5rem',
        large:
          ((nt = o.typography) == null || (it = nt.pxToRem) == null
            ? void 0
            : it.call(nt, 35)) || '2.1875rem',
      }[a.fontSize],
      color:
        (ot =
          (at = (o.vars || o).palette) == null || (at = at[a.color]) == null
            ? void 0
            : at.main) != null
          ? ot
          : {
              action:
                (st = (o.vars || o).palette) == null || (st = st.action) == null
                  ? void 0
                  : st.active,
              disabled:
                (ut = (o.vars || o).palette) == null || (ut = ut.action) == null
                  ? void 0
                  : ut.disabled,
              inherit: void 0,
            }[a.color],
    }
  }),
  SvgIcon = reactExports.forwardRef(function(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiSvgIcon' }),
      {
        children: j,
        className: _e,
        color: et = 'inherit',
        component: tt = 'svg',
        fontSize: rt = 'medium',
        htmlColor: nt,
        inheritViewBox: it = !1,
        titleAccess: ot,
        viewBox: at = '0 0 24 24',
      } = $,
      st = _objectWithoutPropertiesLoose$3($, _excluded$16),
      ut = reactExports.isValidElement(j) && j.type === 'svg',
      ct = _extends$5({}, $, {
        color: et,
        component: tt,
        fontSize: rt,
        instanceFontSize: a.fontSize,
        inheritViewBox: it,
        viewBox: at,
        hasSvgAsChild: ut,
      }),
      dt = {}
    it || (dt.viewBox = at)
    const ft = useUtilityClasses$Y(ct)
    return jsxRuntimeExports.jsxs(
      SvgIconRoot,
      _extends$5(
        {
          as: tt,
          className: clsx$1(ft.root, _e),
          focusable: 'false',
          color: nt,
          'aria-hidden': ot ? void 0 : !0,
          role: ot ? 'img' : void 0,
          ref: s,
        },
        dt,
        st,
        ut && j.props,
        {
          ownerState: ct,
          children: [
            ut ? j.props.children : j,
            ot ? jsxRuntimeExports.jsx('title', { children: ot }) : null,
          ],
        }
      )
    )
  })
SvgIcon.muiName = 'SvgIcon'
function createSvgIcon$1(o, a) {
  function s($, j) {
    return jsxRuntimeExports.jsx(
      SvgIcon,
      _extends$5({ 'data-testid': `${a}Icon`, ref: j }, $, { children: o })
    )
  }
  return (
    (s.muiName = SvgIcon.muiName), reactExports.memo(reactExports.forwardRef(s))
  )
}
const unstable_ClassNameGenerator = {
    configure: o => {
      ClassNameGenerator.configure(o)
    },
  },
  utils$4 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        capitalize: capitalize$2,
        createChainedFunction: createChainedFunction$1,
        createSvgIcon: createSvgIcon$1,
        debounce: debounce$4,
        deprecatedPropType,
        isMuiElement,
        ownerDocument,
        ownerWindow,
        requirePropFactory,
        setRef,
        unstable_ClassNameGenerator,
        unstable_useEnhancedEffect: useEnhancedEffect$1,
        unstable_useId: useId,
        unsupportedProp,
        useControlled,
        useEventCallback: useEventCallback$1,
        useForkRef,
        useIsFocusVisible,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  _excluded$15 = [
    'addEndListener',
    'appear',
    'children',
    'container',
    'direction',
    'easing',
    'in',
    'onEnter',
    'onEntered',
    'onEntering',
    'onExit',
    'onExited',
    'onExiting',
    'style',
    'timeout',
    'TransitionComponent',
  ]
function getTranslateValue(o, a, s) {
  const $ = a.getBoundingClientRect(),
    j = s && s.getBoundingClientRect(),
    _e = ownerWindow(a)
  let et
  if (a.fakeTransform) et = a.fakeTransform
  else {
    const nt = _e.getComputedStyle(a)
    et =
      nt.getPropertyValue('-webkit-transform') ||
      nt.getPropertyValue('transform')
  }
  let tt = 0,
    rt = 0
  if (et && et !== 'none' && typeof et == 'string') {
    const nt = et
      .split('(')[1]
      .split(')')[0]
      .split(',')
    ;(tt = parseInt(nt[4], 10)), (rt = parseInt(nt[5], 10))
  }
  return o === 'left'
    ? j
      ? `translateX(${j.right + tt - $.left}px)`
      : `translateX(${_e.innerWidth + tt - $.left}px)`
    : o === 'right'
    ? j
      ? `translateX(-${$.right - j.left - tt}px)`
      : `translateX(-${$.left + $.width - tt}px)`
    : o === 'up'
    ? j
      ? `translateY(${j.bottom + rt - $.top}px)`
      : `translateY(${_e.innerHeight + rt - $.top}px)`
    : j
    ? `translateY(-${$.top - j.top + $.height - rt}px)`
    : `translateY(-${$.top + $.height - rt}px)`
}
function resolveContainer(o) {
  return typeof o == 'function' ? o() : o
}
function setTranslateValue(o, a, s) {
  const $ = resolveContainer(s),
    j = getTranslateValue(o, a, $)
  j && ((a.style.webkitTransform = j), (a.style.transform = j))
}
const Slide = reactExports.forwardRef(function(a, s) {
  const $ = useTheme$1(),
    j = {
      enter: $.transitions.easing.easeOut,
      exit: $.transitions.easing.sharp,
    },
    _e = {
      enter: $.transitions.duration.enteringScreen,
      exit: $.transitions.duration.leavingScreen,
    },
    {
      addEndListener: et,
      appear: tt = !0,
      children: rt,
      container: nt,
      direction: it = 'down',
      easing: ot = j,
      in: at,
      onEnter: st,
      onEntered: ut,
      onEntering: ct,
      onExit: dt,
      onExited: ft,
      onExiting: mt,
      style: vt,
      timeout: yt = _e,
      TransitionComponent: pt = Transition,
    } = a,
    ht = _objectWithoutPropertiesLoose$3(a, _excluded$15),
    At = reactExports.useRef(null),
    wt = useForkRef(rt.ref, At, s),
    Ct = Tt => kt => {
      Tt && (kt === void 0 ? Tt(At.current) : Tt(At.current, kt))
    },
    Dt = Ct((Tt, kt) => {
      setTranslateValue(it, Tt, nt), reflow(Tt), st && st(Tt, kt)
    }),
    jt = Ct((Tt, kt) => {
      const Ot = getTransitionProps(
        { timeout: yt, style: vt, easing: ot },
        { mode: 'enter' }
      )
      ;(Tt.style.webkitTransition = $.transitions.create(
        '-webkit-transform',
        _extends$5({}, Ot)
      )),
        (Tt.style.transition = $.transitions.create(
          'transform',
          _extends$5({}, Ot)
        )),
        (Tt.style.webkitTransform = 'none'),
        (Tt.style.transform = 'none'),
        ct && ct(Tt, kt)
    }),
    Et = Ct(ut),
    St = Ct(mt),
    Bt = Ct(Tt => {
      const kt = getTransitionProps(
        { timeout: yt, style: vt, easing: ot },
        { mode: 'exit' }
      )
      ;(Tt.style.webkitTransition = $.transitions.create(
        '-webkit-transform',
        kt
      )),
        (Tt.style.transition = $.transitions.create('transform', kt)),
        setTranslateValue(it, Tt, nt),
        dt && dt(Tt)
    }),
    Mt = Ct(Tt => {
      ;(Tt.style.webkitTransition = ''),
        (Tt.style.transition = ''),
        ft && ft(Tt)
    }),
    Ut = Tt => {
      et && et(At.current, Tt)
    },
    Wt = reactExports.useCallback(() => {
      At.current && setTranslateValue(it, At.current, nt)
    }, [it, nt])
  return (
    reactExports.useEffect(() => {
      if (at || it === 'down' || it === 'right') return
      const Tt = debounce$4(() => {
          At.current && setTranslateValue(it, At.current, nt)
        }),
        kt = ownerWindow(At.current)
      return (
        kt.addEventListener('resize', Tt),
        () => {
          Tt.clear(), kt.removeEventListener('resize', Tt)
        }
      )
    }, [it, at, nt]),
    reactExports.useEffect(() => {
      at || Wt()
    }, [at, Wt]),
    jsxRuntimeExports.jsx(
      pt,
      _extends$5(
        {
          nodeRef: At,
          onEnter: Dt,
          onEntered: Et,
          onEntering: jt,
          onExit: Bt,
          onExited: Mt,
          onExiting: St,
          addEndListener: Ut,
          appear: tt,
          in: at,
          timeout: yt,
        },
        ht,
        {
          children: (Tt, kt) =>
            reactExports.cloneElement(
              rt,
              _extends$5(
                {
                  ref: wt,
                  style: _extends$5(
                    { visibility: Tt === 'exited' && !at ? 'hidden' : void 0 },
                    vt,
                    rt.props.style
                  ),
                },
                kt
              )
            ),
        }
      )
    )
  )
})
function getPaperUtilityClass(o) {
  return generateUtilityClass('MuiPaper', o)
}
generateUtilityClasses('MuiPaper', [
  'root',
  'rounded',
  'outlined',
  'elevation',
  'elevation0',
  'elevation1',
  'elevation2',
  'elevation3',
  'elevation4',
  'elevation5',
  'elevation6',
  'elevation7',
  'elevation8',
  'elevation9',
  'elevation10',
  'elevation11',
  'elevation12',
  'elevation13',
  'elevation14',
  'elevation15',
  'elevation16',
  'elevation17',
  'elevation18',
  'elevation19',
  'elevation20',
  'elevation21',
  'elevation22',
  'elevation23',
  'elevation24',
])
const _excluded$14 = [
    'className',
    'component',
    'elevation',
    'square',
    'variant',
  ],
  useUtilityClasses$X = o => {
    const { square: a, elevation: s, variant: $, classes: j } = o,
      _e = {
        root: [
          'root',
          $,
          !a && 'rounded',
          $ === 'elevation' && `elevation${s}`,
        ],
      }
    return composeClasses(_e, getPaperUtilityClass, j)
  },
  PaperRoot = styled('div', {
    name: 'MuiPaper',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        a[s.variant],
        !s.square && a.rounded,
        s.variant === 'elevation' && a[`elevation${s.elevation}`],
      ]
    },
  })(({ theme: o, ownerState: a }) => {
    var s
    return _extends$5(
      {
        backgroundColor: (o.vars || o).palette.background.paper,
        color: (o.vars || o).palette.text.primary,
        transition: o.transitions.create('box-shadow'),
      },
      !a.square && { borderRadius: o.shape.borderRadius },
      a.variant === 'outlined' && {
        border: `1px solid ${(o.vars || o).palette.divider}`,
      },
      a.variant === 'elevation' &&
        _extends$5(
          { boxShadow: (o.vars || o).shadows[a.elevation] },
          !o.vars &&
            o.palette.mode === 'dark' && {
              backgroundImage: `linear-gradient(${alpha_1(
                '#fff',
                getOverlayAlpha(a.elevation)
              )}, ${alpha_1('#fff', getOverlayAlpha(a.elevation))})`,
            },
          o.vars && {
            backgroundImage:
              (s = o.vars.overlays) == null ? void 0 : s[a.elevation],
          }
        )
    )
  }),
  Paper = reactExports.forwardRef(function(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiPaper' }),
      {
        className: j,
        component: _e = 'div',
        elevation: et = 1,
        square: tt = !1,
        variant: rt = 'elevation',
      } = $,
      nt = _objectWithoutPropertiesLoose$3($, _excluded$14),
      it = _extends$5({}, $, {
        component: _e,
        elevation: et,
        square: tt,
        variant: rt,
      }),
      ot = useUtilityClasses$X(it)
    return jsxRuntimeExports.jsx(
      PaperRoot,
      _extends$5(
        { as: _e, ownerState: it, className: clsx$1(ot.root, j), ref: s },
        nt
      )
    )
  })
function getDrawerUtilityClass(o) {
  return generateUtilityClass('MuiDrawer', o)
}
generateUtilityClasses('MuiDrawer', [
  'root',
  'docked',
  'paper',
  'paperAnchorLeft',
  'paperAnchorRight',
  'paperAnchorTop',
  'paperAnchorBottom',
  'paperAnchorDockedLeft',
  'paperAnchorDockedRight',
  'paperAnchorDockedTop',
  'paperAnchorDockedBottom',
  'modal',
])
const _excluded$13 = ['BackdropProps'],
  _excluded2$5 = [
    'anchor',
    'BackdropProps',
    'children',
    'className',
    'elevation',
    'hideBackdrop',
    'ModalProps',
    'onClose',
    'open',
    'PaperProps',
    'SlideProps',
    'TransitionComponent',
    'transitionDuration',
    'variant',
  ],
  overridesResolver$1 = (o, a) => {
    const { ownerState: s } = o
    return [
      a.root,
      (s.variant === 'permanent' || s.variant === 'persistent') && a.docked,
      a.modal,
    ]
  },
  useUtilityClasses$W = o => {
    const { classes: a, anchor: s, variant: $ } = o,
      j = {
        root: ['root'],
        docked: [($ === 'permanent' || $ === 'persistent') && 'docked'],
        modal: ['modal'],
        paper: [
          'paper',
          `paperAnchor${capitalize$2(s)}`,
          $ !== 'temporary' && `paperAnchorDocked${capitalize$2(s)}`,
        ],
      }
    return composeClasses(j, getDrawerUtilityClass, a)
  },
  DrawerRoot = styled(Modal, {
    name: 'MuiDrawer',
    slot: 'Root',
    overridesResolver: overridesResolver$1,
  })(({ theme: o }) => ({ zIndex: (o.vars || o).zIndex.drawer })),
  DrawerDockedRoot = styled('div', {
    shouldForwardProp: rootShouldForwardProp,
    name: 'MuiDrawer',
    slot: 'Docked',
    skipVariantsResolver: !1,
    overridesResolver: overridesResolver$1,
  })({ flex: '0 0 auto' }),
  DrawerPaper = styled(Paper, {
    name: 'MuiDrawer',
    slot: 'Paper',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.paper,
        a[`paperAnchor${capitalize$2(s.anchor)}`],
        s.variant !== 'temporary' &&
          a[`paperAnchorDocked${capitalize$2(s.anchor)}`],
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        overflowY: 'auto',
        display: 'flex',
        flexDirection: 'column',
        height: '100%',
        flex: '1 0 auto',
        zIndex: (o.vars || o).zIndex.drawer,
        WebkitOverflowScrolling: 'touch',
        position: 'fixed',
        top: 0,
        outline: 0,
      },
      a.anchor === 'left' && { left: 0 },
      a.anchor === 'top' && {
        top: 0,
        left: 0,
        right: 0,
        height: 'auto',
        maxHeight: '100%',
      },
      a.anchor === 'right' && { right: 0 },
      a.anchor === 'bottom' && {
        top: 'auto',
        left: 0,
        bottom: 0,
        right: 0,
        height: 'auto',
        maxHeight: '100%',
      },
      a.anchor === 'left' &&
        a.variant !== 'temporary' && {
          borderRight: `1px solid ${(o.vars || o).palette.divider}`,
        },
      a.anchor === 'top' &&
        a.variant !== 'temporary' && {
          borderBottom: `1px solid ${(o.vars || o).palette.divider}`,
        },
      a.anchor === 'right' &&
        a.variant !== 'temporary' && {
          borderLeft: `1px solid ${(o.vars || o).palette.divider}`,
        },
      a.anchor === 'bottom' &&
        a.variant !== 'temporary' && {
          borderTop: `1px solid ${(o.vars || o).palette.divider}`,
        }
    )
  ),
  oppositeDirection = {
    left: 'right',
    right: 'left',
    top: 'down',
    bottom: 'up',
  }
function isHorizontal(o) {
  return ['left', 'right'].indexOf(o) !== -1
}
function getAnchor({ direction: o }, a) {
  return o === 'rtl' && isHorizontal(a) ? oppositeDirection[a] : a
}
const Drawer = reactExports.forwardRef(function(a, s) {
  const $ = useDefaultProps({ props: a, name: 'MuiDrawer' }),
    j = useTheme$1(),
    _e = useRtl(),
    et = {
      enter: j.transitions.duration.enteringScreen,
      exit: j.transitions.duration.leavingScreen,
    },
    {
      anchor: tt = 'left',
      BackdropProps: rt,
      children: nt,
      className: it,
      elevation: ot = 16,
      hideBackdrop: at = !1,
      ModalProps: { BackdropProps: st } = {},
      onClose: ut,
      open: ct = !1,
      PaperProps: dt = {},
      SlideProps: ft,
      TransitionComponent: mt = Slide,
      transitionDuration: vt = et,
      variant: yt = 'temporary',
    } = $,
    pt = _objectWithoutPropertiesLoose$3($.ModalProps, _excluded$13),
    ht = _objectWithoutPropertiesLoose$3($, _excluded2$5),
    At = reactExports.useRef(!1)
  reactExports.useEffect(() => {
    At.current = !0
  }, [])
  const wt = getAnchor({ direction: _e ? 'rtl' : 'ltr' }, tt),
    Dt = _extends$5(
      {},
      $,
      { anchor: tt, elevation: ot, open: ct, variant: yt },
      ht
    ),
    jt = useUtilityClasses$W(Dt),
    Et = jsxRuntimeExports.jsx(
      DrawerPaper,
      _extends$5({ elevation: yt === 'temporary' ? ot : 0, square: !0 }, dt, {
        className: clsx$1(jt.paper, dt.className),
        ownerState: Dt,
        children: nt,
      })
    )
  if (yt === 'permanent')
    return jsxRuntimeExports.jsx(
      DrawerDockedRoot,
      _extends$5(
        { className: clsx$1(jt.root, jt.docked, it), ownerState: Dt, ref: s },
        ht,
        { children: Et }
      )
    )
  const St = jsxRuntimeExports.jsx(
    mt,
    _extends$5(
      {
        in: ct,
        direction: oppositeDirection[wt],
        timeout: vt,
        appear: At.current,
      },
      ft,
      { children: Et }
    )
  )
  return yt === 'persistent'
    ? jsxRuntimeExports.jsx(
        DrawerDockedRoot,
        _extends$5(
          { className: clsx$1(jt.root, jt.docked, it), ownerState: Dt, ref: s },
          ht,
          { children: St }
        )
      )
    : jsxRuntimeExports.jsx(
        DrawerRoot,
        _extends$5(
          {
            BackdropProps: _extends$5({}, rt, st, { transitionDuration: vt }),
            className: clsx$1(jt.root, jt.modal, it),
            open: ct,
            ownerState: Dt,
            onClose: ut,
            hideBackdrop: at,
            ref: s,
          },
          ht,
          pt,
          { children: St }
        )
      )
})
function Ripple(o) {
  const {
      className: a,
      classes: s,
      pulsate: $ = !1,
      rippleX: j,
      rippleY: _e,
      rippleSize: et,
      in: tt,
      onExited: rt,
      timeout: nt,
    } = o,
    [it, ot] = reactExports.useState(!1),
    at = clsx$1(a, s.ripple, s.rippleVisible, $ && s.ripplePulsate),
    st = { width: et, height: et, top: -(et / 2) + _e, left: -(et / 2) + j },
    ut = clsx$1(s.child, it && s.childLeaving, $ && s.childPulsate)
  return (
    !tt && !it && ot(!0),
    reactExports.useEffect(() => {
      if (!tt && rt != null) {
        const ct = setTimeout(rt, nt)
        return () => {
          clearTimeout(ct)
        }
      }
    }, [rt, tt, nt]),
    jsxRuntimeExports.jsx('span', {
      className: at,
      style: st,
      children: jsxRuntimeExports.jsx('span', { className: ut }),
    })
  )
}
const touchRippleClasses = generateUtilityClasses('MuiTouchRipple', [
    'root',
    'ripple',
    'rippleVisible',
    'ripplePulsate',
    'child',
    'childLeaving',
    'childPulsate',
  ]),
  _excluded$12 = ['center', 'classes', 'className']
let _$2 = o => o,
  _t$2,
  _t2$2,
  _t3$2,
  _t4$2
const DURATION = 550,
  DELAY_RIPPLE = 80,
  enterKeyframe = keyframes(
    _t$2 ||
      (_t$2 = _$2`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)
  ),
  exitKeyframe = keyframes(
    _t2$2 ||
      (_t2$2 = _$2`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)
  ),
  pulsateKeyframe = keyframes(
    _t3$2 ||
      (_t3$2 = _$2`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)
  ),
  TouchRippleRoot = styled('span', { name: 'MuiTouchRipple', slot: 'Root' })({
    overflow: 'hidden',
    pointerEvents: 'none',
    position: 'absolute',
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: 'inherit',
  }),
  TouchRippleRipple = styled(Ripple, {
    name: 'MuiTouchRipple',
    slot: 'Ripple',
  })(
    _t4$2 ||
      (_t4$2 = _$2`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),
    touchRippleClasses.rippleVisible,
    enterKeyframe,
    DURATION,
    ({ theme: o }) => o.transitions.easing.easeInOut,
    touchRippleClasses.ripplePulsate,
    ({ theme: o }) => o.transitions.duration.shorter,
    touchRippleClasses.child,
    touchRippleClasses.childLeaving,
    exitKeyframe,
    DURATION,
    ({ theme: o }) => o.transitions.easing.easeInOut,
    touchRippleClasses.childPulsate,
    pulsateKeyframe,
    ({ theme: o }) => o.transitions.easing.easeInOut
  ),
  TouchRipple = reactExports.forwardRef(function(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTouchRipple' }),
      { center: j = !1, classes: _e = {}, className: et } = $,
      tt = _objectWithoutPropertiesLoose$3($, _excluded$12),
      [rt, nt] = reactExports.useState([]),
      it = reactExports.useRef(0),
      ot = reactExports.useRef(null)
    reactExports.useEffect(() => {
      ot.current && (ot.current(), (ot.current = null))
    }, [rt])
    const at = reactExports.useRef(!1),
      st = useTimeout(),
      ut = reactExports.useRef(null),
      ct = reactExports.useRef(null),
      dt = reactExports.useCallback(
        yt => {
          const {
            pulsate: pt,
            rippleX: ht,
            rippleY: At,
            rippleSize: wt,
            cb: Ct,
          } = yt
          nt(Dt => [
            ...Dt,
            jsxRuntimeExports.jsx(
              TouchRippleRipple,
              {
                classes: {
                  ripple: clsx$1(_e.ripple, touchRippleClasses.ripple),
                  rippleVisible: clsx$1(
                    _e.rippleVisible,
                    touchRippleClasses.rippleVisible
                  ),
                  ripplePulsate: clsx$1(
                    _e.ripplePulsate,
                    touchRippleClasses.ripplePulsate
                  ),
                  child: clsx$1(_e.child, touchRippleClasses.child),
                  childLeaving: clsx$1(
                    _e.childLeaving,
                    touchRippleClasses.childLeaving
                  ),
                  childPulsate: clsx$1(
                    _e.childPulsate,
                    touchRippleClasses.childPulsate
                  ),
                },
                timeout: DURATION,
                pulsate: pt,
                rippleX: ht,
                rippleY: At,
                rippleSize: wt,
              },
              it.current
            ),
          ]),
            (it.current += 1),
            (ot.current = Ct)
        },
        [_e]
      ),
      ft = reactExports.useCallback(
        (yt = {}, pt = {}, ht = () => {}) => {
          const {
            pulsate: At = !1,
            center: wt = j || pt.pulsate,
            fakeElement: Ct = !1,
          } = pt
          if ((yt == null ? void 0 : yt.type) === 'mousedown' && at.current) {
            at.current = !1
            return
          }
          ;(yt == null ? void 0 : yt.type) === 'touchstart' && (at.current = !0)
          const Dt = Ct ? null : ct.current,
            jt = Dt
              ? Dt.getBoundingClientRect()
              : { width: 0, height: 0, left: 0, top: 0 }
          let Et, St, Bt
          if (
            wt ||
            yt === void 0 ||
            (yt.clientX === 0 && yt.clientY === 0) ||
            (!yt.clientX && !yt.touches)
          )
            (Et = Math.round(jt.width / 2)), (St = Math.round(jt.height / 2))
          else {
            const { clientX: Mt, clientY: Ut } =
              yt.touches && yt.touches.length > 0 ? yt.touches[0] : yt
            ;(Et = Math.round(Mt - jt.left)), (St = Math.round(Ut - jt.top))
          }
          if (wt)
            (Bt = Math.sqrt((2 * jt.width ** 2 + jt.height ** 2) / 3)),
              Bt % 2 === 0 && (Bt += 1)
          else {
            const Mt =
                Math.max(Math.abs((Dt ? Dt.clientWidth : 0) - Et), Et) * 2 + 2,
              Ut =
                Math.max(Math.abs((Dt ? Dt.clientHeight : 0) - St), St) * 2 + 2
            Bt = Math.sqrt(Mt ** 2 + Ut ** 2)
          }
          yt != null && yt.touches
            ? ut.current === null &&
              ((ut.current = () => {
                dt({
                  pulsate: At,
                  rippleX: Et,
                  rippleY: St,
                  rippleSize: Bt,
                  cb: ht,
                })
              }),
              st.start(DELAY_RIPPLE, () => {
                ut.current && (ut.current(), (ut.current = null))
              }))
            : dt({
                pulsate: At,
                rippleX: Et,
                rippleY: St,
                rippleSize: Bt,
                cb: ht,
              })
        },
        [j, dt, st]
      ),
      mt = reactExports.useCallback(() => {
        ft({}, { pulsate: !0 })
      }, [ft]),
      vt = reactExports.useCallback(
        (yt, pt) => {
          if (
            (st.clear(),
            (yt == null ? void 0 : yt.type) === 'touchend' && ut.current)
          ) {
            ut.current(),
              (ut.current = null),
              st.start(0, () => {
                vt(yt, pt)
              })
            return
          }
          ;(ut.current = null),
            nt(ht => (ht.length > 0 ? ht.slice(1) : ht)),
            (ot.current = pt)
        },
        [st]
      )
    return (
      reactExports.useImperativeHandle(
        s,
        () => ({ pulsate: mt, start: ft, stop: vt }),
        [mt, ft, vt]
      ),
      jsxRuntimeExports.jsx(
        TouchRippleRoot,
        _extends$5(
          { className: clsx$1(touchRippleClasses.root, _e.root, et), ref: ct },
          tt,
          {
            children: jsxRuntimeExports.jsx(TransitionGroup, {
              component: null,
              exit: !0,
              children: rt,
            }),
          }
        )
      )
    )
  })
function getButtonBaseUtilityClass(o) {
  return generateUtilityClass('MuiButtonBase', o)
}
const buttonBaseClasses = generateUtilityClasses('MuiButtonBase', [
    'root',
    'disabled',
    'focusVisible',
  ]),
  _excluded$11 = [
    'action',
    'centerRipple',
    'children',
    'className',
    'component',
    'disabled',
    'disableRipple',
    'disableTouchRipple',
    'focusRipple',
    'focusVisibleClassName',
    'LinkComponent',
    'onBlur',
    'onClick',
    'onContextMenu',
    'onDragLeave',
    'onFocus',
    'onFocusVisible',
    'onKeyDown',
    'onKeyUp',
    'onMouseDown',
    'onMouseLeave',
    'onMouseUp',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'tabIndex',
    'TouchRippleProps',
    'touchRippleRef',
    'type',
  ],
  useUtilityClasses$V = o => {
    const {
        disabled: a,
        focusVisible: s,
        focusVisibleClassName: $,
        classes: j,
      } = o,
      et = composeClasses(
        { root: ['root', a && 'disabled', s && 'focusVisible'] },
        getButtonBaseUtilityClass,
        j
      )
    return s && $ && (et.root += ` ${$}`), et
  },
  ButtonBaseRoot = styled('button', {
    name: 'MuiButtonBase',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    boxSizing: 'border-box',
    WebkitTapHighlightColor: 'transparent',
    backgroundColor: 'transparent',
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: 'pointer',
    userSelect: 'none',
    verticalAlign: 'middle',
    MozAppearance: 'none',
    WebkitAppearance: 'none',
    textDecoration: 'none',
    color: 'inherit',
    '&::-moz-focus-inner': { borderStyle: 'none' },
    [`&.${buttonBaseClasses.disabled}`]: {
      pointerEvents: 'none',
      cursor: 'default',
    },
    '@media print': { colorAdjust: 'exact' },
  }),
  ButtonBase = reactExports.forwardRef(function(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiButtonBase' }),
      {
        action: j,
        centerRipple: _e = !1,
        children: et,
        className: tt,
        component: rt = 'button',
        disabled: nt = !1,
        disableRipple: it = !1,
        disableTouchRipple: ot = !1,
        focusRipple: at = !1,
        LinkComponent: st = 'a',
        onBlur: ut,
        onClick: ct,
        onContextMenu: dt,
        onDragLeave: ft,
        onFocus: mt,
        onFocusVisible: vt,
        onKeyDown: yt,
        onKeyUp: pt,
        onMouseDown: ht,
        onMouseLeave: At,
        onMouseUp: wt,
        onTouchEnd: Ct,
        onTouchMove: Dt,
        onTouchStart: jt,
        tabIndex: Et = 0,
        TouchRippleProps: St,
        touchRippleRef: Bt,
        type: Mt,
      } = $,
      Ut = _objectWithoutPropertiesLoose$3($, _excluded$11),
      Wt = reactExports.useRef(null),
      Tt = reactExports.useRef(null),
      kt = useForkRef(Tt, Bt),
      {
        isFocusVisibleRef: Ot,
        onFocus: Nt,
        onBlur: $t,
        ref: Pt,
      } = useIsFocusVisible(),
      [Ft, Vt] = reactExports.useState(!1)
    nt && Ft && Vt(!1),
      reactExports.useImperativeHandle(
        j,
        () => ({
          focusVisible: () => {
            Vt(!0), Wt.current.focus()
          },
        }),
        []
      )
    const [Xt, Yt] = reactExports.useState(!1)
    reactExports.useEffect(() => {
      Yt(!0)
    }, [])
    const xt = Xt && !it && !nt
    reactExports.useEffect(() => {
      Ft && at && !it && Xt && Tt.current.pulsate()
    }, [it, at, Ft, Xt])
    function It(Rt, qt, rr = ot) {
      return useEventCallback$1(
        ar => (qt && qt(ar), !rr && Tt.current && Tt.current[Rt](ar), !0)
      )
    }
    const Kt = It('start', ht),
      Qt = It('stop', dt),
      Ht = It('stop', ft),
      Lt = It('stop', wt),
      tr = It('stop', Rt => {
        Ft && Rt.preventDefault(), At && At(Rt)
      }),
      lr = It('start', jt),
      yr = It('stop', Ct),
      mr = It('stop', Dt),
      Er = It(
        'stop',
        Rt => {
          $t(Rt), Ot.current === !1 && Vt(!1), ut && ut(Rt)
        },
        !1
      ),
      ur = useEventCallback$1(Rt => {
        Wt.current || (Wt.current = Rt.currentTarget),
          Nt(Rt),
          Ot.current === !0 && (Vt(!0), vt && vt(Rt)),
          mt && mt(Rt)
      }),
      _r = () => {
        const Rt = Wt.current
        return rt && rt !== 'button' && !(Rt.tagName === 'A' && Rt.href)
      },
      Rr = reactExports.useRef(!1),
      nr = useEventCallback$1(Rt => {
        at &&
          !Rr.current &&
          Ft &&
          Tt.current &&
          Rt.key === ' ' &&
          ((Rr.current = !0),
          Tt.current.stop(Rt, () => {
            Tt.current.start(Rt)
          })),
          Rt.target === Rt.currentTarget &&
            _r() &&
            Rt.key === ' ' &&
            Rt.preventDefault(),
          yt && yt(Rt),
          Rt.target === Rt.currentTarget &&
            _r() &&
            Rt.key === 'Enter' &&
            !nt &&
            (Rt.preventDefault(), ct && ct(Rt))
      }),
      fr = useEventCallback$1(Rt => {
        at &&
          Rt.key === ' ' &&
          Tt.current &&
          Ft &&
          !Rt.defaultPrevented &&
          ((Rr.current = !1),
          Tt.current.stop(Rt, () => {
            Tt.current.pulsate(Rt)
          })),
          pt && pt(Rt),
          ct &&
            Rt.target === Rt.currentTarget &&
            _r() &&
            Rt.key === ' ' &&
            !Rt.defaultPrevented &&
            ct(Rt)
      })
    let gr = rt
    gr === 'button' && (Ut.href || Ut.to) && (gr = st)
    const br = {}
    gr === 'button'
      ? ((br.type = Mt === void 0 ? 'button' : Mt), (br.disabled = nt))
      : (!Ut.href && !Ut.to && (br.role = 'button'),
        nt && (br['aria-disabled'] = nt))
    const Sr = useForkRef(s, Pt, Wt),
      zt = _extends$5({}, $, {
        centerRipple: _e,
        component: rt,
        disabled: nt,
        disableRipple: it,
        disableTouchRipple: ot,
        focusRipple: at,
        tabIndex: Et,
        focusVisible: Ft,
      }),
      bt = useUtilityClasses$V(zt)
    return jsxRuntimeExports.jsxs(
      ButtonBaseRoot,
      _extends$5(
        {
          as: gr,
          className: clsx$1(bt.root, tt),
          ownerState: zt,
          onBlur: Er,
          onClick: ct,
          onContextMenu: Qt,
          onFocus: ur,
          onKeyDown: nr,
          onKeyUp: fr,
          onMouseDown: Kt,
          onMouseLeave: tr,
          onMouseUp: Lt,
          onDragLeave: Ht,
          onTouchEnd: yr,
          onTouchMove: mr,
          onTouchStart: lr,
          ref: Sr,
          tabIndex: nt ? -1 : Et,
          type: Mt,
        },
        br,
        Ut,
        {
          children: [
            et,
            xt
              ? jsxRuntimeExports.jsx(
                  TouchRipple,
                  _extends$5({ ref: kt, center: _e }, St)
                )
              : null,
          ],
        }
      )
    )
  })
function getFabUtilityClass(o) {
  return generateUtilityClass('MuiFab', o)
}
const fabClasses = generateUtilityClasses('MuiFab', [
    'root',
    'primary',
    'secondary',
    'extended',
    'circular',
    'focusVisible',
    'disabled',
    'colorInherit',
    'sizeSmall',
    'sizeMedium',
    'sizeLarge',
    'info',
    'error',
    'warning',
    'success',
  ]),
  _excluded$10 = [
    'children',
    'className',
    'color',
    'component',
    'disabled',
    'disableFocusRipple',
    'focusVisibleClassName',
    'size',
    'variant',
  ],
  useUtilityClasses$U = o => {
    const { color: a, variant: s, classes: $, size: j } = o,
      _e = {
        root: [
          'root',
          s,
          `size${capitalize$2(j)}`,
          a === 'inherit' ? 'colorInherit' : a,
        ],
      },
      et = composeClasses(_e, getFabUtilityClass, $)
    return _extends$5({}, $, et)
  },
  FabRoot = styled(ButtonBase, {
    name: 'MuiFab',
    slot: 'Root',
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        a[s.variant],
        a[`size${capitalize$2(s.size)}`],
        s.color === 'inherit' && a.colorInherit,
        a[capitalize$2(s.size)],
        a[s.color],
      ]
    },
  })(
    ({ theme: o, ownerState: a }) => {
      var s, $
      return _extends$5(
        {},
        o.typography.button,
        {
          minHeight: 36,
          transition: o.transitions.create(
            ['background-color', 'box-shadow', 'border-color'],
            { duration: o.transitions.duration.short }
          ),
          borderRadius: '50%',
          padding: 0,
          minWidth: 0,
          width: 56,
          height: 56,
          zIndex: (o.vars || o).zIndex.fab,
          boxShadow: (o.vars || o).shadows[6],
          '&:active': { boxShadow: (o.vars || o).shadows[12] },
          color: o.vars
            ? o.vars.palette.text.primary
            : (s = ($ = o.palette).getContrastText) == null
            ? void 0
            : s.call($, o.palette.grey[300]),
          backgroundColor: (o.vars || o).palette.grey[300],
          '&:hover': {
            backgroundColor: (o.vars || o).palette.grey.A100,
            '@media (hover: none)': {
              backgroundColor: (o.vars || o).palette.grey[300],
            },
            textDecoration: 'none',
          },
          [`&.${fabClasses.focusVisible}`]: {
            boxShadow: (o.vars || o).shadows[6],
          },
        },
        a.size === 'small' && { width: 40, height: 40 },
        a.size === 'medium' && { width: 48, height: 48 },
        a.variant === 'extended' && {
          borderRadius: 48 / 2,
          padding: '0 16px',
          width: 'auto',
          minHeight: 'auto',
          minWidth: 48,
          height: 48,
        },
        a.variant === 'extended' &&
          a.size === 'small' && {
            width: 'auto',
            padding: '0 8px',
            borderRadius: 34 / 2,
            minWidth: 34,
            height: 34,
          },
        a.variant === 'extended' &&
          a.size === 'medium' && {
            width: 'auto',
            padding: '0 16px',
            borderRadius: 40 / 2,
            minWidth: 40,
            height: 40,
          },
        a.color === 'inherit' && { color: 'inherit' }
      )
    },
    ({ theme: o, ownerState: a }) =>
      _extends$5(
        {},
        a.color !== 'inherit' &&
          a.color !== 'default' &&
          (o.vars || o).palette[a.color] != null && {
            color: (o.vars || o).palette[a.color].contrastText,
            backgroundColor: (o.vars || o).palette[a.color].main,
            '&:hover': {
              backgroundColor: (o.vars || o).palette[a.color].dark,
              '@media (hover: none)': {
                backgroundColor: (o.vars || o).palette[a.color].main,
              },
            },
          }
      ),
    ({ theme: o }) => ({
      [`&.${fabClasses.disabled}`]: {
        color: (o.vars || o).palette.action.disabled,
        boxShadow: (o.vars || o).shadows[0],
        backgroundColor: (o.vars || o).palette.action.disabledBackground,
      },
    })
  ),
  Fab = reactExports.forwardRef(function(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiFab' }),
      {
        children: j,
        className: _e,
        color: et = 'default',
        component: tt = 'button',
        disabled: rt = !1,
        disableFocusRipple: nt = !1,
        focusVisibleClassName: it,
        size: ot = 'large',
        variant: at = 'circular',
      } = $,
      st = _objectWithoutPropertiesLoose$3($, _excluded$10),
      ut = _extends$5({}, $, {
        color: et,
        component: tt,
        disabled: rt,
        disableFocusRipple: nt,
        size: ot,
        variant: at,
      }),
      ct = useUtilityClasses$U(ut)
    return jsxRuntimeExports.jsx(
      FabRoot,
      _extends$5(
        {
          className: clsx$1(ct.root, _e),
          component: tt,
          disabled: rt,
          focusRipple: !nt,
          focusVisibleClassName: clsx$1(ct.focusVisible, it),
          ownerState: ut,
          ref: s,
        },
        st,
        { classes: ct, children: j }
      )
    )
  })
var Menu$1 = {},
  createSvgIcon = {}
const require$$0$4 = getAugmentedNamespace(utils$4)
var hasRequiredCreateSvgIcon
function requireCreateSvgIcon() {
  return (
    hasRequiredCreateSvgIcon ||
      ((hasRequiredCreateSvgIcon = 1),
      (function(o) {
        'use client'
        Object.defineProperty(o, '__esModule', { value: !0 }),
          Object.defineProperty(o, 'default', {
            enumerable: !0,
            get: function() {
              return a.createSvgIcon
            },
          })
        var a = require$$0$4
      })(createSvgIcon)),
    createSvgIcon
  )
}
var _interopRequireDefault$f = interopRequireDefaultExports
Object.defineProperty(Menu$1, '__esModule', { value: !0 })
var default_1$f = (Menu$1.default = void 0),
  _createSvgIcon$e = _interopRequireDefault$f(requireCreateSvgIcon()),
  _jsxRuntime$e = jsxRuntimeExports
default_1$f = Menu$1.default = (0, _createSvgIcon$e.default)(
  (0, _jsxRuntime$e.jsx)('path', {
    d: 'M3 18h18v-2H3zm0-5h18v-2H3zm0-7v2h18V6z',
  }),
  'Menu'
)
var Hotel = {},
  _interopRequireDefault$e = interopRequireDefaultExports
Object.defineProperty(Hotel, '__esModule', { value: !0 })
var default_1$e = (Hotel.default = void 0),
  _createSvgIcon$d = _interopRequireDefault$e(requireCreateSvgIcon()),
  _jsxRuntime$d = jsxRuntimeExports
default_1$e = Hotel.default = (0, _createSvgIcon$d.default)(
  (0, _jsxRuntime$d.jsx)('path', {
    d:
      'M7 13c1.66 0 3-1.34 3-3S8.66 7 7 7s-3 1.34-3 3 1.34 3 3 3m12-6h-8v7H3V5H1v15h2v-3h18v3h2v-9c0-2.21-1.79-4-4-4',
  }),
  'Hotel'
)
var KeyboardArrowLeft$1 = {},
  _interopRequireDefault$d = interopRequireDefaultExports
Object.defineProperty(KeyboardArrowLeft$1, '__esModule', { value: !0 })
var default_1$d = (KeyboardArrowLeft$1.default = void 0),
  _createSvgIcon$c = _interopRequireDefault$d(requireCreateSvgIcon()),
  _jsxRuntime$c = jsxRuntimeExports
default_1$d = KeyboardArrowLeft$1.default = (0, _createSvgIcon$c.default)(
  (0, _jsxRuntime$c.jsx)('path', {
    d: 'M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6z',
  }),
  'KeyboardArrowLeft'
)
var KeyboardArrowRight$1 = {},
  _interopRequireDefault$c = interopRequireDefaultExports
Object.defineProperty(KeyboardArrowRight$1, '__esModule', { value: !0 })
var default_1$c = (KeyboardArrowRight$1.default = void 0),
  _createSvgIcon$b = _interopRequireDefault$c(requireCreateSvgIcon()),
  _jsxRuntime$b = jsxRuntimeExports
default_1$c = KeyboardArrowRight$1.default = (0, _createSvgIcon$b.default)(
  (0, _jsxRuntime$b.jsx)('path', {
    d: 'M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6z',
  }),
  'KeyboardArrowRight'
)
const _excluded$$ = [
  'addEndListener',
  'appear',
  'children',
  'easing',
  'in',
  'onEnter',
  'onEntered',
  'onEntering',
  'onExit',
  'onExited',
  'onExiting',
  'style',
  'timeout',
  'TransitionComponent',
]
function getScale(o) {
  return `scale(${o}, ${o ** 2})`
}
const styles$4 = {
    entering: { opacity: 1, transform: getScale(1) },
    entered: { opacity: 1, transform: 'none' },
  },
  isWebKit154 =
    typeof navigator < 'u' &&
    /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) &&
    /(os |version\/)15(.|_)4/i.test(navigator.userAgent),
  Grow = reactExports.forwardRef(function(a, s) {
    const {
        addEndListener: $,
        appear: j = !0,
        children: _e,
        easing: et,
        in: tt,
        onEnter: rt,
        onEntered: nt,
        onEntering: it,
        onExit: ot,
        onExited: at,
        onExiting: st,
        style: ut,
        timeout: ct = 'auto',
        TransitionComponent: dt = Transition,
      } = a,
      ft = _objectWithoutPropertiesLoose$3(a, _excluded$$),
      mt = useTimeout(),
      vt = reactExports.useRef(),
      yt = useTheme$1(),
      pt = reactExports.useRef(null),
      ht = useForkRef(pt, _e.ref, s),
      At = Mt => Ut => {
        if (Mt) {
          const Wt = pt.current
          Ut === void 0 ? Mt(Wt) : Mt(Wt, Ut)
        }
      },
      wt = At(it),
      Ct = At((Mt, Ut) => {
        reflow(Mt)
        const { duration: Wt, delay: Tt, easing: kt } = getTransitionProps(
          { style: ut, timeout: ct, easing: et },
          { mode: 'enter' }
        )
        let Ot
        ct === 'auto'
          ? ((Ot = yt.transitions.getAutoHeightDuration(Mt.clientHeight)),
            (vt.current = Ot))
          : (Ot = Wt),
          (Mt.style.transition = [
            yt.transitions.create('opacity', { duration: Ot, delay: Tt }),
            yt.transitions.create('transform', {
              duration: isWebKit154 ? Ot : Ot * 0.666,
              delay: Tt,
              easing: kt,
            }),
          ].join(',')),
          rt && rt(Mt, Ut)
      }),
      Dt = At(nt),
      jt = At(st),
      Et = At(Mt => {
        const { duration: Ut, delay: Wt, easing: Tt } = getTransitionProps(
          { style: ut, timeout: ct, easing: et },
          { mode: 'exit' }
        )
        let kt
        ct === 'auto'
          ? ((kt = yt.transitions.getAutoHeightDuration(Mt.clientHeight)),
            (vt.current = kt))
          : (kt = Ut),
          (Mt.style.transition = [
            yt.transitions.create('opacity', { duration: kt, delay: Wt }),
            yt.transitions.create('transform', {
              duration: isWebKit154 ? kt : kt * 0.666,
              delay: isWebKit154 ? Wt : Wt || kt * 0.333,
              easing: Tt,
            }),
          ].join(',')),
          (Mt.style.opacity = 0),
          (Mt.style.transform = getScale(0.75)),
          ot && ot(Mt)
      }),
      St = At(at),
      Bt = Mt => {
        ct === 'auto' && mt.start(vt.current || 0, Mt), $ && $(pt.current, Mt)
      }
    return jsxRuntimeExports.jsx(
      dt,
      _extends$5(
        {
          appear: j,
          in: tt,
          nodeRef: pt,
          onEnter: Ct,
          onEntered: Dt,
          onEntering: wt,
          onExit: Et,
          onExited: St,
          onExiting: jt,
          addEndListener: Bt,
          timeout: ct === 'auto' ? null : ct,
        },
        ft,
        {
          children: (Mt, Ut) =>
            reactExports.cloneElement(
              _e,
              _extends$5(
                {
                  style: _extends$5(
                    {
                      opacity: 0,
                      transform: getScale(0.75),
                      visibility: Mt === 'exited' && !tt ? 'hidden' : void 0,
                    },
                    styles$4[Mt],
                    ut,
                    _e.props.style
                  ),
                  ref: ht,
                },
                Ut
              )
            ),
        }
      )
    )
  })
Grow.muiSupportAuto = !0
var useThemeWithoutDefault = {}
Object.defineProperty(useThemeWithoutDefault, '__esModule', { value: !0 })
var default_1$b = (useThemeWithoutDefault.default = void 0),
  React$4 = _interopRequireWildcard$1(reactExports),
  _styledEngine = require$$1$1
function _getRequireWildcardCache(o) {
  if (typeof WeakMap != 'function') return null
  var a = new WeakMap(),
    s = new WeakMap()
  return (_getRequireWildcardCache = function($) {
    return $ ? s : a
  })(o)
}
function _interopRequireWildcard$1(o, a) {
  if (o && o.__esModule) return o
  if (o === null || (typeof o != 'object' && typeof o != 'function'))
    return { default: o }
  var s = _getRequireWildcardCache(a)
  if (s && s.has(o)) return s.get(o)
  var $ = { __proto__: null },
    j = Object.defineProperty && Object.getOwnPropertyDescriptor
  for (var _e in o)
    if (_e !== 'default' && Object.prototype.hasOwnProperty.call(o, _e)) {
      var et = j ? Object.getOwnPropertyDescriptor(o, _e) : null
      et && (et.get || et.set)
        ? Object.defineProperty($, _e, et)
        : ($[_e] = o[_e])
    }
  return ($.default = o), s && s.set(o, $), $
}
function isObjectEmpty(o) {
  return Object.keys(o).length === 0
}
function useTheme(o = null) {
  const a = React$4.useContext(_styledEngine.ThemeContext)
  return !a || isObjectEmpty(a) ? o : a
}
default_1$b = useThemeWithoutDefault.default = useTheme
var top = 'top',
  bottom = 'bottom',
  right = 'right',
  left = 'left',
  auto = 'auto',
  basePlacements = [top, bottom, right, left],
  start = 'start',
  end = 'end',
  clippingParents = 'clippingParents',
  viewport = 'viewport',
  popper = 'popper',
  reference = 'reference',
  variationPlacements = basePlacements.reduce(function(o, a) {
    return o.concat([a + '-' + start, a + '-' + end])
  }, []),
  placements = [].concat(basePlacements, [auto]).reduce(function(o, a) {
    return o.concat([a, a + '-' + start, a + '-' + end])
  }, []),
  beforeRead = 'beforeRead',
  read$1 = 'read',
  afterRead$1 = 'afterRead',
  beforeMain = 'beforeMain',
  main$1 = 'main',
  afterMain = 'afterMain',
  beforeWrite = 'beforeWrite',
  write = 'write',
  afterWrite$1 = 'afterWrite',
  modifierPhases = [
    beforeRead,
    read$1,
    afterRead$1,
    beforeMain,
    main$1,
    afterMain,
    beforeWrite,
    write,
    afterWrite$1,
  ]
function getNodeName(o) {
  return o ? (o.nodeName || '').toLowerCase() : null
}
function getWindow(o) {
  if (o == null) return window
  if (o.toString() !== '[object Window]') {
    var a = o.ownerDocument
    return (a && a.defaultView) || window
  }
  return o
}
function isElement(o) {
  var a = getWindow(o).Element
  return o instanceof a || o instanceof Element
}
function isHTMLElement$1(o) {
  var a = getWindow(o).HTMLElement
  return o instanceof a || o instanceof HTMLElement
}
function isShadowRoot(o) {
  if (typeof ShadowRoot > 'u') return !1
  var a = getWindow(o).ShadowRoot
  return o instanceof a || o instanceof ShadowRoot
}
function applyStyles(o) {
  var a = o.state
  Object.keys(a.elements).forEach(function(s) {
    var $ = a.styles[s] || {},
      j = a.attributes[s] || {},
      _e = a.elements[s]
    !isHTMLElement$1(_e) ||
      !getNodeName(_e) ||
      (Object.assign(_e.style, $),
      Object.keys(j).forEach(function(et) {
        var tt = j[et]
        tt === !1
          ? _e.removeAttribute(et)
          : _e.setAttribute(et, tt === !0 ? '' : tt)
      }))
  })
}
function effect$2(o) {
  var a = o.state,
    s = {
      popper: {
        position: a.options.strategy,
        left: '0',
        top: '0',
        margin: '0',
      },
      arrow: { position: 'absolute' },
      reference: {},
    }
  return (
    Object.assign(a.elements.popper.style, s.popper),
    (a.styles = s),
    a.elements.arrow && Object.assign(a.elements.arrow.style, s.arrow),
    function() {
      Object.keys(a.elements).forEach(function($) {
        var j = a.elements[$],
          _e = a.attributes[$] || {},
          et = Object.keys(a.styles.hasOwnProperty($) ? a.styles[$] : s[$]),
          tt = et.reduce(function(rt, nt) {
            return (rt[nt] = ''), rt
          }, {})
        !isHTMLElement$1(j) ||
          !getNodeName(j) ||
          (Object.assign(j.style, tt),
          Object.keys(_e).forEach(function(rt) {
            j.removeAttribute(rt)
          }))
      })
    }
  )
}
const applyStyles$1 = {
  name: 'applyStyles',
  enabled: !0,
  phase: 'write',
  fn: applyStyles,
  effect: effect$2,
  requires: ['computeStyles'],
}
function getBasePlacement(o) {
  return o.split('-')[0]
}
var max = Math.max,
  min = Math.min,
  round$2 = Math.round
function getUAString() {
  var o = navigator.userAgentData
  return o != null && o.brands && Array.isArray(o.brands)
    ? o.brands
        .map(function(a) {
          return a.brand + '/' + a.version
        })
        .join(' ')
    : navigator.userAgent
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString())
}
function getBoundingClientRect(o, a, s) {
  a === void 0 && (a = !1), s === void 0 && (s = !1)
  var $ = o.getBoundingClientRect(),
    j = 1,
    _e = 1
  a &&
    isHTMLElement$1(o) &&
    ((j = (o.offsetWidth > 0 && round$2($.width) / o.offsetWidth) || 1),
    (_e = (o.offsetHeight > 0 && round$2($.height) / o.offsetHeight) || 1))
  var et = isElement(o) ? getWindow(o) : window,
    tt = et.visualViewport,
    rt = !isLayoutViewport() && s,
    nt = ($.left + (rt && tt ? tt.offsetLeft : 0)) / j,
    it = ($.top + (rt && tt ? tt.offsetTop : 0)) / _e,
    ot = $.width / j,
    at = $.height / _e
  return {
    width: ot,
    height: at,
    top: it,
    right: nt + ot,
    bottom: it + at,
    left: nt,
    x: nt,
    y: it,
  }
}
function getLayoutRect(o) {
  var a = getBoundingClientRect(o),
    s = o.offsetWidth,
    $ = o.offsetHeight
  return (
    Math.abs(a.width - s) <= 1 && (s = a.width),
    Math.abs(a.height - $) <= 1 && ($ = a.height),
    { x: o.offsetLeft, y: o.offsetTop, width: s, height: $ }
  )
}
function contains(o, a) {
  var s = a.getRootNode && a.getRootNode()
  if (o.contains(a)) return !0
  if (s && isShadowRoot(s)) {
    var $ = a
    do {
      if ($ && o.isSameNode($)) return !0
      $ = $.parentNode || $.host
    } while ($)
  }
  return !1
}
function getComputedStyle(o) {
  return getWindow(o).getComputedStyle(o)
}
function isTableElement(o) {
  return ['table', 'td', 'th'].indexOf(getNodeName(o)) >= 0
}
function getDocumentElement(o) {
  return ((isElement(o) ? o.ownerDocument : o.document) || window.document)
    .documentElement
}
function getParentNode(o) {
  return getNodeName(o) === 'html'
    ? o
    : o.assignedSlot ||
        o.parentNode ||
        (isShadowRoot(o) ? o.host : null) ||
        getDocumentElement(o)
}
function getTrueOffsetParent(o) {
  return !isHTMLElement$1(o) || getComputedStyle(o).position === 'fixed'
    ? null
    : o.offsetParent
}
function getContainingBlock(o) {
  var a = /firefox/i.test(getUAString()),
    s = /Trident/i.test(getUAString())
  if (s && isHTMLElement$1(o)) {
    var $ = getComputedStyle(o)
    if ($.position === 'fixed') return null
  }
  var j = getParentNode(o)
  for (
    isShadowRoot(j) && (j = j.host);
    isHTMLElement$1(j) && ['html', 'body'].indexOf(getNodeName(j)) < 0;

  ) {
    var _e = getComputedStyle(j)
    if (
      _e.transform !== 'none' ||
      _e.perspective !== 'none' ||
      _e.contain === 'paint' ||
      ['transform', 'perspective'].indexOf(_e.willChange) !== -1 ||
      (a && _e.willChange === 'filter') ||
      (a && _e.filter && _e.filter !== 'none')
    )
      return j
    j = j.parentNode
  }
  return null
}
function getOffsetParent(o) {
  for (
    var a = getWindow(o), s = getTrueOffsetParent(o);
    s && isTableElement(s) && getComputedStyle(s).position === 'static';

  )
    s = getTrueOffsetParent(s)
  return s &&
    (getNodeName(s) === 'html' ||
      (getNodeName(s) === 'body' && getComputedStyle(s).position === 'static'))
    ? a
    : s || getContainingBlock(o) || a
}
function getMainAxisFromPlacement(o) {
  return ['top', 'bottom'].indexOf(o) >= 0 ? 'x' : 'y'
}
function within(o, a, s) {
  return max(o, min(a, s))
}
function withinMaxClamp(o, a, s) {
  var $ = within(o, a, s)
  return $ > s ? s : $
}
function getFreshSideObject() {
  return { top: 0, right: 0, bottom: 0, left: 0 }
}
function mergePaddingObject(o) {
  return Object.assign({}, getFreshSideObject(), o)
}
function expandToHashMap(o, a) {
  return a.reduce(function(s, $) {
    return (s[$] = o), s
  }, {})
}
var toPaddingObject = function(a, s) {
  return (
    (a =
      typeof a == 'function'
        ? a(Object.assign({}, s.rects, { placement: s.placement }))
        : a),
    mergePaddingObject(
      typeof a != 'number' ? a : expandToHashMap(a, basePlacements)
    )
  )
}
function arrow(o) {
  var a,
    s = o.state,
    $ = o.name,
    j = o.options,
    _e = s.elements.arrow,
    et = s.modifiersData.popperOffsets,
    tt = getBasePlacement(s.placement),
    rt = getMainAxisFromPlacement(tt),
    nt = [left, right].indexOf(tt) >= 0,
    it = nt ? 'height' : 'width'
  if (!(!_e || !et)) {
    var ot = toPaddingObject(j.padding, s),
      at = getLayoutRect(_e),
      st = rt === 'y' ? top : left,
      ut = rt === 'y' ? bottom : right,
      ct =
        s.rects.reference[it] +
        s.rects.reference[rt] -
        et[rt] -
        s.rects.popper[it],
      dt = et[rt] - s.rects.reference[rt],
      ft = getOffsetParent(_e),
      mt = ft ? (rt === 'y' ? ft.clientHeight || 0 : ft.clientWidth || 0) : 0,
      vt = ct / 2 - dt / 2,
      yt = ot[st],
      pt = mt - at[it] - ot[ut],
      ht = mt / 2 - at[it] / 2 + vt,
      At = within(yt, ht, pt),
      wt = rt
    s.modifiersData[$] = ((a = {}), (a[wt] = At), (a.centerOffset = At - ht), a)
  }
}
function effect$1(o) {
  var a = o.state,
    s = o.options,
    $ = s.element,
    j = $ === void 0 ? '[data-popper-arrow]' : $
  j != null &&
    ((typeof j == 'string' && ((j = a.elements.popper.querySelector(j)), !j)) ||
      (contains(a.elements.popper, j) && (a.elements.arrow = j)))
}
const arrow$1 = {
  name: 'arrow',
  enabled: !0,
  phase: 'main',
  fn: arrow,
  effect: effect$1,
  requires: ['popperOffsets'],
  requiresIfExists: ['preventOverflow'],
}
function getVariation(o) {
  return o.split('-')[1]
}
var unsetSides = { top: 'auto', right: 'auto', bottom: 'auto', left: 'auto' }
function roundOffsetsByDPR(o, a) {
  var s = o.x,
    $ = o.y,
    j = a.devicePixelRatio || 1
  return { x: round$2(s * j) / j || 0, y: round$2($ * j) / j || 0 }
}
function mapToStyles(o) {
  var a,
    s = o.popper,
    $ = o.popperRect,
    j = o.placement,
    _e = o.variation,
    et = o.offsets,
    tt = o.position,
    rt = o.gpuAcceleration,
    nt = o.adaptive,
    it = o.roundOffsets,
    ot = o.isFixed,
    at = et.x,
    st = at === void 0 ? 0 : at,
    ut = et.y,
    ct = ut === void 0 ? 0 : ut,
    dt = typeof it == 'function' ? it({ x: st, y: ct }) : { x: st, y: ct }
  ;(st = dt.x), (ct = dt.y)
  var ft = et.hasOwnProperty('x'),
    mt = et.hasOwnProperty('y'),
    vt = left,
    yt = top,
    pt = window
  if (nt) {
    var ht = getOffsetParent(s),
      At = 'clientHeight',
      wt = 'clientWidth'
    if (
      (ht === getWindow(s) &&
        ((ht = getDocumentElement(s)),
        getComputedStyle(ht).position !== 'static' &&
          tt === 'absolute' &&
          ((At = 'scrollHeight'), (wt = 'scrollWidth'))),
      (ht = ht),
      j === top || ((j === left || j === right) && _e === end))
    ) {
      yt = bottom
      var Ct =
        ot && ht === pt && pt.visualViewport ? pt.visualViewport.height : ht[At]
      ;(ct -= Ct - $.height), (ct *= rt ? 1 : -1)
    }
    if (j === left || ((j === top || j === bottom) && _e === end)) {
      vt = right
      var Dt =
        ot && ht === pt && pt.visualViewport ? pt.visualViewport.width : ht[wt]
      ;(st -= Dt - $.width), (st *= rt ? 1 : -1)
    }
  }
  var jt = Object.assign({ position: tt }, nt && unsetSides),
    Et =
      it === !0
        ? roundOffsetsByDPR({ x: st, y: ct }, getWindow(s))
        : { x: st, y: ct }
  if (((st = Et.x), (ct = Et.y), rt)) {
    var St
    return Object.assign(
      {},
      jt,
      ((St = {}),
      (St[yt] = mt ? '0' : ''),
      (St[vt] = ft ? '0' : ''),
      (St.transform =
        (pt.devicePixelRatio || 1) <= 1
          ? 'translate(' + st + 'px, ' + ct + 'px)'
          : 'translate3d(' + st + 'px, ' + ct + 'px, 0)'),
      St)
    )
  }
  return Object.assign(
    {},
    jt,
    ((a = {}),
    (a[yt] = mt ? ct + 'px' : ''),
    (a[vt] = ft ? st + 'px' : ''),
    (a.transform = ''),
    a)
  )
}
function computeStyles(o) {
  var a = o.state,
    s = o.options,
    $ = s.gpuAcceleration,
    j = $ === void 0 ? !0 : $,
    _e = s.adaptive,
    et = _e === void 0 ? !0 : _e,
    tt = s.roundOffsets,
    rt = tt === void 0 ? !0 : tt,
    nt = {
      placement: getBasePlacement(a.placement),
      variation: getVariation(a.placement),
      popper: a.elements.popper,
      popperRect: a.rects.popper,
      gpuAcceleration: j,
      isFixed: a.options.strategy === 'fixed',
    }
  a.modifiersData.popperOffsets != null &&
    (a.styles.popper = Object.assign(
      {},
      a.styles.popper,
      mapToStyles(
        Object.assign({}, nt, {
          offsets: a.modifiersData.popperOffsets,
          position: a.options.strategy,
          adaptive: et,
          roundOffsets: rt,
        })
      )
    )),
    a.modifiersData.arrow != null &&
      (a.styles.arrow = Object.assign(
        {},
        a.styles.arrow,
        mapToStyles(
          Object.assign({}, nt, {
            offsets: a.modifiersData.arrow,
            position: 'absolute',
            adaptive: !1,
            roundOffsets: rt,
          })
        )
      )),
    (a.attributes.popper = Object.assign({}, a.attributes.popper, {
      'data-popper-placement': a.placement,
    }))
}
const computeStyles$1 = {
  name: 'computeStyles',
  enabled: !0,
  phase: 'beforeWrite',
  fn: computeStyles,
  data: {},
}
var passive = { passive: !0 }
function effect(o) {
  var a = o.state,
    s = o.instance,
    $ = o.options,
    j = $.scroll,
    _e = j === void 0 ? !0 : j,
    et = $.resize,
    tt = et === void 0 ? !0 : et,
    rt = getWindow(a.elements.popper),
    nt = [].concat(a.scrollParents.reference, a.scrollParents.popper)
  return (
    _e &&
      nt.forEach(function(it) {
        it.addEventListener('scroll', s.update, passive)
      }),
    tt && rt.addEventListener('resize', s.update, passive),
    function() {
      _e &&
        nt.forEach(function(it) {
          it.removeEventListener('scroll', s.update, passive)
        }),
        tt && rt.removeEventListener('resize', s.update, passive)
    }
  )
}
const eventListeners = {
  name: 'eventListeners',
  enabled: !0,
  phase: 'write',
  fn: function() {},
  effect,
  data: {},
}
var hash$1 = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' }
function getOppositePlacement(o) {
  return o.replace(/left|right|bottom|top/g, function(a) {
    return hash$1[a]
  })
}
var hash = { start: 'end', end: 'start' }
function getOppositeVariationPlacement(o) {
  return o.replace(/start|end/g, function(a) {
    return hash[a]
  })
}
function getWindowScroll(o) {
  var a = getWindow(o),
    s = a.pageXOffset,
    $ = a.pageYOffset
  return { scrollLeft: s, scrollTop: $ }
}
function getWindowScrollBarX(o) {
  return (
    getBoundingClientRect(getDocumentElement(o)).left +
    getWindowScroll(o).scrollLeft
  )
}
function getViewportRect(o, a) {
  var s = getWindow(o),
    $ = getDocumentElement(o),
    j = s.visualViewport,
    _e = $.clientWidth,
    et = $.clientHeight,
    tt = 0,
    rt = 0
  if (j) {
    ;(_e = j.width), (et = j.height)
    var nt = isLayoutViewport()
    ;(nt || (!nt && a === 'fixed')) && ((tt = j.offsetLeft), (rt = j.offsetTop))
  }
  return { width: _e, height: et, x: tt + getWindowScrollBarX(o), y: rt }
}
function getDocumentRect(o) {
  var a,
    s = getDocumentElement(o),
    $ = getWindowScroll(o),
    j = (a = o.ownerDocument) == null ? void 0 : a.body,
    _e = max(
      s.scrollWidth,
      s.clientWidth,
      j ? j.scrollWidth : 0,
      j ? j.clientWidth : 0
    ),
    et = max(
      s.scrollHeight,
      s.clientHeight,
      j ? j.scrollHeight : 0,
      j ? j.clientHeight : 0
    ),
    tt = -$.scrollLeft + getWindowScrollBarX(o),
    rt = -$.scrollTop
  return (
    getComputedStyle(j || s).direction === 'rtl' &&
      (tt += max(s.clientWidth, j ? j.clientWidth : 0) - _e),
    { width: _e, height: et, x: tt, y: rt }
  )
}
function isScrollParent(o) {
  var a = getComputedStyle(o),
    s = a.overflow,
    $ = a.overflowX,
    j = a.overflowY
  return /auto|scroll|overlay|hidden/.test(s + j + $)
}
function getScrollParent(o) {
  return ['html', 'body', '#document'].indexOf(getNodeName(o)) >= 0
    ? o.ownerDocument.body
    : isHTMLElement$1(o) && isScrollParent(o)
    ? o
    : getScrollParent(getParentNode(o))
}
function listScrollParents(o, a) {
  var s
  a === void 0 && (a = [])
  var $ = getScrollParent(o),
    j = $ === ((s = o.ownerDocument) == null ? void 0 : s.body),
    _e = getWindow($),
    et = j
      ? [_e].concat(_e.visualViewport || [], isScrollParent($) ? $ : [])
      : $,
    tt = a.concat(et)
  return j ? tt : tt.concat(listScrollParents(getParentNode(et)))
}
function rectToClientRect(o) {
  return Object.assign({}, o, {
    left: o.x,
    top: o.y,
    right: o.x + o.width,
    bottom: o.y + o.height,
  })
}
function getInnerBoundingClientRect(o, a) {
  var s = getBoundingClientRect(o, !1, a === 'fixed')
  return (
    (s.top = s.top + o.clientTop),
    (s.left = s.left + o.clientLeft),
    (s.bottom = s.top + o.clientHeight),
    (s.right = s.left + o.clientWidth),
    (s.width = o.clientWidth),
    (s.height = o.clientHeight),
    (s.x = s.left),
    (s.y = s.top),
    s
  )
}
function getClientRectFromMixedType(o, a, s) {
  return a === viewport
    ? rectToClientRect(getViewportRect(o, s))
    : isElement(a)
    ? getInnerBoundingClientRect(a, s)
    : rectToClientRect(getDocumentRect(getDocumentElement(o)))
}
function getClippingParents(o) {
  var a = listScrollParents(getParentNode(o)),
    s = ['absolute', 'fixed'].indexOf(getComputedStyle(o).position) >= 0,
    $ = s && isHTMLElement$1(o) ? getOffsetParent(o) : o
  return isElement($)
    ? a.filter(function(j) {
        return isElement(j) && contains(j, $) && getNodeName(j) !== 'body'
      })
    : []
}
function getClippingRect(o, a, s, $) {
  var j = a === 'clippingParents' ? getClippingParents(o) : [].concat(a),
    _e = [].concat(j, [s]),
    et = _e[0],
    tt = _e.reduce(function(rt, nt) {
      var it = getClientRectFromMixedType(o, nt, $)
      return (
        (rt.top = max(it.top, rt.top)),
        (rt.right = min(it.right, rt.right)),
        (rt.bottom = min(it.bottom, rt.bottom)),
        (rt.left = max(it.left, rt.left)),
        rt
      )
    }, getClientRectFromMixedType(o, et, $))
  return (
    (tt.width = tt.right - tt.left),
    (tt.height = tt.bottom - tt.top),
    (tt.x = tt.left),
    (tt.y = tt.top),
    tt
  )
}
function computeOffsets(o) {
  var a = o.reference,
    s = o.element,
    $ = o.placement,
    j = $ ? getBasePlacement($) : null,
    _e = $ ? getVariation($) : null,
    et = a.x + a.width / 2 - s.width / 2,
    tt = a.y + a.height / 2 - s.height / 2,
    rt
  switch (j) {
    case top:
      rt = { x: et, y: a.y - s.height }
      break
    case bottom:
      rt = { x: et, y: a.y + a.height }
      break
    case right:
      rt = { x: a.x + a.width, y: tt }
      break
    case left:
      rt = { x: a.x - s.width, y: tt }
      break
    default:
      rt = { x: a.x, y: a.y }
  }
  var nt = j ? getMainAxisFromPlacement(j) : null
  if (nt != null) {
    var it = nt === 'y' ? 'height' : 'width'
    switch (_e) {
      case start:
        rt[nt] = rt[nt] - (a[it] / 2 - s[it] / 2)
        break
      case end:
        rt[nt] = rt[nt] + (a[it] / 2 - s[it] / 2)
        break
    }
  }
  return rt
}
function detectOverflow(o, a) {
  a === void 0 && (a = {})
  var s = a,
    $ = s.placement,
    j = $ === void 0 ? o.placement : $,
    _e = s.strategy,
    et = _e === void 0 ? o.strategy : _e,
    tt = s.boundary,
    rt = tt === void 0 ? clippingParents : tt,
    nt = s.rootBoundary,
    it = nt === void 0 ? viewport : nt,
    ot = s.elementContext,
    at = ot === void 0 ? popper : ot,
    st = s.altBoundary,
    ut = st === void 0 ? !1 : st,
    ct = s.padding,
    dt = ct === void 0 ? 0 : ct,
    ft = mergePaddingObject(
      typeof dt != 'number' ? dt : expandToHashMap(dt, basePlacements)
    ),
    mt = at === popper ? reference : popper,
    vt = o.rects.popper,
    yt = o.elements[ut ? mt : at],
    pt = getClippingRect(
      isElement(yt)
        ? yt
        : yt.contextElement || getDocumentElement(o.elements.popper),
      rt,
      it,
      et
    ),
    ht = getBoundingClientRect(o.elements.reference),
    At = computeOffsets({
      reference: ht,
      element: vt,
      strategy: 'absolute',
      placement: j,
    }),
    wt = rectToClientRect(Object.assign({}, vt, At)),
    Ct = at === popper ? wt : ht,
    Dt = {
      top: pt.top - Ct.top + ft.top,
      bottom: Ct.bottom - pt.bottom + ft.bottom,
      left: pt.left - Ct.left + ft.left,
      right: Ct.right - pt.right + ft.right,
    },
    jt = o.modifiersData.offset
  if (at === popper && jt) {
    var Et = jt[j]
    Object.keys(Dt).forEach(function(St) {
      var Bt = [right, bottom].indexOf(St) >= 0 ? 1 : -1,
        Mt = [top, bottom].indexOf(St) >= 0 ? 'y' : 'x'
      Dt[St] += Et[Mt] * Bt
    })
  }
  return Dt
}
function computeAutoPlacement(o, a) {
  a === void 0 && (a = {})
  var s = a,
    $ = s.placement,
    j = s.boundary,
    _e = s.rootBoundary,
    et = s.padding,
    tt = s.flipVariations,
    rt = s.allowedAutoPlacements,
    nt = rt === void 0 ? placements : rt,
    it = getVariation($),
    ot = it
      ? tt
        ? variationPlacements
        : variationPlacements.filter(function(ut) {
            return getVariation(ut) === it
          })
      : basePlacements,
    at = ot.filter(function(ut) {
      return nt.indexOf(ut) >= 0
    })
  at.length === 0 && (at = ot)
  var st = at.reduce(function(ut, ct) {
    return (
      (ut[ct] = detectOverflow(o, {
        placement: ct,
        boundary: j,
        rootBoundary: _e,
        padding: et,
      })[getBasePlacement(ct)]),
      ut
    )
  }, {})
  return Object.keys(st).sort(function(ut, ct) {
    return st[ut] - st[ct]
  })
}
function getExpandedFallbackPlacements(o) {
  if (getBasePlacement(o) === auto) return []
  var a = getOppositePlacement(o)
  return [getOppositeVariationPlacement(o), a, getOppositeVariationPlacement(a)]
}
function flip$1(o) {
  var a = o.state,
    s = o.options,
    $ = o.name
  if (!a.modifiersData[$]._skip) {
    for (
      var j = s.mainAxis,
        _e = j === void 0 ? !0 : j,
        et = s.altAxis,
        tt = et === void 0 ? !0 : et,
        rt = s.fallbackPlacements,
        nt = s.padding,
        it = s.boundary,
        ot = s.rootBoundary,
        at = s.altBoundary,
        st = s.flipVariations,
        ut = st === void 0 ? !0 : st,
        ct = s.allowedAutoPlacements,
        dt = a.options.placement,
        ft = getBasePlacement(dt),
        mt = ft === dt,
        vt =
          rt ||
          (mt || !ut
            ? [getOppositePlacement(dt)]
            : getExpandedFallbackPlacements(dt)),
        yt = [dt].concat(vt).reduce(function(Ft, Vt) {
          return Ft.concat(
            getBasePlacement(Vt) === auto
              ? computeAutoPlacement(a, {
                  placement: Vt,
                  boundary: it,
                  rootBoundary: ot,
                  padding: nt,
                  flipVariations: ut,
                  allowedAutoPlacements: ct,
                })
              : Vt
          )
        }, []),
        pt = a.rects.reference,
        ht = a.rects.popper,
        At = new Map(),
        wt = !0,
        Ct = yt[0],
        Dt = 0;
      Dt < yt.length;
      Dt++
    ) {
      var jt = yt[Dt],
        Et = getBasePlacement(jt),
        St = getVariation(jt) === start,
        Bt = [top, bottom].indexOf(Et) >= 0,
        Mt = Bt ? 'width' : 'height',
        Ut = detectOverflow(a, {
          placement: jt,
          boundary: it,
          rootBoundary: ot,
          altBoundary: at,
          padding: nt,
        }),
        Wt = Bt ? (St ? right : left) : St ? bottom : top
      pt[Mt] > ht[Mt] && (Wt = getOppositePlacement(Wt))
      var Tt = getOppositePlacement(Wt),
        kt = []
      if (
        (_e && kt.push(Ut[Et] <= 0),
        tt && kt.push(Ut[Wt] <= 0, Ut[Tt] <= 0),
        kt.every(function(Ft) {
          return Ft
        }))
      ) {
        ;(Ct = jt), (wt = !1)
        break
      }
      At.set(jt, kt)
    }
    if (wt)
      for (
        var Ot = ut ? 3 : 1,
          Nt = function(Vt) {
            var Xt = yt.find(function(Yt) {
              var xt = At.get(Yt)
              if (xt)
                return xt.slice(0, Vt).every(function(It) {
                  return It
                })
            })
            if (Xt) return (Ct = Xt), 'break'
          },
          $t = Ot;
        $t > 0;
        $t--
      ) {
        var Pt = Nt($t)
        if (Pt === 'break') break
      }
    a.placement !== Ct &&
      ((a.modifiersData[$]._skip = !0), (a.placement = Ct), (a.reset = !0))
  }
}
const flip$2 = {
  name: 'flip',
  enabled: !0,
  phase: 'main',
  fn: flip$1,
  requiresIfExists: ['offset'],
  data: { _skip: !1 },
}
function getSideOffsets(o, a, s) {
  return (
    s === void 0 && (s = { x: 0, y: 0 }),
    {
      top: o.top - a.height - s.y,
      right: o.right - a.width + s.x,
      bottom: o.bottom - a.height + s.y,
      left: o.left - a.width - s.x,
    }
  )
}
function isAnySideFullyClipped(o) {
  return [top, right, bottom, left].some(function(a) {
    return o[a] >= 0
  })
}
function hide(o) {
  var a = o.state,
    s = o.name,
    $ = a.rects.reference,
    j = a.rects.popper,
    _e = a.modifiersData.preventOverflow,
    et = detectOverflow(a, { elementContext: 'reference' }),
    tt = detectOverflow(a, { altBoundary: !0 }),
    rt = getSideOffsets(et, $),
    nt = getSideOffsets(tt, j, _e),
    it = isAnySideFullyClipped(rt),
    ot = isAnySideFullyClipped(nt)
  ;(a.modifiersData[s] = {
    referenceClippingOffsets: rt,
    popperEscapeOffsets: nt,
    isReferenceHidden: it,
    hasPopperEscaped: ot,
  }),
    (a.attributes.popper = Object.assign({}, a.attributes.popper, {
      'data-popper-reference-hidden': it,
      'data-popper-escaped': ot,
    }))
}
const hide$1 = {
  name: 'hide',
  enabled: !0,
  phase: 'main',
  requiresIfExists: ['preventOverflow'],
  fn: hide,
}
function distanceAndSkiddingToXY(o, a, s) {
  var $ = getBasePlacement(o),
    j = [left, top].indexOf($) >= 0 ? -1 : 1,
    _e = typeof s == 'function' ? s(Object.assign({}, a, { placement: o })) : s,
    et = _e[0],
    tt = _e[1]
  return (
    (et = et || 0),
    (tt = (tt || 0) * j),
    [left, right].indexOf($) >= 0 ? { x: tt, y: et } : { x: et, y: tt }
  )
}
function offset(o) {
  var a = o.state,
    s = o.options,
    $ = o.name,
    j = s.offset,
    _e = j === void 0 ? [0, 0] : j,
    et = placements.reduce(function(it, ot) {
      return (it[ot] = distanceAndSkiddingToXY(ot, a.rects, _e)), it
    }, {}),
    tt = et[a.placement],
    rt = tt.x,
    nt = tt.y
  a.modifiersData.popperOffsets != null &&
    ((a.modifiersData.popperOffsets.x += rt),
    (a.modifiersData.popperOffsets.y += nt)),
    (a.modifiersData[$] = et)
}
const offset$1 = {
  name: 'offset',
  enabled: !0,
  phase: 'main',
  requires: ['popperOffsets'],
  fn: offset,
}
function popperOffsets(o) {
  var a = o.state,
    s = o.name
  a.modifiersData[s] = computeOffsets({
    reference: a.rects.reference,
    element: a.rects.popper,
    strategy: 'absolute',
    placement: a.placement,
  })
}
const popperOffsets$1 = {
  name: 'popperOffsets',
  enabled: !0,
  phase: 'read',
  fn: popperOffsets,
  data: {},
}
function getAltAxis(o) {
  return o === 'x' ? 'y' : 'x'
}
function preventOverflow(o) {
  var a = o.state,
    s = o.options,
    $ = o.name,
    j = s.mainAxis,
    _e = j === void 0 ? !0 : j,
    et = s.altAxis,
    tt = et === void 0 ? !1 : et,
    rt = s.boundary,
    nt = s.rootBoundary,
    it = s.altBoundary,
    ot = s.padding,
    at = s.tether,
    st = at === void 0 ? !0 : at,
    ut = s.tetherOffset,
    ct = ut === void 0 ? 0 : ut,
    dt = detectOverflow(a, {
      boundary: rt,
      rootBoundary: nt,
      padding: ot,
      altBoundary: it,
    }),
    ft = getBasePlacement(a.placement),
    mt = getVariation(a.placement),
    vt = !mt,
    yt = getMainAxisFromPlacement(ft),
    pt = getAltAxis(yt),
    ht = a.modifiersData.popperOffsets,
    At = a.rects.reference,
    wt = a.rects.popper,
    Ct =
      typeof ct == 'function'
        ? ct(Object.assign({}, a.rects, { placement: a.placement }))
        : ct,
    Dt =
      typeof Ct == 'number'
        ? { mainAxis: Ct, altAxis: Ct }
        : Object.assign({ mainAxis: 0, altAxis: 0 }, Ct),
    jt = a.modifiersData.offset ? a.modifiersData.offset[a.placement] : null,
    Et = { x: 0, y: 0 }
  if (ht) {
    if (_e) {
      var St,
        Bt = yt === 'y' ? top : left,
        Mt = yt === 'y' ? bottom : right,
        Ut = yt === 'y' ? 'height' : 'width',
        Wt = ht[yt],
        Tt = Wt + dt[Bt],
        kt = Wt - dt[Mt],
        Ot = st ? -wt[Ut] / 2 : 0,
        Nt = mt === start ? At[Ut] : wt[Ut],
        $t = mt === start ? -wt[Ut] : -At[Ut],
        Pt = a.elements.arrow,
        Ft = st && Pt ? getLayoutRect(Pt) : { width: 0, height: 0 },
        Vt = a.modifiersData['arrow#persistent']
          ? a.modifiersData['arrow#persistent'].padding
          : getFreshSideObject(),
        Xt = Vt[Bt],
        Yt = Vt[Mt],
        xt = within(0, At[Ut], Ft[Ut]),
        It = vt
          ? At[Ut] / 2 - Ot - xt - Xt - Dt.mainAxis
          : Nt - xt - Xt - Dt.mainAxis,
        Kt = vt
          ? -At[Ut] / 2 + Ot + xt + Yt + Dt.mainAxis
          : $t + xt + Yt + Dt.mainAxis,
        Qt = a.elements.arrow && getOffsetParent(a.elements.arrow),
        Ht = Qt ? (yt === 'y' ? Qt.clientTop || 0 : Qt.clientLeft || 0) : 0,
        Lt = (St = jt == null ? void 0 : jt[yt]) != null ? St : 0,
        tr = Wt + It - Lt - Ht,
        lr = Wt + Kt - Lt,
        yr = within(st ? min(Tt, tr) : Tt, Wt, st ? max(kt, lr) : kt)
      ;(ht[yt] = yr), (Et[yt] = yr - Wt)
    }
    if (tt) {
      var mr,
        Er = yt === 'x' ? top : left,
        ur = yt === 'x' ? bottom : right,
        _r = ht[pt],
        Rr = pt === 'y' ? 'height' : 'width',
        nr = _r + dt[Er],
        fr = _r - dt[ur],
        gr = [top, left].indexOf(ft) !== -1,
        br = (mr = jt == null ? void 0 : jt[pt]) != null ? mr : 0,
        Sr = gr ? nr : _r - At[Rr] - wt[Rr] - br + Dt.altAxis,
        zt = gr ? _r + At[Rr] + wt[Rr] - br - Dt.altAxis : fr,
        bt =
          st && gr
            ? withinMaxClamp(Sr, _r, zt)
            : within(st ? Sr : nr, _r, st ? zt : fr)
      ;(ht[pt] = bt), (Et[pt] = bt - _r)
    }
    a.modifiersData[$] = Et
  }
}
const preventOverflow$1 = {
  name: 'preventOverflow',
  enabled: !0,
  phase: 'main',
  fn: preventOverflow,
  requiresIfExists: ['offset'],
}
function getHTMLElementScroll(o) {
  return { scrollLeft: o.scrollLeft, scrollTop: o.scrollTop }
}
function getNodeScroll(o) {
  return o === getWindow(o) || !isHTMLElement$1(o)
    ? getWindowScroll(o)
    : getHTMLElementScroll(o)
}
function isElementScaled(o) {
  var a = o.getBoundingClientRect(),
    s = round$2(a.width) / o.offsetWidth || 1,
    $ = round$2(a.height) / o.offsetHeight || 1
  return s !== 1 || $ !== 1
}
function getCompositeRect(o, a, s) {
  s === void 0 && (s = !1)
  var $ = isHTMLElement$1(a),
    j = isHTMLElement$1(a) && isElementScaled(a),
    _e = getDocumentElement(a),
    et = getBoundingClientRect(o, j, s),
    tt = { scrollLeft: 0, scrollTop: 0 },
    rt = { x: 0, y: 0 }
  return (
    ($ || (!$ && !s)) &&
      ((getNodeName(a) !== 'body' || isScrollParent(_e)) &&
        (tt = getNodeScroll(a)),
      isHTMLElement$1(a)
        ? ((rt = getBoundingClientRect(a, !0)),
          (rt.x += a.clientLeft),
          (rt.y += a.clientTop))
        : _e && (rt.x = getWindowScrollBarX(_e))),
    {
      x: et.left + tt.scrollLeft - rt.x,
      y: et.top + tt.scrollTop - rt.y,
      width: et.width,
      height: et.height,
    }
  )
}
function order$1(o) {
  var a = new Map(),
    s = new Set(),
    $ = []
  o.forEach(function(_e) {
    a.set(_e.name, _e)
  })
  function j(_e) {
    s.add(_e.name)
    var et = [].concat(_e.requires || [], _e.requiresIfExists || [])
    et.forEach(function(tt) {
      if (!s.has(tt)) {
        var rt = a.get(tt)
        rt && j(rt)
      }
    }),
      $.push(_e)
  }
  return (
    o.forEach(function(_e) {
      s.has(_e.name) || j(_e)
    }),
    $
  )
}
function orderModifiers(o) {
  var a = order$1(o)
  return modifierPhases.reduce(function(s, $) {
    return s.concat(
      a.filter(function(j) {
        return j.phase === $
      })
    )
  }, [])
}
function debounce$3(o) {
  var a
  return function() {
    return (
      a ||
        (a = new Promise(function(s) {
          Promise.resolve().then(function() {
            ;(a = void 0), s(o())
          })
        })),
      a
    )
  }
}
function mergeByName(o) {
  var a = o.reduce(function(s, $) {
    var j = s[$.name]
    return (
      (s[$.name] = j
        ? Object.assign({}, j, $, {
            options: Object.assign({}, j.options, $.options),
            data: Object.assign({}, j.data, $.data),
          })
        : $),
      s
    )
  }, {})
  return Object.keys(a).map(function(s) {
    return a[s]
  })
}
var DEFAULT_OPTIONS = {
  placement: 'bottom',
  modifiers: [],
  strategy: 'absolute',
}
function areValidElements() {
  for (var o = arguments.length, a = new Array(o), s = 0; s < o; s++)
    a[s] = arguments[s]
  return !a.some(function($) {
    return !($ && typeof $.getBoundingClientRect == 'function')
  })
}
function popperGenerator(o) {
  o === void 0 && (o = {})
  var a = o,
    s = a.defaultModifiers,
    $ = s === void 0 ? [] : s,
    j = a.defaultOptions,
    _e = j === void 0 ? DEFAULT_OPTIONS : j
  return function(tt, rt, nt) {
    nt === void 0 && (nt = _e)
    var it = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, _e),
        modifiersData: {},
        elements: { reference: tt, popper: rt },
        attributes: {},
        styles: {},
      },
      ot = [],
      at = !1,
      st = {
        state: it,
        setOptions: function(ft) {
          var mt = typeof ft == 'function' ? ft(it.options) : ft
          ct(),
            (it.options = Object.assign({}, _e, it.options, mt)),
            (it.scrollParents = {
              reference: isElement(tt)
                ? listScrollParents(tt)
                : tt.contextElement
                ? listScrollParents(tt.contextElement)
                : [],
              popper: listScrollParents(rt),
            })
          var vt = orderModifiers(
            mergeByName([].concat($, it.options.modifiers))
          )
          return (
            (it.orderedModifiers = vt.filter(function(yt) {
              return yt.enabled
            })),
            ut(),
            st.update()
          )
        },
        forceUpdate: function() {
          if (!at) {
            var ft = it.elements,
              mt = ft.reference,
              vt = ft.popper
            if (areValidElements(mt, vt)) {
              ;(it.rects = {
                reference: getCompositeRect(
                  mt,
                  getOffsetParent(vt),
                  it.options.strategy === 'fixed'
                ),
                popper: getLayoutRect(vt),
              }),
                (it.reset = !1),
                (it.placement = it.options.placement),
                it.orderedModifiers.forEach(function(Dt) {
                  return (it.modifiersData[Dt.name] = Object.assign(
                    {},
                    Dt.data
                  ))
                })
              for (var yt = 0; yt < it.orderedModifiers.length; yt++) {
                if (it.reset === !0) {
                  ;(it.reset = !1), (yt = -1)
                  continue
                }
                var pt = it.orderedModifiers[yt],
                  ht = pt.fn,
                  At = pt.options,
                  wt = At === void 0 ? {} : At,
                  Ct = pt.name
                typeof ht == 'function' &&
                  (it =
                    ht({ state: it, options: wt, name: Ct, instance: st }) ||
                    it)
              }
            }
          }
        },
        update: debounce$3(function() {
          return new Promise(function(dt) {
            st.forceUpdate(), dt(it)
          })
        }),
        destroy: function() {
          ct(), (at = !0)
        },
      }
    if (!areValidElements(tt, rt)) return st
    st.setOptions(nt).then(function(dt) {
      !at && nt.onFirstUpdate && nt.onFirstUpdate(dt)
    })
    function ut() {
      it.orderedModifiers.forEach(function(dt) {
        var ft = dt.name,
          mt = dt.options,
          vt = mt === void 0 ? {} : mt,
          yt = dt.effect
        if (typeof yt == 'function') {
          var pt = yt({ state: it, name: ft, instance: st, options: vt }),
            ht = function() {}
          ot.push(pt || ht)
        }
      })
    }
    function ct() {
      ot.forEach(function(dt) {
        return dt()
      }),
        (ot = [])
    }
    return st
  }
}
var defaultModifiers = [
    eventListeners,
    popperOffsets$1,
    computeStyles$1,
    applyStyles$1,
    offset$1,
    flip$2,
    preventOverflow$1,
    arrow$1,
    hide$1,
  ],
  createPopper = popperGenerator({ defaultModifiers })
function getPopperUtilityClass(o) {
  return generateUtilityClass('MuiPopper', o)
}
generateUtilityClasses('MuiPopper', ['root'])
const _excluded$_ = [
    'anchorEl',
    'children',
    'direction',
    'disablePortal',
    'modifiers',
    'open',
    'placement',
    'popperOptions',
    'popperRef',
    'slotProps',
    'slots',
    'TransitionProps',
    'ownerState',
  ],
  _excluded2$4 = [
    'anchorEl',
    'children',
    'container',
    'direction',
    'disablePortal',
    'keepMounted',
    'modifiers',
    'open',
    'placement',
    'popperOptions',
    'popperRef',
    'style',
    'transition',
    'slotProps',
    'slots',
  ]
function flipPlacement(o, a) {
  if (a === 'ltr') return o
  switch (o) {
    case 'bottom-end':
      return 'bottom-start'
    case 'bottom-start':
      return 'bottom-end'
    case 'top-end':
      return 'top-start'
    case 'top-start':
      return 'top-end'
    default:
      return o
  }
}
function resolveAnchorEl$1(o) {
  return typeof o == 'function' ? o() : o
}
function isHTMLElement(o) {
  return o.nodeType !== void 0
}
const useUtilityClasses$T = o => {
    const { classes: a } = o
    return composeClasses({ root: ['root'] }, getPopperUtilityClass, a)
  },
  defaultPopperOptions = {},
  PopperTooltip = reactExports.forwardRef(function(a, s) {
    var $
    const {
        anchorEl: j,
        children: _e,
        direction: et,
        disablePortal: tt,
        modifiers: rt,
        open: nt,
        placement: it,
        popperOptions: ot,
        popperRef: at,
        slotProps: st = {},
        slots: ut = {},
        TransitionProps: ct,
      } = a,
      dt = _objectWithoutPropertiesLoose$3(a, _excluded$_),
      ft = reactExports.useRef(null),
      mt = useForkRef(ft, s),
      vt = reactExports.useRef(null),
      yt = useForkRef(vt, at),
      pt = reactExports.useRef(yt)
    useEnhancedEffect$1(() => {
      pt.current = yt
    }, [yt]),
      reactExports.useImperativeHandle(at, () => vt.current, [])
    const ht = flipPlacement(it, et),
      [At, wt] = reactExports.useState(ht),
      [Ct, Dt] = reactExports.useState(resolveAnchorEl$1(j))
    reactExports.useEffect(() => {
      vt.current && vt.current.forceUpdate()
    }),
      reactExports.useEffect(() => {
        j && Dt(resolveAnchorEl$1(j))
      }, [j]),
      useEnhancedEffect$1(() => {
        if (!Ct || !nt) return
        const Mt = Tt => {
          wt(Tt.placement)
        }
        let Ut = [
          { name: 'preventOverflow', options: { altBoundary: tt } },
          { name: 'flip', options: { altBoundary: tt } },
          {
            name: 'onUpdate',
            enabled: !0,
            phase: 'afterWrite',
            fn: ({ state: Tt }) => {
              Mt(Tt)
            },
          },
        ]
        rt != null && (Ut = Ut.concat(rt)),
          ot && ot.modifiers != null && (Ut = Ut.concat(ot.modifiers))
        const Wt = createPopper(
          Ct,
          ft.current,
          _extends$5({ placement: ht }, ot, { modifiers: Ut })
        )
        return (
          pt.current(Wt),
          () => {
            Wt.destroy(), pt.current(null)
          }
        )
      }, [Ct, tt, rt, nt, ot, ht])
    const jt = { placement: At }
    ct !== null && (jt.TransitionProps = ct)
    const Et = useUtilityClasses$T(a),
      St = ($ = ut.root) != null ? $ : 'div',
      Bt = useSlotProps({
        elementType: St,
        externalSlotProps: st.root,
        externalForwardedProps: dt,
        additionalProps: { role: 'tooltip', ref: mt },
        ownerState: a,
        className: Et.root,
      })
    return jsxRuntimeExports.jsx(
      St,
      _extends$5({}, Bt, { children: typeof _e == 'function' ? _e(jt) : _e })
    )
  }),
  Popper$1 = reactExports.forwardRef(function(a, s) {
    const {
        anchorEl: $,
        children: j,
        container: _e,
        direction: et = 'ltr',
        disablePortal: tt = !1,
        keepMounted: rt = !1,
        modifiers: nt,
        open: it,
        placement: ot = 'bottom',
        popperOptions: at = defaultPopperOptions,
        popperRef: st,
        style: ut,
        transition: ct = !1,
        slotProps: dt = {},
        slots: ft = {},
      } = a,
      mt = _objectWithoutPropertiesLoose$3(a, _excluded2$4),
      [vt, yt] = reactExports.useState(!0),
      pt = () => {
        yt(!1)
      },
      ht = () => {
        yt(!0)
      }
    if (!rt && !it && (!ct || vt)) return null
    let At
    if (_e) At = _e
    else if ($) {
      const Dt = resolveAnchorEl$1($)
      At =
        Dt && isHTMLElement(Dt)
          ? ownerDocument(Dt).body
          : ownerDocument(null).body
    }
    const wt = !it && rt && (!ct || vt) ? 'none' : void 0,
      Ct = ct ? { in: it, onEnter: pt, onExited: ht } : void 0
    return jsxRuntimeExports.jsx(Portal, {
      disablePortal: tt,
      container: At,
      children: jsxRuntimeExports.jsx(
        PopperTooltip,
        _extends$5(
          {
            anchorEl: $,
            direction: et,
            disablePortal: tt,
            modifiers: nt,
            ref: s,
            open: ct ? !vt : it,
            placement: ot,
            popperOptions: at,
            popperRef: st,
            slotProps: dt,
            slots: ft,
          },
          mt,
          {
            style: _extends$5(
              { position: 'fixed', top: 0, left: 0, display: wt },
              ut
            ),
            TransitionProps: Ct,
            children: j,
          }
        )
      ),
    })
  }),
  _excluded$Z = [
    'anchorEl',
    'component',
    'components',
    'componentsProps',
    'container',
    'disablePortal',
    'keepMounted',
    'modifiers',
    'open',
    'placement',
    'popperOptions',
    'popperRef',
    'transition',
    'slots',
    'slotProps',
  ],
  PopperRoot = styled(Popper$1, {
    name: 'MuiPopper',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({}),
  Popper = reactExports.forwardRef(function(a, s) {
    var $
    const j = default_1$b(),
      _e = useDefaultProps({ props: a, name: 'MuiPopper' }),
      {
        anchorEl: et,
        component: tt,
        components: rt,
        componentsProps: nt,
        container: it,
        disablePortal: ot,
        keepMounted: at,
        modifiers: st,
        open: ut,
        placement: ct,
        popperOptions: dt,
        popperRef: ft,
        transition: mt,
        slots: vt,
        slotProps: yt,
      } = _e,
      pt = _objectWithoutPropertiesLoose$3(_e, _excluded$Z),
      ht =
        ($ = vt == null ? void 0 : vt.root) != null
          ? $
          : rt == null
          ? void 0
          : rt.Root,
      At = _extends$5(
        {
          anchorEl: et,
          container: it,
          disablePortal: ot,
          keepMounted: at,
          modifiers: st,
          open: ut,
          placement: ct,
          popperOptions: dt,
          popperRef: ft,
          transition: mt,
        },
        pt
      )
    return jsxRuntimeExports.jsx(
      PopperRoot,
      _extends$5(
        {
          as: tt,
          direction: j == null ? void 0 : j.direction,
          slots: { root: ht },
          slotProps: yt ?? nt,
        },
        At,
        { ref: s }
      )
    )
  })
function getTooltipUtilityClass(o) {
  return generateUtilityClass('MuiTooltip', o)
}
const tooltipClasses = generateUtilityClasses('MuiTooltip', [
    'popper',
    'popperInteractive',
    'popperArrow',
    'popperClose',
    'tooltip',
    'tooltipArrow',
    'touch',
    'tooltipPlacementLeft',
    'tooltipPlacementRight',
    'tooltipPlacementTop',
    'tooltipPlacementBottom',
    'arrow',
  ]),
  _excluded$Y = [
    'arrow',
    'children',
    'classes',
    'components',
    'componentsProps',
    'describeChild',
    'disableFocusListener',
    'disableHoverListener',
    'disableInteractive',
    'disableTouchListener',
    'enterDelay',
    'enterNextDelay',
    'enterTouchDelay',
    'followCursor',
    'id',
    'leaveDelay',
    'leaveTouchDelay',
    'onClose',
    'onOpen',
    'open',
    'placement',
    'PopperComponent',
    'PopperProps',
    'slotProps',
    'slots',
    'title',
    'TransitionComponent',
    'TransitionProps',
  ]
function round$1(o) {
  return Math.round(o * 1e5) / 1e5
}
const useUtilityClasses$S = o => {
    const {
        classes: a,
        disableInteractive: s,
        arrow: $,
        touch: j,
        placement: _e,
      } = o,
      et = {
        popper: ['popper', !s && 'popperInteractive', $ && 'popperArrow'],
        tooltip: [
          'tooltip',
          $ && 'tooltipArrow',
          j && 'touch',
          `tooltipPlacement${capitalize$2(_e.split('-')[0])}`,
        ],
        arrow: ['arrow'],
      }
    return composeClasses(et, getTooltipUtilityClass, a)
  },
  TooltipPopper = styled(Popper, {
    name: 'MuiTooltip',
    slot: 'Popper',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.popper,
        !s.disableInteractive && a.popperInteractive,
        s.arrow && a.popperArrow,
        !s.open && a.popperClose,
      ]
    },
  })(({ theme: o, ownerState: a, open: s }) =>
    _extends$5(
      { zIndex: (o.vars || o).zIndex.tooltip, pointerEvents: 'none' },
      !a.disableInteractive && { pointerEvents: 'auto' },
      !s && { pointerEvents: 'none' },
      a.arrow && {
        [`&[data-popper-placement*="bottom"] .${tooltipClasses.arrow}`]: {
          top: 0,
          marginTop: '-0.71em',
          '&::before': { transformOrigin: '0 100%' },
        },
        [`&[data-popper-placement*="top"] .${tooltipClasses.arrow}`]: {
          bottom: 0,
          marginBottom: '-0.71em',
          '&::before': { transformOrigin: '100% 0' },
        },
        [`&[data-popper-placement*="right"] .${tooltipClasses.arrow}`]: _extends$5(
          {},
          a.isRtl
            ? { right: 0, marginRight: '-0.71em' }
            : { left: 0, marginLeft: '-0.71em' },
          {
            height: '1em',
            width: '0.71em',
            '&::before': { transformOrigin: '100% 100%' },
          }
        ),
        [`&[data-popper-placement*="left"] .${tooltipClasses.arrow}`]: _extends$5(
          {},
          a.isRtl
            ? { left: 0, marginLeft: '-0.71em' }
            : { right: 0, marginRight: '-0.71em' },
          {
            height: '1em',
            width: '0.71em',
            '&::before': { transformOrigin: '0 0' },
          }
        ),
      }
    )
  ),
  TooltipTooltip = styled('div', {
    name: 'MuiTooltip',
    slot: 'Tooltip',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.tooltip,
        s.touch && a.touch,
        s.arrow && a.tooltipArrow,
        a[`tooltipPlacement${capitalize$2(s.placement.split('-')[0])}`],
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        backgroundColor: o.vars
          ? o.vars.palette.Tooltip.bg
          : alpha_1(o.palette.grey[700], 0.92),
        borderRadius: (o.vars || o).shape.borderRadius,
        color: (o.vars || o).palette.common.white,
        fontFamily: o.typography.fontFamily,
        padding: '4px 8px',
        fontSize: o.typography.pxToRem(11),
        maxWidth: 300,
        margin: 2,
        wordWrap: 'break-word',
        fontWeight: o.typography.fontWeightMedium,
      },
      a.arrow && { position: 'relative', margin: 0 },
      a.touch && {
        padding: '8px 16px',
        fontSize: o.typography.pxToRem(14),
        lineHeight: `${round$1(16 / 14)}em`,
        fontWeight: o.typography.fontWeightRegular,
      },
      {
        [`.${tooltipClasses.popper}[data-popper-placement*="left"] &`]: _extends$5(
          { transformOrigin: 'right center' },
          a.isRtl
            ? _extends$5(
                { marginLeft: '14px' },
                a.touch && { marginLeft: '24px' }
              )
            : _extends$5(
                { marginRight: '14px' },
                a.touch && { marginRight: '24px' }
              )
        ),
        [`.${tooltipClasses.popper}[data-popper-placement*="right"] &`]: _extends$5(
          { transformOrigin: 'left center' },
          a.isRtl
            ? _extends$5(
                { marginRight: '14px' },
                a.touch && { marginRight: '24px' }
              )
            : _extends$5(
                { marginLeft: '14px' },
                a.touch && { marginLeft: '24px' }
              )
        ),
        [`.${tooltipClasses.popper}[data-popper-placement*="top"] &`]: _extends$5(
          { transformOrigin: 'center bottom', marginBottom: '14px' },
          a.touch && { marginBottom: '24px' }
        ),
        [`.${tooltipClasses.popper}[data-popper-placement*="bottom"] &`]: _extends$5(
          { transformOrigin: 'center top', marginTop: '14px' },
          a.touch && { marginTop: '24px' }
        ),
      }
    )
  ),
  TooltipArrow = styled('span', {
    name: 'MuiTooltip',
    slot: 'Arrow',
    overridesResolver: (o, a) => a.arrow,
  })(({ theme: o }) => ({
    overflow: 'hidden',
    position: 'absolute',
    width: '1em',
    height: '0.71em',
    boxSizing: 'border-box',
    color: o.vars
      ? o.vars.palette.Tooltip.bg
      : alpha_1(o.palette.grey[700], 0.9),
    '&::before': {
      content: '""',
      margin: 'auto',
      display: 'block',
      width: '100%',
      height: '100%',
      backgroundColor: 'currentColor',
      transform: 'rotate(45deg)',
    },
  }))
let hystersisOpen = !1
const hystersisTimer = new Timeout()
let cursorPosition = { x: 0, y: 0 }
function composeEventHandler(o, a) {
  return (s, ...$) => {
    a && a(s, ...$), o(s, ...$)
  }
}
const Tooltip = reactExports.forwardRef(function(a, s) {
  var $, j, _e, et, tt, rt, nt, it, ot, at, st, ut, ct, dt, ft, mt, vt, yt, pt
  const ht = useDefaultProps({ props: a, name: 'MuiTooltip' }),
    {
      arrow: At = !1,
      children: wt,
      components: Ct = {},
      componentsProps: Dt = {},
      describeChild: jt = !1,
      disableFocusListener: Et = !1,
      disableHoverListener: St = !1,
      disableInteractive: Bt = !1,
      disableTouchListener: Mt = !1,
      enterDelay: Ut = 100,
      enterNextDelay: Wt = 0,
      enterTouchDelay: Tt = 700,
      followCursor: kt = !1,
      id: Ot,
      leaveDelay: Nt = 0,
      leaveTouchDelay: $t = 1500,
      onClose: Pt,
      onOpen: Ft,
      open: Vt,
      placement: Xt = 'bottom',
      PopperComponent: Yt,
      PopperProps: xt = {},
      slotProps: It = {},
      slots: Kt = {},
      title: Qt,
      TransitionComponent: Ht = Grow,
      TransitionProps: Lt,
    } = ht,
    tr = _objectWithoutPropertiesLoose$3(ht, _excluded$Y),
    lr = reactExports.isValidElement(wt)
      ? wt
      : jsxRuntimeExports.jsx('span', { children: wt }),
    yr = useTheme$1(),
    mr = useRtl(),
    [Er, ur] = reactExports.useState(),
    [_r, Rr] = reactExports.useState(null),
    nr = reactExports.useRef(!1),
    fr = Bt || kt,
    gr = useTimeout(),
    br = useTimeout(),
    Sr = useTimeout(),
    zt = useTimeout(),
    [bt, Rt] = useControlled({
      controlled: Vt,
      default: !1,
      name: 'Tooltip',
      state: 'open',
    })
  let qt = bt
  const rr = useId(Ot),
    ar = reactExports.useRef(),
    ir = useEventCallback$1(() => {
      ar.current !== void 0 &&
        ((document.body.style.WebkitUserSelect = ar.current),
        (ar.current = void 0)),
        zt.clear()
    })
  reactExports.useEffect(() => ir, [ir])
  const Tr = jr => {
      hystersisTimer.clear(), (hystersisOpen = !0), Rt(!0), Ft && !qt && Ft(jr)
    },
    vr = useEventCallback$1(jr => {
      hystersisTimer.start(800 + Nt, () => {
        hystersisOpen = !1
      }),
        Rt(!1),
        Pt && qt && Pt(jr),
        gr.start(yr.transitions.duration.shortest, () => {
          nr.current = !1
        })
    }),
    Ar = jr => {
      ;(nr.current && jr.type !== 'touchstart') ||
        (Er && Er.removeAttribute('title'),
        br.clear(),
        Sr.clear(),
        Ut || (hystersisOpen && Wt)
          ? br.start(hystersisOpen ? Wt : Ut, () => {
              Tr(jr)
            })
          : Tr(jr))
    },
    Nr = jr => {
      br.clear(),
        Sr.start(Nt, () => {
          vr(jr)
        })
    },
    {
      isFocusVisibleRef: Or,
      onBlur: Fr,
      onFocus: Qr,
      ref: qr,
    } = useIsFocusVisible(),
    [, tn] = reactExports.useState(!1),
    en = jr => {
      Fr(jr), Or.current === !1 && (tn(!1), Nr(jr))
    },
    ln = jr => {
      Er || ur(jr.currentTarget), Qr(jr), Or.current === !0 && (tn(!0), Ar(jr))
    },
    yn = jr => {
      nr.current = !0
      const rn = lr.props
      rn.onTouchStart && rn.onTouchStart(jr)
    },
    Bn = jr => {
      yn(jr),
        Sr.clear(),
        gr.clear(),
        ir(),
        (ar.current = document.body.style.WebkitUserSelect),
        (document.body.style.WebkitUserSelect = 'none'),
        zt.start(Tt, () => {
          ;(document.body.style.WebkitUserSelect = ar.current), Ar(jr)
        })
    },
    xn = jr => {
      lr.props.onTouchEnd && lr.props.onTouchEnd(jr),
        ir(),
        Sr.start($t, () => {
          vr(jr)
        })
    }
  reactExports.useEffect(() => {
    if (!qt) return
    function jr(rn) {
      ;(rn.key === 'Escape' || rn.key === 'Esc') && vr(rn)
    }
    return (
      document.addEventListener('keydown', jr),
      () => {
        document.removeEventListener('keydown', jr)
      }
    )
  }, [vr, qt])
  const vn = useForkRef(lr.ref, qr, ur, s)
  !Qt && Qt !== 0 && (qt = !1)
  const on = reactExports.useRef(),
    Cn = jr => {
      const rn = lr.props
      rn.onMouseMove && rn.onMouseMove(jr),
        (cursorPosition = { x: jr.clientX, y: jr.clientY }),
        on.current && on.current.update()
    },
    dn = {},
    An = typeof Qt == 'string'
  jt
    ? ((dn.title = !qt && An && !St ? Qt : null),
      (dn['aria-describedby'] = qt ? rr : null))
    : ((dn['aria-label'] = An ? Qt : null),
      (dn['aria-labelledby'] = qt && !An ? rr : null))
  const Jr = _extends$5(
      {},
      dn,
      tr,
      lr.props,
      {
        className: clsx$1(tr.className, lr.props.className),
        onTouchStart: yn,
        ref: vn,
      },
      kt ? { onMouseMove: Cn } : {}
    ),
    En = {}
  Mt || ((Jr.onTouchStart = Bn), (Jr.onTouchEnd = xn)),
    St ||
      ((Jr.onMouseOver = composeEventHandler(Ar, Jr.onMouseOver)),
      (Jr.onMouseLeave = composeEventHandler(Nr, Jr.onMouseLeave)),
      fr || ((En.onMouseOver = Ar), (En.onMouseLeave = Nr))),
    Et ||
      ((Jr.onFocus = composeEventHandler(ln, Jr.onFocus)),
      (Jr.onBlur = composeEventHandler(en, Jr.onBlur)),
      fr || ((En.onFocus = ln), (En.onBlur = en)))
  const Pn = reactExports.useMemo(() => {
      var jr
      let rn = [
        { name: 'arrow', enabled: !!_r, options: { element: _r, padding: 4 } },
      ]
      return (
        (jr = xt.popperOptions) != null &&
          jr.modifiers &&
          (rn = rn.concat(xt.popperOptions.modifiers)),
        _extends$5({}, xt.popperOptions, { modifiers: rn })
      )
    }, [_r, xt]),
    pn = _extends$5({}, ht, {
      isRtl: mr,
      arrow: At,
      disableInteractive: fr,
      placement: Xt,
      PopperComponentProp: Yt,
      touch: nr.current,
    }),
    Tn = useUtilityClasses$S(pn),
    _n =
      ($ = (j = Kt.popper) != null ? j : Ct.Popper) != null ? $ : TooltipPopper,
    hn =
      (_e =
        (et = (tt = Kt.transition) != null ? tt : Ct.Transition) != null
          ? et
          : Ht) != null
        ? _e
        : Grow,
    wn =
      (rt = (nt = Kt.tooltip) != null ? nt : Ct.Tooltip) != null
        ? rt
        : TooltipTooltip,
    Kr =
      (it = (ot = Kt.arrow) != null ? ot : Ct.Arrow) != null
        ? it
        : TooltipArrow,
    Vr = appendOwnerState(
      _n,
      _extends$5({}, xt, (at = It.popper) != null ? at : Dt.popper, {
        className: clsx$1(
          Tn.popper,
          xt == null ? void 0 : xt.className,
          (st = (ut = It.popper) != null ? ut : Dt.popper) == null
            ? void 0
            : st.className
        ),
      }),
      pn
    ),
    In = appendOwnerState(
      hn,
      _extends$5({}, Lt, (ct = It.transition) != null ? ct : Dt.transition),
      pn
    ),
    Sn = appendOwnerState(
      wn,
      _extends$5({}, (dt = It.tooltip) != null ? dt : Dt.tooltip, {
        className: clsx$1(
          Tn.tooltip,
          (ft = (mt = It.tooltip) != null ? mt : Dt.tooltip) == null
            ? void 0
            : ft.className
        ),
      }),
      pn
    ),
    an = appendOwnerState(
      Kr,
      _extends$5({}, (vt = It.arrow) != null ? vt : Dt.arrow, {
        className: clsx$1(
          Tn.arrow,
          (yt = (pt = It.arrow) != null ? pt : Dt.arrow) == null
            ? void 0
            : yt.className
        ),
      }),
      pn
    )
  return jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [
      reactExports.cloneElement(lr, Jr),
      jsxRuntimeExports.jsx(
        _n,
        _extends$5(
          {
            as: Yt ?? Popper,
            placement: Xt,
            anchorEl: kt
              ? {
                  getBoundingClientRect: () => ({
                    top: cursorPosition.y,
                    left: cursorPosition.x,
                    right: cursorPosition.x,
                    bottom: cursorPosition.y,
                    width: 0,
                    height: 0,
                  }),
                }
              : Er,
            popperRef: on,
            open: Er ? qt : !1,
            id: rr,
            transition: !0,
          },
          En,
          Vr,
          {
            popperOptions: Pn,
            children: ({ TransitionProps: jr }) =>
              jsxRuntimeExports.jsx(
                hn,
                _extends$5(
                  { timeout: yr.transitions.duration.shorter },
                  jr,
                  In,
                  {
                    children: jsxRuntimeExports.jsxs(
                      wn,
                      _extends$5({}, Sn, {
                        children: [
                          Qt,
                          At
                            ? jsxRuntimeExports.jsx(
                                Kr,
                                _extends$5({}, an, { ref: Rr })
                              )
                            : null,
                        ],
                      })
                    ),
                  }
                )
              ),
          }
        )
      ),
    ],
  })
})
function getLinearProgressUtilityClass(o) {
  return generateUtilityClass('MuiLinearProgress', o)
}
generateUtilityClasses('MuiLinearProgress', [
  'root',
  'colorPrimary',
  'colorSecondary',
  'determinate',
  'indeterminate',
  'buffer',
  'query',
  'dashed',
  'dashedColorPrimary',
  'dashedColorSecondary',
  'bar',
  'barColorPrimary',
  'barColorSecondary',
  'bar1Indeterminate',
  'bar1Determinate',
  'bar1Buffer',
  'bar2Indeterminate',
  'bar2Buffer',
])
const _excluded$X = ['className', 'color', 'value', 'valueBuffer', 'variant']
let _$1 = o => o,
  _t$1,
  _t2$1,
  _t3$1,
  _t4$1,
  _t5,
  _t6
const TRANSITION_DURATION = 4,
  indeterminate1Keyframe = keyframes(
    _t$1 ||
      (_t$1 = _$1`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`)
  ),
  indeterminate2Keyframe = keyframes(
    _t2$1 ||
      (_t2$1 = _$1`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`)
  ),
  bufferKeyframe = keyframes(
    _t3$1 ||
      (_t3$1 = _$1`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`)
  ),
  useUtilityClasses$R = o => {
    const { classes: a, variant: s, color: $ } = o,
      j = {
        root: ['root', `color${capitalize$2($)}`, s],
        dashed: ['dashed', `dashedColor${capitalize$2($)}`],
        bar1: [
          'bar',
          `barColor${capitalize$2($)}`,
          (s === 'indeterminate' || s === 'query') && 'bar1Indeterminate',
          s === 'determinate' && 'bar1Determinate',
          s === 'buffer' && 'bar1Buffer',
        ],
        bar2: [
          'bar',
          s !== 'buffer' && `barColor${capitalize$2($)}`,
          s === 'buffer' && `color${capitalize$2($)}`,
          (s === 'indeterminate' || s === 'query') && 'bar2Indeterminate',
          s === 'buffer' && 'bar2Buffer',
        ],
      }
    return composeClasses(j, getLinearProgressUtilityClass, a)
  },
  getColorShade = (o, a) =>
    a === 'inherit'
      ? 'currentColor'
      : o.vars
      ? o.vars.palette.LinearProgress[`${a}Bg`]
      : o.palette.mode === 'light'
      ? lighten_1(o.palette[a].main, 0.62)
      : darken_1(o.palette[a].main, 0.5),
  LinearProgressRoot = styled('span', {
    name: 'MuiLinearProgress',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, a[`color${capitalize$2(s.color)}`], a[s.variant]]
    },
  })(({ ownerState: o, theme: a }) =>
    _extends$5(
      {
        position: 'relative',
        overflow: 'hidden',
        display: 'block',
        height: 4,
        zIndex: 0,
        '@media print': { colorAdjust: 'exact' },
        backgroundColor: getColorShade(a, o.color),
      },
      o.color === 'inherit' &&
        o.variant !== 'buffer' && {
          backgroundColor: 'none',
          '&::before': {
            content: '""',
            position: 'absolute',
            left: 0,
            top: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'currentColor',
            opacity: 0.3,
          },
        },
      o.variant === 'buffer' && { backgroundColor: 'transparent' },
      o.variant === 'query' && { transform: 'rotate(180deg)' }
    )
  ),
  LinearProgressDashed = styled('span', {
    name: 'MuiLinearProgress',
    slot: 'Dashed',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.dashed, a[`dashedColor${capitalize$2(s.color)}`]]
    },
  })(
    ({ ownerState: o, theme: a }) => {
      const s = getColorShade(a, o.color)
      return _extends$5(
        { position: 'absolute', marginTop: 0, height: '100%', width: '100%' },
        o.color === 'inherit' && { opacity: 0.3 },
        {
          backgroundImage: `radial-gradient(${s} 0%, ${s} 16%, transparent 42%)`,
          backgroundSize: '10px 10px',
          backgroundPosition: '0 -23px',
        }
      )
    },
    css$2(
      _t4$1 ||
        (_t4$1 = _$1`
    animation: ${0} 3s infinite linear;
  `),
      bufferKeyframe
    )
  ),
  LinearProgressBar1 = styled('span', {
    name: 'MuiLinearProgress',
    slot: 'Bar1',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.bar,
        a[`barColor${capitalize$2(s.color)}`],
        (s.variant === 'indeterminate' || s.variant === 'query') &&
          a.bar1Indeterminate,
        s.variant === 'determinate' && a.bar1Determinate,
        s.variant === 'buffer' && a.bar1Buffer,
      ]
    },
  })(
    ({ ownerState: o, theme: a }) =>
      _extends$5(
        {
          width: '100%',
          position: 'absolute',
          left: 0,
          bottom: 0,
          top: 0,
          transition: 'transform 0.2s linear',
          transformOrigin: 'left',
          backgroundColor:
            o.color === 'inherit'
              ? 'currentColor'
              : (a.vars || a).palette[o.color].main,
        },
        o.variant === 'determinate' && {
          transition: `transform .${TRANSITION_DURATION}s linear`,
        },
        o.variant === 'buffer' && {
          zIndex: 1,
          transition: `transform .${TRANSITION_DURATION}s linear`,
        }
      ),
    ({ ownerState: o }) =>
      (o.variant === 'indeterminate' || o.variant === 'query') &&
      css$2(
        _t5 ||
          (_t5 = _$1`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
    `),
        indeterminate1Keyframe
      )
  ),
  LinearProgressBar2 = styled('span', {
    name: 'MuiLinearProgress',
    slot: 'Bar2',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.bar,
        a[`barColor${capitalize$2(s.color)}`],
        (s.variant === 'indeterminate' || s.variant === 'query') &&
          a.bar2Indeterminate,
        s.variant === 'buffer' && a.bar2Buffer,
      ]
    },
  })(
    ({ ownerState: o, theme: a }) =>
      _extends$5(
        {
          width: '100%',
          position: 'absolute',
          left: 0,
          bottom: 0,
          top: 0,
          transition: 'transform 0.2s linear',
          transformOrigin: 'left',
        },
        o.variant !== 'buffer' && {
          backgroundColor:
            o.color === 'inherit'
              ? 'currentColor'
              : (a.vars || a).palette[o.color].main,
        },
        o.color === 'inherit' && { opacity: 0.3 },
        o.variant === 'buffer' && {
          backgroundColor: getColorShade(a, o.color),
          transition: `transform .${TRANSITION_DURATION}s linear`,
        }
      ),
    ({ ownerState: o }) =>
      (o.variant === 'indeterminate' || o.variant === 'query') &&
      css$2(
        _t6 ||
          (_t6 = _$1`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
    `),
        indeterminate2Keyframe
      )
  ),
  LinearProgress = reactExports.forwardRef(function(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiLinearProgress' }),
      {
        className: j,
        color: _e = 'primary',
        value: et,
        valueBuffer: tt,
        variant: rt = 'indeterminate',
      } = $,
      nt = _objectWithoutPropertiesLoose$3($, _excluded$X),
      it = _extends$5({}, $, { color: _e, variant: rt }),
      ot = useUtilityClasses$R(it),
      at = useRtl(),
      st = {},
      ut = { bar1: {}, bar2: {} }
    if ((rt === 'determinate' || rt === 'buffer') && et !== void 0) {
      ;(st['aria-valuenow'] = Math.round(et)),
        (st['aria-valuemin'] = 0),
        (st['aria-valuemax'] = 100)
      let ct = et - 100
      at && (ct = -ct), (ut.bar1.transform = `translateX(${ct}%)`)
    }
    if (rt === 'buffer' && tt !== void 0) {
      let ct = (tt || 0) - 100
      at && (ct = -ct), (ut.bar2.transform = `translateX(${ct}%)`)
    }
    return jsxRuntimeExports.jsxs(
      LinearProgressRoot,
      _extends$5(
        { className: clsx$1(ot.root, j), ownerState: it, role: 'progressbar' },
        st,
        { ref: s },
        nt,
        {
          children: [
            rt === 'buffer'
              ? jsxRuntimeExports.jsx(LinearProgressDashed, {
                  className: ot.dashed,
                  ownerState: it,
                })
              : null,
            jsxRuntimeExports.jsx(LinearProgressBar1, {
              className: ot.bar1,
              ownerState: it,
              style: ut.bar1,
            }),
            rt === 'determinate'
              ? null
              : jsxRuntimeExports.jsx(LinearProgressBar2, {
                  className: ot.bar2,
                  ownerState: it,
                  style: ut.bar2,
                }),
          ],
        }
      )
    )
  })
function getMobileStepperUtilityClass(o) {
  return generateUtilityClass('MuiMobileStepper', o)
}
generateUtilityClasses('MuiMobileStepper', [
  'root',
  'positionBottom',
  'positionTop',
  'positionStatic',
  'dots',
  'dot',
  'dotActive',
  'progress',
])
const _excluded$W = [
    'activeStep',
    'backButton',
    'className',
    'LinearProgressProps',
    'nextButton',
    'position',
    'steps',
    'variant',
  ],
  useUtilityClasses$Q = o => {
    const { classes: a, position: s } = o,
      $ = {
        root: ['root', `position${capitalize$2(s)}`],
        dots: ['dots'],
        dot: ['dot'],
        dotActive: ['dotActive'],
        progress: ['progress'],
      }
    return composeClasses($, getMobileStepperUtilityClass, a)
  },
  MobileStepperRoot = styled(Paper, {
    name: 'MuiMobileStepper',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, a[`position${capitalize$2(s.position)}`]]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        display: 'flex',
        flexDirection: 'row',
        justifyContent: 'space-between',
        alignItems: 'center',
        background: (o.vars || o).palette.background.default,
        padding: 8,
      },
      a.position === 'bottom' && {
        position: 'fixed',
        bottom: 0,
        left: 0,
        right: 0,
        zIndex: (o.vars || o).zIndex.mobileStepper,
      },
      a.position === 'top' && {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        zIndex: (o.vars || o).zIndex.mobileStepper,
      }
    )
  ),
  MobileStepperDots = styled('div', {
    name: 'MuiMobileStepper',
    slot: 'Dots',
    overridesResolver: (o, a) => a.dots,
  })(({ ownerState: o }) =>
    _extends$5(
      {},
      o.variant === 'dots' && { display: 'flex', flexDirection: 'row' }
    )
  ),
  MobileStepperDot = styled('div', {
    name: 'MuiMobileStepper',
    slot: 'Dot',
    shouldForwardProp: o => slotShouldForwardProp(o) && o !== 'dotActive',
    overridesResolver: (o, a) => {
      const { dotActive: s } = o
      return [a.dot, s && a.dotActive]
    },
  })(({ theme: o, ownerState: a, dotActive: s }) =>
    _extends$5(
      {},
      a.variant === 'dots' &&
        _extends$5(
          {
            transition: o.transitions.create('background-color', {
              duration: o.transitions.duration.shortest,
            }),
            backgroundColor: (o.vars || o).palette.action.disabled,
            borderRadius: '50%',
            width: 8,
            height: 8,
            margin: '0 2px',
          },
          s && { backgroundColor: (o.vars || o).palette.primary.main }
        )
    )
  ),
  MobileStepperProgress = styled(LinearProgress, {
    name: 'MuiMobileStepper',
    slot: 'Progress',
    overridesResolver: (o, a) => a.progress,
  })(({ ownerState: o }) =>
    _extends$5({}, o.variant === 'progress' && { width: '50%' })
  ),
  MobileStepper = reactExports.forwardRef(function(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiMobileStepper' }),
      {
        activeStep: j = 0,
        backButton: _e,
        className: et,
        LinearProgressProps: tt,
        nextButton: rt,
        position: nt = 'bottom',
        steps: it,
        variant: ot = 'dots',
      } = $,
      at = _objectWithoutPropertiesLoose$3($, _excluded$W),
      st = _extends$5({}, $, { activeStep: j, position: nt, variant: ot })
    let ut
    ot === 'progress' &&
      (it === 1 ? (ut = 100) : (ut = Math.ceil((j / (it - 1)) * 100)))
    const ct = useUtilityClasses$Q(st)
    return jsxRuntimeExports.jsxs(
      MobileStepperRoot,
      _extends$5(
        {
          square: !0,
          elevation: 0,
          className: clsx$1(ct.root, et),
          ref: s,
          ownerState: st,
        },
        at,
        {
          children: [
            _e,
            ot === 'text' &&
              jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [j + 1, ' / ', it],
              }),
            ot === 'dots' &&
              jsxRuntimeExports.jsx(MobileStepperDots, {
                ownerState: st,
                className: ct.dots,
                children: [...new Array(it)].map((dt, ft) =>
                  jsxRuntimeExports.jsx(
                    MobileStepperDot,
                    {
                      className: clsx$1(ct.dot, ft === j && ct.dotActive),
                      ownerState: st,
                      dotActive: ft === j,
                    },
                    ft
                  )
                ),
              }),
            ot === 'progress' &&
              jsxRuntimeExports.jsx(
                MobileStepperProgress,
                _extends$5(
                  {
                    ownerState: st,
                    className: ct.progress,
                    variant: 'determinate',
                    value: ut,
                  },
                  tt
                )
              ),
            rt,
          ],
        }
      )
    )
  }),
  libName = 'Trystero',
  alloc = (o, a) =>
    Array(o)
      .fill()
      .map(a),
  charSet = '0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz',
  genId = o =>
    alloc(o, () => charSet[Math.floor(Math.random() * charSet.length)]).join(
      ''
    ),
  selfId = genId(20),
  all$1 = Promise.all.bind(Promise),
  isBrowser = typeof window < 'u',
  { entries, fromEntries, keys: keys$2 } = Object,
  noOp = () => {},
  mkErr = o => new Error(`${libName}: ${o}`),
  encoder$1 = new TextEncoder(),
  decoder = new TextDecoder(),
  encodeBytes = o => encoder$1.encode(o),
  decodeBytes = o => decoder.decode(o),
  topicPath = (...o) => o.join('@'),
  getRelays = (o, a, s) =>
    (o.relayUrls || a).slice(
      0,
      o.relayUrls ? o.relayUrls.length : o.relayRedundancy || s
    ),
  toJson = JSON.stringify,
  fromJson = JSON.parse,
  defaultRetryMs = 3333,
  socketRetryPeriods = {},
  makeSocket = (o, a) => {
    const s = {},
      $ = () => {
        const j = new WebSocket(o)
        ;(j.onclose = () => {
          socketRetryPeriods[o] ?? (socketRetryPeriods[o] = defaultRetryMs),
            setTimeout($, socketRetryPeriods[o]),
            (socketRetryPeriods[o] *= 2)
        }),
          (j.onmessage = _e => a(_e.data)),
          (s.socket = j),
          (s.url = j.url),
          (s.ready = new Promise(
            _e =>
              (j.onopen = () => {
                _e(s), (socketRetryPeriods[o] = defaultRetryMs)
              })
          )),
          (s.send = _e => {
            j.readyState === 1 && j.send(_e)
          })
      }
    return $(), s
  },
  algo = 'AES-GCM',
  strToSha1 = {},
  pack$1 = o => btoa(String.fromCharCode.apply(null, new Uint8Array(o))),
  unpack = o => {
    const a = atob(o)
    return new Uint8Array(a.length).map((s, $) => a.charCodeAt($)).buffer
  },
  sha1 = async o => {
    if (strToSha1[o]) return strToSha1[o]
    const a = Array.from(
      new Uint8Array(await crypto.subtle.digest('SHA-1', encodeBytes(o)))
    )
      .map(s => s.toString(36))
      .join('')
    return (strToSha1[o] = a), a
  },
  genKey = async (o, a, s) =>
    crypto.subtle.importKey(
      'raw',
      await crypto.subtle.digest(
        { name: 'SHA-256' },
        encodeBytes(`${o}:${a}:${s}`)
      ),
      { name: algo },
      !1,
      ['encrypt', 'decrypt']
    ),
  joinChar = '$',
  ivJoinChar = ',',
  encrypt = async (o, a) => {
    const s = crypto.getRandomValues(new Uint8Array(16))
    return (
      s.join(ivJoinChar) +
      joinChar +
      pack$1(
        await crypto.subtle.encrypt(
          { name: algo, iv: s },
          await o,
          encodeBytes(a)
        )
      )
    )
  },
  decrypt = async (o, a) => {
    const [s, $] = a.split(joinChar)
    return decodeBytes(
      await crypto.subtle.decrypt(
        { name: algo, iv: new Uint8Array(s.split(ivJoinChar)) },
        await o,
        unpack($)
      )
    )
  }
var browser$2 = { exports: {} },
  ms,
  hasRequiredMs
function requireMs() {
  if (hasRequiredMs) return ms
  hasRequiredMs = 1
  var o = 1e3,
    a = o * 60,
    s = a * 60,
    $ = s * 24,
    j = $ * 7,
    _e = $ * 365.25
  ms = function(it, ot) {
    ot = ot || {}
    var at = typeof it
    if (at === 'string' && it.length > 0) return et(it)
    if (at === 'number' && isFinite(it)) return ot.long ? rt(it) : tt(it)
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(it)
    )
  }
  function et(it) {
    if (((it = String(it)), !(it.length > 100))) {
      var ot = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        it
      )
      if (ot) {
        var at = parseFloat(ot[1]),
          st = (ot[2] || 'ms').toLowerCase()
        switch (st) {
          case 'years':
          case 'year':
          case 'yrs':
          case 'yr':
          case 'y':
            return at * _e
          case 'weeks':
          case 'week':
          case 'w':
            return at * j
          case 'days':
          case 'day':
          case 'd':
            return at * $
          case 'hours':
          case 'hour':
          case 'hrs':
          case 'hr':
          case 'h':
            return at * s
          case 'minutes':
          case 'minute':
          case 'mins':
          case 'min':
          case 'm':
            return at * a
          case 'seconds':
          case 'second':
          case 'secs':
          case 'sec':
          case 's':
            return at * o
          case 'milliseconds':
          case 'millisecond':
          case 'msecs':
          case 'msec':
          case 'ms':
            return at
          default:
            return
        }
      }
    }
  }
  function tt(it) {
    var ot = Math.abs(it)
    return ot >= $
      ? Math.round(it / $) + 'd'
      : ot >= s
      ? Math.round(it / s) + 'h'
      : ot >= a
      ? Math.round(it / a) + 'm'
      : ot >= o
      ? Math.round(it / o) + 's'
      : it + 'ms'
  }
  function rt(it) {
    var ot = Math.abs(it)
    return ot >= $
      ? nt(it, ot, $, 'day')
      : ot >= s
      ? nt(it, ot, s, 'hour')
      : ot >= a
      ? nt(it, ot, a, 'minute')
      : ot >= o
      ? nt(it, ot, o, 'second')
      : it + ' ms'
  }
  function nt(it, ot, at, st) {
    var ut = ot >= at * 1.5
    return Math.round(it / at) + ' ' + st + (ut ? 's' : '')
  }
  return ms
}
function setup(o) {
  ;(s.debug = s),
    (s.default = s),
    (s.coerce = rt),
    (s.disable = et),
    (s.enable = j),
    (s.enabled = tt),
    (s.humanize = requireMs()),
    (s.destroy = nt),
    Object.keys(o).forEach(it => {
      s[it] = o[it]
    }),
    (s.names = []),
    (s.skips = []),
    (s.formatters = {})
  function a(it) {
    let ot = 0
    for (let at = 0; at < it.length; at++)
      (ot = (ot << 5) - ot + it.charCodeAt(at)), (ot |= 0)
    return s.colors[Math.abs(ot) % s.colors.length]
  }
  s.selectColor = a
  function s(it) {
    let ot,
      at = null,
      st,
      ut
    function ct(...dt) {
      if (!ct.enabled) return
      const ft = ct,
        mt = Number(new Date()),
        vt = mt - (ot || mt)
      ;(ft.diff = vt),
        (ft.prev = ot),
        (ft.curr = mt),
        (ot = mt),
        (dt[0] = s.coerce(dt[0])),
        typeof dt[0] != 'string' && dt.unshift('%O')
      let yt = 0
      ;(dt[0] = dt[0].replace(/%([a-zA-Z%])/g, (ht, At) => {
        if (ht === '%%') return '%'
        yt++
        const wt = s.formatters[At]
        if (typeof wt == 'function') {
          const Ct = dt[yt]
          ;(ht = wt.call(ft, Ct)), dt.splice(yt, 1), yt--
        }
        return ht
      })),
        s.formatArgs.call(ft, dt),
        (ft.log || s.log).apply(ft, dt)
    }
    return (
      (ct.namespace = it),
      (ct.useColors = s.useColors()),
      (ct.color = s.selectColor(it)),
      (ct.extend = $),
      (ct.destroy = s.destroy),
      Object.defineProperty(ct, 'enabled', {
        enumerable: !0,
        configurable: !1,
        get: () =>
          at !== null
            ? at
            : (st !== s.namespaces &&
                ((st = s.namespaces), (ut = s.enabled(it))),
              ut),
        set: dt => {
          at = dt
        },
      }),
      typeof s.init == 'function' && s.init(ct),
      ct
    )
  }
  function $(it, ot) {
    const at = s(this.namespace + (typeof ot > 'u' ? ':' : ot) + it)
    return (at.log = this.log), at
  }
  function j(it) {
    s.save(it), (s.namespaces = it), (s.names = []), (s.skips = [])
    const ot = (typeof it == 'string' ? it : '')
      .trim()
      .replace(' ', ',')
      .split(',')
      .filter(Boolean)
    for (const at of ot)
      at[0] === '-' ? s.skips.push(at.slice(1)) : s.names.push(at)
  }
  function _e(it, ot) {
    let at = 0,
      st = 0,
      ut = -1,
      ct = 0
    for (; at < it.length; )
      if (st < ot.length && (ot[st] === it[at] || ot[st] === '*'))
        ot[st] === '*' ? ((ut = st), (ct = at), st++) : (at++, st++)
      else if (ut !== -1) (st = ut + 1), ct++, (at = ct)
      else return !1
    for (; st < ot.length && ot[st] === '*'; ) st++
    return st === ot.length
  }
  function et() {
    const it = [...s.names, ...s.skips.map(ot => '-' + ot)].join(',')
    return s.enable(''), it
  }
  function tt(it) {
    for (const ot of s.skips) if (_e(it, ot)) return !1
    for (const ot of s.names) if (_e(it, ot)) return !0
    return !1
  }
  function rt(it) {
    return it instanceof Error ? it.stack || it.message : it
  }
  function nt() {
    console.warn(
      'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
    )
  }
  return s.enable(s.load()), s
}
var common$1 = setup
;(function(o, a) {
  var s = {}
  ;(a.formatArgs = j),
    (a.save = _e),
    (a.load = et),
    (a.useColors = $),
    (a.storage = tt()),
    (a.destroy = (() => {
      let nt = !1
      return () => {
        nt ||
          ((nt = !0),
          console.warn(
            'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
          ))
      }
    })()),
    (a.colors = [
      '#0000CC',
      '#0000FF',
      '#0033CC',
      '#0033FF',
      '#0066CC',
      '#0066FF',
      '#0099CC',
      '#0099FF',
      '#00CC00',
      '#00CC33',
      '#00CC66',
      '#00CC99',
      '#00CCCC',
      '#00CCFF',
      '#3300CC',
      '#3300FF',
      '#3333CC',
      '#3333FF',
      '#3366CC',
      '#3366FF',
      '#3399CC',
      '#3399FF',
      '#33CC00',
      '#33CC33',
      '#33CC66',
      '#33CC99',
      '#33CCCC',
      '#33CCFF',
      '#6600CC',
      '#6600FF',
      '#6633CC',
      '#6633FF',
      '#66CC00',
      '#66CC33',
      '#9900CC',
      '#9900FF',
      '#9933CC',
      '#9933FF',
      '#99CC00',
      '#99CC33',
      '#CC0000',
      '#CC0033',
      '#CC0066',
      '#CC0099',
      '#CC00CC',
      '#CC00FF',
      '#CC3300',
      '#CC3333',
      '#CC3366',
      '#CC3399',
      '#CC33CC',
      '#CC33FF',
      '#CC6600',
      '#CC6633',
      '#CC9900',
      '#CC9933',
      '#CCCC00',
      '#CCCC33',
      '#FF0000',
      '#FF0033',
      '#FF0066',
      '#FF0099',
      '#FF00CC',
      '#FF00FF',
      '#FF3300',
      '#FF3333',
      '#FF3366',
      '#FF3399',
      '#FF33CC',
      '#FF33FF',
      '#FF6600',
      '#FF6633',
      '#FF9900',
      '#FF9933',
      '#FFCC00',
      '#FFCC33',
    ])
  function $() {
    if (
      typeof window < 'u' &&
      window.process &&
      (window.process.type === 'renderer' || window.process.__nwjs)
    )
      return !0
    if (
      typeof navigator < 'u' &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
    )
      return !1
    let nt
    return (
      (typeof document < 'u' &&
        document.documentElement &&
        document.documentElement.style &&
        document.documentElement.style.WebkitAppearance) ||
      (typeof window < 'u' &&
        window.console &&
        (window.console.firebug ||
          (window.console.exception && window.console.table))) ||
      (typeof navigator < 'u' &&
        navigator.userAgent &&
        (nt = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
        parseInt(nt[1], 10) >= 31) ||
      (typeof navigator < 'u' &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    )
  }
  function j(nt) {
    if (
      ((nt[0] =
        (this.useColors ? '%c' : '') +
        this.namespace +
        (this.useColors ? ' %c' : ' ') +
        nt[0] +
        (this.useColors ? '%c ' : ' ') +
        '+' +
        o.exports.humanize(this.diff)),
      !this.useColors)
    )
      return
    const it = 'color: ' + this.color
    nt.splice(1, 0, it, 'color: inherit')
    let ot = 0,
      at = 0
    nt[0].replace(/%[a-zA-Z%]/g, st => {
      st !== '%%' && (ot++, st === '%c' && (at = ot))
    }),
      nt.splice(at, 0, it)
  }
  a.log = console.debug || console.log || (() => {})
  function _e(nt) {
    try {
      nt ? a.storage.setItem('debug', nt) : a.storage.removeItem('debug')
    } catch {}
  }
  function et() {
    let nt
    try {
      nt = a.storage.getItem('debug')
    } catch {}
    return !nt && typeof process < 'u' && 'env' in process && (nt = s.DEBUG), nt
  }
  function tt() {
    try {
      return localStorage
    } catch {}
  }
  o.exports = common$1(a)
  const { formatters: rt } = o.exports
  rt.j = function(nt) {
    try {
      return JSON.stringify(nt)
    } catch (it) {
      return '[UnexpectedJSONParseError]: ' + it.message
    }
  }
})(browser$2, browser$2.exports)
var browserExports = browser$2.exports
const debug = getDefaultExportFromCjs(browserExports),
  scope$1 = typeof window < 'u' ? window : self,
  RTCPeerConnection =
    scope$1.RTCPeerConnection ||
    scope$1.mozRTCPeerConnection ||
    scope$1.webkitRTCPeerConnection,
  RTCSessionDescription =
    scope$1.RTCSessionDescription ||
    scope$1.mozRTCSessionDescription ||
    scope$1.webkitRTCSessionDescription,
  RTCIceCandidate =
    scope$1.RTCIceCandidate ||
    scope$1.mozRTCIceCandidate ||
    scope$1.webkitRTCIceCandidate
var events$1 = { exports: {} },
  R = typeof Reflect == 'object' ? Reflect : null,
  ReflectApply =
    R && typeof R.apply == 'function'
      ? R.apply
      : function(a, s, $) {
          return Function.prototype.apply.call(a, s, $)
        },
  ReflectOwnKeys
R && typeof R.ownKeys == 'function'
  ? (ReflectOwnKeys = R.ownKeys)
  : Object.getOwnPropertySymbols
  ? (ReflectOwnKeys = function(a) {
      return Object.getOwnPropertyNames(a).concat(
        Object.getOwnPropertySymbols(a)
      )
    })
  : (ReflectOwnKeys = function(a) {
      return Object.getOwnPropertyNames(a)
    })
function ProcessEmitWarning(o) {
  console && console.warn && console.warn(o)
}
var NumberIsNaN =
  Number.isNaN ||
  function(a) {
    return a !== a
  }
function EventEmitter$3() {
  EventEmitter$3.init.call(this)
}
events$1.exports = EventEmitter$3
events$1.exports.once = once$5
EventEmitter$3.EventEmitter = EventEmitter$3
EventEmitter$3.prototype._events = void 0
EventEmitter$3.prototype._eventsCount = 0
EventEmitter$3.prototype._maxListeners = void 0
var defaultMaxListeners = 10
function checkListener(o) {
  if (typeof o != 'function')
    throw new TypeError(
      'The "listener" argument must be of type Function. Received type ' +
        typeof o
    )
}
Object.defineProperty(EventEmitter$3, 'defaultMaxListeners', {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners
  },
  set: function(o) {
    if (typeof o != 'number' || o < 0 || NumberIsNaN(o))
      throw new RangeError(
        'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' +
          o +
          '.'
      )
    defaultMaxListeners = o
  },
})
EventEmitter$3.init = function() {
  ;(this._events === void 0 ||
    this._events === Object.getPrototypeOf(this)._events) &&
    ((this._events = Object.create(null)), (this._eventsCount = 0)),
    (this._maxListeners = this._maxListeners || void 0)
}
EventEmitter$3.prototype.setMaxListeners = function(a) {
  if (typeof a != 'number' || a < 0 || NumberIsNaN(a))
    throw new RangeError(
      'The value of "n" is out of range. It must be a non-negative number. Received ' +
        a +
        '.'
    )
  return (this._maxListeners = a), this
}
function _getMaxListeners(o) {
  return o._maxListeners === void 0
    ? EventEmitter$3.defaultMaxListeners
    : o._maxListeners
}
EventEmitter$3.prototype.getMaxListeners = function() {
  return _getMaxListeners(this)
}
EventEmitter$3.prototype.emit = function(a) {
  for (var s = [], $ = 1; $ < arguments.length; $++) s.push(arguments[$])
  var j = a === 'error',
    _e = this._events
  if (_e !== void 0) j = j && _e.error === void 0
  else if (!j) return !1
  if (j) {
    var et
    if ((s.length > 0 && (et = s[0]), et instanceof Error)) throw et
    var tt = new Error('Unhandled error.' + (et ? ' (' + et.message + ')' : ''))
    throw ((tt.context = et), tt)
  }
  var rt = _e[a]
  if (rt === void 0) return !1
  if (typeof rt == 'function') ReflectApply(rt, this, s)
  else
    for (var nt = rt.length, it = arrayClone(rt, nt), $ = 0; $ < nt; ++$)
      ReflectApply(it[$], this, s)
  return !0
}
function _addListener(o, a, s, $) {
  var j, _e, et
  if (
    (checkListener(s),
    (_e = o._events),
    _e === void 0
      ? ((_e = o._events = Object.create(null)), (o._eventsCount = 0))
      : (_e.newListener !== void 0 &&
          (o.emit('newListener', a, s.listener ? s.listener : s),
          (_e = o._events)),
        (et = _e[a])),
    et === void 0)
  )
    (et = _e[a] = s), ++o._eventsCount
  else if (
    (typeof et == 'function'
      ? (et = _e[a] = $ ? [s, et] : [et, s])
      : $
      ? et.unshift(s)
      : et.push(s),
    (j = _getMaxListeners(o)),
    j > 0 && et.length > j && !et.warned)
  ) {
    et.warned = !0
    var tt = new Error(
      'Possible EventEmitter memory leak detected. ' +
        et.length +
        ' ' +
        String(a) +
        ' listeners added. Use emitter.setMaxListeners() to increase limit'
    )
    ;(tt.name = 'MaxListenersExceededWarning'),
      (tt.emitter = o),
      (tt.type = a),
      (tt.count = et.length),
      ProcessEmitWarning(tt)
  }
  return o
}
EventEmitter$3.prototype.addListener = function(a, s) {
  return _addListener(this, a, s, !1)
}
EventEmitter$3.prototype.on = EventEmitter$3.prototype.addListener
EventEmitter$3.prototype.prependListener = function(a, s) {
  return _addListener(this, a, s, !0)
}
function onceWrapper() {
  if (!this.fired)
    return (
      this.target.removeListener(this.type, this.wrapFn),
      (this.fired = !0),
      arguments.length === 0
        ? this.listener.call(this.target)
        : this.listener.apply(this.target, arguments)
    )
}
function _onceWrap(o, a, s) {
  var $ = { fired: !1, wrapFn: void 0, target: o, type: a, listener: s },
    j = onceWrapper.bind($)
  return (j.listener = s), ($.wrapFn = j), j
}
EventEmitter$3.prototype.once = function(a, s) {
  return checkListener(s), this.on(a, _onceWrap(this, a, s)), this
}
EventEmitter$3.prototype.prependOnceListener = function(a, s) {
  return checkListener(s), this.prependListener(a, _onceWrap(this, a, s)), this
}
EventEmitter$3.prototype.removeListener = function(a, s) {
  var $, j, _e, et, tt
  if ((checkListener(s), (j = this._events), j === void 0)) return this
  if ((($ = j[a]), $ === void 0)) return this
  if ($ === s || $.listener === s)
    --this._eventsCount === 0
      ? (this._events = Object.create(null))
      : (delete j[a],
        j.removeListener && this.emit('removeListener', a, $.listener || s))
  else if (typeof $ != 'function') {
    for (_e = -1, et = $.length - 1; et >= 0; et--)
      if ($[et] === s || $[et].listener === s) {
        ;(tt = $[et].listener), (_e = et)
        break
      }
    if (_e < 0) return this
    _e === 0 ? $.shift() : spliceOne($, _e),
      $.length === 1 && (j[a] = $[0]),
      j.removeListener !== void 0 && this.emit('removeListener', a, tt || s)
  }
  return this
}
EventEmitter$3.prototype.off = EventEmitter$3.prototype.removeListener
EventEmitter$3.prototype.removeAllListeners = function(a) {
  var s, $, j
  if ((($ = this._events), $ === void 0)) return this
  if ($.removeListener === void 0)
    return (
      arguments.length === 0
        ? ((this._events = Object.create(null)), (this._eventsCount = 0))
        : $[a] !== void 0 &&
          (--this._eventsCount === 0
            ? (this._events = Object.create(null))
            : delete $[a]),
      this
    )
  if (arguments.length === 0) {
    var _e = Object.keys($),
      et
    for (j = 0; j < _e.length; ++j)
      (et = _e[j]), et !== 'removeListener' && this.removeAllListeners(et)
    return (
      this.removeAllListeners('removeListener'),
      (this._events = Object.create(null)),
      (this._eventsCount = 0),
      this
    )
  }
  if (((s = $[a]), typeof s == 'function')) this.removeListener(a, s)
  else if (s !== void 0)
    for (j = s.length - 1; j >= 0; j--) this.removeListener(a, s[j])
  return this
}
function _listeners(o, a, s) {
  var $ = o._events
  if ($ === void 0) return []
  var j = $[a]
  return j === void 0
    ? []
    : typeof j == 'function'
    ? s
      ? [j.listener || j]
      : [j]
    : s
    ? unwrapListeners(j)
    : arrayClone(j, j.length)
}
EventEmitter$3.prototype.listeners = function(a) {
  return _listeners(this, a, !0)
}
EventEmitter$3.prototype.rawListeners = function(a) {
  return _listeners(this, a, !1)
}
EventEmitter$3.listenerCount = function(o, a) {
  return typeof o.listenerCount == 'function'
    ? o.listenerCount(a)
    : listenerCount.call(o, a)
}
EventEmitter$3.prototype.listenerCount = listenerCount
function listenerCount(o) {
  var a = this._events
  if (a !== void 0) {
    var s = a[o]
    if (typeof s == 'function') return 1
    if (s !== void 0) return s.length
  }
  return 0
}
EventEmitter$3.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : []
}
function arrayClone(o, a) {
  for (var s = new Array(a), $ = 0; $ < a; ++$) s[$] = o[$]
  return s
}
function spliceOne(o, a) {
  for (; a + 1 < o.length; a++) o[a] = o[a + 1]
  o.pop()
}
function unwrapListeners(o) {
  for (var a = new Array(o.length), s = 0; s < a.length; ++s)
    a[s] = o[s].listener || o[s]
  return a
}
function once$5(o, a) {
  return new Promise(function(s, $) {
    function j(et) {
      o.removeListener(a, _e), $(et)
    }
    function _e() {
      typeof o.removeListener == 'function' && o.removeListener('error', j),
        s([].slice.call(arguments))
    }
    eventTargetAgnosticAddListener(o, a, _e, { once: !0 }),
      a !== 'error' && addErrorHandlerIfEventEmitter(o, j, { once: !0 })
  })
}
function addErrorHandlerIfEventEmitter(o, a, s) {
  typeof o.on == 'function' && eventTargetAgnosticAddListener(o, 'error', a, s)
}
function eventTargetAgnosticAddListener(o, a, s, $) {
  if (typeof o.on == 'function') $.once ? o.once(a, s) : o.on(a, s)
  else if (typeof o.addEventListener == 'function')
    o.addEventListener(a, function j(_e) {
      $.once && o.removeEventListener(a, j), s(_e)
    })
  else
    throw new TypeError(
      'The "emitter" argument must be of type EventEmitter. Received type ' +
        typeof o
    )
}
var eventsExports = events$1.exports
const EventEmitter$4 = getDefaultExportFromCjs(eventsExports)
var queueMicrotask_1 =
    typeof queueMicrotask == 'function'
      ? queueMicrotask
      : o => Promise.resolve().then(o),
  fixedSize = class {
    constructor(a) {
      if (!(a > 0) || (a - 1) & a)
        throw new Error('Max size for a FixedFIFO should be a power of two')
      ;(this.buffer = new Array(a)),
        (this.mask = a - 1),
        (this.top = 0),
        (this.btm = 0),
        (this.next = null)
    }
    clear() {
      ;(this.top = this.btm = 0), (this.next = null), this.buffer.fill(void 0)
    }
    push(a) {
      return this.buffer[this.top] !== void 0
        ? !1
        : ((this.buffer[this.top] = a),
          (this.top = (this.top + 1) & this.mask),
          !0)
    }
    shift() {
      const a = this.buffer[this.btm]
      if (a !== void 0)
        return (
          (this.buffer[this.btm] = void 0),
          (this.btm = (this.btm + 1) & this.mask),
          a
        )
    }
    peek() {
      return this.buffer[this.btm]
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0
    }
  }
const FixedFIFO = fixedSize
var fastFifo = class {
    constructor(a) {
      ;(this.hwm = a || 16),
        (this.head = new FixedFIFO(this.hwm)),
        (this.tail = this.head),
        (this.length = 0)
    }
    clear() {
      ;(this.head = this.tail), this.head.clear(), (this.length = 0)
    }
    push(a) {
      if ((this.length++, !this.head.push(a))) {
        const s = this.head
        ;(this.head = s.next = new FixedFIFO(2 * this.head.buffer.length)),
          this.head.push(a)
      }
    }
    shift() {
      this.length !== 0 && this.length--
      const a = this.tail.shift()
      if (a === void 0 && this.tail.next) {
        const s = this.tail.next
        return (this.tail.next = null), (this.tail = s), this.tail.shift()
      }
      return a
    }
    peek() {
      const a = this.tail.peek()
      return a === void 0 && this.tail.next ? this.tail.next.peek() : a
    }
    isEmpty() {
      return this.length === 0
    }
  },
  browserDecoder = class {
    constructor(a) {
      this.decoder = new TextDecoder(a === 'utf16le' ? 'utf16-le' : a)
    }
    decode(a) {
      return this.decoder.decode(a, { stream: !0 })
    }
    flush() {
      return this.decoder.decode(new Uint8Array(0))
    }
  }
const PassThroughDecoder = browserDecoder,
  UTF8Decoder = browserDecoder
var textDecoder = class {
  constructor(a = 'utf8') {
    switch (((this.encoding = normalizeEncoding(a)), this.encoding)) {
      case 'utf8':
        this.decoder = new UTF8Decoder()
        break
      case 'utf16le':
      case 'base64':
        throw new Error('Unsupported encoding: ' + this.encoding)
      default:
        this.decoder = new PassThroughDecoder(this.encoding)
    }
  }
  push(a) {
    return typeof a == 'string' ? a : this.decoder.decode(a)
  }
  write(a) {
    return this.push(a)
  }
  end(a) {
    let s = ''
    return a && (s = this.push(a)), (s += this.decoder.flush()), s
  }
}
function normalizeEncoding(o) {
  switch (((o = o.toLowerCase()), o)) {
    case 'utf8':
    case 'utf-8':
      return 'utf8'
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return 'utf16le'
    case 'latin1':
    case 'binary':
      return 'latin1'
    case 'base64':
    case 'ascii':
    case 'hex':
      return o
    default:
      throw new Error('Unknown encoding: ' + o)
  }
}
const { EventEmitter: EventEmitter$2 } = eventsExports,
  STREAM_DESTROYED = new Error('Stream was destroyed'),
  PREMATURE_CLOSE = new Error('Premature close'),
  queueTick = queueMicrotask_1,
  FIFO = fastFifo,
  TextDecoder$1 = textDecoder,
  MAX = (1 << 29) - 1,
  OPENING = 1,
  PREDESTROYING = 2,
  DESTROYING = 4,
  DESTROYED = 8,
  NOT_OPENING = MAX ^ OPENING,
  NOT_PREDESTROYING = MAX ^ PREDESTROYING,
  READ_ACTIVE = 16,
  READ_UPDATING = 32,
  READ_PRIMARY = 64,
  READ_QUEUED = 128,
  READ_RESUMED = 256,
  READ_PIPE_DRAINED = 512,
  READ_ENDING = 1024,
  READ_EMIT_DATA = 2048,
  READ_EMIT_READABLE = 4096,
  READ_EMITTED_READABLE = 8192,
  READ_DONE = 16384,
  READ_NEXT_TICK = 32768,
  READ_NEEDS_PUSH = 65536,
  READ_READ_AHEAD = 131072,
  READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED,
  READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH,
  READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE,
  READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED,
  READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD,
  READ_NOT_ACTIVE = MAX ^ READ_ACTIVE,
  READ_NON_PRIMARY = MAX ^ READ_PRIMARY,
  READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH),
  READ_PUSHED = MAX ^ READ_NEEDS_PUSH,
  READ_PAUSED = MAX ^ READ_RESUMED,
  READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE),
  READ_NOT_ENDING = MAX ^ READ_ENDING,
  READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING,
  READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK,
  READ_NOT_UPDATING = MAX ^ READ_UPDATING,
  READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD,
  READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD,
  WRITE_ACTIVE = 1 << 18,
  WRITE_UPDATING = 2 << 18,
  WRITE_PRIMARY = 4 << 18,
  WRITE_QUEUED = 8 << 18,
  WRITE_UNDRAINED = 16 << 18,
  WRITE_DONE = 32 << 18,
  WRITE_EMIT_DRAIN = 64 << 18,
  WRITE_NEXT_TICK = 128 << 18,
  WRITE_WRITING = 256 << 18,
  WRITE_FINISHING = 512 << 18,
  WRITE_CORKED = 1024 << 18,
  WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING),
  WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY,
  WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING,
  WRITE_DRAINED = MAX ^ WRITE_UNDRAINED,
  WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED,
  WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK,
  WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING,
  WRITE_NOT_CORKED = MAX ^ WRITE_CORKED,
  ACTIVE = READ_ACTIVE | WRITE_ACTIVE,
  NOT_ACTIVE = MAX ^ ACTIVE,
  DONE$1 = READ_DONE | WRITE_DONE,
  DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING,
  OPEN_STATUS = DESTROY_STATUS | OPENING,
  AUTO_DESTROY = DESTROY_STATUS | DONE$1,
  NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY,
  ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK,
  TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE,
  IS_OPENING = OPEN_STATUS | TICKING,
  READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE,
  READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED,
  READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED,
  READ_READABLE_STATUS =
    OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE,
  SHOULD_NOT_READ =
    OPEN_STATUS |
    READ_ACTIVE |
    READ_ENDING |
    READ_DONE |
    READ_NEEDS_PUSH |
    READ_READ_AHEAD,
  READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE,
  READ_UPDATE_SYNC_STATUS =
    READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY,
  WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE,
  WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED,
  WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE,
  WRITE_DRAIN_STATUS =
    WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE,
  WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED,
  WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE,
  WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING,
  WRITE_FINISHING_STATUS =
    OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE,
  WRITE_BACKPRESSURE_STATUS =
    WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE,
  WRITE_UPDATE_SYNC_STATUS =
    WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY,
  asyncIterator = Symbol.asyncIterator || Symbol('asyncIterator')
class WritableState {
  constructor(
    a,
    {
      highWaterMark: s = 16384,
      map: $ = null,
      mapWritable: j,
      byteLength: _e,
      byteLengthWritable: et,
    } = {}
  ) {
    ;(this.stream = a),
      (this.queue = new FIFO()),
      (this.highWaterMark = s),
      (this.buffered = 0),
      (this.error = null),
      (this.pipeline = null),
      (this.drains = null),
      (this.byteLength = et || _e || defaultByteLength),
      (this.map = j || $),
      (this.afterWrite = afterWrite.bind(this)),
      (this.afterUpdateNextTick = updateWriteNT.bind(this))
  }
  get ended() {
    return (this.stream._duplexState & WRITE_DONE) !== 0
  }
  push(a) {
    return (
      this.map !== null && (a = this.map(a)),
      (this.buffered += this.byteLength(a)),
      this.queue.push(a),
      this.buffered < this.highWaterMark
        ? ((this.stream._duplexState |= WRITE_QUEUED), !0)
        : ((this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED), !1)
    )
  }
  shift() {
    const a = this.queue.shift()
    return (
      (this.buffered -= this.byteLength(a)),
      this.buffered === 0 && (this.stream._duplexState &= WRITE_NOT_QUEUED),
      a
    )
  }
  end(a) {
    typeof a == 'function'
      ? this.stream.once('finish', a)
      : a != null && this.push(a),
      (this.stream._duplexState =
        (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY)
  }
  autoBatch(a, s) {
    const $ = [],
      j = this.stream
    for (
      $.push(a);
      (j._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE;

    )
      $.push(j._writableState.shift())
    if (j._duplexState & OPEN_STATUS) return s(null)
    j._writev($, s)
  }
  update() {
    const a = this.stream
    a._duplexState |= WRITE_UPDATING
    do {
      for (; (a._duplexState & WRITE_STATUS) === WRITE_QUEUED; ) {
        const s = this.shift()
        ;(a._duplexState |= WRITE_ACTIVE_AND_WRITING),
          a._write(s, this.afterWrite)
      }
      a._duplexState & WRITE_PRIMARY_AND_ACTIVE || this.updateNonPrimary()
    } while (this.continueUpdate() === !0)
    a._duplexState &= WRITE_NOT_UPDATING
  }
  updateNonPrimary() {
    const a = this.stream
    if ((a._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
      ;(a._duplexState = (a._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING),
        a._final(afterFinal.bind(this))
      return
    }
    if ((a._duplexState & DESTROY_STATUS) === DESTROYING) {
      a._duplexState & ACTIVE_OR_TICKING ||
        ((a._duplexState |= ACTIVE), a._destroy(afterDestroy.bind(this)))
      return
    }
    ;(a._duplexState & IS_OPENING) === OPENING &&
      ((a._duplexState = (a._duplexState | ACTIVE) & NOT_OPENING),
      a._open(afterOpen.bind(this)))
  }
  continueUpdate() {
    return this.stream._duplexState & WRITE_NEXT_TICK
      ? ((this.stream._duplexState &= WRITE_NOT_NEXT_TICK), !0)
      : !1
  }
  updateCallback() {
    ;(this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY
      ? this.update()
      : this.updateNextTick()
  }
  updateNextTick() {
    this.stream._duplexState & WRITE_NEXT_TICK ||
      ((this.stream._duplexState |= WRITE_NEXT_TICK),
      this.stream._duplexState & WRITE_UPDATING ||
        queueTick(this.afterUpdateNextTick))
  }
}
let ReadableState$3 = class {
    constructor(
      a,
      {
        highWaterMark: s = 16384,
        map: $ = null,
        mapReadable: j,
        byteLength: _e,
        byteLengthReadable: et,
      } = {}
    ) {
      ;(this.stream = a),
        (this.queue = new FIFO()),
        (this.highWaterMark = s === 0 ? 1 : s),
        (this.buffered = 0),
        (this.readAhead = s > 0),
        (this.error = null),
        (this.pipeline = null),
        (this.byteLength = et || _e || defaultByteLength),
        (this.map = j || $),
        (this.pipeTo = null),
        (this.afterRead = afterRead.bind(this)),
        (this.afterUpdateNextTick = updateReadNT.bind(this))
    }
    get ended() {
      return (this.stream._duplexState & READ_DONE) !== 0
    }
    pipe(a, s) {
      if (this.pipeTo !== null)
        throw new Error('Can only pipe to one destination')
      if (
        (typeof s != 'function' && (s = null),
        (this.stream._duplexState |= READ_PIPE_DRAINED),
        (this.pipeTo = a),
        (this.pipeline = new Pipeline(this.stream, a, s)),
        s && this.stream.on('error', noop$8),
        isStreamx(a))
      )
        (a._writableState.pipeline = this.pipeline),
          s && a.on('error', noop$8),
          a.on('finish', this.pipeline.finished.bind(this.pipeline))
      else {
        const $ = this.pipeline.done.bind(this.pipeline, a),
          j = this.pipeline.done.bind(this.pipeline, a, null)
        a.on('error', $),
          a.on('close', j),
          a.on('finish', this.pipeline.finished.bind(this.pipeline))
      }
      a.on('drain', afterDrain.bind(this)),
        this.stream.emit('piping', a),
        a.emit('pipe', this.stream)
    }
    push(a) {
      const s = this.stream
      return a === null
        ? ((this.highWaterMark = 0),
          (s._duplexState =
            (s._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED),
          !1)
        : this.map !== null && ((a = this.map(a)), a === null)
        ? this.buffered < this.highWaterMark
        : ((this.buffered += this.byteLength(a)),
          this.queue.push(a),
          (s._duplexState = (s._duplexState | READ_QUEUED) & READ_PUSHED),
          this.buffered < this.highWaterMark)
    }
    shift() {
      const a = this.queue.shift()
      return (
        (this.buffered -= this.byteLength(a)),
        this.buffered === 0 && (this.stream._duplexState &= READ_NOT_QUEUED),
        a
      )
    }
    unshift(a) {
      const s = [this.map !== null ? this.map(a) : a]
      for (; this.buffered > 0; ) s.push(this.shift())
      for (let $ = 0; $ < s.length - 1; $++) {
        const j = s[$]
        ;(this.buffered += this.byteLength(j)), this.queue.push(j)
      }
      this.push(s[s.length - 1])
    }
    read() {
      const a = this.stream
      if ((a._duplexState & READ_STATUS) === READ_QUEUED) {
        const s = this.shift()
        return (
          this.pipeTo !== null &&
            this.pipeTo.write(s) === !1 &&
            (a._duplexState &= READ_PIPE_NOT_DRAINED),
          a._duplexState & READ_EMIT_DATA && a.emit('data', s),
          s
        )
      }
      return (
        this.readAhead === !1 &&
          ((a._duplexState |= READ_READ_AHEAD), this.updateNextTick()),
        null
      )
    }
    drain() {
      const a = this.stream
      for (
        ;
        (a._duplexState & READ_STATUS) === READ_QUEUED &&
        a._duplexState & READ_FLOWING;

      ) {
        const s = this.shift()
        this.pipeTo !== null &&
          this.pipeTo.write(s) === !1 &&
          (a._duplexState &= READ_PIPE_NOT_DRAINED),
          a._duplexState & READ_EMIT_DATA && a.emit('data', s)
      }
    }
    update() {
      const a = this.stream
      a._duplexState |= READ_UPDATING
      do {
        for (
          this.drain();
          this.buffered < this.highWaterMark &&
          (a._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD;

        )
          (a._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH),
            a._read(this.afterRead),
            this.drain()
        ;(a._duplexState & READ_READABLE_STATUS) ===
          READ_EMIT_READABLE_AND_QUEUED &&
          ((a._duplexState |= READ_EMITTED_READABLE), a.emit('readable')),
          a._duplexState & READ_PRIMARY_AND_ACTIVE || this.updateNonPrimary()
      } while (this.continueUpdate() === !0)
      a._duplexState &= READ_NOT_UPDATING
    }
    updateNonPrimary() {
      const a = this.stream
      if (
        ((a._duplexState & READ_ENDING_STATUS) === READ_ENDING &&
          ((a._duplexState = (a._duplexState | READ_DONE) & READ_NOT_ENDING),
          a.emit('end'),
          (a._duplexState & AUTO_DESTROY) === DONE$1 &&
            (a._duplexState |= DESTROYING),
          this.pipeTo !== null && this.pipeTo.end()),
        (a._duplexState & DESTROY_STATUS) === DESTROYING)
      ) {
        a._duplexState & ACTIVE_OR_TICKING ||
          ((a._duplexState |= ACTIVE), a._destroy(afterDestroy.bind(this)))
        return
      }
      ;(a._duplexState & IS_OPENING) === OPENING &&
        ((a._duplexState = (a._duplexState | ACTIVE) & NOT_OPENING),
        a._open(afterOpen.bind(this)))
    }
    continueUpdate() {
      return this.stream._duplexState & READ_NEXT_TICK
        ? ((this.stream._duplexState &= READ_NOT_NEXT_TICK), !0)
        : !1
    }
    updateCallback() {
      ;(this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY
        ? this.update()
        : this.updateNextTick()
    }
    updateNextTick() {
      this.stream._duplexState & READ_NEXT_TICK ||
        ((this.stream._duplexState |= READ_NEXT_TICK),
        this.stream._duplexState & READ_UPDATING ||
          queueTick(this.afterUpdateNextTick))
    }
  },
  TransformState$4 = class {
    constructor(a) {
      ;(this.data = null),
        (this.afterTransform = afterTransform$5.bind(a)),
        (this.afterFinal = null)
    }
  }
class Pipeline {
  constructor(a, s, $) {
    ;(this.from = a),
      (this.to = s),
      (this.afterPipe = $),
      (this.error = null),
      (this.pipeToFinished = !1)
  }
  finished() {
    this.pipeToFinished = !0
  }
  done(a, s) {
    if (
      (s && (this.error = s),
      a === this.to && ((this.to = null), this.from !== null))
    ) {
      ;(!(this.from._duplexState & READ_DONE) || !this.pipeToFinished) &&
        this.from.destroy(
          this.error || new Error('Writable stream closed prematurely')
        )
      return
    }
    if (a === this.from && ((this.from = null), this.to !== null)) {
      a._duplexState & READ_DONE ||
        this.to.destroy(
          this.error || new Error('Readable stream closed before ending')
        )
      return
    }
    this.afterPipe !== null && this.afterPipe(this.error),
      (this.to = this.from = this.afterPipe = null)
  }
}
function afterDrain() {
  ;(this.stream._duplexState |= READ_PIPE_DRAINED), this.updateCallback()
}
function afterFinal(o) {
  const a = this.stream
  o && a.destroy(o),
    a._duplexState & DESTROY_STATUS ||
      ((a._duplexState |= WRITE_DONE), a.emit('finish')),
    (a._duplexState & AUTO_DESTROY) === DONE$1 &&
      (a._duplexState |= DESTROYING),
    (a._duplexState &= WRITE_NOT_ACTIVE),
    a._duplexState & WRITE_UPDATING ? this.updateNextTick() : this.update()
}
function afterDestroy(o) {
  const a = this.stream
  !o && this.error !== STREAM_DESTROYED && (o = this.error),
    o && a.emit('error', o),
    (a._duplexState |= DESTROYED),
    a.emit('close')
  const s = a._readableState,
    $ = a._writableState
  if (
    (s !== null && s.pipeline !== null && s.pipeline.done(a, o), $ !== null)
  ) {
    for (; $.drains !== null && $.drains.length > 0; )
      $.drains.shift().resolve(!1)
    $.pipeline !== null && $.pipeline.done(a, o)
  }
}
function afterWrite(o) {
  const a = this.stream
  o && a.destroy(o),
    (a._duplexState &= WRITE_NOT_ACTIVE),
    this.drains !== null && tickDrains(this.drains),
    (a._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED &&
      ((a._duplexState &= WRITE_DRAINED),
      (a._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN &&
        a.emit('drain')),
    this.updateCallback()
}
function afterRead(o) {
  o && this.stream.destroy(o),
    (this.stream._duplexState &= READ_NOT_ACTIVE),
    this.readAhead === !1 &&
      !(this.stream._duplexState & READ_RESUMED) &&
      (this.stream._duplexState &= READ_NO_READ_AHEAD),
    this.updateCallback()
}
function updateReadNT() {
  this.stream._duplexState & READ_UPDATING ||
    ((this.stream._duplexState &= READ_NOT_NEXT_TICK), this.update())
}
function updateWriteNT() {
  this.stream._duplexState & WRITE_UPDATING ||
    ((this.stream._duplexState &= WRITE_NOT_NEXT_TICK), this.update())
}
function tickDrains(o) {
  for (let a = 0; a < o.length; a++)
    --o[a].writes === 0 && (o.shift().resolve(!0), a--)
}
function afterOpen(o) {
  const a = this.stream
  o && a.destroy(o),
    a._duplexState & DESTROYING ||
      (a._duplexState & READ_PRIMARY_STATUS || (a._duplexState |= READ_PRIMARY),
      a._duplexState & WRITE_PRIMARY_STATUS ||
        (a._duplexState |= WRITE_PRIMARY),
      a.emit('open')),
    (a._duplexState &= NOT_ACTIVE),
    a._writableState !== null && a._writableState.updateCallback(),
    a._readableState !== null && a._readableState.updateCallback()
}
function afterTransform$5(o, a) {
  a != null && this.push(a), this._writableState.afterWrite(o)
}
function newListener(o) {
  this._readableState !== null &&
    (o === 'data' &&
      ((this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD),
      this._readableState.updateNextTick()),
    o === 'readable' &&
      ((this._duplexState |= READ_EMIT_READABLE),
      this._readableState.updateNextTick())),
    this._writableState !== null &&
      o === 'drain' &&
      ((this._duplexState |= WRITE_EMIT_DRAIN),
      this._writableState.updateNextTick())
}
let Stream$8 = class extends EventEmitter$2 {
    constructor(a) {
      super(),
        (this._duplexState = 0),
        (this._readableState = null),
        (this._writableState = null),
        a &&
          (a.open && (this._open = a.open),
          a.destroy && (this._destroy = a.destroy),
          a.predestroy && (this._predestroy = a.predestroy),
          a.signal && a.signal.addEventListener('abort', abort.bind(this))),
        this.on('newListener', newListener)
    }
    _open(a) {
      a(null)
    }
    _destroy(a) {
      a(null)
    }
    _predestroy() {}
    get readable() {
      return this._readableState !== null ? !0 : void 0
    }
    get writable() {
      return this._writableState !== null ? !0 : void 0
    }
    get destroyed() {
      return (this._duplexState & DESTROYED) !== 0
    }
    get destroying() {
      return (this._duplexState & DESTROY_STATUS) !== 0
    }
    destroy(a) {
      this._duplexState & DESTROY_STATUS ||
        (a || (a = STREAM_DESTROYED),
        (this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY),
        this._readableState !== null &&
          ((this._readableState.highWaterMark = 0),
          (this._readableState.error = a)),
        this._writableState !== null &&
          ((this._writableState.highWaterMark = 0),
          (this._writableState.error = a)),
        (this._duplexState |= PREDESTROYING),
        this._predestroy(),
        (this._duplexState &= NOT_PREDESTROYING),
        this._readableState !== null && this._readableState.updateNextTick(),
        this._writableState !== null && this._writableState.updateNextTick())
    }
  },
  Readable$5 = class xo extends Stream$8 {
    constructor(a) {
      super(a),
        (this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD),
        (this._readableState = new ReadableState$3(this, a)),
        a &&
          (this._readableState.readAhead === !1 &&
            (this._duplexState &= READ_NO_READ_AHEAD),
          a.read && (this._read = a.read),
          a.eagerOpen && this._readableState.updateNextTick(),
          a.encoding && this.setEncoding(a.encoding))
    }
    setEncoding(a) {
      const s = new TextDecoder$1(a),
        $ = this._readableState.map || echo
      return (this._readableState.map = j), this
      function j(_e) {
        const et = s.push(_e)
        return et === '' ? null : $(et)
      }
    }
    _read(a) {
      a(null)
    }
    pipe(a, s) {
      return (
        this._readableState.updateNextTick(), this._readableState.pipe(a, s), a
      )
    }
    read() {
      return this._readableState.updateNextTick(), this._readableState.read()
    }
    push(a) {
      return this._readableState.updateNextTick(), this._readableState.push(a)
    }
    unshift(a) {
      return (
        this._readableState.updateNextTick(), this._readableState.unshift(a)
      )
    }
    resume() {
      return (
        (this._duplexState |= READ_RESUMED_READ_AHEAD),
        this._readableState.updateNextTick(),
        this
      )
    }
    pause() {
      return (
        (this._duplexState &=
          this._readableState.readAhead === !1
            ? READ_PAUSED_NO_READ_AHEAD
            : READ_PAUSED),
        this
      )
    }
    static _fromAsyncIterator(a, s) {
      let $
      const j = new xo({
        ...s,
        read(et) {
          a.next()
            .then(_e)
            .then(et.bind(null, null))
            .catch(et)
        },
        predestroy() {
          $ = a.return()
        },
        destroy(et) {
          if (!$) return et(null)
          $.then(et.bind(null, null)).catch(et)
        },
      })
      return j
      function _e(et) {
        et.done ? j.push(null) : j.push(et.value)
      }
    }
    static from(a, s) {
      if (isReadStreamx(a)) return a
      if (a[asyncIterator])
        return this._fromAsyncIterator(a[asyncIterator](), s)
      Array.isArray(a) || (a = a === void 0 ? [] : [a])
      let $ = 0
      return new xo({
        ...s,
        read(j) {
          this.push($ === a.length ? null : a[$++]), j(null)
        },
      })
    }
    static isBackpressured(a) {
      return (
        (a._duplexState & READ_BACKPRESSURE_STATUS) !== 0 ||
        a._readableState.buffered >= a._readableState.highWaterMark
      )
    }
    static isPaused(a) {
      return (a._duplexState & READ_RESUMED) === 0
    }
    [asyncIterator]() {
      const a = this
      let s = null,
        $ = null,
        j = null
      return (
        this.on('error', nt => {
          s = nt
        }),
        this.on('readable', _e),
        this.on('close', et),
        {
          [asyncIterator]() {
            return this
          },
          next() {
            return new Promise(function(nt, it) {
              ;($ = nt), (j = it)
              const ot = a.read()
              ot !== null ? tt(ot) : a._duplexState & DESTROYED && tt(null)
            })
          },
          return() {
            return rt(null)
          },
          throw(nt) {
            return rt(nt)
          },
        }
      )
      function _e() {
        $ !== null && tt(a.read())
      }
      function et() {
        $ !== null && tt(null)
      }
      function tt(nt) {
        j !== null &&
          (s
            ? j(s)
            : nt === null && !(a._duplexState & READ_DONE)
            ? j(STREAM_DESTROYED)
            : $({ value: nt, done: nt === null }),
          (j = $ = null))
      }
      function rt(nt) {
        return (
          a.destroy(nt),
          new Promise((it, ot) => {
            if (a._duplexState & DESTROYED)
              return it({ value: void 0, done: !0 })
            a.once('close', function() {
              nt ? ot(nt) : it({ value: void 0, done: !0 })
            })
          })
        )
      }
    }
  },
  Writable$2 = class extends Stream$8 {
    constructor(a) {
      super(a),
        (this._duplexState |= OPENING | READ_DONE),
        (this._writableState = new WritableState(this, a)),
        a &&
          (a.writev && (this._writev = a.writev),
          a.write && (this._write = a.write),
          a.final && (this._final = a.final),
          a.eagerOpen && this._writableState.updateNextTick())
    }
    cork() {
      this._duplexState |= WRITE_CORKED
    }
    uncork() {
      ;(this._duplexState &= WRITE_NOT_CORKED),
        this._writableState.updateNextTick()
    }
    _writev(a, s) {
      s(null)
    }
    _write(a, s) {
      this._writableState.autoBatch(a, s)
    }
    _final(a) {
      a(null)
    }
    static isBackpressured(a) {
      return (a._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0
    }
    static drained(a) {
      if (a.destroyed) return Promise.resolve(!1)
      const s = a._writableState,
        j =
          (isWritev(a) ? Math.min(1, s.queue.length) : s.queue.length) +
          (a._duplexState & WRITE_WRITING ? 1 : 0)
      return j === 0
        ? Promise.resolve(!0)
        : (s.drains === null && (s.drains = []),
          new Promise(_e => {
            s.drains.push({ writes: j, resolve: _e })
          }))
    }
    write(a) {
      return this._writableState.updateNextTick(), this._writableState.push(a)
    }
    end(a) {
      return (
        this._writableState.updateNextTick(), this._writableState.end(a), this
      )
    }
  },
  Duplex$5 = class extends Readable$5 {
    constructor(a) {
      super(a),
        (this._duplexState = OPENING | (this._duplexState & READ_READ_AHEAD)),
        (this._writableState = new WritableState(this, a)),
        a &&
          (a.writev && (this._writev = a.writev),
          a.write && (this._write = a.write),
          a.final && (this._final = a.final))
    }
    cork() {
      this._duplexState |= WRITE_CORKED
    }
    uncork() {
      ;(this._duplexState &= WRITE_NOT_CORKED),
        this._writableState.updateNextTick()
    }
    _writev(a, s) {
      s(null)
    }
    _write(a, s) {
      this._writableState.autoBatch(a, s)
    }
    _final(a) {
      a(null)
    }
    write(a) {
      return this._writableState.updateNextTick(), this._writableState.push(a)
    }
    end(a) {
      return (
        this._writableState.updateNextTick(), this._writableState.end(a), this
      )
    }
  },
  Transform$a = class extends Duplex$5 {
    constructor(a) {
      super(a),
        (this._transformState = new TransformState$4(this)),
        a &&
          (a.transform && (this._transform = a.transform),
          a.flush && (this._flush = a.flush))
    }
    _write(a, s) {
      this._readableState.buffered >= this._readableState.highWaterMark
        ? (this._transformState.data = a)
        : this._transform(a, this._transformState.afterTransform)
    }
    _read(a) {
      if (this._transformState.data !== null) {
        const s = this._transformState.data
        ;(this._transformState.data = null),
          a(null),
          this._transform(s, this._transformState.afterTransform)
      } else a(null)
    }
    destroy(a) {
      super.destroy(a),
        this._transformState.data !== null &&
          ((this._transformState.data = null),
          this._transformState.afterTransform())
    }
    _transform(a, s) {
      s(null, a)
    }
    _flush(a) {
      a(null)
    }
    _final(a) {
      ;(this._transformState.afterFinal = a),
        this._flush(transformAfterFlush.bind(this))
    }
  },
  PassThrough$5 = class extends Transform$a {}
function transformAfterFlush(o, a) {
  const s = this._transformState.afterFinal
  if (o) return s(o)
  a != null && this.push(a), this.push(null), s(null)
}
function pipelinePromise(...o) {
  return new Promise((a, s) =>
    pipeline$1(...o, $ => {
      if ($) return s($)
      a()
    })
  )
}
function pipeline$1(o, ...a) {
  const s = Array.isArray(o) ? [...o, ...a] : [o, ...a],
    $ = s.length && typeof s[s.length - 1] == 'function' ? s.pop() : null
  if (s.length < 2) throw new Error('Pipeline requires at least 2 streams')
  let j = s[0],
    _e = null,
    et = null
  for (let nt = 1; nt < s.length; nt++)
    (_e = s[nt]),
      isStreamx(j) ? j.pipe(_e, rt) : (tt(j, !0, nt > 1, rt), j.pipe(_e)),
      (j = _e)
  if ($) {
    let nt = !1
    const it =
      isStreamx(_e) || !!(_e._writableState && _e._writableState.autoDestroy)
    _e.on('error', ot => {
      et === null && (et = ot)
    }),
      _e.on('finish', () => {
        ;(nt = !0), it || $(et)
      }),
      it && _e.on('close', () => $(et || (nt ? null : PREMATURE_CLOSE)))
  }
  return _e
  function tt(nt, it, ot, at) {
    nt.on('error', at), nt.on('close', st)
    function st() {
      if (
        (nt._readableState && !nt._readableState.ended) ||
        (ot && nt._writableState && !nt._writableState.ended)
      )
        return at(PREMATURE_CLOSE)
    }
  }
  function rt(nt) {
    if (!(!nt || et)) {
      et = nt
      for (const it of s) it.destroy(nt)
    }
  }
}
function echo(o) {
  return o
}
function isStream(o) {
  return !!o._readableState || !!o._writableState
}
function isStreamx(o) {
  return typeof o._duplexState == 'number' && isStream(o)
}
function getStreamError(o, a = {}) {
  const s =
    (o._readableState && o._readableState.error) ||
    (o._writableState && o._writableState.error)
  return !a.all && s === STREAM_DESTROYED ? null : s
}
function isReadStreamx(o) {
  return isStreamx(o) && o.readable
}
function isTypedArray$1(o) {
  return typeof o == 'object' && o !== null && typeof o.byteLength == 'number'
}
function defaultByteLength(o) {
  return isTypedArray$1(o) ? o.byteLength : 1024
}
function noop$8() {}
function abort() {
  this.destroy(new Error('Stream aborted.'))
}
function isWritev(o) {
  return (
    o._writev !== Writable$2.prototype._writev &&
    o._writev !== Duplex$5.prototype._writev
  )
}
var streamx = {
  pipeline: pipeline$1,
  pipelinePromise,
  isStream,
  isStreamx,
  getStreamError,
  Stream: Stream$8,
  Writable: Writable$2,
  Readable: Readable$5,
  Duplex: Duplex$5,
  Transform: Transform$a,
  PassThrough: PassThrough$5,
}
function assign(o, a) {
  for (const s in a)
    Object.defineProperty(o, s, {
      value: a[s],
      enumerable: !0,
      configurable: !0,
    })
  return o
}
function createError$2(o, a, s) {
  if (!o || typeof o == 'string')
    throw new TypeError('Please pass an Error to err-code')
  s || (s = {}), typeof a == 'object' && ((s = a), (a = '')), a && (s.code = a)
  try {
    return assign(o, s)
  } catch {
    ;(s.message = o.message), (s.stack = o.stack)
    const j = function() {}
    return (
      (j.prototype = Object.create(Object.getPrototypeOf(o))),
      assign(new j(), s)
    )
  }
}
var errCode = createError$2
const errCode$1 = getDefaultExportFromCjs(errCode)
/* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)
 *
 * @author   Jimmy Wrting <jimmy@warting.se> (https://jimmy.warting.se/opensource)
 * @license  MIT
 */ const alphabet$1 = '0123456789abcdef',
  encodeLookup = []
for (let o = 0; o < 256; o++)
  encodeLookup[o] = alphabet$1[(o >> 4) & 15] + alphabet$1[o & 15]
const arr2hex = o => {
  const a = o.length
  let s = '',
    $ = 0
  for (; $ < a; ) s += encodeLookup[o[$++]]
  return s
}
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
  lookup = typeof Uint8Array > 'u' ? [] : new Uint8Array(256)
for (var i = 0; i < chars.length; i++) lookup[chars.charCodeAt(i)] = i
new TextDecoder()
const encoder = new TextEncoder(),
  text2arr = o => encoder.encode(o),
  scope = typeof window < 'u' ? window : self,
  crypto$1 = scope.crypto || scope.msCrypto || {}
crypto$1.subtle || crypto$1.webkitSubtle
const randomBytes = o => {
  const a = new Uint8Array(o)
  return crypto$1.getRandomValues(a)
}
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ const Debug = debug(
    'simple-peer'
  ),
  MAX_BUFFERED_AMOUNT = 64 * 1024,
  ICECOMPLETE_TIMEOUT = 5 * 1e3,
  CHANNEL_CLOSING_TIMEOUT = 5 * 1e3
function filterTrickle(o) {
  return o.replace(/a=ice-options:trickle\s\n/g, '')
}
function warn$2(o) {
  console.warn(o)
}
let Peer$1 = class _o extends streamx.Duplex {
  constructor(s) {
    s = Object.assign({ allowHalfOpen: !1 }, s)
    super(s)
    Wr(this, '_pc')
    if (
      ((this.__objectMode = !!s.objectMode),
      (this._id = arr2hex(randomBytes(4)).slice(0, 7)),
      this._debug('new peer %o', s),
      (this.channelName = s.initiator
        ? s.channelName || arr2hex(randomBytes(20))
        : null),
      (this.initiator = s.initiator || !1),
      (this.channelConfig = s.channelConfig || _o.channelConfig),
      (this.channelNegotiated = this.channelConfig.negotiated),
      (this.config = Object.assign({}, _o.config, s.config)),
      (this.offerOptions = s.offerOptions || {}),
      (this.answerOptions = s.answerOptions || {}),
      (this.sdpTransform = s.sdpTransform || ($ => $)),
      (this.trickle = s.trickle !== void 0 ? s.trickle : !0),
      (this.allowHalfTrickle =
        s.allowHalfTrickle !== void 0 ? s.allowHalfTrickle : !1),
      (this.iceCompleteTimeout = s.iceCompleteTimeout || ICECOMPLETE_TIMEOUT),
      (this._destroying = !1),
      (this._connected = !1),
      (this.remoteAddress = void 0),
      (this.remoteFamily = void 0),
      (this.remotePort = void 0),
      (this.localAddress = void 0),
      (this.localFamily = void 0),
      (this.localPort = void 0),
      !RTCPeerConnection)
    )
      throw errCode$1(
        typeof window > 'u'
          ? new Error(
              'No WebRTC support: Specify `opts.wrtc` option in this environment'
            )
          : new Error('No WebRTC support: Not a supported browser'),
        'ERR_WEBRTC_SUPPORT'
      )
    ;(this._pcReady = !1),
      (this._channelReady = !1),
      (this._iceComplete = !1),
      (this._iceCompleteTimer = null),
      (this._channel = null),
      (this._pendingCandidates = []),
      (this._isNegotiating = !1),
      (this._firstNegotiation = !0),
      (this._batchedNegotiation = !1),
      (this._queuedNegotiation = !1),
      (this._sendersAwaitingStable = []),
      (this._closingInterval = null),
      (this._remoteTracks = []),
      (this._remoteStreams = []),
      (this._chunk = null),
      (this._cb = null),
      (this._interval = null)
    try {
      this._pc = new RTCPeerConnection(this.config)
    } catch ($) {
      this.__destroy(errCode$1($, 'ERR_PC_CONSTRUCTOR'))
      return
    }
    ;(this._isReactNativeWebrtc =
      typeof this._pc._peerConnectionId == 'number'),
      (this._pc.oniceconnectionstatechange = () => {
        this._onIceStateChange()
      }),
      (this._pc.onicegatheringstatechange = () => {
        this._onIceStateChange()
      }),
      (this._pc.onconnectionstatechange = () => {
        this._onConnectionStateChange()
      }),
      (this._pc.onsignalingstatechange = () => {
        this._onSignalingStateChange()
      }),
      (this._pc.onicecandidate = $ => {
        this._onIceCandidate($)
      }),
      typeof this._pc.peerIdentity == 'object' &&
        this._pc.peerIdentity.catch($ => {
          this.__destroy(errCode$1($, 'ERR_PC_PEER_IDENTITY'))
        }),
      this.initiator || this.channelNegotiated
        ? this._setupData({
            channel: this._pc.createDataChannel(
              this.channelName,
              this.channelConfig
            ),
          })
        : (this._pc.ondatachannel = $ => {
            this._setupData($)
          }),
      this._debug('initial negotiation'),
      this._needsNegotiation(),
      (this._onFinishBound = () => {
        this._onFinish()
      }),
      this.once('finish', this._onFinishBound)
  }
  get bufferSize() {
    return (this._channel && this._channel.bufferedAmount) || 0
  }
  get connected() {
    return this._connected && this._channel.readyState === 'open'
  }
  address() {
    return {
      port: this.localPort,
      family: this.localFamily,
      address: this.localAddress,
    }
  }
  signal(s) {
    if (!this._destroying) {
      if (this.destroyed)
        throw errCode$1(
          new Error('cannot signal after peer is destroyed'),
          'ERR_DESTROYED'
        )
      if (typeof s == 'string')
        try {
          s = JSON.parse(s)
        } catch {
          s = {}
        }
      this._debug('signal()'),
        s.renegotiate &&
          this.initiator &&
          (this._debug('got request to renegotiate'), this._needsNegotiation()),
        s.transceiverRequest &&
          this.initiator &&
          (this._debug('got request for transceiver'),
          this.addTransceiver(
            s.transceiverRequest.kind,
            s.transceiverRequest.init
          )),
        s.candidate &&
          (this._pc.remoteDescription && this._pc.remoteDescription.type
            ? this._addIceCandidate(s.candidate)
            : this._pendingCandidates.push(s.candidate)),
        s.sdp &&
          this._pc
            .setRemoteDescription(new RTCSessionDescription(s))
            .then(() => {
              this.destroyed ||
                (this._pendingCandidates.forEach($ => {
                  this._addIceCandidate($)
                }),
                (this._pendingCandidates = []),
                this._pc.remoteDescription.type === 'offer' &&
                  this._createAnswer())
            })
            .catch($ => {
              this.__destroy(errCode$1($, 'ERR_SET_REMOTE_DESCRIPTION'))
            }),
        !s.sdp &&
          !s.candidate &&
          !s.renegotiate &&
          !s.transceiverRequest &&
          this.__destroy(
            errCode$1(
              new Error('signal() called with invalid signal data'),
              'ERR_SIGNALING'
            )
          )
    }
  }
  _addIceCandidate(s) {
    const $ = new RTCIceCandidate(s)
    this._pc.addIceCandidate($).catch(j => {
      !$.address || $.address.endsWith('.local')
        ? warn$2('Ignoring unsupported ICE candidate.')
        : this.__destroy(errCode$1(j, 'ERR_ADD_ICE_CANDIDATE'))
    })
  }
  send(s) {
    if (!this._destroying) {
      if (this.destroyed)
        throw errCode$1(
          new Error('cannot send after peer is destroyed'),
          'ERR_DESTROYED'
        )
      this._channel.send(s)
    }
  }
  _needsNegotiation() {
    this._debug('_needsNegotiation'),
      !this._batchedNegotiation &&
        ((this._batchedNegotiation = !0),
        queueMicrotask(() => {
          ;(this._batchedNegotiation = !1),
            this.initiator || !this._firstNegotiation
              ? (this._debug('starting batched negotiation'), this.negotiate())
              : this._debug(
                  'non-initiator initial negotiation request discarded'
                ),
            (this._firstNegotiation = !1)
        }))
  }
  negotiate() {
    if (!this._destroying) {
      if (this.destroyed)
        throw errCode$1(
          new Error('cannot negotiate after peer is destroyed'),
          'ERR_DESTROYED'
        )
      this.initiator
        ? this._isNegotiating
          ? ((this._queuedNegotiation = !0),
            this._debug('already negotiating, queueing'))
          : (this._debug('start negotiation'),
            setTimeout(() => {
              this._createOffer()
            }, 0))
        : this._isNegotiating
        ? ((this._queuedNegotiation = !0),
          this._debug('already negotiating, queueing'))
        : (this._debug('requesting negotiation from initiator'),
          this.emit('signal', { type: 'renegotiate', renegotiate: !0 })),
        (this._isNegotiating = !0)
    }
  }
  _final(s) {
    this._readableState.ended || this.push(null), s(null)
  }
  __destroy(s) {
    this.end(), this._destroy(() => {}, s)
  }
  _destroy(s, $) {
    this.destroyed ||
      this._destroying ||
      ((this._destroying = !0),
      this._debug('destroying (error: %s)', $ && ($.message || $)),
      setTimeout(() => {
        if (
          ((this._connected = !1),
          (this._pcReady = !1),
          (this._channelReady = !1),
          (this._remoteTracks = null),
          (this._remoteStreams = null),
          (this._senderMap = null),
          clearInterval(this._closingInterval),
          (this._closingInterval = null),
          clearInterval(this._interval),
          (this._interval = null),
          (this._chunk = null),
          (this._cb = null),
          this._onFinishBound &&
            this.removeListener('finish', this._onFinishBound),
          (this._onFinishBound = null),
          this._channel)
        ) {
          try {
            this._channel.close()
          } catch {}
          ;(this._channel.onmessage = null),
            (this._channel.onopen = null),
            (this._channel.onclose = null),
            (this._channel.onerror = null)
        }
        if (this._pc) {
          try {
            this._pc.close()
          } catch {}
          ;(this._pc.oniceconnectionstatechange = null),
            (this._pc.onicegatheringstatechange = null),
            (this._pc.onsignalingstatechange = null),
            (this._pc.onicecandidate = null),
            (this._pc.ontrack = null),
            (this._pc.ondatachannel = null)
        }
        ;(this._pc = null),
          (this._channel = null),
          $ && this.emit('error', $),
          s()
      }, 0))
  }
  _setupData(s) {
    if (!s.channel)
      return this.__destroy(
        errCode$1(
          new Error('Data channel event is missing `channel` property'),
          'ERR_DATA_CHANNEL'
        )
      )
    ;(this._channel = s.channel),
      (this._channel.binaryType = 'arraybuffer'),
      typeof this._channel.bufferedAmountLowThreshold == 'number' &&
        (this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT),
      (this.channelName = this._channel.label),
      (this._channel.onmessage = j => {
        this._onChannelMessage(j)
      }),
      (this._channel.onbufferedamountlow = () => {
        this._onChannelBufferedAmountLow()
      }),
      (this._channel.onopen = () => {
        this._onChannelOpen()
      }),
      (this._channel.onclose = () => {
        this._onChannelClose()
      }),
      (this._channel.onerror = j => {
        const _e =
          j.error instanceof Error
            ? j.error
            : new Error(
                `Datachannel error: ${j.message} ${j.filename}:${j.lineno}:${j.colno}`
              )
        this.__destroy(errCode$1(_e, 'ERR_DATA_CHANNEL'))
      })
    let $ = !1
    this._closingInterval = setInterval(() => {
      this._channel && this._channel.readyState === 'closing'
        ? ($ && this._onChannelClose(), ($ = !0))
        : ($ = !1)
    }, CHANNEL_CLOSING_TIMEOUT)
  }
  _write(s, $) {
    if (this.destroyed)
      return $(
        errCode$1(
          new Error('cannot write after peer is destroyed'),
          'ERR_DATA_CHANNEL'
        )
      )
    if (this._connected) {
      try {
        this.send(s)
      } catch (j) {
        return this.__destroy(errCode$1(j, 'ERR_DATA_CHANNEL'))
      }
      this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT
        ? (this._debug(
            'start backpressure: bufferedAmount %d',
            this._channel.bufferedAmount
          ),
          (this._cb = $))
        : $(null)
    } else
      this._debug('write before connect'), (this._chunk = s), (this._cb = $)
  }
  _onFinish() {
    if (this.destroyed) return
    const s = () => {
      setTimeout(() => this.__destroy(), 1e3)
    }
    this._connected ? s() : this.once('connect', s)
  }
  _startIceCompleteTimeout() {
    this.destroyed ||
      this._iceCompleteTimer ||
      (this._debug('started iceComplete timeout'),
      (this._iceCompleteTimer = setTimeout(() => {
        this._iceComplete ||
          ((this._iceComplete = !0),
          this._debug('iceComplete timeout completed'),
          this.emit('iceTimeout'),
          this.emit('_iceComplete'))
      }, this.iceCompleteTimeout)))
  }
  _createOffer() {
    this.destroyed ||
      this._pc
        .createOffer(this.offerOptions)
        .then(s => {
          if (this.destroyed) return
          !this.trickle &&
            !this.allowHalfTrickle &&
            (s.sdp = filterTrickle(s.sdp)),
            (s.sdp = this.sdpTransform(s.sdp))
          const $ = () => {
              if (this.destroyed) return
              const et = this._pc.localDescription || s
              this._debug('signal'),
                this.emit('signal', { type: et.type, sdp: et.sdp })
            },
            j = () => {
              this._debug('createOffer success'),
                !this.destroyed &&
                  (this.trickle || this._iceComplete
                    ? $()
                    : this.once('_iceComplete', $))
            },
            _e = et => {
              this.__destroy(errCode$1(et, 'ERR_SET_LOCAL_DESCRIPTION'))
            }
          this._pc
            .setLocalDescription(s)
            .then(j)
            .catch(_e)
        })
        .catch(s => {
          this.__destroy(errCode$1(s, 'ERR_CREATE_OFFER'))
        })
  }
  _createAnswer() {
    this.destroyed ||
      this._pc
        .createAnswer(this.answerOptions)
        .then(s => {
          if (this.destroyed) return
          !this.trickle &&
            !this.allowHalfTrickle &&
            (s.sdp = filterTrickle(s.sdp)),
            (s.sdp = this.sdpTransform(s.sdp))
          const $ = () => {
              var tt
              if (this.destroyed) return
              const et = this._pc.localDescription || s
              this._debug('signal'),
                this.emit('signal', { type: et.type, sdp: et.sdp }),
                this.initiator ||
                  (tt = this._requestMissingTransceivers) == null ||
                  tt.call(this)
            },
            j = () => {
              this.destroyed ||
                (this.trickle || this._iceComplete
                  ? $()
                  : this.once('_iceComplete', $))
            },
            _e = et => {
              this.__destroy(errCode$1(et, 'ERR_SET_LOCAL_DESCRIPTION'))
            }
          this._pc
            .setLocalDescription(s)
            .then(j)
            .catch(_e)
        })
        .catch(s => {
          this.__destroy(errCode$1(s, 'ERR_CREATE_ANSWER'))
        })
  }
  _onConnectionStateChange() {
    this.destroyed ||
      this._destroying ||
      (this._pc.connectionState === 'failed' &&
        this.__destroy(
          errCode$1(new Error('Connection failed.'), 'ERR_CONNECTION_FAILURE')
        ))
  }
  _onIceStateChange() {
    if (this.destroyed) return
    const s = this._pc.iceConnectionState,
      $ = this._pc.iceGatheringState
    this._debug('iceStateChange (connection: %s) (gathering: %s)', s, $),
      this.emit('iceStateChange', s, $),
      (s === 'connected' || s === 'completed') &&
        ((this._pcReady = !0), this._maybeReady()),
      s === 'failed' &&
        this.__destroy(
          errCode$1(
            new Error('Ice connection failed.'),
            'ERR_ICE_CONNECTION_FAILURE'
          )
        ),
      s === 'closed' &&
        this.__destroy(
          errCode$1(
            new Error('Ice connection closed.'),
            'ERR_ICE_CONNECTION_CLOSED'
          )
        )
  }
  getStats(s) {
    const $ = j => (
      Object.prototype.toString.call(j.values) === '[object Array]' &&
        j.values.forEach(_e => {
          Object.assign(j, _e)
        }),
      j
    )
    this._pc.getStats.length === 0 || this._isReactNativeWebrtc
      ? this._pc.getStats().then(
          j => {
            const _e = []
            j.forEach(et => {
              _e.push($(et))
            }),
              s(null, _e)
          },
          j => s(j)
        )
      : this._pc.getStats.length > 0
      ? this._pc.getStats(
          j => {
            if (this.destroyed) return
            const _e = []
            j.result().forEach(et => {
              const tt = {}
              et.names().forEach(rt => {
                tt[rt] = et.stat(rt)
              }),
                (tt.id = et.id),
                (tt.type = et.type),
                (tt.timestamp = et.timestamp),
                _e.push($(tt))
            }),
              s(null, _e)
          },
          j => s(j)
        )
      : s(null, [])
  }
  _maybeReady() {
    if (
      (this._debug(
        'maybeReady pc %s channel %s',
        this._pcReady,
        this._channelReady
      ),
      this._connected ||
        this._connecting ||
        !this._pcReady ||
        !this._channelReady)
    )
      return
    this._connecting = !0
    const s = () => {
      this.destroyed ||
        this._destroying ||
        this.getStats(($, j) => {
          if (this.destroyed || this._destroying) return
          $ && (j = [])
          const _e = {},
            et = {},
            tt = {}
          let rt = !1
          j.forEach(it => {
            ;(it.type === 'remotecandidate' ||
              it.type === 'remote-candidate') &&
              (_e[it.id] = it),
              (it.type === 'localcandidate' || it.type === 'local-candidate') &&
                (et[it.id] = it),
              (it.type === 'candidatepair' || it.type === 'candidate-pair') &&
                (tt[it.id] = it)
          })
          const nt = it => {
            rt = !0
            let ot = et[it.localCandidateId]
            ot && (ot.ip || ot.address)
              ? ((this.localAddress = ot.ip || ot.address),
                (this.localPort = Number(ot.port)))
              : ot && ot.ipAddress
              ? ((this.localAddress = ot.ipAddress),
                (this.localPort = Number(ot.portNumber)))
              : typeof it.googLocalAddress == 'string' &&
                ((ot = it.googLocalAddress.split(':')),
                (this.localAddress = ot[0]),
                (this.localPort = Number(ot[1]))),
              this.localAddress &&
                (this.localFamily = this.localAddress.includes(':')
                  ? 'IPv6'
                  : 'IPv4')
            let at = _e[it.remoteCandidateId]
            at && (at.ip || at.address)
              ? ((this.remoteAddress = at.ip || at.address),
                (this.remotePort = Number(at.port)))
              : at && at.ipAddress
              ? ((this.remoteAddress = at.ipAddress),
                (this.remotePort = Number(at.portNumber)))
              : typeof it.googRemoteAddress == 'string' &&
                ((at = it.googRemoteAddress.split(':')),
                (this.remoteAddress = at[0]),
                (this.remotePort = Number(at[1]))),
              this.remoteAddress &&
                (this.remoteFamily = this.remoteAddress.includes(':')
                  ? 'IPv6'
                  : 'IPv4'),
              this._debug(
                'connect local: %s:%s remote: %s:%s',
                this.localAddress,
                this.localPort,
                this.remoteAddress,
                this.remotePort
              )
          }
          if (
            (j.forEach(it => {
              it.type === 'transport' &&
                it.selectedCandidatePairId &&
                nt(tt[it.selectedCandidatePairId]),
                ((it.type === 'googCandidatePair' &&
                  it.googActiveConnection === 'true') ||
                  ((it.type === 'candidatepair' ||
                    it.type === 'candidate-pair') &&
                    it.selected)) &&
                  nt(it)
            }),
            !rt && (!Object.keys(tt).length || Object.keys(et).length))
          ) {
            setTimeout(s, 100)
            return
          } else (this._connecting = !1), (this._connected = !0)
          if (this._chunk) {
            try {
              this.send(this._chunk)
            } catch (ot) {
              return this.__destroy(errCode$1(ot, 'ERR_DATA_CHANNEL'))
            }
            ;(this._chunk = null),
              this._debug('sent chunk from "write before connect"')
            const it = this._cb
            ;(this._cb = null), it(null)
          }
          typeof this._channel.bufferedAmountLowThreshold != 'number' &&
            ((this._interval = setInterval(() => this._onInterval(), 150)),
            this._interval.unref && this._interval.unref()),
            this._debug('connect'),
            this.emit('connect')
        })
    }
    s()
  }
  _onInterval() {
    !this._cb ||
      !this._channel ||
      this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT ||
      this._onChannelBufferedAmountLow()
  }
  _onSignalingStateChange() {
    this.destroyed ||
      (this._pc.signalingState === 'stable' &&
        ((this._isNegotiating = !1),
        this._debug('flushing sender queue', this._sendersAwaitingStable),
        this._sendersAwaitingStable.forEach(s => {
          this._pc.removeTrack(s), (this._queuedNegotiation = !0)
        }),
        (this._sendersAwaitingStable = []),
        this._queuedNegotiation
          ? (this._debug('flushing negotiation queue'),
            (this._queuedNegotiation = !1),
            this._needsNegotiation())
          : (this._debug('negotiated'), this.emit('negotiated'))),
      this._debug('signalingStateChange %s', this._pc.signalingState),
      this.emit('signalingStateChange', this._pc.signalingState))
  }
  _onIceCandidate(s) {
    this.destroyed ||
      (s.candidate && this.trickle
        ? this.emit('signal', {
            type: 'candidate',
            candidate: {
              candidate: s.candidate.candidate,
              sdpMLineIndex: s.candidate.sdpMLineIndex,
              sdpMid: s.candidate.sdpMid,
            },
          })
        : !s.candidate &&
          !this._iceComplete &&
          ((this._iceComplete = !0), this.emit('_iceComplete')),
      s.candidate && this._startIceCompleteTimeout())
  }
  _onChannelMessage(s) {
    if (this.destroyed) return
    let $ = s.data
    $ instanceof ArrayBuffer
      ? ($ = new Uint8Array($))
      : this.__objectMode === !1 && ($ = text2arr($)),
      this.push($)
  }
  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb) return
    this._debug(
      'ending backpressure: bufferedAmount %d',
      this._channel.bufferedAmount
    )
    const s = this._cb
    ;(this._cb = null), s(null)
  }
  _onChannelOpen() {
    this._connected ||
      this.destroyed ||
      (this._debug('on channel open'),
      (this._channelReady = !0),
      this._maybeReady())
  }
  _onChannelClose() {
    this.destroyed || (this._debug('on channel close'), this.__destroy())
  }
  _debug() {
    const s = [].slice.call(arguments)
    ;(s[0] = '[' + this._id + '] ' + s[0]), Debug.apply(null, s)
  }
}
Peer$1.WEBRTC_SUPPORT = !!RTCPeerConnection
Peer$1.config = {
  iceServers: [
    {
      urls: [
        'stun:stun.l.google.com:19302',
        'stun:global.stun.twilio.com:3478',
      ],
    },
  ],
  sdpSemantics: 'unified-plan',
}
Peer$1.channelConfig = {}
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ class Peer extends Peer$1 {
  constructor(a = {}) {
    super(a),
      this._pc &&
        ((this.streams = a.streams || (a.stream ? [a.stream] : [])),
        (this._senderMap = new Map()),
        this.streams &&
          this.streams.forEach(s => {
            this.addStream(s)
          }),
        (this._pc.ontrack = s => {
          this._onTrack(s)
        }))
  }
  addTransceiver(a, s) {
    if (!this._destroying) {
      if (this.destroyed)
        throw errCode$1(
          new Error('cannot addTransceiver after peer is destroyed'),
          'ERR_DESTROYED'
        )
      if ((this._debug('addTransceiver()'), this.initiator))
        try {
          this._pc.addTransceiver(a, s), this._needsNegotiation()
        } catch ($) {
          this.__destroy(errCode$1($, 'ERR_ADD_TRANSCEIVER'))
        }
      else
        this.emit('signal', {
          type: 'transceiverRequest',
          transceiverRequest: { kind: a, init: s },
        })
    }
  }
  addStream(a) {
    if (!this._destroying) {
      if (this.destroyed)
        throw errCode$1(
          new Error('cannot addStream after peer is destroyed'),
          'ERR_DESTROYED'
        )
      this._debug('addStream()'),
        a.getTracks().forEach(s => {
          this.addTrack(s, a)
        })
    }
  }
  addTrack(a, s) {
    if (this._destroying) return
    if (this.destroyed)
      throw errCode$1(
        new Error('cannot addTrack after peer is destroyed'),
        'ERR_DESTROYED'
      )
    this._debug('addTrack()')
    const $ = this._senderMap.get(a) || new Map()
    let j = $.get(s)
    if (!j)
      (j = this._pc.addTrack(a, s)),
        $.set(s, j),
        this._senderMap.set(a, $),
        this._needsNegotiation()
    else
      throw j.removed
        ? errCode$1(
            new Error(
              'Track has been removed. You should enable/disable tracks that you want to re-add.'
            ),
            'ERR_SENDER_REMOVED'
          )
        : errCode$1(
            new Error('Track has already been added to that stream.'),
            'ERR_SENDER_ALREADY_ADDED'
          )
  }
  replaceTrack(a, s, $) {
    if (this._destroying) return
    if (this.destroyed)
      throw errCode$1(
        new Error('cannot replaceTrack after peer is destroyed'),
        'ERR_DESTROYED'
      )
    this._debug('replaceTrack()')
    const j = this._senderMap.get(a),
      _e = j ? j.get($) : null
    if (!_e)
      throw errCode$1(
        new Error('Cannot replace track that was never added.'),
        'ERR_TRACK_NOT_ADDED'
      )
    s && this._senderMap.set(s, j),
      _e.replaceTrack != null
        ? _e.replaceTrack(s)
        : this.__destroy(
            errCode$1(
              new Error('replaceTrack is not supported in this browser'),
              'ERR_UNSUPPORTED_REPLACETRACK'
            )
          )
  }
  removeTrack(a, s) {
    if (this._destroying) return
    if (this.destroyed)
      throw errCode$1(
        new Error('cannot removeTrack after peer is destroyed'),
        'ERR_DESTROYED'
      )
    this._debug('removeSender()')
    const $ = this._senderMap.get(a),
      j = $ ? $.get(s) : null
    if (!j)
      throw errCode$1(
        new Error('Cannot remove track that was never added.'),
        'ERR_TRACK_NOT_ADDED'
      )
    try {
      ;(j.removed = !0), this._pc.removeTrack(j)
    } catch (_e) {
      _e.name === 'NS_ERROR_UNEXPECTED'
        ? this._sendersAwaitingStable.push(j)
        : this.__destroy(errCode$1(_e, 'ERR_REMOVE_TRACK'))
    }
    this._needsNegotiation()
  }
  removeStream(a) {
    if (!this._destroying) {
      if (this.destroyed)
        throw errCode$1(
          new Error('cannot removeStream after peer is destroyed'),
          'ERR_DESTROYED'
        )
      this._debug('removeSenders()'),
        a.getTracks().forEach(s => {
          this.removeTrack(s, a)
        })
    }
  }
  _requestMissingTransceivers() {
    this._pc.getTransceivers &&
      this._pc.getTransceivers().forEach(a => {
        !a.mid &&
          a.sender.track &&
          !a.requested &&
          ((a.requested = !0), this.addTransceiver(a.sender.track.kind))
      })
  }
  _onTrack(a) {
    this.destroyed ||
      a.streams.forEach(s => {
        this._debug('on track'),
          this.emit('track', a.track, s),
          this._remoteTracks.push({ track: a.track, stream: s }),
          !this._remoteStreams.some($ => $.id === s.id) &&
            (this._remoteStreams.push(s),
            queueMicrotask(() => {
              this._debug('on stream'), this.emit('stream', s)
            }))
      })
  }
}
const dataEvent = 'data',
  signalEvent = 'signal',
  initPeer = (o, a) => {
    const s = new Peer({
        iceServers: [{ urls: defaultIceServers }],
        ...a,
        initiator: o,
        trickle: !1,
      }),
      $ = _e => j.push(_e)
    let j = []
    return (
      s.on(dataEvent, $),
      {
        id: s._id,
        created: Date.now(),
        connection: s._pc,
        get channel() {
          return s._channel
        },
        get isDead() {
          return s.destroyed
        },
        signal: _e =>
          new Promise(et => {
            o || s.on(signalEvent, et), s.signal(_e)
          }),
        sendData: _e => s.send(_e),
        destroy: () => s.destroy(),
        setHandlers: _e =>
          Object.entries(_e).forEach(([et, tt]) => s.on(et, tt)),
        offerPromise: o
          ? new Promise(_e => s.on(signalEvent, _e))
          : Promise.resolve(),
        addStream: _e => s.addStream(_e),
        removeStream: _e => s.removeStream(_e),
        addTrack: (_e, et) => s.addTrack(_e, et),
        removeTrack: (_e, et) => s.removeTrack(_e, et),
        replaceTrack: (_e, et, tt) => s.replaceTrack(_e, et, tt),
        drainEarlyData: _e => {
          s.off(dataEvent, $), j.forEach(_e), (j = null)
        },
      }
    )
  },
  defaultIceServers = [
    ...alloc(5, (o, a) => `stun:stun${a || ''}.l.google.com:19302`),
    'stun:global.stun.twilio.com:3478',
  ],
  TypedArray = Object.getPrototypeOf(Uint8Array),
  typeByteLimit = 12,
  typeIndex = 0,
  nonceIndex = typeIndex + typeByteLimit,
  tagIndex = nonceIndex + 1,
  progressIndex = tagIndex + 1,
  payloadIndex = progressIndex + 1,
  chunkSize = 16 * 2 ** 10 - payloadIndex,
  oneByteMax = 255,
  buffLowEvent = 'bufferedamountlow',
  internalNs = o => '@_' + o,
  room = (o, a, s) => {
    const $ = {},
      j = {},
      _e = {},
      et = {},
      tt = {},
      rt = {},
      nt = {},
      it = {
        onPeerJoin: noOp,
        onPeerLeave: noOp,
        onPeerStream: noOp,
        onPeerTrack: noOp,
      },
      ot = (Et, St) =>
        (Et ? (Array.isArray(Et) ? Et : [Et]) : keys$2($)).flatMap(Bt => {
          const Mt = $[Bt]
          return Mt
            ? St(Bt, Mt)
            : (console.warn(`${libName}: no peer with id ${Bt} found`), [])
        }),
      at = Et => {
        $[Et] &&
          (delete $[Et],
          delete et[Et],
          delete tt[Et],
          it.onPeerLeave(Et),
          a(Et))
      },
      st = Et => {
        if (j[Et]) return _e[Et]
        if (!Et) throw mkErr('action type argument is required')
        const St = encodeBytes(Et)
        if (St.byteLength > typeByteLimit)
          throw mkErr(
            `action type string "${Et}" (${St.byteLength}b) exceeds byte limit (${typeByteLimit}). Hint: choose a shorter name.`
          )
        const Bt = new Uint8Array(typeByteLimit)
        Bt.set(St)
        let Mt = 0
        return (
          (j[Et] = {
            onComplete: noOp,
            onProgress: noOp,
            setOnComplete: Ut => (j[Et] = { ...j[Et], onComplete: Ut }),
            setOnProgress: Ut => (j[Et] = { ...j[Et], onProgress: Ut }),
            send: async (Ut, Wt, Tt, kt) => {
              if (Tt && typeof Tt != 'object')
                throw mkErr('action meta argument must be an object')
              const Ot = typeof Ut
              if (Ot === 'undefined')
                throw mkErr('action data cannot be undefined')
              const Nt = Ot !== 'string',
                $t = Ut instanceof Blob,
                Pt = $t || Ut instanceof ArrayBuffer || Ut instanceof TypedArray
              if (Tt && !Pt)
                throw mkErr(
                  'action meta argument can only be used with binary data'
                )
              const Ft = Pt
                  ? new Uint8Array($t ? await Ut.arrayBuffer() : Ut)
                  : encodeBytes(Nt ? toJson(Ut) : Ut),
                Vt = Tt ? encodeBytes(toJson(Tt)) : null,
                Xt = Math.ceil(Ft.byteLength / chunkSize) + (Tt ? 1 : 0) || 1,
                Yt = alloc(Xt, (xt, It) => {
                  const Kt = It === Xt - 1,
                    Qt = Tt && It === 0,
                    Ht = new Uint8Array(
                      payloadIndex +
                        (Qt
                          ? Vt.byteLength
                          : Kt
                          ? Ft.byteLength - chunkSize * (Xt - (Tt ? 2 : 1))
                          : chunkSize)
                    )
                  return (
                    Ht.set(Bt),
                    Ht.set([Mt], nonceIndex),
                    Ht.set([Kt | (Qt << 1) | (Pt << 2) | (Nt << 3)], tagIndex),
                    Ht.set(
                      [Math.round(((It + 1) / Xt) * oneByteMax)],
                      progressIndex
                    ),
                    Ht.set(
                      Tt
                        ? Qt
                          ? Vt
                          : Ft.subarray((It - 1) * chunkSize, It * chunkSize)
                        : Ft.subarray(It * chunkSize, (It + 1) * chunkSize),
                      payloadIndex
                    ),
                    Ht
                  )
                })
              return (
                (Mt = (Mt + 1) & oneByteMax),
                all$1(
                  ot(Wt, async (xt, It) => {
                    const { channel: Kt } = It
                    let Qt = 0
                    for (; Qt < Xt; ) {
                      const Ht = Yt[Qt]
                      if (
                        (Kt.bufferedAmount > Kt.bufferedAmountLowThreshold &&
                          (await new Promise(Lt => {
                            const tr = () => {
                              Kt.removeEventListener(buffLowEvent, tr), Lt()
                            }
                            Kt.addEventListener(buffLowEvent, tr)
                          })),
                        !$[xt])
                      )
                        break
                      It.sendData(Ht),
                        Qt++,
                        kt == null || kt(Ht[progressIndex] / oneByteMax, xt, Tt)
                    }
                  })
                )
              )
            },
          }),
          _e[Et] ||
            (_e[Et] = [j[Et].send, j[Et].setOnComplete, j[Et].setOnProgress])
        )
      },
      ut = (Et, St) => {
        var Xt, Yt
        const Bt = new Uint8Array(St),
          Mt = decodeBytes(Bt.subarray(typeIndex, nonceIndex)).replaceAll(
            '\0',
            ''
          ),
          [Ut] = Bt.subarray(nonceIndex, tagIndex),
          [Wt] = Bt.subarray(tagIndex, progressIndex),
          [Tt] = Bt.subarray(progressIndex, payloadIndex),
          kt = Bt.subarray(payloadIndex),
          Ot = !!(Wt & 1),
          Nt = !!(Wt & 2),
          $t = !!(Wt & 4),
          Pt = !!(Wt & 8)
        if (!j[Mt]) {
          console.warn(
            `${libName}: received message with unregistered type (${Mt})`
          )
          return
        }
        et[Et] || (et[Et] = {}), (Xt = et[Et])[Mt] || (Xt[Mt] = {})
        const Ft = (Yt = et[Et][Mt])[Ut] || (Yt[Ut] = { chunks: [] })
        if (
          (Nt ? (Ft.meta = fromJson(decodeBytes(kt))) : Ft.chunks.push(kt),
          j[Mt].onProgress(Tt / oneByteMax, Et, Ft.meta),
          !Ot)
        )
          return
        const Vt = new Uint8Array(
          Ft.chunks.reduce((xt, It) => xt + It.byteLength, 0)
        )
        if (
          (Ft.chunks.reduce(
            (xt, It) => (Vt.set(It, xt), xt + It.byteLength),
            0
          ),
          delete et[Et][Mt][Ut],
          $t)
        )
          j[Mt].onComplete(Vt, Et, Ft.meta)
        else {
          const xt = decodeBytes(Vt)
          j[Mt].onComplete(Pt ? fromJson(xt) : xt, Et)
        }
      },
      ct = async () => {
        await Dt(''),
          await new Promise(Et => setTimeout(Et, 99)),
          entries($).forEach(([Et, St]) => {
            St.destroy(), delete $[Et]
          }),
          s()
      },
      [dt, ft] = st(internalNs('ping')),
      [mt, vt] = st(internalNs('pong')),
      [yt, pt] = st(internalNs('signal')),
      [ht, At] = st(internalNs('stream')),
      [wt, Ct] = st(internalNs('track')),
      [Dt, jt] = st(internalNs('leave'))
    return (
      o((Et, St) => {
        var Bt
        $[St] ||
          (($[St] = Et),
          Et.setHandlers({
            data: Mt => ut(St, Mt),
            stream: Mt => {
              it.onPeerStream(Mt, St, rt[St]), delete rt[St]
            },
            track: (Mt, Ut) => {
              it.onPeerTrack(Mt, Ut, St, nt[St]), delete nt[St]
            },
            signal: Mt => yt(Mt, St),
            close: () => at(St),
            error: () => at(St),
          }),
          it.onPeerJoin(St),
          (Bt = Et.drainEarlyData) == null || Bt.call(Et, Mt => ut(St, Mt)))
      }),
      ft((Et, St) => mt('', St)),
      vt((Et, St) => {
        var Bt
        ;(Bt = tt[St]) == null || Bt.call(tt), delete tt[St]
      }),
      pt((Et, St) => {
        var Bt
        return (Bt = $[St]) == null ? void 0 : Bt.signal(Et)
      }),
      At((Et, St) => (rt[St] = Et)),
      Ct((Et, St) => (nt[St] = Et)),
      jt((Et, St) => at(St)),
      isBrowser && addEventListener('beforeunload', ct),
      {
        makeAction: st,
        leave: ct,
        ping: async Et => {
          if (!Et) throw mkErr('ping() must be called with target peer ID')
          const St = Date.now()
          return (
            dt('', Et), await new Promise(Bt => (tt[Et] = Bt)), Date.now() - St
          )
        },
        getPeers: () =>
          fromEntries(entries($).map(([Et, St]) => [Et, St.connection])),
        addStream: (Et, St, Bt) =>
          ot(St, async (Mt, Ut) => {
            Bt && (await ht(Bt, Mt)), Ut.addStream(Et)
          }),
        removeStream: (Et, St) => ot(St, (Bt, Mt) => Mt.removeStream(Et)),
        addTrack: (Et, St, Bt, Mt) =>
          ot(Bt, async (Ut, Wt) => {
            Mt && (await wt(Mt, Ut)), Wt.addTrack(Et, St)
          }),
        removeTrack: (Et, St, Bt) => ot(Bt, (Mt, Ut) => Ut.removeTrack(Et, St)),
        replaceTrack: (Et, St, Bt, Mt, Ut) =>
          ot(Mt, async (Wt, Tt) => {
            Ut && (await wt(Ut, Wt)), Tt.replaceTrack(Et, St, Bt)
          }),
        onPeerJoin: Et => (it.onPeerJoin = Et),
        onPeerLeave: Et => (it.onPeerLeave = Et),
        onPeerStream: Et => (it.onPeerStream = Et),
        onPeerTrack: Et => (it.onPeerTrack = Et),
      }
    )
  },
  poolSize = 20,
  announceIntervalMs = 5333,
  offerTtl = 57333,
  strategy = ({ init: o, subscribe: a, announce: s }) => {
    const $ = {}
    let j = !1,
      _e,
      et,
      tt
    return (rt, nt, it) => {
      var Ut
      const { appId: ot } = rt
      if ((Ut = $[ot]) != null && Ut[nt]) return $[ot][nt]
      const at = {},
        st = {},
        ut = topicPath(libName, ot, nt),
        ct = sha1(ut),
        dt = sha1(topicPath(ut, selfId)),
        ft = genKey(rt.password || '', ot, nt),
        mt = Wt => async Tt => ({ type: Tt.type, sdp: await Wt(ft, Tt.sdp) }),
        vt = mt(decrypt),
        yt = mt(encrypt),
        pt = () => initPeer(!0, rt.rtcConfig),
        ht = (Wt, Tt, kt) => {
          var Ot
          if (st[Tt]) {
            st[Tt] !== Wt && Wt.destroy()
            return
          }
          ;(st[Tt] = Wt),
            Mt(Wt, Tt),
            (Ot = at[Tt]) == null ||
              Ot.forEach((Nt, $t) => {
                $t !== kt && Nt.destroy()
              }),
            delete at[Tt]
        },
        At = (Wt, Tt) => {
          st[Tt] === Wt && delete st[Tt]
        },
        wt = (Wt, Tt) => {
          var Ot
          if (st[Wt]) return
          const kt = (Ot = at[Wt]) == null ? void 0 : Ot[Tt]
          kt && (delete at[Wt][Tt], kt.destroy())
        },
        Ct = Wt => (
          et.push(...alloc(Wt, pt)),
          all$1(
            et
              .splice(0, Wt)
              .map(Tt =>
                Tt.offerPromise.then(yt).then(kt => ({ peer: Tt, offer: kt }))
              )
          )
        ),
        Dt = (Wt, Tt) =>
          it == null
            ? void 0
            : it({
                error: `incorrect password (${rt.password}) when decrypting ${Tt}`,
                appId: ot,
                peerId: Wt,
                roomId: nt,
              }),
        jt = Wt => async (Tt, kt, Ot) => {
          var Yt, xt, It
          const [Nt, $t] = await all$1([ct, dt])
          if (Tt !== Nt && Tt !== $t) return
          const { peerId: Pt, offer: Ft, answer: Vt, peer: Xt } =
            typeof kt == 'string' ? fromJson(kt) : kt
          if (!(Pt === selfId || st[Pt])) {
            if (Pt && !Ft && !Vt) {
              if ((Yt = at[Pt]) != null && Yt[Wt]) return
              const [[{ peer: Kt, offer: Qt }], Ht] = await all$1([
                Ct(1),
                sha1(topicPath(ut, Pt)),
              ])
              at[Pt] || (at[Pt] = []),
                (at[Pt][Wt] = Kt),
                setTimeout(() => wt(Pt, Wt), Et[Wt] * 0.9),
                Kt.setHandlers({
                  connect: () => ht(Kt, Pt, Wt),
                  close: () => At(Kt, Pt),
                }),
                Ot(Ht, toJson({ peerId: selfId, offer: Qt }))
            } else if (Ft) {
              if (((xt = at[Pt]) == null ? void 0 : xt[Wt]) && selfId > Pt)
                return
              const Qt = initPeer(!1, rt.rtcConfig)
              Qt.setHandlers({
                connect: () => ht(Qt, Pt, Wt),
                close: () => At(Qt, Pt),
              })
              let Ht
              try {
                Ht = await vt(Ft)
              } catch {
                Dt(Pt, 'offer')
                return
              }
              if (Qt.isDead) return
              const [Lt, tr] = await all$1([
                sha1(topicPath(ut, Pt)),
                Qt.signal(Ht),
              ])
              Ot(Lt, toJson({ peerId: selfId, answer: await yt(tr) }))
            } else if (Vt) {
              let Kt
              try {
                Kt = await vt(Vt)
              } catch {
                Dt(Pt, 'answer')
                return
              }
              if (Xt)
                Xt.setHandlers({
                  connect: () => ht(Xt, Pt, Wt),
                  close: () => At(Xt, Pt),
                }),
                  Xt.signal(Kt)
              else {
                const Qt = (It = at[Pt]) == null ? void 0 : It[Wt]
                Qt && !Qt.isDead && Qt.signal(Kt)
              }
            }
          }
        }
      if (!rt) throw mkErr('requires a config map as the first argument')
      if (!ot && !rt.firebaseApp)
        throw mkErr('config map is missing appId field')
      if (!nt) throw mkErr('roomId argument required')
      if (!j) {
        const Wt = o(rt)
        ;(et = alloc(poolSize, pt)),
          (_e = Array.isArray(Wt) ? Wt : [Wt]),
          (j = !0),
          (tt = setInterval(
            () =>
              (et = et.filter(Tt => {
                const kt = Date.now() - Tt.created < offerTtl
                return kt || Tt.destroy(), kt
              })),
            offerTtl * 1.03
          ))
      }
      const Et = _e.map(() => announceIntervalMs),
        St = [],
        Bt = _e.map(async (Wt, Tt) =>
          a(await Wt, await ct, await dt, jt(Tt), Ct)
        )
      all$1([ct, dt]).then(([Wt, Tt]) => {
        const kt = async (Ot, Nt) => {
          const $t = await s(Ot, Wt, Tt)
          typeof $t == 'number' && (Et[Nt] = $t),
            (St[Nt] = setTimeout(() => kt(Ot, Nt), Et[Nt]))
        }
        Bt.forEach(async (Ot, Nt) => {
          await Ot, kt(await _e[Nt], Nt)
        })
      })
      let Mt = noOp
      return (
        $[ot] || ($[ot] = {}),
        ($[ot][nt] = room(
          Wt => (Mt = Wt),
          Wt => delete st[Wt],
          () => {
            delete $[ot][nt],
              St.forEach(clearTimeout),
              Bt.forEach(async Wt => (await Wt)()),
              clearInterval(tt)
          }
        ))
      )
    }
  },
  topicToInfoHash = {},
  infoHashToTopic = {},
  announceIntervals = {},
  announceFns = {},
  trackerAnnounceMs = {},
  handledOffers = {},
  msgHandlers = {},
  trackerAction = 'announce',
  hashLimit = 20,
  offerPoolSize = 10,
  defaultAnnounceMs = 33333,
  maxAnnounceMs = 120333,
  defaultRedundancy = 3,
  getInfoHash = async o => {
    if (topicToInfoHash[o]) return topicToInfoHash[o]
    const a = (await sha1(o)).slice(0, hashLimit)
    return (topicToInfoHash[o] = a), (infoHashToTopic[a] = o), a
  },
  send = async (o, a, s) =>
    o.send(
      toJson({
        action: trackerAction,
        info_hash: await getInfoHash(a),
        peer_id: selfId,
        ...s,
      })
    ),
  warn$1 = (o, a, s) =>
    console.warn(
      `${libName}: torrent tracker ${
        s ? 'failure' : 'warning'
      } from ${o} - ${a}`
    ),
  joinRoom = strategy({
    init: o =>
      getRelays(o, defaultRelayUrls, defaultRedundancy).map(a => {
        const s = makeSocket(a, j => {
            var it, ot
            const _e = fromJson(j),
              et = _e['failure reason'],
              tt = _e['warning message'],
              { interval: rt } = _e,
              nt = infoHashToTopic[_e.info_hash]
            if (et) {
              warn$1($, et, !0)
              return
            }
            if (
              (tt && warn$1($, tt),
              rt && rt * 1e3 > trackerAnnounceMs[$] && announceFns[$][nt])
            ) {
              const at = Math.min(rt * 1e3, maxAnnounceMs)
              clearInterval(announceIntervals[$][nt]),
                (trackerAnnounceMs[$] = at),
                (announceIntervals[$][nt] = setInterval(announceFns[$][nt], at))
            }
            handledOffers[_e.offer_id] ||
              ((_e.offer || _e.answer) &&
                ((handledOffers[_e.offer_id] = !0),
                (ot = (it = msgHandlers[$])[nt]) == null || ot.call(it, _e)))
          }),
          { url: $ } = s
        return (msgHandlers[$] = {}), s.ready
      }),
    subscribe: (o, a, s, $, j) => {
      const { url: _e } = o,
        et = async () => {
          const tt = fromEntries(
            (await j(offerPoolSize)).map(rt => [genId(hashLimit), rt])
          )
          ;(msgHandlers[o.url][a] = rt => {
            if (rt.offer)
              $(a, { offer: rt.offer, peerId: rt.peer_id }, (nt, it) =>
                send(o, a, {
                  answer: fromJson(it).answer,
                  offer_id: rt.offer_id,
                  to_peer_id: rt.peer_id,
                })
              )
            else if (rt.answer) {
              const nt = tt[rt.offer_id]
              nt &&
                $(a, { answer: rt.answer, peerId: rt.peer_id, peer: nt.peer })
            }
          }),
            send(o, a, {
              numwant: offerPoolSize,
              offers: entries(tt).map(([rt, { offer: nt }]) => ({
                offer_id: rt,
                offer: nt,
              })),
            })
        }
      return (
        (trackerAnnounceMs[_e] = defaultAnnounceMs),
        announceFns[_e] || (announceFns[_e] = {}),
        (announceFns[_e][a] = et),
        announceIntervals[_e] || (announceIntervals[_e] = {}),
        (announceIntervals[_e][a] = setInterval(et, trackerAnnounceMs[_e])),
        et(),
        () => {
          clearInterval(announceIntervals[_e][a]),
            delete msgHandlers[_e][a],
            delete announceFns[_e][a]
        }
      )
    },
    announce: o => trackerAnnounceMs[o.url],
  }),
  defaultRelayUrls = [
    'tracker.webtorrent.dev',
    'tracker.openwebtorrent.com',
    'tracker.files.fm:7073/announce',
    'tracker.btorrent.xyz',
  ].map(o => 'wss://' + o)
function r$1(o) {
  var a,
    s,
    $ = ''
  if (typeof o == 'string' || typeof o == 'number') $ += o
  else if (typeof o == 'object')
    if (Array.isArray(o))
      for (a = 0; a < o.length; a++)
        o[a] && (s = r$1(o[a])) && ($ && ($ += ' '), ($ += s))
    else for (a in o) o[a] && ($ && ($ += ' '), ($ += a))
  return $
}
function clsx() {
  for (var o, a, s = 0, $ = ''; s < arguments.length; )
    (o = arguments[s++]) && (a = r$1(o)) && ($ && ($ += ' '), ($ += a))
  return $
}
function getCollapseUtilityClass(o) {
  return generateUtilityClass('MuiCollapse', o)
}
generateUtilityClasses('MuiCollapse', [
  'root',
  'horizontal',
  'vertical',
  'entered',
  'hidden',
  'wrapper',
  'wrapperInner',
])
const _excluded$V = [
    'addEndListener',
    'children',
    'className',
    'collapsedSize',
    'component',
    'easing',
    'in',
    'onEnter',
    'onEntered',
    'onEntering',
    'onExit',
    'onExited',
    'onExiting',
    'orientation',
    'style',
    'timeout',
    'TransitionComponent',
  ],
  useUtilityClasses$P = o => {
    const { orientation: a, classes: s } = o,
      $ = {
        root: ['root', `${a}`],
        entered: ['entered'],
        hidden: ['hidden'],
        wrapper: ['wrapper', `${a}`],
        wrapperInner: ['wrapperInner', `${a}`],
      }
    return composeClasses($, getCollapseUtilityClass, s)
  },
  CollapseRoot = styled('div', {
    name: 'MuiCollapse',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        a[s.orientation],
        s.state === 'entered' && a.entered,
        s.state === 'exited' && !s.in && s.collapsedSize === '0px' && a.hidden,
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        height: 0,
        overflow: 'hidden',
        transition: o.transitions.create('height'),
      },
      a.orientation === 'horizontal' && {
        height: 'auto',
        width: 0,
        transition: o.transitions.create('width'),
      },
      a.state === 'entered' &&
        _extends$5(
          { height: 'auto', overflow: 'visible' },
          a.orientation === 'horizontal' && { width: 'auto' }
        ),
      a.state === 'exited' &&
        !a.in &&
        a.collapsedSize === '0px' && { visibility: 'hidden' }
    )
  ),
  CollapseWrapper = styled('div', {
    name: 'MuiCollapse',
    slot: 'Wrapper',
    overridesResolver: (o, a) => a.wrapper,
  })(({ ownerState: o }) =>
    _extends$5(
      { display: 'flex', width: '100%' },
      o.orientation === 'horizontal' && { width: 'auto', height: '100%' }
    )
  ),
  CollapseWrapperInner = styled('div', {
    name: 'MuiCollapse',
    slot: 'WrapperInner',
    overridesResolver: (o, a) => a.wrapperInner,
  })(({ ownerState: o }) =>
    _extends$5(
      { width: '100%' },
      o.orientation === 'horizontal' && { width: 'auto', height: '100%' }
    )
  ),
  Collapse = reactExports.forwardRef(function(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiCollapse' }),
      {
        addEndListener: j,
        children: _e,
        className: et,
        collapsedSize: tt = '0px',
        component: rt,
        easing: nt,
        in: it,
        onEnter: ot,
        onEntered: at,
        onEntering: st,
        onExit: ut,
        onExited: ct,
        onExiting: dt,
        orientation: ft = 'vertical',
        style: mt,
        timeout: vt = duration.standard,
        TransitionComponent: yt = Transition,
      } = $,
      pt = _objectWithoutPropertiesLoose$3($, _excluded$V),
      ht = _extends$5({}, $, { orientation: ft, collapsedSize: tt }),
      At = useUtilityClasses$P(ht),
      wt = useTheme$1(),
      Ct = useTimeout(),
      Dt = reactExports.useRef(null),
      jt = reactExports.useRef(),
      Et = typeof tt == 'number' ? `${tt}px` : tt,
      St = ft === 'horizontal',
      Bt = St ? 'width' : 'height',
      Mt = reactExports.useRef(null),
      Ut = useForkRef(s, Mt),
      Wt = Xt => Yt => {
        if (Xt) {
          const xt = Mt.current
          Yt === void 0 ? Xt(xt) : Xt(xt, Yt)
        }
      },
      Tt = () =>
        Dt.current ? Dt.current[St ? 'clientWidth' : 'clientHeight'] : 0,
      kt = Wt((Xt, Yt) => {
        Dt.current && St && (Dt.current.style.position = 'absolute'),
          (Xt.style[Bt] = Et),
          ot && ot(Xt, Yt)
      }),
      Ot = Wt((Xt, Yt) => {
        const xt = Tt()
        Dt.current && St && (Dt.current.style.position = '')
        const { duration: It, easing: Kt } = getTransitionProps(
          { style: mt, timeout: vt, easing: nt },
          { mode: 'enter' }
        )
        if (vt === 'auto') {
          const Qt = wt.transitions.getAutoHeightDuration(xt)
          ;(Xt.style.transitionDuration = `${Qt}ms`), (jt.current = Qt)
        } else
          Xt.style.transitionDuration = typeof It == 'string' ? It : `${It}ms`
        ;(Xt.style[Bt] = `${xt}px`),
          (Xt.style.transitionTimingFunction = Kt),
          st && st(Xt, Yt)
      }),
      Nt = Wt((Xt, Yt) => {
        ;(Xt.style[Bt] = 'auto'), at && at(Xt, Yt)
      }),
      $t = Wt(Xt => {
        ;(Xt.style[Bt] = `${Tt()}px`), ut && ut(Xt)
      }),
      Pt = Wt(ct),
      Ft = Wt(Xt => {
        const Yt = Tt(),
          { duration: xt, easing: It } = getTransitionProps(
            { style: mt, timeout: vt, easing: nt },
            { mode: 'exit' }
          )
        if (vt === 'auto') {
          const Kt = wt.transitions.getAutoHeightDuration(Yt)
          ;(Xt.style.transitionDuration = `${Kt}ms`), (jt.current = Kt)
        } else
          Xt.style.transitionDuration = typeof xt == 'string' ? xt : `${xt}ms`
        ;(Xt.style[Bt] = Et),
          (Xt.style.transitionTimingFunction = It),
          dt && dt(Xt)
      }),
      Vt = Xt => {
        vt === 'auto' && Ct.start(jt.current || 0, Xt), j && j(Mt.current, Xt)
      }
    return jsxRuntimeExports.jsx(
      yt,
      _extends$5(
        {
          in: it,
          onEnter: kt,
          onEntered: Nt,
          onEntering: Ot,
          onExit: $t,
          onExited: Pt,
          onExiting: Ft,
          addEndListener: Vt,
          nodeRef: Mt,
          timeout: vt === 'auto' ? null : vt,
        },
        pt,
        {
          children: (Xt, Yt) =>
            jsxRuntimeExports.jsx(
              CollapseRoot,
              _extends$5(
                {
                  as: rt,
                  className: clsx$1(
                    At.root,
                    et,
                    {
                      entered: At.entered,
                      exited: !it && Et === '0px' && At.hidden,
                    }[Xt]
                  ),
                  style: _extends$5(
                    { [St ? 'minWidth' : 'minHeight']: Et },
                    mt
                  ),
                  ref: Ut,
                },
                Yt,
                {
                  ownerState: _extends$5({}, ht, { state: Xt }),
                  children: jsxRuntimeExports.jsx(CollapseWrapper, {
                    ownerState: _extends$5({}, ht, { state: Xt }),
                    className: At.wrapper,
                    ref: Dt,
                    children: jsxRuntimeExports.jsx(CollapseWrapperInner, {
                      ownerState: _extends$5({}, ht, { state: Xt }),
                      className: At.wrapperInner,
                      children: _e,
                    }),
                  }),
                }
              )
            ),
        }
      )
    )
  })
Collapse.muiSupportAuto = !0
function mapEventPropToEvent(o) {
  return o.substring(2).toLowerCase()
}
function clickedRootScrollbar(o, a) {
  return (
    a.documentElement.clientWidth < o.clientX ||
    a.documentElement.clientHeight < o.clientY
  )
}
function ClickAwayListener(o) {
  const {
      children: a,
      disableReactTree: s = !1,
      mouseEvent: $ = 'onClick',
      onClickAway: j,
      touchEvent: _e = 'onTouchEnd',
    } = o,
    et = reactExports.useRef(!1),
    tt = reactExports.useRef(null),
    rt = reactExports.useRef(!1),
    nt = reactExports.useRef(!1)
  reactExports.useEffect(
    () => (
      setTimeout(() => {
        rt.current = !0
      }, 0),
      () => {
        rt.current = !1
      }
    ),
    []
  )
  const it = useForkRef(a.ref, tt),
    ot = useEventCallback$1(ut => {
      const ct = nt.current
      nt.current = !1
      const dt = ownerDocument(tt.current)
      if (
        !rt.current ||
        !tt.current ||
        ('clientX' in ut && clickedRootScrollbar(ut, dt))
      )
        return
      if (et.current) {
        et.current = !1
        return
      }
      let ft
      ut.composedPath
        ? (ft = ut.composedPath().indexOf(tt.current) > -1)
        : (ft =
            !dt.documentElement.contains(ut.target) ||
            tt.current.contains(ut.target)),
        !ft && (s || !ct) && j(ut)
    }),
    at = ut => ct => {
      nt.current = !0
      const dt = a.props[ut]
      dt && dt(ct)
    },
    st = { ref: it }
  return (
    _e !== !1 && (st[_e] = at(_e)),
    reactExports.useEffect(() => {
      if (_e !== !1) {
        const ut = mapEventPropToEvent(_e),
          ct = ownerDocument(tt.current),
          dt = () => {
            et.current = !0
          }
        return (
          ct.addEventListener(ut, ot),
          ct.addEventListener('touchmove', dt),
          () => {
            ct.removeEventListener(ut, ot),
              ct.removeEventListener('touchmove', dt)
          }
        )
      }
    }, [ot, _e]),
    $ !== !1 && (st[$] = at($)),
    reactExports.useEffect(() => {
      if ($ !== !1) {
        const ut = mapEventPropToEvent($),
          ct = ownerDocument(tt.current)
        return (
          ct.addEventListener(ut, ot),
          () => {
            ct.removeEventListener(ut, ot)
          }
        )
      }
    }, [ot, $]),
    jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: reactExports.cloneElement(a, st),
    })
  )
}
function _defineProperties$1(o, a) {
  for (var s = 0; s < a.length; s++) {
    var $ = a[s]
    ;($.enumerable = $.enumerable || !1),
      ($.configurable = !0),
      'value' in $ && ($.writable = !0),
      Object.defineProperty(o, $.key, $)
  }
}
function _createClass$2(o, a, s) {
  return a && _defineProperties$1(o.prototype, a), o
}
function _extends$2() {
  return (
    (_extends$2 =
      Object.assign ||
      function(o) {
        for (var a = 1; a < arguments.length; a++) {
          var s = arguments[a]
          for (var $ in s)
            Object.prototype.hasOwnProperty.call(s, $) && (o[$] = s[$])
        }
        return o
      }),
    _extends$2.apply(this, arguments)
  )
}
function _inheritsLoose$1(o, a) {
  ;(o.prototype = Object.create(a.prototype)),
    (o.prototype.constructor = o),
    (o.__proto__ = a)
}
function _objectWithoutPropertiesLoose$1(o, a) {
  if (o == null) return {}
  var s = {},
    $ = Object.keys(o),
    j,
    _e
  for (_e = 0; _e < $.length; _e++)
    (j = $[_e]), !(a.indexOf(j) >= 0) && (s[j] = o[j])
  return s
}
function _assertThisInitialized(o) {
  if (o === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return o
}
var SnackbarContext = React$5.createContext(),
  allClasses = {
    mui: {
      root: {},
      anchorOriginTopCenter: {},
      anchorOriginBottomCenter: {},
      anchorOriginTopRight: {},
      anchorOriginBottomRight: {},
      anchorOriginTopLeft: {},
      anchorOriginBottomLeft: {},
    },
    container: {
      containerRoot: {},
      containerAnchorOriginTopCenter: {},
      containerAnchorOriginBottomCenter: {},
      containerAnchorOriginTopRight: {},
      containerAnchorOriginBottomRight: {},
      containerAnchorOriginTopLeft: {},
      containerAnchorOriginBottomLeft: {},
    },
  },
  SNACKBAR_INDENTS = {
    view: { default: 20, dense: 4 },
    snackbar: { default: 6, dense: 2 },
  },
  DEFAULTS = {
    maxSnack: 3,
    dense: !1,
    hideIconVariant: !1,
    variant: 'default',
    autoHideDuration: 5e3,
    anchorOrigin: { vertical: 'bottom', horizontal: 'left' },
    TransitionComponent: Slide,
    transitionDuration: { enter: 225, exit: 195 },
  },
  capitalise = function(a) {
    return a.charAt(0).toUpperCase() + a.slice(1)
  },
  originKeyExtractor = function(a) {
    return '' + capitalise(a.vertical) + capitalise(a.horizontal)
  },
  omitContainerKeys = function(a) {
    return Object.keys(a)
      .filter(function(s) {
        return !allClasses.container[s]
      })
      .reduce(function(s, $) {
        var j
        return _extends$2({}, s, ((j = {}), (j[$] = a[$]), j))
      }, {})
  },
  REASONS = {
    TIMEOUT: 'timeout',
    CLICKAWAY: 'clickaway',
    MAXSNACK: 'maxsnack',
    INSTRUCTED: 'instructed',
  },
  transformer = {
    toContainerAnchorOrigin: function(a) {
      return 'containerAnchorOrigin' + a
    },
    toAnchorOrigin: function(a) {
      var s = a.vertical,
        $ = a.horizontal
      return 'anchorOrigin' + capitalise(s) + capitalise($)
    },
    toVariant: function(a) {
      return 'variant' + capitalise(a)
    },
  },
  isDefined = function(a) {
    return !!a || a === 0
  },
  numberOrNull = function(a) {
    return typeof a == 'number' || a === null
  },
  merge = function(a, s, $) {
    return function(j) {
      return j === 'autoHideDuration'
        ? numberOrNull(a.autoHideDuration)
          ? a.autoHideDuration
          : numberOrNull(s.autoHideDuration)
          ? s.autoHideDuration
          : DEFAULTS.autoHideDuration
        : a[j] || s[j] || $[j]
    }
  }
function objectMerge(o, a, s) {
  return (
    o === void 0 && (o = {}),
    a === void 0 && (a = {}),
    s === void 0 && (s = {}),
    _extends$2({}, s, {}, a, {}, o)
  )
}
var componentName = 'SnackbarContent',
  classes = { root: componentName + '-root' },
  Root$1 = styled('div')(function(o) {
    var a,
      s,
      $ = o.theme
    return (
      (s = {}),
      (s['&.' + classes.root] =
        ((a = { display: 'flex', flexWrap: 'wrap', flexGrow: 1 }),
        (a[$.breakpoints.up('sm')] = { flexGrow: 'initial', minWidth: 288 }),
        a)),
      s
    )
  }),
  SnackbarContent = reactExports.forwardRef(function(o, a) {
    var s = o.className,
      $ = _objectWithoutPropertiesLoose$1(o, ['className'])
    return React$5.createElement(
      Root$1,
      Object.assign({ ref: a, className: clsx(classes.root, s) }, $)
    )
  }),
  DIRECTION = { right: 'left', left: 'right', bottom: 'up', top: 'down' },
  getTransitionDirection = function(a) {
    return a.horizontal !== 'center'
      ? DIRECTION[a.horizontal]
      : DIRECTION[a.vertical]
  },
  CheckIcon = function(a) {
    return React$5.createElement(
      SvgIcon,
      Object.assign({}, a),
      React$5.createElement('path', {
        d: `M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41
        10.59L10 14.17L17.59 6.58L19 8L10 17Z`,
      })
    )
  },
  WarningIcon = function(a) {
    return React$5.createElement(
      SvgIcon,
      Object.assign({}, a),
      React$5.createElement('path', {
        d: 'M13,14H11V10H13M13,18H11V16H13M1,21H23L12,2L1,21Z',
      })
    )
  },
  ErrorIcon = function(a) {
    return React$5.createElement(
      SvgIcon,
      Object.assign({}, a),
      React$5.createElement('path', {
        d: `M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,
        6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,
        13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z`,
      })
    )
  },
  InfoIcon = function(a) {
    return React$5.createElement(
      SvgIcon,
      Object.assign({}, a),
      React$5.createElement('path', {
        d: `M13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,
        0 22,12A10,10 0 0,0 12,2Z`,
      })
    )
  },
  iconStyles = { fontSize: 20, marginInlineEnd: 8 },
  defaultIconVariants = {
    default: void 0,
    success: React$5.createElement(CheckIcon, { style: iconStyles }),
    warning: React$5.createElement(WarningIcon, { style: iconStyles }),
    error: React$5.createElement(ErrorIcon, { style: iconStyles }),
    info: React$5.createElement(InfoIcon, { style: iconStyles }),
  }
function createChainedFunction(o, a) {
  return o.reduce(
    function(s, $) {
      return $ == null
        ? s
        : function() {
            for (
              var _e = arguments.length, et = new Array(_e), tt = 0;
              tt < _e;
              tt++
            )
              et[tt] = arguments[tt]
            var rt = [].concat(et)
            a && rt.indexOf(a) === -1 && rt.push(a),
              s.apply(this, rt),
              $.apply(this, rt)
          }
    },
    function() {}
  )
}
var useEnhancedEffect =
  typeof window < 'u' ? reactExports.useLayoutEffect : reactExports.useEffect
function useEventCallback(o) {
  var a = reactExports.useRef(o)
  return (
    useEnhancedEffect(function() {
      a.current = o
    }),
    reactExports.useCallback(function() {
      return a.current.apply(void 0, arguments)
    }, [])
  )
}
var Snackbar = reactExports.forwardRef(function(o, a) {
    var s = o.children,
      $ = o.autoHideDuration,
      j = o.ClickAwayListenerProps,
      _e = o.disableWindowBlurListener,
      et = _e === void 0 ? !1 : _e,
      tt = o.onClose,
      rt = o.onMouseEnter,
      nt = o.onMouseLeave,
      it = o.open,
      ot = o.resumeHideDuration,
      at = _objectWithoutPropertiesLoose$1(o, [
        'children',
        'autoHideDuration',
        'ClickAwayListenerProps',
        'disableWindowBlurListener',
        'onClose',
        'onMouseEnter',
        'onMouseLeave',
        'open',
        'resumeHideDuration',
      ]),
      st = reactExports.useRef(),
      ut = useEventCallback(function() {
        tt && tt.apply(void 0, arguments)
      }),
      ct = useEventCallback(function(pt) {
        !tt ||
          pt == null ||
          (clearTimeout(st.current),
          (st.current = setTimeout(function() {
            ut(null, REASONS.TIMEOUT)
          }, pt)))
      })
    reactExports.useEffect(
      function() {
        return (
          it && ct($),
          function() {
            clearTimeout(st.current)
          }
        )
      },
      [it, $, ct]
    )
    var dt = function() {
        clearTimeout(st.current)
      },
      ft = reactExports.useCallback(
        function() {
          $ != null && ct(ot ?? $ * 0.5)
        },
        [$, ot, ct]
      ),
      mt = function(ht) {
        rt && rt(ht), dt()
      },
      vt = function(ht) {
        nt && nt(ht), ft()
      },
      yt = function(ht) {
        tt && tt(ht, REASONS.CLICKAWAY)
      }
    return (
      reactExports.useEffect(
        function() {
          if (!et && it)
            return (
              window.addEventListener('focus', ft),
              window.addEventListener('blur', dt),
              function() {
                window.removeEventListener('focus', ft),
                  window.removeEventListener('blur', dt)
              }
            )
        },
        [et, ft, it]
      ),
      reactExports.createElement(
        ClickAwayListener,
        _extends$2({ onClickAway: yt }, j),
        reactExports.createElement(
          'div',
          _extends$2({ onMouseEnter: mt, onMouseLeave: vt, ref: a }, at),
          s
        )
      )
    )
  }),
  componentName$1 = 'SnackbarItem',
  classes$1 = {
    contentRoot: componentName$1 + '-contentRoot',
    lessPadding: componentName$1 + '-lessPadding',
    variantSuccess: componentName$1 + '-variantSuccess',
    variantError: componentName$1 + '-variantError',
    variantInfo: componentName$1 + '-variantInfo',
    variantWarning: componentName$1 + '-variantWarning',
    message: componentName$1 + '-message',
    action: componentName$1 + '-action',
    wrappedRoot: componentName$1 + '-wrappedRoot',
  },
  StyledSnackbar = styled(Snackbar)(function(o) {
    var a,
      s = o.theme,
      $ = s.palette.mode || s.palette.type,
      j = emphasize$1(s.palette.background.default, $ === 'light' ? 0.8 : 0.98)
    return (
      (a = {}),
      (a['&.' + classes$1.wrappedRoot] = {
        position: 'relative',
        transform: 'translateX(0)',
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
      }),
      (a['.' + classes$1.contentRoot] = _extends$2({}, s.typography.body2, {
        backgroundColor: j,
        color: s.palette.getContrastText(j),
        alignItems: 'center',
        padding: '6px 16px',
        borderRadius: '4px',
        boxShadow:
          '0px 3px 5px -1px rgba(0,0,0,0.2),0px 6px 10px 0px rgba(0,0,0,0.14),0px 1px 18px 0px rgba(0,0,0,0.12)',
      })),
      (a['.' + classes$1.lessPadding] = { paddingLeft: 8 * 2.5 }),
      (a['.' + classes$1.variantSuccess] = {
        backgroundColor: '#43a047',
        color: '#fff',
      }),
      (a['.' + classes$1.variantError] = {
        backgroundColor: '#d32f2f',
        color: '#fff',
      }),
      (a['.' + classes$1.variantInfo] = {
        backgroundColor: '#2196f3',
        color: '#fff',
      }),
      (a['.' + classes$1.variantWarning] = {
        backgroundColor: '#ff9800',
        color: '#fff',
      }),
      (a['.' + classes$1.message] = {
        display: 'flex',
        alignItems: 'center',
        padding: '8px 0',
      }),
      (a['.' + classes$1.action] = {
        display: 'flex',
        alignItems: 'center',
        marginLeft: 'auto',
        paddingLeft: 16,
        marginRight: -8,
      }),
      a
    )
  }),
  SnackbarItem = function(a) {
    var s = a.classes,
      $ = _objectWithoutPropertiesLoose$1(a, ['classes']),
      j = reactExports.useRef(),
      _e = reactExports.useState(!0),
      et = _e[0],
      tt = _e[1]
    reactExports.useEffect(function() {
      return function() {
        j.current && clearTimeout(j.current)
      }
    }, [])
    var rt = createChainedFunction([$.snack.onClose, $.onClose], $.snack.key),
      nt = function() {
        $.snack.requestClose && rt(null, REASONS.INSTRCUTED)
      },
      it = function() {
        j.current = setTimeout(function() {
          tt(!et)
        }, 125)
      },
      ot = $.style,
      at = $.ariaAttributes,
      st = $.className,
      ut = $.hideIconVariant,
      ct = $.iconVariant,
      dt = $.snack,
      ft = $.action,
      mt = $.content,
      vt = $.TransitionComponent,
      yt = $.TransitionProps,
      pt = $.transitionDuration,
      ht = _objectWithoutPropertiesLoose$1($, [
        'style',
        'dense',
        'ariaAttributes',
        'className',
        'hideIconVariant',
        'iconVariant',
        'snack',
        'action',
        'content',
        'TransitionComponent',
        'TransitionProps',
        'transitionDuration',
        'onEnter',
        'onEntered',
        'onEntering',
        'onExit',
        'onExited',
        'onExiting',
      ]),
      At = dt.key,
      wt = dt.open,
      Ct = dt.className,
      Dt = dt.variant,
      jt = dt.content,
      Et = dt.action,
      St = dt.ariaAttributes,
      Bt = dt.anchorOrigin,
      Mt = dt.message,
      Ut = dt.TransitionComponent,
      Wt = dt.TransitionProps,
      Tt = dt.transitionDuration,
      kt = _objectWithoutPropertiesLoose$1(dt, [
        'persist',
        'key',
        'open',
        'entered',
        'requestClose',
        'className',
        'variant',
        'content',
        'action',
        'ariaAttributes',
        'anchorOrigin',
        'message',
        'TransitionComponent',
        'TransitionProps',
        'transitionDuration',
        'onEnter',
        'onEntered',
        'onEntering',
        'onExit',
        'onExited',
        'onExiting',
      ]),
      Ot = _extends$2({}, defaultIconVariants, {}, ct)[Dt],
      Nt = _extends$2(
        { 'aria-describedby': 'notistack-snackbar' },
        objectMerge(St, at)
      ),
      $t = Ut || vt || DEFAULTS.TransitionComponent,
      Pt = objectMerge(Tt, pt, DEFAULTS.transitionDuration),
      Ft = _extends$2(
        { direction: getTransitionDirection(Bt) },
        objectMerge(Wt, yt)
      ),
      Vt = Et || ft
    typeof Vt == 'function' && (Vt = Vt(At))
    var Xt = jt || mt
    typeof Xt == 'function' && (Xt = Xt(At, dt.message))
    var Yt = [
      'onEnter',
      'onEntering',
      'onEntered',
      'onExit',
      'onExiting',
      'onExited',
    ].reduce(function(xt, It) {
      var Kt
      return _extends$2(
        {},
        xt,
        ((Kt = {}),
        (Kt[It] = createChainedFunction([$.snack[It], $[It]], $.snack.key)),
        Kt)
      )
    }, {})
    return React$5.createElement(
      Collapse,
      { unmountOnExit: !0, timeout: 175, in: et, onExited: Yt.onExited },
      React$5.createElement(
        StyledSnackbar,
        Object.assign({}, ht, kt, {
          open: wt,
          className: clsx(
            s.root,
            classes$1.wrappedRoot,
            s[transformer.toAnchorOrigin(Bt)]
          ),
          onClose: rt,
        }),
        React$5.createElement(
          $t,
          Object.assign({ appear: !0, in: wt, timeout: Pt }, Ft, {
            onExit: Yt.onExit,
            onExiting: Yt.onExiting,
            onExited: it,
            onEnter: Yt.onEnter,
            onEntering: Yt.onEntering,
            onEntered: createChainedFunction([Yt.onEntered, nt]),
          }),
          Xt ||
            React$5.createElement(
              SnackbarContent,
              Object.assign({}, Nt, {
                role: 'alert',
                style: ot,
                className: clsx(
                  classes$1.contentRoot,
                  classes$1[transformer.toVariant(Dt)],
                  s[transformer.toVariant(Dt)],
                  st,
                  Ct,
                  !ut && Ot && classes$1.lessPadding
                ),
              }),
              React$5.createElement(
                'div',
                { id: Nt['aria-describedby'], className: classes$1.message },
                ut ? null : Ot,
                Mt
              ),
              Vt &&
                React$5.createElement(
                  'div',
                  { className: classes$1.action },
                  Vt
                )
            )
        )
      )
    )
  },
  collapse = {
    container: '& > .MuiCollapse-container, & > .MuiCollapse-root',
    wrapper:
      '& > .MuiCollapse-container > .MuiCollapse-wrapper, & > .MuiCollapse-root > .MuiCollapse-wrapper',
  },
  xsWidthMargin = 16,
  componentName$2 = 'SnackbarContainer',
  classes$2 = {
    root: componentName$2 + '-root',
    rootDense: componentName$2 + '-rootDense',
    top: componentName$2 + '-top',
    bottom: componentName$2 + '-bottom',
    left: componentName$2 + '-left',
    right: componentName$2 + '-right',
    center: componentName$2 + '-center',
  },
  Root$1$1 = styled('div')(function(o) {
    var a,
      s,
      $,
      j,
      _e,
      et,
      tt = o.theme
    return (
      (et = {}),
      (et['&.' + classes$2.root] =
        ((a = {
          boxSizing: 'border-box',
          display: 'flex',
          maxHeight: '100%',
          position: 'fixed',
          zIndex: tt.zIndex.snackbar,
          height: 'auto',
          width: 'auto',
          transition:
            'top 300ms ease 0ms, right 300ms ease 0ms, bottom 300ms ease 0ms, left 300ms ease 0ms, margin 300ms ease 0ms, max-width 300ms ease 0ms',
          pointerEvents: 'none',
        }),
        (a[collapse.container] = { pointerEvents: 'all' }),
        (a[collapse.wrapper] = {
          padding: SNACKBAR_INDENTS.snackbar.default + 'px 0px',
          transition: 'padding 300ms ease 0ms',
        }),
        (a.maxWidth =
          'calc(100% - ' + SNACKBAR_INDENTS.view.default * 2 + 'px)'),
        (a[tt.breakpoints.down('sm')] = {
          width: '100%',
          maxWidth: 'calc(100% - ' + xsWidthMargin * 2 + 'px)',
        }),
        a)),
      (et['&.' + classes$2.rootDense] =
        ((s = {}),
        (s[collapse.wrapper] = {
          padding: SNACKBAR_INDENTS.snackbar.dense + 'px 0px',
        }),
        s)),
      (et['&.' + classes$2.top] = {
        top: SNACKBAR_INDENTS.view.default - SNACKBAR_INDENTS.snackbar.default,
        flexDirection: 'column',
      }),
      (et['&.' + classes$2.bottom] = {
        bottom:
          SNACKBAR_INDENTS.view.default - SNACKBAR_INDENTS.snackbar.default,
        flexDirection: 'column-reverse',
      }),
      (et['&.' + classes$2.left] =
        (($ = { left: SNACKBAR_INDENTS.view.default }),
        ($[tt.breakpoints.up('sm')] = { alignItems: 'flex-start' }),
        ($[tt.breakpoints.down('sm')] = { left: xsWidthMargin + 'px' }),
        $)),
      (et['&.' + classes$2.right] =
        ((j = { right: SNACKBAR_INDENTS.view.default }),
        (j[tt.breakpoints.up('sm')] = { alignItems: 'flex-end' }),
        (j[tt.breakpoints.down('sm')] = { right: xsWidthMargin + 'px' }),
        j)),
      (et['&.' + classes$2.center] =
        ((_e = { left: '50%', transform: 'translateX(-50%)' }),
        (_e[tt.breakpoints.up('sm')] = { alignItems: 'center' }),
        _e)),
      et
    )
  }),
  SnackbarContainer = function(a) {
    var s = a.className,
      $ = a.anchorOrigin,
      j = a.dense,
      _e = _objectWithoutPropertiesLoose$1(a, [
        'className',
        'anchorOrigin',
        'dense',
      ]),
      et = clsx(
        classes$2[$.vertical],
        classes$2[$.horizontal],
        classes$2.root,
        s,
        j && classes$2.rootDense
      )
    return React$5.createElement(Root$1$1, Object.assign({ className: et }, _e))
  },
  SnackbarContainer$1 = React$5.memo(SnackbarContainer),
  SnackbarProvider = (function(o) {
    _inheritsLoose$1(a, o)
    function a($) {
      var j
      return (
        (j = o.call(this, $) || this),
        (j.enqueueSnackbar = function(_e, et) {
          et === void 0 && (et = {})
          var tt = et,
            rt = tt.key,
            nt = tt.preventDuplicate,
            it = _objectWithoutPropertiesLoose$1(tt, [
              'key',
              'preventDuplicate',
            ]),
            ot = isDefined(rt),
            at = ot ? rt : new Date().getTime() + Math.random(),
            st = merge(it, j.props, DEFAULTS),
            ut = _extends$2({ key: at }, it, {
              message: _e,
              open: !0,
              entered: !1,
              requestClose: !1,
              variant: st('variant'),
              anchorOrigin: st('anchorOrigin'),
              autoHideDuration: st('autoHideDuration'),
            })
          return (
            it.persist && (ut.autoHideDuration = void 0),
            j.setState(function(ct) {
              if ((nt === void 0 && j.props.preventDuplicate) || nt) {
                var dt = function(yt) {
                    return ot ? yt.key === rt : yt.message === _e
                  },
                  ft = ct.queue.findIndex(dt) > -1,
                  mt = ct.snacks.findIndex(dt) > -1
                if (ft || mt) return ct
              }
              return j.handleDisplaySnack(
                _extends$2({}, ct, { queue: [].concat(ct.queue, [ut]) })
              )
            }),
            at
          )
        }),
        (j.handleDisplaySnack = function(_e) {
          var et = _e.snacks
          return et.length >= j.maxSnack
            ? j.handleDismissOldest(_e)
            : j.processQueue(_e)
        }),
        (j.processQueue = function(_e) {
          var et = _e.queue,
            tt = _e.snacks
          return et.length > 0
            ? _extends$2({}, _e, {
                snacks: [].concat(tt, [et[0]]),
                queue: et.slice(1, et.length),
              })
            : _e
        }),
        (j.handleDismissOldest = function(_e) {
          if (
            _e.snacks.some(function(it) {
              return !it.open || it.requestClose
            })
          )
            return _e
          var et = !1,
            tt = !1,
            rt = _e.snacks.reduce(function(it, ot) {
              return it + (ot.open && ot.persist ? 1 : 0)
            }, 0)
          rt === j.maxSnack && (tt = !0)
          var nt = _e.snacks.map(function(it) {
            return !et && (!it.persist || tt)
              ? ((et = !0),
                it.entered
                  ? (it.onClose && it.onClose(null, REASONS.MAXSNACK, it.key),
                    j.props.onClose &&
                      j.props.onClose(null, REASONS.MAXSNACK, it.key),
                    _extends$2({}, it, { open: !1 }))
                  : _extends$2({}, it, { requestClose: !0 }))
              : _extends$2({}, it)
          })
          return _extends$2({}, _e, { snacks: nt })
        }),
        (j.handleEnteredSnack = function(_e, et, tt) {
          if (!isDefined(tt))
            throw new Error(
              'handleEnteredSnack Cannot be called with undefined key'
            )
          j.setState(function(rt) {
            var nt = rt.snacks
            return {
              snacks: nt.map(function(it) {
                return it.key === tt
                  ? _extends$2({}, it, { entered: !0 })
                  : _extends$2({}, it)
              }),
            }
          })
        }),
        (j.handleCloseSnack = function(_e, et, tt) {
          if (
            (j.props.onClose && j.props.onClose(_e, et, tt),
            et !== REASONS.CLICKAWAY)
          ) {
            var rt = tt === void 0
            j.setState(function(nt) {
              var it = nt.snacks,
                ot = nt.queue
              return {
                snacks: it.map(function(at) {
                  return !rt && at.key !== tt
                    ? _extends$2({}, at)
                    : at.entered
                    ? _extends$2({}, at, { open: !1 })
                    : _extends$2({}, at, { requestClose: !0 })
                }),
                queue: ot.filter(function(at) {
                  return at.key !== tt
                }),
              }
            })
          }
        }),
        (j.closeSnackbar = function(_e) {
          var et = j.state.snacks.find(function(tt) {
            return tt.key === _e
          })
          isDefined(_e) &&
            et &&
            et.onClose &&
            et.onClose(null, REASONS.INSTRUCTED, _e),
            j.handleCloseSnack(null, REASONS.INSTRUCTED, _e)
        }),
        (j.handleExitedSnack = function(_e, et, tt) {
          var rt = et || tt
          if (!isDefined(rt))
            throw new Error(
              'handleExitedSnack Cannot be called with undefined key'
            )
          j.setState(function(nt) {
            var it = j.processQueue(
              _extends$2({}, nt, {
                snacks: nt.snacks.filter(function(ot) {
                  return ot.key !== rt
                }),
              })
            )
            return it.queue.length === 0 ? it : j.handleDismissOldest(it)
          })
        }),
        (j.state = {
          snacks: [],
          queue: [],
          contextValue: {
            enqueueSnackbar: j.enqueueSnackbar.bind(_assertThisInitialized(j)),
            closeSnackbar: j.closeSnackbar.bind(_assertThisInitialized(j)),
          },
        }),
        j
      )
    }
    var s = a.prototype
    return (
      (s.render = function() {
        var j = this,
          _e = this.state.contextValue,
          et = this.props,
          tt = et.iconVariant,
          rt = et.dense,
          nt = rt === void 0 ? DEFAULTS.dense : rt,
          it = et.hideIconVariant,
          ot = it === void 0 ? DEFAULTS.hideIconVariant : it,
          at = et.domRoot,
          st = et.children,
          ut = et.classes,
          ct = ut === void 0 ? {} : ut,
          dt = _objectWithoutPropertiesLoose$1(et, [
            'maxSnack',
            'preventDuplicate',
            'variant',
            'anchorOrigin',
            'iconVariant',
            'dense',
            'hideIconVariant',
            'domRoot',
            'children',
            'classes',
          ]),
          ft = this.state.snacks.reduce(function(vt, yt) {
            var pt,
              ht = originKeyExtractor(yt.anchorOrigin),
              At = vt[ht] || []
            return _extends$2(
              {},
              vt,
              ((pt = {}), (pt[ht] = [].concat(At, [yt])), pt)
            )
          }, {}),
          mt = Object.keys(ft).map(function(vt) {
            var yt = ft[vt]
            return React$5.createElement(
              SnackbarContainer$1,
              {
                key: vt,
                dense: nt,
                anchorOrigin: yt[0].anchorOrigin,
                className: clsx(
                  ct.containerRoot,
                  ct[transformer.toContainerAnchorOrigin(vt)]
                ),
              },
              yt.map(function(pt) {
                return React$5.createElement(
                  SnackbarItem,
                  Object.assign({}, dt, {
                    key: pt.key,
                    snack: pt,
                    dense: nt,
                    iconVariant: tt,
                    hideIconVariant: ot,
                    classes: omitContainerKeys(ct),
                    onClose: j.handleCloseSnack,
                    onExited: createChainedFunction([
                      j.handleExitedSnack,
                      j.props.onExited,
                    ]),
                    onEntered: createChainedFunction([
                      j.handleEnteredSnack,
                      j.props.onEntered,
                    ]),
                  })
                )
              })
            )
          })
        return React$5.createElement(
          SnackbarContext.Provider,
          { value: _e },
          st,
          at ? reactDomExports.createPortal(mt, at) : mt
        )
      }),
      _createClass$2(a, [
        {
          key: 'maxSnack',
          get: function() {
            return this.props.maxSnack || DEFAULTS.maxSnack
          },
        },
      ]),
      a
    )
  })(reactExports.Component),
  withSnackbar = function(a) {
    var s = React$5.forwardRef(function($, j) {
      return React$5.createElement(SnackbarContext.Consumer, null, function(
        _e
      ) {
        return React$5.createElement(
          a,
          _extends$2({}, $, {
            ref: j,
            enqueueSnackbar: _e.enqueueSnackbar,
            closeSnackbar: _e.closeSnackbar,
          })
        )
      })
    })
    return hoistNonReactStatics$1(s, a), s
  },
  define_global_default$7 = {},
  FUNC_ERROR_TEXT$1 = 'Expected a function',
  NAN$1 = NaN,
  symbolTag$1 = '[object Symbol]',
  reTrim$1 = /^\s+|\s+$/g,
  reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i,
  reIsBinary$1 = /^0b[01]+$/i,
  reIsOctal$1 = /^0o[0-7]+$/i,
  freeParseInt$1 = parseInt,
  freeGlobal$1 =
    typeof define_global_default$7 == 'object' &&
    define_global_default$7 &&
    define_global_default$7.Object === Object &&
    define_global_default$7,
  freeSelf$1 =
    typeof self == 'object' && self && self.Object === Object && self,
  root$2 = freeGlobal$1 || freeSelf$1 || Function('return this')(),
  objectProto$1 = Object.prototype,
  objectToString$2 = objectProto$1.toString,
  nativeMax$1 = Math.max,
  nativeMin$1 = Math.min,
  now$1 = function() {
    return root$2.Date.now()
  }
function debounce$1(o, a, s) {
  var $,
    j,
    _e,
    et,
    tt,
    rt,
    nt = 0,
    it = !1,
    ot = !1,
    at = !0
  if (typeof o != 'function') throw new TypeError(FUNC_ERROR_TEXT$1)
  ;(a = toNumber$1(a) || 0),
    isObject$2(s) &&
      ((it = !!s.leading),
      (ot = 'maxWait' in s),
      (_e = ot ? nativeMax$1(toNumber$1(s.maxWait) || 0, a) : _e),
      (at = 'trailing' in s ? !!s.trailing : at))
  function st(ht) {
    var At = $,
      wt = j
    return ($ = j = void 0), (nt = ht), (et = o.apply(wt, At)), et
  }
  function ut(ht) {
    return (nt = ht), (tt = setTimeout(ft, a)), it ? st(ht) : et
  }
  function ct(ht) {
    var At = ht - rt,
      wt = ht - nt,
      Ct = a - At
    return ot ? nativeMin$1(Ct, _e - wt) : Ct
  }
  function dt(ht) {
    var At = ht - rt,
      wt = ht - nt
    return rt === void 0 || At >= a || At < 0 || (ot && wt >= _e)
  }
  function ft() {
    var ht = now$1()
    if (dt(ht)) return mt(ht)
    tt = setTimeout(ft, ct(ht))
  }
  function mt(ht) {
    return (tt = void 0), at && $ ? st(ht) : (($ = j = void 0), et)
  }
  function vt() {
    tt !== void 0 && clearTimeout(tt), (nt = 0), ($ = rt = j = tt = void 0)
  }
  function yt() {
    return tt === void 0 ? et : mt(now$1())
  }
  function pt() {
    var ht = now$1(),
      At = dt(ht)
    if ((($ = arguments), (j = this), (rt = ht), At)) {
      if (tt === void 0) return ut(rt)
      if (ot) return (tt = setTimeout(ft, a)), st(rt)
    }
    return tt === void 0 && (tt = setTimeout(ft, a)), et
  }
  return (pt.cancel = vt), (pt.flush = yt), pt
}
function isObject$2(o) {
  var a = typeof o
  return !!o && (a == 'object' || a == 'function')
}
function isObjectLike$1(o) {
  return !!o && typeof o == 'object'
}
function isSymbol$2(o) {
  return (
    typeof o == 'symbol' ||
    (isObjectLike$1(o) && objectToString$2.call(o) == symbolTag$1)
  )
}
function toNumber$1(o) {
  if (typeof o == 'number') return o
  if (isSymbol$2(o)) return NAN$1
  if (isObject$2(o)) {
    var a = typeof o.valueOf == 'function' ? o.valueOf() : o
    o = isObject$2(a) ? a + '' : a
  }
  if (typeof o != 'string') return o === 0 ? o : +o
  o = o.replace(reTrim$1, '')
  var s = reIsBinary$1.test(o)
  return s || reIsOctal$1.test(o)
    ? freeParseInt$1(o.slice(2), s ? 2 : 8)
    : reIsBadHex$1.test(o)
    ? NAN$1
    : +o
}
var lodash_debounce = debounce$1
const debounce$2 = getDefaultExportFromCjs(lodash_debounce)
var define_global_default$6 = {},
  FUNC_ERROR_TEXT = 'Expected a function',
  NAN = NaN,
  symbolTag = '[object Symbol]',
  reTrim = /^\s+|\s+$/g,
  reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
  reIsBinary = /^0b[01]+$/i,
  reIsOctal = /^0o[0-7]+$/i,
  freeParseInt = parseInt,
  freeGlobal =
    typeof define_global_default$6 == 'object' &&
    define_global_default$6 &&
    define_global_default$6.Object === Object &&
    define_global_default$6,
  freeSelf = typeof self == 'object' && self && self.Object === Object && self,
  root$1 = freeGlobal || freeSelf || Function('return this')(),
  objectProto = Object.prototype,
  objectToString$1 = objectProto.toString,
  nativeMax = Math.max,
  nativeMin = Math.min,
  now = function() {
    return root$1.Date.now()
  }
function debounce(o, a, s) {
  var $,
    j,
    _e,
    et,
    tt,
    rt,
    nt = 0,
    it = !1,
    ot = !1,
    at = !0
  if (typeof o != 'function') throw new TypeError(FUNC_ERROR_TEXT)
  ;(a = toNumber(a) || 0),
    isObject$1(s) &&
      ((it = !!s.leading),
      (ot = 'maxWait' in s),
      (_e = ot ? nativeMax(toNumber(s.maxWait) || 0, a) : _e),
      (at = 'trailing' in s ? !!s.trailing : at))
  function st(ht) {
    var At = $,
      wt = j
    return ($ = j = void 0), (nt = ht), (et = o.apply(wt, At)), et
  }
  function ut(ht) {
    return (nt = ht), (tt = setTimeout(ft, a)), it ? st(ht) : et
  }
  function ct(ht) {
    var At = ht - rt,
      wt = ht - nt,
      Ct = a - At
    return ot ? nativeMin(Ct, _e - wt) : Ct
  }
  function dt(ht) {
    var At = ht - rt,
      wt = ht - nt
    return rt === void 0 || At >= a || At < 0 || (ot && wt >= _e)
  }
  function ft() {
    var ht = now()
    if (dt(ht)) return mt(ht)
    tt = setTimeout(ft, ct(ht))
  }
  function mt(ht) {
    return (tt = void 0), at && $ ? st(ht) : (($ = j = void 0), et)
  }
  function vt() {
    tt !== void 0 && clearTimeout(tt), (nt = 0), ($ = rt = j = tt = void 0)
  }
  function yt() {
    return tt === void 0 ? et : mt(now())
  }
  function pt() {
    var ht = now(),
      At = dt(ht)
    if ((($ = arguments), (j = this), (rt = ht), At)) {
      if (tt === void 0) return ut(rt)
      if (ot) return (tt = setTimeout(ft, a)), st(rt)
    }
    return tt === void 0 && (tt = setTimeout(ft, a)), et
  }
  return (pt.cancel = vt), (pt.flush = yt), pt
}
function throttle(o, a, s) {
  var $ = !0,
    j = !0
  if (typeof o != 'function') throw new TypeError(FUNC_ERROR_TEXT)
  return (
    isObject$1(s) &&
      (($ = 'leading' in s ? !!s.leading : $),
      (j = 'trailing' in s ? !!s.trailing : j)),
    debounce(o, a, { leading: $, maxWait: a, trailing: j })
  )
}
function isObject$1(o) {
  var a = typeof o
  return !!o && (a == 'object' || a == 'function')
}
function isObjectLike(o) {
  return !!o && typeof o == 'object'
}
function isSymbol$1(o) {
  return (
    typeof o == 'symbol' ||
    (isObjectLike(o) && objectToString$1.call(o) == symbolTag)
  )
}
function toNumber(o) {
  if (typeof o == 'number') return o
  if (isSymbol$1(o)) return NAN
  if (isObject$1(o)) {
    var a = typeof o.valueOf == 'function' ? o.valueOf() : o
    o = isObject$1(a) ? a + '' : a
  }
  if (typeof o != 'string') return o === 0 ? o : +o
  o = o.replace(reTrim, '')
  var s = reIsBinary.test(o)
  return s || reIsOctal.test(o)
    ? freeParseInt(o.slice(2), s ? 2 : 8)
    : reIsBadHex.test(o)
    ? NAN
    : +o
}
var lodash_throttle = throttle
const throttle$1 = getDefaultExportFromCjs(lodash_throttle)
var classnames = { exports: {} }
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ ;(function(
  o
) {
  ;(function() {
    var a = {}.hasOwnProperty
    function s() {
      for (var _e = '', et = 0; et < arguments.length; et++) {
        var tt = arguments[et]
        tt && (_e = j(_e, $(tt)))
      }
      return _e
    }
    function $(_e) {
      if (typeof _e == 'string' || typeof _e == 'number') return _e
      if (typeof _e != 'object') return ''
      if (Array.isArray(_e)) return s.apply(null, _e)
      if (
        _e.toString !== Object.prototype.toString &&
        !_e.toString.toString().includes('[native code]')
      )
        return _e.toString()
      var et = ''
      for (var tt in _e) a.call(_e, tt) && _e[tt] && (et = j(et, tt))
      return et
    }
    function j(_e, et) {
      return et ? (_e ? _e + ' ' + et : _e + et) : _e
    }
    o.exports ? ((s.default = s), (o.exports = s)) : (window.classNames = s)
  })()
})(classnames)
var classnamesExports = classnames.exports
const classNames = getDefaultExportFromCjs(classnamesExports)
var FileSaver_min = { exports: {} }
;(function(o, a) {
  var s = {}
  ;(function($, j) {
    j()
  })(commonjsGlobal$1, function() {
    function $(it, ot) {
      return (
        typeof ot > 'u'
          ? (ot = { autoBom: !1 })
          : typeof ot != 'object' &&
            (console.warn('Deprecated: Expected third argument to be a object'),
            (ot = { autoBom: !ot })),
        ot.autoBom &&
        /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(
          it.type
        )
          ? new Blob(['\uFEFF', it], { type: it.type })
          : it
      )
    }
    function j(it, ot, at) {
      var st = new XMLHttpRequest()
      st.open('GET', it),
        (st.responseType = 'blob'),
        (st.onload = function() {
          nt(st.response, ot, at)
        }),
        (st.onerror = function() {
          console.error('could not download file')
        }),
        st.send()
    }
    function _e(it) {
      var ot = new XMLHttpRequest()
      ot.open('HEAD', it, !1)
      try {
        ot.send()
      } catch {}
      return 200 <= ot.status && 299 >= ot.status
    }
    function et(it) {
      try {
        it.dispatchEvent(new MouseEvent('click'))
      } catch {
        var ot = document.createEvent('MouseEvents')
        ot.initMouseEvent(
          'click',
          !0,
          !0,
          window,
          0,
          0,
          0,
          80,
          20,
          !1,
          !1,
          !1,
          !1,
          0,
          null
        ),
          it.dispatchEvent(ot)
      }
    }
    var tt =
        typeof window == 'object' && window.window === window
          ? window
          : typeof self == 'object' && self.self === self
          ? self
          : typeof s == 'object' && s.global === s
          ? s
          : void 0,
      rt =
        tt.navigator &&
        /Macintosh/.test(navigator.userAgent) &&
        /AppleWebKit/.test(navigator.userAgent) &&
        !/Safari/.test(navigator.userAgent),
      nt =
        tt.saveAs ||
        (typeof window != 'object' || window !== tt
          ? function() {}
          : 'download' in HTMLAnchorElement.prototype && !rt
          ? function(it, ot, at) {
              var st = tt.URL || tt.webkitURL,
                ut = document.createElement('a')
              ;(ot = ot || it.name || 'download'),
                (ut.download = ot),
                (ut.rel = 'noopener'),
                typeof it == 'string'
                  ? ((ut.href = it),
                    ut.origin === location.origin
                      ? et(ut)
                      : _e(ut.href)
                      ? j(it, ot, at)
                      : et(ut, (ut.target = '_blank')))
                  : ((ut.href = st.createObjectURL(it)),
                    setTimeout(function() {
                      st.revokeObjectURL(ut.href)
                    }, 4e4),
                    setTimeout(function() {
                      et(ut)
                    }, 0))
            }
          : 'msSaveOrOpenBlob' in navigator
          ? function(it, ot, at) {
              if (((ot = ot || it.name || 'download'), typeof it != 'string'))
                navigator.msSaveOrOpenBlob($(it, at), ot)
              else if (_e(it)) j(it, ot, at)
              else {
                var st = document.createElement('a')
                ;(st.href = it),
                  (st.target = '_blank'),
                  setTimeout(function() {
                    et(st)
                  })
              }
            }
          : function(it, ot, at, st) {
              if (
                ((st = st || open('', '_blank')),
                st &&
                  (st.document.title = st.document.body.innerText =
                    'downloading...'),
                typeof it == 'string')
              )
                return j(it, ot, at)
              var ut = it.type === 'application/octet-stream',
                ct = /constructor/i.test(tt.HTMLElement) || tt.safari,
                dt = /CriOS\/[\d]+/.test(navigator.userAgent)
              if ((dt || (ut && ct) || rt) && typeof FileReader < 'u') {
                var ft = new FileReader()
                ;(ft.onloadend = function() {
                  var yt = ft.result
                  ;(yt = dt
                    ? yt
                    : yt.replace(/^data:[^;]*;/, 'data:attachment/file;')),
                    st ? (st.location.href = yt) : (location = yt),
                    (st = null)
                }),
                  ft.readAsDataURL(it)
              } else {
                var mt = tt.URL || tt.webkitURL,
                  vt = mt.createObjectURL(it)
                st ? (st.location = vt) : (location.href = vt),
                  (st = null),
                  setTimeout(function() {
                    mt.revokeObjectURL(vt)
                  }, 4e4)
              }
            })
    ;(tt.saveAs = nt.saveAs = nt), (o.exports = nt)
  })
})(FileSaver_min)
var FileSaver_minExports = FileSaver_min.exports,
  Defaults = { defaultAmount: 0, defaultCurrency: 'USD', defaultPrecision: 2 },
  Globals = {
    globalLocale: 'en-US',
    globalFormat: '$0,0.00',
    globalRoundingMode: 'HALF_EVEN',
    globalFormatRoundingMode: 'HALF_AWAY_FROM_ZERO',
    globalExchangeRatesApi: {
      endpoint: void 0,
      headers: void 0,
      propertyPath: void 0,
    },
  }
function _typeof$5(o) {
  '@babel/helpers - typeof'
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (_typeof$5 = function(a) {
          return typeof a
        })
      : (_typeof$5 = function(a) {
          return a &&
            typeof Symbol == 'function' &&
            a.constructor === Symbol &&
            a !== Symbol.prototype
            ? 'symbol'
            : typeof a
        }),
    _typeof$5(o)
  )
}
function _toArray(o) {
  return (
    _arrayWithHoles$1(o) ||
    _iterableToArray$2(o) ||
    _unsupportedIterableToArray$1(o) ||
    _nonIterableRest$1()
  )
}
function _arrayWithHoles$1(o) {
  if (Array.isArray(o)) return o
}
function _iterableToArray$2(o) {
  if (typeof Symbol < 'u' && Symbol.iterator in Object(o)) return Array.from(o)
}
function _unsupportedIterableToArray$1(o, a) {
  if (o) {
    if (typeof o == 'string') return _arrayLikeToArray$1(o, a)
    var s = Object.prototype.toString.call(o).slice(8, -1)
    if (
      (s === 'Object' && o.constructor && (s = o.constructor.name),
      s === 'Map' || s === 'Set')
    )
      return Array.from(o)
    if (s === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s))
      return _arrayLikeToArray$1(o, a)
  }
}
function _arrayLikeToArray$1(o, a) {
  ;(a == null || a > o.length) && (a = o.length)
  for (var s = 0, $ = new Array(a); s < a; s++) $[s] = o[s]
  return $
}
function _nonIterableRest$1() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
var Static = {
  normalizePrecision: function(a) {
    var s = a.reduce(function($, j) {
      return Math.max($.getPrecision(), j.getPrecision())
    })
    return a.map(function($) {
      return $.getPrecision() !== s ? $.convertPrecision(s) : $
    })
  },
  minimum: function(a) {
    var s = _toArray(a),
      $ = s[0],
      j = s.slice(1),
      _e = $
    return (
      j.forEach(function(et) {
        _e = _e.lessThan(et) ? _e : et
      }),
      _e
    )
  },
  maximum: function(a) {
    var s = _toArray(a),
      $ = s[0],
      j = s.slice(1),
      _e = $
    return (
      j.forEach(function(et) {
        _e = _e.greaterThan(et) ? _e : et
      }),
      _e
    )
  },
}
function isNumeric(o) {
  return !isNaN(parseInt(o)) && isFinite(o)
}
function isPercentage$1(o) {
  return isNumeric(o) && o <= 100 && o >= 0
}
function areValidRatios(o) {
  return (
    o.length > 0 &&
    o.every(function(a) {
      return a >= 0
    }) &&
    o.some(function(a) {
      return a > 0
    })
  )
}
function isEven(o) {
  return o % 2 === 0
}
function isFloat(o) {
  return isNumeric(o) && !Number.isInteger(o)
}
function countFractionDigits() {
  var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0,
    a = o.toString()
  if (a.indexOf('e-') > 0) return parseInt(a.split('e-')[1])
  var s = a.split('.')[1]
  return s ? s.length : 0
}
function isHalf(o) {
  return Math.abs(o) % 1 === 0.5
}
function getJSON(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  return new Promise(function(s, $) {
    var j = Object.assign(new XMLHttpRequest(), {
      onreadystatechange: function() {
        j.readyState === 4 &&
          (j.status >= 200 && j.status < 400
            ? s(JSON.parse(j.responseText))
            : $(new Error(j.statusText)))
      },
      onerror: function() {
        $(new Error('Network error'))
      },
    })
    j.open('GET', o, !0), setXHRHeaders(j, a.headers), j.send()
  })
}
function setXHRHeaders(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
  for (var s in a) o.setRequestHeader(s, a[s])
  return o
}
function isUndefined$1(o) {
  return typeof o > 'u'
}
function flattenObject(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '.',
    s = {}
  return (
    Object.entries(o).forEach(function($) {
      if (_typeof$5($[1]) === 'object') {
        var j = flattenObject($[1])
        Object.entries(j).forEach(function(_e) {
          s[$[0] + a + _e[0]] = _e[1]
        })
      } else s[$[0]] = $[1]
    }),
    s
  )
}
function isThenable(o) {
  return (
    !!o &&
    (_typeof$5(o) === 'object' || typeof o == 'function') &&
    typeof o.then == 'function'
  )
}
function Calculator() {
  var o = function($, j) {
      var _e = function(rt) {
          return Math.pow(10, countFractionDigits(rt))
        },
        et = Math.max(_e($), _e(j))
      return (Math.round($ * et) * Math.round(j * et)) / (et * et)
    },
    a = {
      HALF_ODD: function($) {
        var j = Math.round($)
        return isHalf($) && isEven(j) ? j - 1 : j
      },
      HALF_EVEN: function($) {
        var j = Math.round($)
        return isHalf($) ? (isEven(j) ? j : j - 1) : j
      },
      HALF_UP: function($) {
        return Math.round($)
      },
      HALF_DOWN: function($) {
        return isHalf($) ? Math.floor($) : Math.round($)
      },
      HALF_TOWARDS_ZERO: function($) {
        return isHalf($)
          ? Math.sign($) * Math.floor(Math.abs($))
          : Math.round($)
      },
      HALF_AWAY_FROM_ZERO: function($) {
        return isHalf($) ? Math.sign($) * Math.ceil(Math.abs($)) : Math.round($)
      },
      DOWN: function($) {
        return Math.floor($)
      },
    }
  return {
    add: function($, j) {
      return $ + j
    },
    subtract: function($, j) {
      return $ - j
    },
    multiply: function($, j) {
      return isFloat($) || isFloat(j) ? o($, j) : $ * j
    },
    divide: function($, j) {
      return $ / j
    },
    modulo: function($, j) {
      return $ % j
    },
    round: function($) {
      var j =
        arguments.length > 1 && arguments[1] !== void 0
          ? arguments[1]
          : 'HALF_EVEN'
      return a[j]($)
    },
  }
}
var calculator = Calculator()
function Format(o) {
  var a = /^(?:(\$|USD)?0(?:(,)0)?(\.)?(0+)?|0(?:(,)0)?(\.)?(0+)?\s?(dollar)?)$/gm.exec(
    o
  )
  return {
    getMatches: function() {
      return a !== null
        ? a.slice(1).filter(function($) {
            return !isUndefined$1($)
          })
        : []
    },
    getMinimumFractionDigits: function() {
      var $ = function(_e) {
        return _e === '.'
      }
      return isUndefined$1(this.getMatches().find($))
        ? 0
        : this.getMatches()[
            calculator.add(this.getMatches().findIndex($), 1)
          ].split('').length
    },
    getCurrencyDisplay: function() {
      var $ = { USD: 'code', dollar: 'name', $: 'symbol' }
      return $[
        this.getMatches().find(function(j) {
          return j === 'USD' || j === 'dollar' || j === '$'
        })
      ]
    },
    getStyle: function() {
      return isUndefined$1(this.getCurrencyDisplay(this.getMatches()))
        ? 'decimal'
        : 'currency'
    },
    getUseGrouping: function() {
      return !isUndefined$1(
        this.getMatches().find(function($) {
          return $ === ','
        })
      )
    },
  }
}
function CurrencyConverter(o) {
  var a = function() {
      var j =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : '',
        _e = arguments.length > 1 ? arguments[1] : void 0
      for (var et in _e) j = j.replace('{{'.concat(et, '}}'), _e[et])
      return j
    },
    s = function(j, _e) {
      return getJSON(a(o.endpoint, { from: j, to: _e }), { headers: o.headers })
    }
  return {
    getExchangeRate: function(j, _e) {
      return (isThenable(o.endpoint) ? o.endpoint : s(j, _e)).then(function(
        et
      ) {
        return flattenObject(et)[a(o.propertyPath, { from: j, to: _e })]
      })
    },
  }
}
function assert$1(o, a) {
  var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Error
  if (!o) throw new s(a)
}
function assertPercentage(o) {
  assert$1(
    isPercentage$1(o),
    'You must provide a numeric value between 0 and 100.',
    RangeError
  )
}
function assertValidRatios(o) {
  assert$1(
    areValidRatios(o),
    'You must provide a non-empty array of numeric values greater than 0.',
    TypeError
  )
}
function assertInteger(o) {
  assert$1(Number.isInteger(o), 'You must provide an integer.', TypeError)
}
var calculator$1 = Calculator(),
  Dinero = function o(a) {
    var s = Object.assign(
        {},
        {
          amount: o.defaultAmount,
          currency: o.defaultCurrency,
          precision: o.defaultPrecision,
        },
        a
      ),
      $ = s.amount,
      j = s.currency,
      _e = s.precision
    assertInteger($), assertInteger(_e)
    var et = o.globalLocale,
      tt = o.globalFormat,
      rt = o.globalRoundingMode,
      nt = o.globalFormatRoundingMode,
      it = Object.assign({}, o.globalExchangeRatesApi),
      ot = function(ut) {
        var ct = Object.assign(
          {},
          Object.assign({}, { amount: $, currency: j, precision: _e }, ut),
          Object.assign({}, { locale: this.locale }, ut)
        )
        return Object.assign(
          o({
            amount: ct.amount,
            currency: ct.currency,
            precision: ct.precision,
          }),
          { locale: ct.locale }
        )
      },
      at = function(ut) {
        assert$1(
          this.hasSameCurrency(ut),
          'You must provide a Dinero instance with the same currency.',
          TypeError
        )
      }
    return {
      getAmount: function() {
        return $
      },
      getCurrency: function() {
        return j
      },
      getLocale: function() {
        return this.locale || et
      },
      setLocale: function(ut) {
        return ot.call(this, { locale: ut })
      },
      getPrecision: function() {
        return _e
      },
      convertPrecision: function(ut) {
        var ct =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : nt
        assertInteger(ut)
        var dt = this.getPrecision(),
          ft = ut > dt,
          mt = ft ? calculator$1.multiply : calculator$1.divide,
          vt = ft ? [ut, dt] : [dt, ut],
          yt = Math.pow(10, calculator$1.subtract.apply(calculator$1, vt))
        return ot.call(this, {
          amount: calculator$1.round(mt(this.getAmount(), yt), ct),
          precision: ut,
        })
      },
      add: function(ut) {
        at.call(this, ut)
        var ct = o.normalizePrecision([this, ut])
        return ot.call(this, {
          amount: calculator$1.add(ct[0].getAmount(), ct[1].getAmount()),
          precision: ct[0].getPrecision(),
        })
      },
      subtract: function(ut) {
        at.call(this, ut)
        var ct = o.normalizePrecision([this, ut])
        return ot.call(this, {
          amount: calculator$1.subtract(ct[0].getAmount(), ct[1].getAmount()),
          precision: ct[0].getPrecision(),
        })
      },
      multiply: function(ut) {
        var ct =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rt
        return ot.call(this, {
          amount: calculator$1.round(
            calculator$1.multiply(this.getAmount(), ut),
            ct
          ),
        })
      },
      divide: function(ut) {
        var ct =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rt
        return ot.call(this, {
          amount: calculator$1.round(
            calculator$1.divide(this.getAmount(), ut),
            ct
          ),
        })
      },
      percentage: function(ut) {
        var ct =
          arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : rt
        return (
          assertPercentage(ut), this.multiply(calculator$1.divide(ut, 100), ct)
        )
      },
      allocate: function(ut) {
        var ct = this
        assertValidRatios(ut)
        for (
          var dt = ut.reduce(function(yt, pt) {
              return calculator$1.add(yt, pt)
            }),
            ft = this.getAmount(),
            mt = ut.map(function(yt) {
              var pt = Math.floor(
                calculator$1.divide(
                  calculator$1.multiply(ct.getAmount(), yt),
                  dt
                )
              )
              return (
                (ft = calculator$1.subtract(ft, pt)),
                ot.call(ct, { amount: pt })
              )
            }),
            vt = 0;
          ft > 0;

        )
          ut[vt] > 0 &&
            ((mt[vt] = mt[vt].add(ot.call(this, { amount: 1 }))),
            (ft = calculator$1.subtract(ft, 1))),
            (vt += 1)
        return mt
      },
      convert: function(ut) {
        var ct = this,
          dt =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
          ft = dt.endpoint,
          mt = ft === void 0 ? it.endpoint : ft,
          vt = dt.propertyPath,
          yt = vt === void 0 ? it.propertyPath || 'rates.{{to}}' : vt,
          pt = dt.headers,
          ht = pt === void 0 ? it.headers : pt,
          At = dt.roundingMode,
          wt = At === void 0 ? rt : At,
          Ct = Object.assign(
            {},
            { endpoint: mt, propertyPath: yt, headers: ht, roundingMode: wt }
          )
        return CurrencyConverter(Ct)
          .getExchangeRate(this.getCurrency(), ut)
          .then(function(Dt) {
            return (
              assert$1(
                !isUndefined$1(Dt),
                'No rate was found for the destination currency "'.concat(
                  ut,
                  '".'
                ),
                TypeError
              ),
              ot.call(ct, {
                amount: calculator$1.round(
                  calculator$1.multiply(ct.getAmount(), parseFloat(Dt)),
                  Ct.roundingMode
                ),
                currency: ut,
              })
            )
          })
      },
      equalsTo: function(ut) {
        return this.hasSameAmount(ut) && this.hasSameCurrency(ut)
      },
      lessThan: function(ut) {
        at.call(this, ut)
        var ct = o.normalizePrecision([this, ut])
        return ct[0].getAmount() < ct[1].getAmount()
      },
      lessThanOrEqual: function(ut) {
        at.call(this, ut)
        var ct = o.normalizePrecision([this, ut])
        return ct[0].getAmount() <= ct[1].getAmount()
      },
      greaterThan: function(ut) {
        at.call(this, ut)
        var ct = o.normalizePrecision([this, ut])
        return ct[0].getAmount() > ct[1].getAmount()
      },
      greaterThanOrEqual: function(ut) {
        at.call(this, ut)
        var ct = o.normalizePrecision([this, ut])
        return ct[0].getAmount() >= ct[1].getAmount()
      },
      isZero: function() {
        return this.getAmount() === 0
      },
      isPositive: function() {
        return this.getAmount() >= 0
      },
      isNegative: function() {
        return this.getAmount() < 0
      },
      hasSubUnits: function() {
        return calculator$1.modulo(this.getAmount(), Math.pow(10, _e)) !== 0
      },
      hasCents: function() {
        return calculator$1.modulo(this.getAmount(), Math.pow(10, _e)) !== 0
      },
      hasSameCurrency: function(ut) {
        return this.getCurrency() === ut.getCurrency()
      },
      hasSameAmount: function(ut) {
        var ct = o.normalizePrecision([this, ut])
        return ct[0].getAmount() === ct[1].getAmount()
      },
      toFormat: function() {
        var ut =
            arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : tt,
          ct =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : nt,
          dt = Format(ut)
        return this.toRoundedUnit(
          dt.getMinimumFractionDigits(),
          ct
        ).toLocaleString(this.getLocale(), {
          currencyDisplay: dt.getCurrencyDisplay(),
          useGrouping: dt.getUseGrouping(),
          minimumFractionDigits: dt.getMinimumFractionDigits(),
          style: dt.getStyle(),
          currency: this.getCurrency(),
        })
      },
      toUnit: function() {
        return calculator$1.divide(this.getAmount(), Math.pow(10, _e))
      },
      toRoundedUnit: function(ut) {
        var ct =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : nt,
          dt = Math.pow(10, ut)
        return calculator$1.divide(
          calculator$1.round(calculator$1.multiply(this.toUnit(), dt), ct),
          dt
        )
      },
      toObject: function() {
        return { amount: $, currency: j, precision: _e }
      },
      toJSON: function() {
        return this.toObject()
      },
    }
  },
  dinero = Object.assign(Dinero, Defaults, Globals, Static),
  idbstore = { exports: {} }
/**
 * @license IDBWrapper - A cross-browser wrapper for IndexedDB
 * Version 1.7.2
 * Copyright (c) 2011 - 2017 Jens Arps
 * http://jensarps.de/
 *
 * Licensed under the MIT license
 */ ;(function(o) {
  ;(function(a, s, $) {
    o.exports ? (o.exports = s()) : ($[a] = s())
  })(
    'IDBStore',
    function() {
      var a = function(nt) {
          throw nt
        },
        s = function() {},
        $ = {
          storeName: 'Store',
          storePrefix: 'IDBWrapper-',
          dbVersion: 1,
          keyPath: 'id',
          autoIncrement: !0,
          onStoreReady: function() {},
          onError: a,
          indexes: [],
          implementationPreference: [
            'indexedDB',
            'webkitIndexedDB',
            'mozIndexedDB',
            'shimIndexedDB',
          ],
        },
        j = function(nt, it) {
          typeof it > 'u' && typeof nt == 'function' && (it = nt),
            Object.prototype.toString.call(nt) != '[object Object]' && (nt = {})
          for (var ot in $) this[ot] = typeof nt[ot] < 'u' ? nt[ot] : $[ot]
          ;(this.dbName = this.storePrefix + this.storeName),
            (this.dbVersion = parseInt(this.dbVersion, 10) || 1),
            it && (this.onStoreReady = it)
          var at = typeof window == 'object' ? window : self,
            st = this.implementationPreference.filter(function(ut) {
              return ut in at
            })
          ;(this.implementation = st[0]),
            (this.idb = at[this.implementation]),
            (this.keyRange =
              at.IDBKeyRange || at.webkitIDBKeyRange || at.mozIDBKeyRange),
            (this.consts = {
              READ_ONLY: 'readonly',
              READ_WRITE: 'readwrite',
              VERSION_CHANGE: 'versionchange',
              NEXT: 'next',
              NEXT_NO_DUPLICATE: 'nextunique',
              PREV: 'prev',
              PREV_NO_DUPLICATE: 'prevunique',
            }),
            this.openDB()
        },
        _e = {
          constructor: j,
          version: '1.7.2',
          db: null,
          dbName: null,
          dbVersion: null,
          store: null,
          storeName: null,
          storePrefix: null,
          keyPath: null,
          autoIncrement: null,
          indexes: null,
          implementationPreference: null,
          implementation: '',
          onStoreReady: null,
          onError: null,
          _insertIdCount: 0,
          openDB: function() {
            var nt = this.idb.open(this.dbName, this.dbVersion),
              it = !1
            ;(nt.onerror = function(ot) {
              if (rt(ot))
                this.onError(
                  new Error(
                    'The version number provided is lower than the existing one.'
                  )
                )
              else {
                var at
                if (ot.target.error) at = ot.target.error
                else {
                  var st =
                    'IndexedDB unknown error occurred when opening DB ' +
                    this.dbName +
                    ' version ' +
                    this.dbVersion
                  'errorCode' in ot.target &&
                    (st += ' with error code ' + ot.target.errorCode),
                    (at = new Error(st))
                }
                this.onError(at)
              }
            }.bind(this)),
              (nt.onsuccess = function(ot) {
                if (!it) {
                  if (this.db) {
                    this.onStoreReady()
                    return
                  }
                  if (
                    ((this.db = ot.target.result),
                    typeof this.db.version == 'string')
                  ) {
                    this.onError(
                      new Error(
                        'The IndexedDB implementation in this browser is outdated. Please upgrade your browser.'
                      )
                    )
                    return
                  }
                  if (!this.db.objectStoreNames.contains(this.storeName)) {
                    this.onError(new Error("Object store couldn't be created."))
                    return
                  }
                  var at = this.db.transaction(
                    [this.storeName],
                    this.consts.READ_ONLY
                  )
                  this.store = at.objectStore(this.storeName)
                  var st = Array.prototype.slice.call(this.getIndexList())
                  this.indexes.forEach(function(ut) {
                    var ct = ut.name
                    if (!ct) {
                      ;(it = !0),
                        this.onError(
                          new Error('Cannot create index: No index name given.')
                        )
                      return
                    }
                    if ((this.normalizeIndexData(ut), this.hasIndex(ct))) {
                      var dt = this.store.index(ct),
                        ft = this.indexComplies(dt, ut)
                      ft ||
                        ((it = !0),
                        this.onError(
                          new Error(
                            'Cannot modify index "' +
                              ct +
                              '" for current version. Please bump version number to ' +
                              (this.dbVersion + 1) +
                              '.'
                          )
                        )),
                        st.splice(st.indexOf(ct), 1)
                    } else (it = !0), this.onError(new Error('Cannot create new index "' + ct + '" for current version. Please bump version number to ' + (this.dbVersion + 1) + '.'))
                  }, this),
                    st.length &&
                      ((it = !0),
                      this.onError(
                        new Error(
                          'Cannot delete index(es) "' +
                            st.toString() +
                            '" for current version. Please bump version number to ' +
                            (this.dbVersion + 1) +
                            '.'
                        )
                      )),
                    it || this.onStoreReady()
                }
              }.bind(this)),
              (nt.onupgradeneeded = function(ot) {
                if (
                  ((this.db = ot.target.result),
                  this.db.objectStoreNames.contains(this.storeName))
                )
                  this.store = ot.target.transaction.objectStore(this.storeName)
                else {
                  var at = { autoIncrement: this.autoIncrement }
                  this.keyPath !== null && (at.keyPath = this.keyPath),
                    (this.store = this.db.createObjectStore(this.storeName, at))
                }
                var st = Array.prototype.slice.call(this.getIndexList())
                this.indexes.forEach(function(ut) {
                  var ct = ut.name
                  if (
                    (ct ||
                      ((it = !0),
                      this.onError(
                        new Error('Cannot create index: No index name given.')
                      )),
                    this.normalizeIndexData(ut),
                    this.hasIndex(ct))
                  ) {
                    var dt = this.store.index(ct),
                      ft = this.indexComplies(dt, ut)
                    ft ||
                      (this.store.deleteIndex(ct),
                      this.store.createIndex(ct, ut.keyPath, {
                        unique: ut.unique,
                        multiEntry: ut.multiEntry,
                      })),
                      st.splice(st.indexOf(ct), 1)
                  } else this.store.createIndex(ct, ut.keyPath, { unique: ut.unique, multiEntry: ut.multiEntry })
                }, this),
                  st.length &&
                    st.forEach(function(ut) {
                      this.store.deleteIndex(ut)
                    }, this)
              }.bind(this))
          },
          deleteDatabase: function(nt, it) {
            if (this.idb.deleteDatabase) {
              this.db.close()
              var ot = this.idb.deleteDatabase(this.dbName)
              ;(ot.onsuccess = nt), (ot.onerror = it)
            } else
              it(
                new Error('Browser does not support IndexedDB deleteDatabase!')
              )
          },
          put: function(nt, it, ot, at) {
            this.keyPath !== null && ((at = ot), (ot = it), (it = nt)),
              at || (at = a),
              ot || (ot = s)
            var st = !1,
              ut = null,
              ct,
              dt = this.db.transaction([this.storeName], this.consts.READ_WRITE)
            return (
              (dt.oncomplete = function() {
                var ft = st ? ot : at
                ft(ut)
              }),
              (dt.onabort = at),
              (dt.onerror = at),
              this.keyPath !== null
                ? (this._addIdPropertyIfNeeded(it),
                  (ct = dt.objectStore(this.storeName).put(it)))
                : (ct = dt.objectStore(this.storeName).put(it, nt)),
              (ct.onsuccess = function(ft) {
                ;(st = !0), (ut = ft.target.result)
              }),
              (ct.onerror = at),
              dt
            )
          },
          get: function(nt, it, ot) {
            ot || (ot = a), it || (it = s)
            var at = !1,
              st = null,
              ut = this.db.transaction([this.storeName], this.consts.READ_ONLY)
            ;(ut.oncomplete = function() {
              var dt = at ? it : ot
              dt(st)
            }),
              (ut.onabort = ot),
              (ut.onerror = ot)
            var ct = ut.objectStore(this.storeName).get(nt)
            return (
              (ct.onsuccess = function(dt) {
                ;(at = !0), (st = dt.target.result)
              }),
              (ct.onerror = ot),
              ut
            )
          },
          remove: function(nt, it, ot) {
            ot || (ot = a), it || (it = s)
            var at = !1,
              st = null,
              ut = this.db.transaction([this.storeName], this.consts.READ_WRITE)
            ;(ut.oncomplete = function() {
              var dt = at ? it : ot
              dt(st)
            }),
              (ut.onabort = ot),
              (ut.onerror = ot)
            var ct = ut.objectStore(this.storeName).delete(nt)
            return (
              (ct.onsuccess = function(dt) {
                ;(at = !0), (st = dt.target.result)
              }),
              (ct.onerror = ot),
              ut
            )
          },
          batch: function(nt, it, ot) {
            if (
              (ot || (ot = a),
              it || (it = s),
              Object.prototype.toString.call(nt) != '[object Array]')
            )
              ot(new Error('dataArray argument must be of type Array.'))
            else if (nt.length === 0) return it(!0)
            var at = nt.length,
              st = !1,
              ut = !1,
              ct = this.db.transaction([this.storeName], this.consts.READ_WRITE)
            ;(ct.oncomplete = function() {
              var ft = ut ? it : ot
              ft(ut)
            }),
              (ct.onabort = ot),
              (ct.onerror = ot)
            var dt = function() {
              at--, at === 0 && !st && ((st = !0), (ut = !0))
            }
            return (
              nt.forEach(function(ft) {
                var mt = ft.type,
                  vt = ft.key,
                  yt = ft.value,
                  pt = function(wt) {
                    ct.abort(), st || ((st = !0), ot(wt, mt, vt))
                  }
                if (mt == 'remove') {
                  var ht = ct.objectStore(this.storeName).delete(vt)
                  ;(ht.onsuccess = dt), (ht.onerror = pt)
                } else if (mt == 'put') {
                  var At
                  this.keyPath !== null
                    ? (this._addIdPropertyIfNeeded(yt),
                      (At = ct.objectStore(this.storeName).put(yt)))
                    : (At = ct.objectStore(this.storeName).put(yt, vt)),
                    (At.onsuccess = dt),
                    (At.onerror = pt)
                }
              }, this),
              ct
            )
          },
          putBatch: function(nt, it, ot) {
            var at = nt.map(function(st) {
              return { type: 'put', value: st }
            })
            return this.batch(at, it, ot)
          },
          upsertBatch: function(nt, it, ot, at) {
            typeof it == 'function' && ((ot = it), (at = ot), (it = {})),
              at || (at = a),
              ot || (ot = s),
              it || (it = {}),
              Object.prototype.toString.call(nt) != '[object Array]' &&
                at(new Error('dataArray argument must be of type Array.'))
            var st = it.keyField || this.keyPath,
              ut = nt.length,
              ct = !1,
              dt = !1,
              ft = 0,
              mt = this.db.transaction([this.storeName], this.consts.READ_WRITE)
            ;(mt.oncomplete = function() {
              dt ? ot(nt) : at(!1)
            }),
              (mt.onabort = at),
              (mt.onerror = at)
            var vt = function(yt) {
              var pt = nt[ft++]
              ;(pt[st] = yt.target.result),
                ut--,
                ut === 0 && !ct && ((ct = !0), (dt = !0))
            }
            return (
              nt.forEach(function(yt) {
                var pt = yt.key,
                  ht = function(wt) {
                    mt.abort(), ct || ((ct = !0), at(wt))
                  },
                  At
                this.keyPath !== null
                  ? (this._addIdPropertyIfNeeded(yt),
                    (At = mt.objectStore(this.storeName).put(yt)))
                  : (At = mt.objectStore(this.storeName).put(yt, pt)),
                  (At.onsuccess = vt),
                  (At.onerror = ht)
              }, this),
              mt
            )
          },
          removeBatch: function(nt, it, ot) {
            var at = nt.map(function(st) {
              return { type: 'remove', key: st }
            })
            return this.batch(at, it, ot)
          },
          getBatch: function(nt, it, ot, at) {
            if (
              (ot || (ot = a),
              it || (it = s),
              at || (at = 'sparse'),
              Object.prototype.toString.call(nt) != '[object Array]')
            )
              ot(new Error('keyArray argument must be of type Array.'))
            else if (nt.length === 0) return it([])
            var st = [],
              ut = nt.length,
              ct = !1,
              dt = null,
              ft = this.db.transaction([this.storeName], this.consts.READ_ONLY)
            ;(ft.oncomplete = function() {
              var vt = ct ? it : ot
              vt(dt)
            }),
              (ft.onabort = ot),
              (ft.onerror = ot)
            var mt = function(vt) {
              vt.target.result || at == 'dense'
                ? st.push(vt.target.result)
                : at == 'sparse' && st.length++,
                ut--,
                ut === 0 && ((ct = !0), (dt = st))
            }
            return (
              nt.forEach(function(vt) {
                var yt = function(ht) {
                    ;(dt = ht), ot(ht), ft.abort()
                  },
                  pt = ft.objectStore(this.storeName).get(vt)
                ;(pt.onsuccess = mt), (pt.onerror = yt)
              }, this),
              ft
            )
          },
          getAll: function(nt, it) {
            it || (it = a), nt || (nt = s)
            var ot = this.db.transaction(
                [this.storeName],
                this.consts.READ_ONLY
              ),
              at = ot.objectStore(this.storeName)
            return (
              at.getAll
                ? this._getAllNative(ot, at, nt, it)
                : this._getAllCursor(ot, at, nt, it),
              ot
            )
          },
          _getAllNative: function(nt, it, ot, at) {
            var st = !1,
              ut = null
            ;(nt.oncomplete = function() {
              var dt = st ? ot : at
              dt(ut)
            }),
              (nt.onabort = at),
              (nt.onerror = at)
            var ct = it.getAll()
            ;(ct.onsuccess = function(dt) {
              ;(st = !0), (ut = dt.target.result)
            }),
              (ct.onerror = at)
          },
          _getAllCursor: function(nt, it, ot, at) {
            var st = [],
              ut = !1,
              ct = null
            ;(nt.oncomplete = function() {
              var ft = ut ? ot : at
              ft(ct)
            }),
              (nt.onabort = at),
              (nt.onerror = at)
            var dt = it.openCursor()
            ;(dt.onsuccess = function(ft) {
              var mt = ft.target.result
              mt ? (st.push(mt.value), mt.continue()) : ((ut = !0), (ct = st))
            }),
              (dt.onError = at)
          },
          clear: function(nt, it) {
            it || (it = a), nt || (nt = s)
            var ot = !1,
              at = null,
              st = this.db.transaction([this.storeName], this.consts.READ_WRITE)
            ;(st.oncomplete = function() {
              var ct = ot ? nt : it
              ct(at)
            }),
              (st.onabort = it),
              (st.onerror = it)
            var ut = st.objectStore(this.storeName).clear()
            return (
              (ut.onsuccess = function(ct) {
                ;(ot = !0), (at = ct.target.result)
              }),
              (ut.onerror = it),
              st
            )
          },
          _addIdPropertyIfNeeded: function(nt) {
            typeof nt[this.keyPath] > 'u' &&
              (nt[this.keyPath] = this._insertIdCount++ + Date.now())
          },
          getIndexList: function() {
            return this.store.indexNames
          },
          hasIndex: function(nt) {
            return this.store.indexNames.contains(nt)
          },
          normalizeIndexData: function(nt) {
            ;(nt.keyPath = nt.keyPath || nt.name),
              (nt.unique = !!nt.unique),
              (nt.multiEntry = !!nt.multiEntry)
          },
          indexComplies: function(nt, it) {
            var ot = ['keyPath', 'unique', 'multiEntry'].every(function(at) {
              if (at == 'multiEntry' && nt[at] === void 0 && it[at] === !1)
                return !0
              if (
                at == 'keyPath' &&
                Object.prototype.toString.call(it[at]) == '[object Array]'
              ) {
                var st = it.keyPath,
                  ut = nt.keyPath
                if (typeof ut == 'string') return st.toString() == ut
                if (
                  !(
                    typeof ut.contains == 'function' ||
                    typeof ut.indexOf == 'function'
                  ) ||
                  ut.length !== st.length
                )
                  return !1
                for (var ct = 0, dt = st.length; ct < dt; ct++)
                  if (
                    !(
                      (ut.contains && ut.contains(st[ct])) ||
                      ut.indexOf(st[ct] !== -1)
                    )
                  )
                    return !1
                return !0
              }
              return it[at] == nt[at]
            })
            return ot
          },
          iterate: function(nt, it) {
            it = tt(
              {
                index: null,
                order: 'ASC',
                autoContinue: !0,
                filterDuplicates: !1,
                keyRange: null,
                writeAccess: !1,
                onEnd: null,
                onError: a,
                limit: 1 / 0,
                offset: 0,
                allowItemRejection: !1,
              },
              it || {}
            )
            var ot = it.order.toLowerCase() == 'desc' ? 'PREV' : 'NEXT'
            it.filterDuplicates && (ot += '_NO_DUPLICATE')
            var at = !1,
              st = this.db.transaction(
                [this.storeName],
                this.consts[it.writeAccess ? 'READ_WRITE' : 'READ_ONLY']
              ),
              ut = st.objectStore(this.storeName)
            it.index && (ut = ut.index(it.index))
            var ct = 0
            ;(st.oncomplete = function() {
              if (!at) {
                it.onError(null)
                return
              }
              it.onEnd ? it.onEnd() : nt(null)
            }),
              (st.onabort = it.onError),
              (st.onerror = it.onError)
            var dt = ut.openCursor(it.keyRange, this.consts[ot])
            return (
              (dt.onerror = it.onError),
              (dt.onsuccess = function(ft) {
                var mt = ft.target.result
                if (mt)
                  if (it.offset) mt.advance(it.offset), (it.offset = 0)
                  else {
                    var vt = nt(mt.value, mt, st)
                    ;(!it.allowItemRejection || vt !== !1) && ct++,
                      it.autoContinue &&
                        (ct + it.offset < it.limit ? mt.continue() : (at = !0))
                  }
                else at = !0
              }),
              st
            )
          },
          query: function(nt, it) {
            var ot = [],
              at = 0
            return (
              (it = it || {}),
              (it.autoContinue = !0),
              (it.writeAccess = !1),
              (it.allowItemRejection = !!it.filter),
              (it.onEnd = function() {
                nt(ot, at)
              }),
              this.iterate(function(st) {
                at++
                var ut = it.filter ? it.filter(st) : !0
                return ut !== !1 && ot.push(st), ut
              }, it)
            )
          },
          count: function(nt, it) {
            it = tt({ index: null, keyRange: null }, it || {})
            var ot = it.onError || a,
              at = !1,
              st = null,
              ut = this.db.transaction([this.storeName], this.consts.READ_ONLY)
            ;(ut.oncomplete = function() {
              var ft = at ? nt : ot
              ft(st)
            }),
              (ut.onabort = ot),
              (ut.onerror = ot)
            var ct = ut.objectStore(this.storeName)
            it.index && (ct = ct.index(it.index))
            var dt = ct.count(it.keyRange)
            return (
              (dt.onsuccess = function(ft) {
                ;(at = !0), (st = ft.target.result)
              }),
              (dt.onError = ot),
              ut
            )
          },
          makeKeyRange: function(nt) {
            var it,
              ot = typeof nt.lower < 'u',
              at = typeof nt.upper < 'u',
              st = typeof nt.only < 'u'
            switch (!0) {
              case st:
                it = this.keyRange.only(nt.only)
                break
              case ot && at:
                it = this.keyRange.bound(
                  nt.lower,
                  nt.upper,
                  nt.excludeLower,
                  nt.excludeUpper
                )
                break
              case ot:
                it = this.keyRange.lowerBound(nt.lower, nt.excludeLower)
                break
              case at:
                it = this.keyRange.upperBound(nt.upper, nt.excludeUpper)
                break
              default:
                throw new Error(
                  'Cannot create KeyRange. Provide one or both of "lower" or "upper" value, or an "only" value.'
                )
            }
            return it
          },
        },
        et = {}
      function tt(nt, it) {
        var ot, at
        for (ot in it)
          (at = it[ot]), at !== et[ot] && at !== nt[ot] && (nt[ot] = at)
        return nt
      }
      function rt(nt) {
        return 'error' in nt.target
          ? nt.target.error.name == 'VersionError'
          : 'errorCode' in nt.target
          ? nt.target.errorCode == 12
          : !1
      }
      return (j.prototype = _e), (j.version = _e.version), j
    },
    commonjsGlobal$1
  )
})(idbstore)
var idbstoreExports = idbstore.exports,
  abstractLeveldown = {},
  xtend$f = extend$d
function extend$d() {
  for (var o = {}, a = 0; a < arguments.length; a++) {
    var s = arguments[a]
    for (var $ in s) s.hasOwnProperty($) && (o[$] = s[$])
  }
  return o
}
function AbstractIterator$2(o) {
  ;(this.db = o), (this._ended = !1), (this._nexting = !1)
}
AbstractIterator$2.prototype.next = function(o) {
  var a = this
  if (typeof o != 'function')
    throw new Error('next() requires a callback argument')
  if (a._ended) return o(new Error('cannot call next() after end()'))
  if (a._nexting)
    return o(
      new Error('cannot call next() before previous next() has completed')
    )
  if (((a._nexting = !0), typeof a._next == 'function'))
    return a._next(function() {
      ;(a._nexting = !1), o.apply(null, arguments)
    })
  process.nextTick(function() {
    ;(a._nexting = !1), o()
  })
}
AbstractIterator$2.prototype.end = function(o) {
  if (typeof o != 'function')
    throw new Error('end() requires a callback argument')
  if (this._ended) return o(new Error('end() already called on iterator'))
  if (((this._ended = !0), typeof this._end == 'function')) return this._end(o)
  process.nextTick(o)
}
var abstractIterator = AbstractIterator$2
function AbstractChainedBatch$1(o) {
  ;(this._db = o), (this._operations = []), (this._written = !1)
}
AbstractChainedBatch$1.prototype._checkWritten = function() {
  if (this._written) throw new Error('write() already called on this batch')
}
AbstractChainedBatch$1.prototype.put = function(o, a) {
  this._checkWritten()
  var s = this._db._checkKeyValue(o, 'key', this._db._isBuffer)
  if (s || ((s = this._db._checkKeyValue(a, 'value', this._db._isBuffer)), s))
    throw s
  return (
    this._db._isBuffer(o) || (o = String(o)),
    this._db._isBuffer(a) || (a = String(a)),
    typeof this._put == 'function'
      ? this._put(o, a)
      : this._operations.push({ type: 'put', key: o, value: a }),
    this
  )
}
AbstractChainedBatch$1.prototype.del = function(o) {
  this._checkWritten()
  var a = this._db._checkKeyValue(o, 'key', this._db._isBuffer)
  if (a) throw a
  return (
    this._db._isBuffer(o) || (o = String(o)),
    typeof this._del == 'function'
      ? this._del(o)
      : this._operations.push({ type: 'del', key: o }),
    this
  )
}
AbstractChainedBatch$1.prototype.clear = function() {
  return (
    this._checkWritten(),
    (this._operations = []),
    typeof this._clear == 'function' && this._clear(),
    this
  )
}
AbstractChainedBatch$1.prototype.write = function(o, a) {
  if (
    (this._checkWritten(),
    typeof o == 'function' && (a = o),
    typeof a != 'function')
  )
    throw new Error('write() requires a callback argument')
  if (
    (typeof o != 'object' && (o = {}),
    (this._written = !0),
    typeof this._write == 'function')
  )
    return this._write(a)
  if (typeof this._db._batch == 'function')
    return this._db._batch(this._operations, o, a)
  process.nextTick(a)
}
var abstractChainedBatch = AbstractChainedBatch$1,
  xtend$e = xtend$f,
  AbstractIterator$1 = abstractIterator,
  AbstractChainedBatch = abstractChainedBatch
function AbstractLevelDOWN$2(o) {
  if (!arguments.length || o === void 0)
    throw new Error('constructor requires at least a location argument')
  if (typeof o != 'string')
    throw new Error('constructor requires a location string argument')
  this.location = o
}
AbstractLevelDOWN$2.prototype.open = function(o, a) {
  if ((typeof o == 'function' && (a = o), typeof a != 'function'))
    throw new Error('open() requires a callback argument')
  if ((typeof o != 'object' && (o = {}), typeof this._open == 'function'))
    return this._open(o, a)
  process.nextTick(a)
}
AbstractLevelDOWN$2.prototype.close = function(o) {
  if (typeof o != 'function')
    throw new Error('close() requires a callback argument')
  if (typeof this._close == 'function') return this._close(o)
  process.nextTick(o)
}
AbstractLevelDOWN$2.prototype.get = function(o, a, s) {
  var $
  if ((typeof a == 'function' && (s = a), typeof s != 'function'))
    throw new Error('get() requires a callback argument')
  if (($ = this._checkKeyValue(o, 'key', this._isBuffer))) return s($)
  if (
    (this._isBuffer(o) || (o = String(o)),
    typeof a != 'object' && (a = {}),
    typeof this._get == 'function')
  )
    return this._get(o, a, s)
  process.nextTick(function() {
    s(new Error('NotFound'))
  })
}
AbstractLevelDOWN$2.prototype.put = function(o, a, s, $) {
  var j
  if ((typeof s == 'function' && ($ = s), typeof $ != 'function'))
    throw new Error('put() requires a callback argument')
  if (
    (j = this._checkKeyValue(o, 'key', this._isBuffer)) ||
    (j = this._checkKeyValue(a, 'value', this._isBuffer))
  )
    return $(j)
  if (
    (this._isBuffer(o) || (o = String(o)),
    !this._isBuffer(a) && !process.browser && (a = String(a)),
    typeof s != 'object' && (s = {}),
    typeof this._put == 'function')
  )
    return this._put(o, a, s, $)
  process.nextTick($)
}
AbstractLevelDOWN$2.prototype.del = function(o, a, s) {
  var $
  if ((typeof a == 'function' && (s = a), typeof s != 'function'))
    throw new Error('del() requires a callback argument')
  if (($ = this._checkKeyValue(o, 'key', this._isBuffer))) return s($)
  if (
    (this._isBuffer(o) || (o = String(o)),
    typeof a != 'object' && (a = {}),
    typeof this._del == 'function')
  )
    return this._del(o, a, s)
  process.nextTick(s)
}
AbstractLevelDOWN$2.prototype.batch = function(o, a, s) {
  if (!arguments.length) return this._chainedBatch()
  if ((typeof a == 'function' && (s = a), typeof s != 'function'))
    throw new Error('batch(array) requires a callback argument')
  if (!Array.isArray(o))
    return s(new Error('batch(array) requires an array argument'))
  typeof a != 'object' && (a = {})
  for (var $ = 0, j = o.length, _e, et; $ < j; $++)
    if (
      ((_e = o[$]),
      typeof _e == 'object' &&
        ((et = this._checkKeyValue(_e.type, 'type', this._isBuffer)) ||
          (et = this._checkKeyValue(_e.key, 'key', this._isBuffer)) ||
          (_e.type == 'put' &&
            (et = this._checkKeyValue(_e.value, 'value', this._isBuffer)))))
    )
      return s(et)
  if (typeof this._batch == 'function') return this._batch(o, a, s)
  process.nextTick(s)
}
AbstractLevelDOWN$2.prototype.approximateSize = function(o, a, s) {
  if (
    o == null ||
    a == null ||
    typeof o == 'function' ||
    typeof a == 'function'
  )
    throw new Error(
      'approximateSize() requires valid `start`, `end` and `callback` arguments'
    )
  if (typeof s != 'function')
    throw new Error('approximateSize() requires a callback argument')
  if (
    (this._isBuffer(o) || (o = String(o)),
    this._isBuffer(a) || (a = String(a)),
    typeof this._approximateSize == 'function')
  )
    return this._approximateSize(o, a, s)
  process.nextTick(function() {
    s(null, 0)
  })
}
AbstractLevelDOWN$2.prototype._setupIteratorOptions = function(o) {
  var a = this
  return (
    (o = xtend$e(o)),
    ['start', 'end', 'gt', 'gte', 'lt', 'lte'].forEach(function(s) {
      o[s] && a._isBuffer(o[s]) && o[s].length === 0 && delete o[s]
    }),
    (o.reverse = !!o.reverse),
    o.reverse && o.lt && (o.start = o.lt),
    o.reverse && o.lte && (o.start = o.lte),
    !o.reverse && o.gt && (o.start = o.gt),
    !o.reverse && o.gte && (o.start = o.gte),
    ((o.reverse && o.lt && !o.lte) || (!o.reverse && o.gt && !o.gte)) &&
      (o.exclusiveStart = !0),
    o
  )
}
AbstractLevelDOWN$2.prototype.iterator = function(o) {
  return (
    typeof o != 'object' && (o = {}),
    (o = this._setupIteratorOptions(o)),
    typeof this._iterator == 'function'
      ? this._iterator(o)
      : new AbstractIterator$1(this)
  )
}
AbstractLevelDOWN$2.prototype._chainedBatch = function() {
  return new AbstractChainedBatch(this)
}
AbstractLevelDOWN$2.prototype._isBuffer = function(o) {
  return Buffer.isBuffer(o)
}
AbstractLevelDOWN$2.prototype._checkKeyValue = function(o, a) {
  if (o == null) return new Error(a + ' cannot be `null` or `undefined`')
  if (this._isBuffer(o)) {
    if (o.length === 0) return new Error(a + ' cannot be an empty Buffer')
  } else if (String(o) === '')
    return new Error(a + ' cannot be an empty String')
}
abstractLeveldown.AbstractLevelDOWN = AbstractLevelDOWN$2
abstractLeveldown.AbstractIterator = AbstractIterator$1
abstractLeveldown.AbstractChainedBatch = AbstractChainedBatch
var util$u = {},
  types = {},
  shams$1,
  hasRequiredShams
function requireShams() {
  return (
    hasRequiredShams ||
      ((hasRequiredShams = 1),
      (shams$1 = function() {
        if (
          typeof Symbol != 'function' ||
          typeof Object.getOwnPropertySymbols != 'function'
        )
          return !1
        if (typeof Symbol.iterator == 'symbol') return !0
        var a = {},
          s = Symbol('test'),
          $ = Object(s)
        if (
          typeof s == 'string' ||
          Object.prototype.toString.call(s) !== '[object Symbol]' ||
          Object.prototype.toString.call($) !== '[object Symbol]'
        )
          return !1
        var j = 42
        a[s] = j
        for (s in a) return !1
        if (
          (typeof Object.keys == 'function' && Object.keys(a).length !== 0) ||
          (typeof Object.getOwnPropertyNames == 'function' &&
            Object.getOwnPropertyNames(a).length !== 0)
        )
          return !1
        var _e = Object.getOwnPropertySymbols(a)
        if (
          _e.length !== 1 ||
          _e[0] !== s ||
          !Object.prototype.propertyIsEnumerable.call(a, s)
        )
          return !1
        if (typeof Object.getOwnPropertyDescriptor == 'function') {
          var et = Object.getOwnPropertyDescriptor(a, s)
          if (et.value !== j || et.enumerable !== !0) return !1
        }
        return !0
      })),
    shams$1
  )
}
var hasSymbols$1 = requireShams(),
  shams = function() {
    return hasSymbols$1() && !!Symbol.toStringTag
  },
  esErrors,
  hasRequiredEsErrors
function requireEsErrors() {
  return (
    hasRequiredEsErrors || ((hasRequiredEsErrors = 1), (esErrors = Error)),
    esErrors
  )
}
var _eval, hasRequired_eval
function require_eval() {
  return (
    hasRequired_eval || ((hasRequired_eval = 1), (_eval = EvalError)), _eval
  )
}
var range, hasRequiredRange
function requireRange() {
  return (
    hasRequiredRange || ((hasRequiredRange = 1), (range = RangeError)), range
  )
}
var ref, hasRequiredRef
function requireRef() {
  return hasRequiredRef || ((hasRequiredRef = 1), (ref = ReferenceError)), ref
}
var syntax, hasRequiredSyntax
function requireSyntax() {
  return (
    hasRequiredSyntax || ((hasRequiredSyntax = 1), (syntax = SyntaxError)),
    syntax
  )
}
var type$1, hasRequiredType
function requireType() {
  return (
    hasRequiredType || ((hasRequiredType = 1), (type$1 = TypeError)), type$1
  )
}
var uri, hasRequiredUri
function requireUri() {
  return hasRequiredUri || ((hasRequiredUri = 1), (uri = URIError)), uri
}
var hasSymbols, hasRequiredHasSymbols
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols
  hasRequiredHasSymbols = 1
  var o = typeof Symbol < 'u' && Symbol,
    a = requireShams()
  return (
    (hasSymbols = function() {
      return typeof o != 'function' ||
        typeof Symbol != 'function' ||
        typeof o('foo') != 'symbol' ||
        typeof Symbol('bar') != 'symbol'
        ? !1
        : a()
    }),
    hasSymbols
  )
}
var hasProto, hasRequiredHasProto
function requireHasProto() {
  if (hasRequiredHasProto) return hasProto
  hasRequiredHasProto = 1
  var o = { __proto__: null, foo: {} },
    a = Object
  return (
    (hasProto = function() {
      return { __proto__: o }.foo === o.foo && !(o instanceof a)
    }),
    hasProto
  )
}
var implementation$3, hasRequiredImplementation$3
function requireImplementation$3() {
  if (hasRequiredImplementation$3) return implementation$3
  hasRequiredImplementation$3 = 1
  var o = 'Function.prototype.bind called on incompatible ',
    a = Object.prototype.toString,
    s = Math.max,
    $ = '[object Function]',
    j = function(rt, nt) {
      for (var it = [], ot = 0; ot < rt.length; ot += 1) it[ot] = rt[ot]
      for (var at = 0; at < nt.length; at += 1) it[at + rt.length] = nt[at]
      return it
    },
    _e = function(rt, nt) {
      for (var it = [], ot = nt, at = 0; ot < rt.length; ot += 1, at += 1)
        it[at] = rt[ot]
      return it
    },
    et = function(tt, rt) {
      for (var nt = '', it = 0; it < tt.length; it += 1)
        (nt += tt[it]), it + 1 < tt.length && (nt += rt)
      return nt
    }
  return (
    (implementation$3 = function(rt) {
      var nt = this
      if (typeof nt != 'function' || a.apply(nt) !== $)
        throw new TypeError(o + nt)
      for (
        var it = _e(arguments, 1),
          ot,
          at = function() {
            if (this instanceof ot) {
              var ft = nt.apply(this, j(it, arguments))
              return Object(ft) === ft ? ft : this
            }
            return nt.apply(rt, j(it, arguments))
          },
          st = s(0, nt.length - it.length),
          ut = [],
          ct = 0;
        ct < st;
        ct++
      )
        ut[ct] = '$' + ct
      if (
        ((ot = Function(
          'binder',
          'return function (' +
            et(ut, ',') +
            '){ return binder.apply(this,arguments); }'
        )(at)),
        nt.prototype)
      ) {
        var dt = function() {}
        ;(dt.prototype = nt.prototype),
          (ot.prototype = new dt()),
          (dt.prototype = null)
      }
      return ot
    }),
    implementation$3
  )
}
var functionBind, hasRequiredFunctionBind
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind
  hasRequiredFunctionBind = 1
  var o = requireImplementation$3()
  return (functionBind = Function.prototype.bind || o), functionBind
}
var hasown, hasRequiredHasown
function requireHasown() {
  if (hasRequiredHasown) return hasown
  hasRequiredHasown = 1
  var o = Function.prototype.call,
    a = Object.prototype.hasOwnProperty,
    s = requireFunctionBind()
  return (hasown = s.call(o, a)), hasown
}
var getIntrinsic, hasRequiredGetIntrinsic
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic
  hasRequiredGetIntrinsic = 1
  var o,
    a = requireEsErrors(),
    s = require_eval(),
    $ = requireRange(),
    j = requireRef(),
    _e = requireSyntax(),
    et = requireType(),
    tt = requireUri(),
    rt = Function,
    nt = function(Wt) {
      try {
        return rt('"use strict"; return (' + Wt + ').constructor;')()
      } catch {}
    },
    it = Object.getOwnPropertyDescriptor
  if (it)
    try {
      it({}, '')
    } catch {
      it = null
    }
  var ot = function() {
      throw new et()
    },
    at = it
      ? (function() {
          try {
            return arguments.callee, ot
          } catch {
            try {
              return it(arguments, 'callee').get
            } catch {
              return ot
            }
          }
        })()
      : ot,
    st = requireHasSymbols()(),
    ut = requireHasProto()(),
    ct =
      Object.getPrototypeOf ||
      (ut
        ? function(Wt) {
            return Wt.__proto__
          }
        : null),
    dt = {},
    ft = typeof Uint8Array > 'u' || !ct ? o : ct(Uint8Array),
    mt = {
      __proto__: null,
      '%AggregateError%': typeof AggregateError > 'u' ? o : AggregateError,
      '%Array%': Array,
      '%ArrayBuffer%': typeof ArrayBuffer > 'u' ? o : ArrayBuffer,
      '%ArrayIteratorPrototype%': st && ct ? ct([][Symbol.iterator]()) : o,
      '%AsyncFromSyncIteratorPrototype%': o,
      '%AsyncFunction%': dt,
      '%AsyncGenerator%': dt,
      '%AsyncGeneratorFunction%': dt,
      '%AsyncIteratorPrototype%': dt,
      '%Atomics%': typeof Atomics > 'u' ? o : Atomics,
      '%BigInt%': typeof BigInt > 'u' ? o : BigInt,
      '%BigInt64Array%': typeof BigInt64Array > 'u' ? o : BigInt64Array,
      '%BigUint64Array%': typeof BigUint64Array > 'u' ? o : BigUint64Array,
      '%Boolean%': Boolean,
      '%DataView%': typeof DataView > 'u' ? o : DataView,
      '%Date%': Date,
      '%decodeURI%': decodeURI,
      '%decodeURIComponent%': decodeURIComponent,
      '%encodeURI%': encodeURI,
      '%encodeURIComponent%': encodeURIComponent,
      '%Error%': a,
      '%eval%': eval,
      '%EvalError%': s,
      '%Float32Array%': typeof Float32Array > 'u' ? o : Float32Array,
      '%Float64Array%': typeof Float64Array > 'u' ? o : Float64Array,
      '%FinalizationRegistry%':
        typeof FinalizationRegistry > 'u' ? o : FinalizationRegistry,
      '%Function%': rt,
      '%GeneratorFunction%': dt,
      '%Int8Array%': typeof Int8Array > 'u' ? o : Int8Array,
      '%Int16Array%': typeof Int16Array > 'u' ? o : Int16Array,
      '%Int32Array%': typeof Int32Array > 'u' ? o : Int32Array,
      '%isFinite%': isFinite,
      '%isNaN%': isNaN,
      '%IteratorPrototype%': st && ct ? ct(ct([][Symbol.iterator]())) : o,
      '%JSON%': typeof JSON == 'object' ? JSON : o,
      '%Map%': typeof Map > 'u' ? o : Map,
      '%MapIteratorPrototype%':
        typeof Map > 'u' || !st || !ct ? o : ct(new Map()[Symbol.iterator]()),
      '%Math%': Math,
      '%Number%': Number,
      '%Object%': Object,
      '%parseFloat%': parseFloat,
      '%parseInt%': parseInt,
      '%Promise%': typeof Promise > 'u' ? o : Promise,
      '%Proxy%': typeof Proxy > 'u' ? o : Proxy,
      '%RangeError%': $,
      '%ReferenceError%': j,
      '%Reflect%': typeof Reflect > 'u' ? o : Reflect,
      '%RegExp%': RegExp,
      '%Set%': typeof Set > 'u' ? o : Set,
      '%SetIteratorPrototype%':
        typeof Set > 'u' || !st || !ct ? o : ct(new Set()[Symbol.iterator]()),
      '%SharedArrayBuffer%':
        typeof SharedArrayBuffer > 'u' ? o : SharedArrayBuffer,
      '%String%': String,
      '%StringIteratorPrototype%': st && ct ? ct(''[Symbol.iterator]()) : o,
      '%Symbol%': st ? Symbol : o,
      '%SyntaxError%': _e,
      '%ThrowTypeError%': at,
      '%TypedArray%': ft,
      '%TypeError%': et,
      '%Uint8Array%': typeof Uint8Array > 'u' ? o : Uint8Array,
      '%Uint8ClampedArray%':
        typeof Uint8ClampedArray > 'u' ? o : Uint8ClampedArray,
      '%Uint16Array%': typeof Uint16Array > 'u' ? o : Uint16Array,
      '%Uint32Array%': typeof Uint32Array > 'u' ? o : Uint32Array,
      '%URIError%': tt,
      '%WeakMap%': typeof WeakMap > 'u' ? o : WeakMap,
      '%WeakRef%': typeof WeakRef > 'u' ? o : WeakRef,
      '%WeakSet%': typeof WeakSet > 'u' ? o : WeakSet,
    }
  if (ct)
    try {
      null.error
    } catch (Wt) {
      var vt = ct(ct(Wt))
      mt['%Error.prototype%'] = vt
    }
  var yt = function Wt(Tt) {
      var kt
      if (Tt === '%AsyncFunction%') kt = nt('async function () {}')
      else if (Tt === '%GeneratorFunction%') kt = nt('function* () {}')
      else if (Tt === '%AsyncGeneratorFunction%')
        kt = nt('async function* () {}')
      else if (Tt === '%AsyncGenerator%') {
        var Ot = Wt('%AsyncGeneratorFunction%')
        Ot && (kt = Ot.prototype)
      } else if (Tt === '%AsyncIteratorPrototype%') {
        var Nt = Wt('%AsyncGenerator%')
        Nt && ct && (kt = ct(Nt.prototype))
      }
      return (mt[Tt] = kt), kt
    },
    pt = {
      __proto__: null,
      '%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
      '%ArrayPrototype%': ['Array', 'prototype'],
      '%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
      '%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
      '%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
      '%ArrayProto_values%': ['Array', 'prototype', 'values'],
      '%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
      '%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
      '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype',
      ],
      '%BooleanPrototype%': ['Boolean', 'prototype'],
      '%DataViewPrototype%': ['DataView', 'prototype'],
      '%DatePrototype%': ['Date', 'prototype'],
      '%ErrorPrototype%': ['Error', 'prototype'],
      '%EvalErrorPrototype%': ['EvalError', 'prototype'],
      '%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
      '%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
      '%FunctionPrototype%': ['Function', 'prototype'],
      '%Generator%': ['GeneratorFunction', 'prototype'],
      '%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
      '%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
      '%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
      '%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
      '%JSONParse%': ['JSON', 'parse'],
      '%JSONStringify%': ['JSON', 'stringify'],
      '%MapPrototype%': ['Map', 'prototype'],
      '%NumberPrototype%': ['Number', 'prototype'],
      '%ObjectPrototype%': ['Object', 'prototype'],
      '%ObjProto_toString%': ['Object', 'prototype', 'toString'],
      '%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
      '%PromisePrototype%': ['Promise', 'prototype'],
      '%PromiseProto_then%': ['Promise', 'prototype', 'then'],
      '%Promise_all%': ['Promise', 'all'],
      '%Promise_reject%': ['Promise', 'reject'],
      '%Promise_resolve%': ['Promise', 'resolve'],
      '%RangeErrorPrototype%': ['RangeError', 'prototype'],
      '%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
      '%RegExpPrototype%': ['RegExp', 'prototype'],
      '%SetPrototype%': ['Set', 'prototype'],
      '%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
      '%StringPrototype%': ['String', 'prototype'],
      '%SymbolPrototype%': ['Symbol', 'prototype'],
      '%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
      '%TypedArrayPrototype%': ['TypedArray', 'prototype'],
      '%TypeErrorPrototype%': ['TypeError', 'prototype'],
      '%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
      '%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
      '%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
      '%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
      '%URIErrorPrototype%': ['URIError', 'prototype'],
      '%WeakMapPrototype%': ['WeakMap', 'prototype'],
      '%WeakSetPrototype%': ['WeakSet', 'prototype'],
    },
    ht = requireFunctionBind(),
    At = requireHasown(),
    wt = ht.call(Function.call, Array.prototype.concat),
    Ct = ht.call(Function.apply, Array.prototype.splice),
    Dt = ht.call(Function.call, String.prototype.replace),
    jt = ht.call(Function.call, String.prototype.slice),
    Et = ht.call(Function.call, RegExp.prototype.exec),
    St = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
    Bt = /\\(\\)?/g,
    Mt = function(Tt) {
      var kt = jt(Tt, 0, 1),
        Ot = jt(Tt, -1)
      if (kt === '%' && Ot !== '%')
        throw new _e('invalid intrinsic syntax, expected closing `%`')
      if (Ot === '%' && kt !== '%')
        throw new _e('invalid intrinsic syntax, expected opening `%`')
      var Nt = []
      return (
        Dt(Tt, St, function($t, Pt, Ft, Vt) {
          Nt[Nt.length] = Ft ? Dt(Vt, Bt, '$1') : Pt || $t
        }),
        Nt
      )
    },
    Ut = function(Tt, kt) {
      var Ot = Tt,
        Nt
      if (
        (At(pt, Ot) && ((Nt = pt[Ot]), (Ot = '%' + Nt[0] + '%')), At(mt, Ot))
      ) {
        var $t = mt[Ot]
        if (($t === dt && ($t = yt(Ot)), typeof $t > 'u' && !kt))
          throw new et(
            'intrinsic ' +
              Tt +
              ' exists, but is not available. Please file an issue!'
          )
        return { alias: Nt, name: Ot, value: $t }
      }
      throw new _e('intrinsic ' + Tt + ' does not exist!')
    }
  return (
    (getIntrinsic = function(Tt, kt) {
      if (typeof Tt != 'string' || Tt.length === 0)
        throw new et('intrinsic name must be a non-empty string')
      if (arguments.length > 1 && typeof kt != 'boolean')
        throw new et('"allowMissing" argument must be a boolean')
      if (Et(/^%?[^%]*%?$/, Tt) === null)
        throw new _e(
          '`%` may not be present anywhere but at the beginning and end of the intrinsic name'
        )
      var Ot = Mt(Tt),
        Nt = Ot.length > 0 ? Ot[0] : '',
        $t = Ut('%' + Nt + '%', kt),
        Pt = $t.name,
        Ft = $t.value,
        Vt = !1,
        Xt = $t.alias
      Xt && ((Nt = Xt[0]), Ct(Ot, wt([0, 1], Xt)))
      for (var Yt = 1, xt = !0; Yt < Ot.length; Yt += 1) {
        var It = Ot[Yt],
          Kt = jt(It, 0, 1),
          Qt = jt(It, -1)
        if (
          (Kt === '"' ||
            Kt === "'" ||
            Kt === '`' ||
            Qt === '"' ||
            Qt === "'" ||
            Qt === '`') &&
          Kt !== Qt
        )
          throw new _e('property names with quotes must have matching quotes')
        if (
          ((It === 'constructor' || !xt) && (Vt = !0),
          (Nt += '.' + It),
          (Pt = '%' + Nt + '%'),
          At(mt, Pt))
        )
          Ft = mt[Pt]
        else if (Ft != null) {
          if (!(It in Ft)) {
            if (!kt)
              throw new et(
                'base intrinsic for ' +
                  Tt +
                  ' exists, but the property is not available.'
              )
            return
          }
          if (it && Yt + 1 >= Ot.length) {
            var Ht = it(Ft, It)
            ;(xt = !!Ht),
              xt && 'get' in Ht && !('originalValue' in Ht.get)
                ? (Ft = Ht.get)
                : (Ft = Ft[It])
          } else (xt = At(Ft, It)), (Ft = Ft[It])
          xt && !Vt && (mt[Pt] = Ft)
        }
      }
      return Ft
    }),
    getIntrinsic
  )
}
var callBind$2 = { exports: {} },
  esDefineProperty,
  hasRequiredEsDefineProperty
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty
  hasRequiredEsDefineProperty = 1
  var o = requireGetIntrinsic(),
    a = o('%Object.defineProperty%', !0) || !1
  if (a)
    try {
      a({}, 'a', { value: 1 })
    } catch {
      a = !1
    }
  return (esDefineProperty = a), esDefineProperty
}
var gopd, hasRequiredGopd
function requireGopd() {
  if (hasRequiredGopd) return gopd
  hasRequiredGopd = 1
  var o = requireGetIntrinsic(),
    a = o('%Object.getOwnPropertyDescriptor%', !0)
  if (a)
    try {
      a([], 'length')
    } catch {
      a = null
    }
  return (gopd = a), gopd
}
var defineDataProperty, hasRequiredDefineDataProperty
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty
  hasRequiredDefineDataProperty = 1
  var o = requireEsDefineProperty(),
    a = requireSyntax(),
    s = requireType(),
    $ = requireGopd()
  return (
    (defineDataProperty = function(_e, et, tt) {
      if (!_e || (typeof _e != 'object' && typeof _e != 'function'))
        throw new s('`obj` must be an object or a function`')
      if (typeof et != 'string' && typeof et != 'symbol')
        throw new s('`property` must be a string or a symbol`')
      if (
        arguments.length > 3 &&
        typeof arguments[3] != 'boolean' &&
        arguments[3] !== null
      )
        throw new s('`nonEnumerable`, if provided, must be a boolean or null')
      if (
        arguments.length > 4 &&
        typeof arguments[4] != 'boolean' &&
        arguments[4] !== null
      )
        throw new s('`nonWritable`, if provided, must be a boolean or null')
      if (
        arguments.length > 5 &&
        typeof arguments[5] != 'boolean' &&
        arguments[5] !== null
      )
        throw new s('`nonConfigurable`, if provided, must be a boolean or null')
      if (arguments.length > 6 && typeof arguments[6] != 'boolean')
        throw new s('`loose`, if provided, must be a boolean')
      var rt = arguments.length > 3 ? arguments[3] : null,
        nt = arguments.length > 4 ? arguments[4] : null,
        it = arguments.length > 5 ? arguments[5] : null,
        ot = arguments.length > 6 ? arguments[6] : !1,
        at = !!$ && $(_e, et)
      if (o)
        o(_e, et, {
          configurable: it === null && at ? at.configurable : !it,
          enumerable: rt === null && at ? at.enumerable : !rt,
          value: tt,
          writable: nt === null && at ? at.writable : !nt,
        })
      else if (ot || (!rt && !nt && !it)) _e[et] = tt
      else
        throw new a(
          'This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.'
        )
    }),
    defineDataProperty
  )
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1
  hasRequiredHasPropertyDescriptors = 1
  var o = requireEsDefineProperty(),
    a = function() {
      return !!o
    }
  return (
    (a.hasArrayLengthDefineBug = function() {
      if (!o) return null
      try {
        return o([], 'length', { value: 1 }).length !== 1
      } catch {
        return !0
      }
    }),
    (hasPropertyDescriptors_1 = a),
    hasPropertyDescriptors_1
  )
}
var setFunctionLength, hasRequiredSetFunctionLength
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength
  hasRequiredSetFunctionLength = 1
  var o = requireGetIntrinsic(),
    a = requireDefineDataProperty(),
    s = requireHasPropertyDescriptors()(),
    $ = requireGopd(),
    j = requireType(),
    _e = o('%Math.floor%')
  return (
    (setFunctionLength = function(tt, rt) {
      if (typeof tt != 'function') throw new j('`fn` is not a function')
      if (typeof rt != 'number' || rt < 0 || rt > 4294967295 || _e(rt) !== rt)
        throw new j('`length` must be a positive 32-bit integer')
      var nt = arguments.length > 2 && !!arguments[2],
        it = !0,
        ot = !0
      if ('length' in tt && $) {
        var at = $(tt, 'length')
        at && !at.configurable && (it = !1), at && !at.writable && (ot = !1)
      }
      return (
        (it || ot || !nt) &&
          (s ? a(tt, 'length', rt, !0, !0) : a(tt, 'length', rt)),
        tt
      )
    }),
    setFunctionLength
  )
}
var hasRequiredCallBind
function requireCallBind() {
  return (
    hasRequiredCallBind ||
      ((hasRequiredCallBind = 1),
      (function(o) {
        var a = requireFunctionBind(),
          s = requireGetIntrinsic(),
          $ = requireSetFunctionLength(),
          j = requireType(),
          _e = s('%Function.prototype.apply%'),
          et = s('%Function.prototype.call%'),
          tt = s('%Reflect.apply%', !0) || a.call(et, _e),
          rt = requireEsDefineProperty(),
          nt = s('%Math.max%')
        o.exports = function(at) {
          if (typeof at != 'function') throw new j('a function is required')
          var st = tt(a, et, arguments)
          return $(st, 1 + nt(0, at.length - (arguments.length - 1)), !0)
        }
        var it = function() {
          return tt(a, _e, arguments)
        }
        rt ? rt(o.exports, 'apply', { value: it }) : (o.exports.apply = it)
      })(callBind$2)),
    callBind$2.exports
  )
}
var GetIntrinsic = requireGetIntrinsic(),
  callBind$1 = requireCallBind(),
  $indexOf$1 = callBind$1(GetIntrinsic('String.prototype.indexOf')),
  callBound$2 = function(a, s) {
    var $ = GetIntrinsic(a, !!s)
    return typeof $ == 'function' && $indexOf$1(a, '.prototype.') > -1
      ? callBind$1($)
      : $
  },
  hasToStringTag$3 = shams(),
  callBound$1 = callBound$2,
  $toString$1 = callBound$1('Object.prototype.toString'),
  isStandardArguments = function(a) {
    return hasToStringTag$3 &&
      a &&
      typeof a == 'object' &&
      Symbol.toStringTag in a
      ? !1
      : $toString$1(a) === '[object Arguments]'
  },
  isLegacyArguments = function(a) {
    return isStandardArguments(a)
      ? !0
      : a !== null &&
          typeof a == 'object' &&
          typeof a.length == 'number' &&
          a.length >= 0 &&
          $toString$1(a) !== '[object Array]' &&
          $toString$1(a.callee) === '[object Function]'
  },
  supportsStandardArguments = (function() {
    return isStandardArguments(arguments)
  })()
isStandardArguments.isLegacyArguments = isLegacyArguments
var isArguments$2 = supportsStandardArguments
    ? isStandardArguments
    : isLegacyArguments,
  toStr$3 = Object.prototype.toString,
  fnToStr$1 = Function.prototype.toString,
  isFnRegex = /^\s*(?:function)?\*/,
  hasToStringTag$2 = shams(),
  getProto = Object.getPrototypeOf,
  getGeneratorFunc = function() {
    if (!hasToStringTag$2) return !1
    try {
      return Function('return function*() {}')()
    } catch {}
  },
  GeneratorFunction,
  isGeneratorFunction = function(a) {
    if (typeof a != 'function') return !1
    if (isFnRegex.test(fnToStr$1.call(a))) return !0
    if (!hasToStringTag$2) {
      var s = toStr$3.call(a)
      return s === '[object GeneratorFunction]'
    }
    if (!getProto) return !1
    if (typeof GeneratorFunction > 'u') {
      var $ = getGeneratorFunc()
      GeneratorFunction = $ ? getProto($) : !1
    }
    return getProto(a) === GeneratorFunction
  },
  fnToStr = Function.prototype.toString,
  reflectApply =
    typeof Reflect == 'object' && Reflect !== null && Reflect.apply,
  badArrayLike,
  isCallableMarker
if (
  typeof reflectApply == 'function' &&
  typeof Object.defineProperty == 'function'
)
  try {
    ;(badArrayLike = Object.defineProperty({}, 'length', {
      get: function() {
        throw isCallableMarker
      },
    })),
      (isCallableMarker = {}),
      reflectApply(
        function() {
          throw 42
        },
        null,
        badArrayLike
      )
  } catch (o) {
    o !== isCallableMarker && (reflectApply = null)
  }
else reflectApply = null
var constructorRegex = /^\s*class\b/,
  isES6ClassFn = function(a) {
    try {
      var s = fnToStr.call(a)
      return constructorRegex.test(s)
    } catch {
      return !1
    }
  },
  tryFunctionObject = function(a) {
    try {
      return isES6ClassFn(a) ? !1 : (fnToStr.call(a), !0)
    } catch {
      return !1
    }
  },
  toStr$2 = Object.prototype.toString,
  objectClass = '[object Object]',
  fnClass = '[object Function]',
  genClass = '[object GeneratorFunction]',
  ddaClass = '[object HTMLAllCollection]',
  ddaClass2 = '[object HTML document.all class]',
  ddaClass3 = '[object HTMLCollection]',
  hasToStringTag$1 = typeof Symbol == 'function' && !!Symbol.toStringTag,
  isIE68 = !(0 in [,]),
  isDDA = function() {
    return !1
  }
if (typeof document == 'object') {
  var all = document.all
  toStr$2.call(all) === toStr$2.call(document.all) &&
    (isDDA = function(a) {
      if ((isIE68 || !a) && (typeof a > 'u' || typeof a == 'object'))
        try {
          var s = toStr$2.call(a)
          return (
            (s === ddaClass ||
              s === ddaClass2 ||
              s === ddaClass3 ||
              s === objectClass) &&
            a('') == null
          )
        } catch {}
      return !1
    })
}
var isCallable$1 = reflectApply
    ? function(a) {
        if (isDDA(a)) return !0
        if (!a || (typeof a != 'function' && typeof a != 'object')) return !1
        try {
          reflectApply(a, null, badArrayLike)
        } catch (s) {
          if (s !== isCallableMarker) return !1
        }
        return !isES6ClassFn(a) && tryFunctionObject(a)
      }
    : function(a) {
        if (isDDA(a)) return !0
        if (!a || (typeof a != 'function' && typeof a != 'object')) return !1
        if (hasToStringTag$1) return tryFunctionObject(a)
        if (isES6ClassFn(a)) return !1
        var s = toStr$2.call(a)
        return s !== fnClass && s !== genClass && !/^\[object HTML/.test(s)
          ? !1
          : tryFunctionObject(a)
      },
  isCallable = isCallable$1,
  toStr$1 = Object.prototype.toString,
  hasOwnProperty$3 = Object.prototype.hasOwnProperty,
  forEachArray = function(a, s, $) {
    for (var j = 0, _e = a.length; j < _e; j++)
      hasOwnProperty$3.call(a, j) &&
        ($ == null ? s(a[j], j, a) : s.call($, a[j], j, a))
  },
  forEachString = function(a, s, $) {
    for (var j = 0, _e = a.length; j < _e; j++)
      $ == null ? s(a.charAt(j), j, a) : s.call($, a.charAt(j), j, a)
  },
  forEachObject = function(a, s, $) {
    for (var j in a)
      hasOwnProperty$3.call(a, j) &&
        ($ == null ? s(a[j], j, a) : s.call($, a[j], j, a))
  },
  forEach$4 = function(a, s, $) {
    if (!isCallable(s)) throw new TypeError('iterator must be a function')
    var j
    arguments.length >= 3 && (j = $),
      toStr$1.call(a) === '[object Array]'
        ? forEachArray(a, s, j)
        : typeof a == 'string'
        ? forEachString(a, s, j)
        : forEachObject(a, s, j)
  },
  forEach_1 = forEach$4,
  possibleTypedArrayNames = [
    'Float32Array',
    'Float64Array',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Uint16Array',
    'Uint32Array',
    'BigInt64Array',
    'BigUint64Array',
  ],
  define_global_default$5 = {},
  possibleNames = possibleTypedArrayNames,
  g$3 = typeof globalThis > 'u' ? define_global_default$5 : globalThis,
  availableTypedArrays$1 = function() {
    for (var a = [], s = 0; s < possibleNames.length; s++)
      typeof g$3[possibleNames[s]] == 'function' &&
        (a[a.length] = possibleNames[s])
    return a
  },
  define_global_default$4 = {},
  forEach$3 = forEach_1,
  availableTypedArrays = availableTypedArrays$1,
  callBind = requireCallBind(),
  callBound = callBound$2,
  gOPD$1 = requireGopd(),
  $toString = callBound('Object.prototype.toString'),
  hasToStringTag = shams(),
  g$2 = typeof globalThis > 'u' ? define_global_default$4 : globalThis,
  typedArrays = availableTypedArrays(),
  $slice = callBound('String.prototype.slice'),
  getPrototypeOf = Object.getPrototypeOf,
  $indexOf =
    callBound('Array.prototype.indexOf', !0) ||
    function(a, s) {
      for (var $ = 0; $ < a.length; $ += 1) if (a[$] === s) return $
      return -1
    },
  cache = { __proto__: null }
hasToStringTag && gOPD$1 && getPrototypeOf
  ? forEach$3(typedArrays, function(o) {
      var a = new g$2[o]()
      if (Symbol.toStringTag in a) {
        var s = getPrototypeOf(a),
          $ = gOPD$1(s, Symbol.toStringTag)
        if (!$) {
          var j = getPrototypeOf(s)
          $ = gOPD$1(j, Symbol.toStringTag)
        }
        cache['$' + o] = callBind($.get)
      }
    })
  : forEach$3(typedArrays, function(o) {
      var a = new g$2[o](),
        s = a.slice || a.set
      s && (cache['$' + o] = callBind(s))
    })
var tryTypedArrays = function(a) {
    var s = !1
    return (
      forEach$3(cache, function($, j) {
        if (!s)
          try {
            '$' + $(a) === j && (s = $slice(j, 1))
          } catch {}
      }),
      s
    )
  },
  trySlices = function(a) {
    var s = !1
    return (
      forEach$3(cache, function($, j) {
        if (!s)
          try {
            $(a), (s = $slice(j, 1))
          } catch {}
      }),
      s
    )
  },
  whichTypedArray$1 = function(a) {
    if (!a || typeof a != 'object') return !1
    if (!hasToStringTag) {
      var s = $slice($toString(a), 8, -1)
      return $indexOf(typedArrays, s) > -1
        ? s
        : s !== 'Object'
        ? !1
        : trySlices(a)
    }
    return gOPD$1 ? tryTypedArrays(a) : null
  },
  whichTypedArray = whichTypedArray$1,
  isTypedArray = function(a) {
    return !!whichTypedArray(a)
  }
;(function(o) {
  var a = isArguments$2,
    s = isGeneratorFunction,
    $ = whichTypedArray$1,
    j = isTypedArray
  function _e(ur) {
    return ur.call.bind(ur)
  }
  var et = typeof BigInt < 'u',
    tt = typeof Symbol < 'u',
    rt = _e(Object.prototype.toString),
    nt = _e(Number.prototype.valueOf),
    it = _e(String.prototype.valueOf),
    ot = _e(Boolean.prototype.valueOf)
  if (et) var at = _e(BigInt.prototype.valueOf)
  if (tt) var st = _e(Symbol.prototype.valueOf)
  function ut(ur, _r) {
    if (typeof ur != 'object') return !1
    try {
      return _r(ur), !0
    } catch {
      return !1
    }
  }
  ;(o.isArgumentsObject = a), (o.isGeneratorFunction = s), (o.isTypedArray = j)
  function ct(ur) {
    return (
      (typeof Promise < 'u' && ur instanceof Promise) ||
      (ur !== null &&
        typeof ur == 'object' &&
        typeof ur.then == 'function' &&
        typeof ur.catch == 'function')
    )
  }
  o.isPromise = ct
  function dt(ur) {
    return typeof ArrayBuffer < 'u' && ArrayBuffer.isView
      ? ArrayBuffer.isView(ur)
      : j(ur) || Pt(ur)
  }
  o.isArrayBufferView = dt
  function ft(ur) {
    return $(ur) === 'Uint8Array'
  }
  o.isUint8Array = ft
  function mt(ur) {
    return $(ur) === 'Uint8ClampedArray'
  }
  o.isUint8ClampedArray = mt
  function vt(ur) {
    return $(ur) === 'Uint16Array'
  }
  o.isUint16Array = vt
  function yt(ur) {
    return $(ur) === 'Uint32Array'
  }
  o.isUint32Array = yt
  function pt(ur) {
    return $(ur) === 'Int8Array'
  }
  o.isInt8Array = pt
  function ht(ur) {
    return $(ur) === 'Int16Array'
  }
  o.isInt16Array = ht
  function At(ur) {
    return $(ur) === 'Int32Array'
  }
  o.isInt32Array = At
  function wt(ur) {
    return $(ur) === 'Float32Array'
  }
  o.isFloat32Array = wt
  function Ct(ur) {
    return $(ur) === 'Float64Array'
  }
  o.isFloat64Array = Ct
  function Dt(ur) {
    return $(ur) === 'BigInt64Array'
  }
  o.isBigInt64Array = Dt
  function jt(ur) {
    return $(ur) === 'BigUint64Array'
  }
  o.isBigUint64Array = jt
  function Et(ur) {
    return rt(ur) === '[object Map]'
  }
  Et.working = typeof Map < 'u' && Et(new Map())
  function St(ur) {
    return typeof Map > 'u' ? !1 : Et.working ? Et(ur) : ur instanceof Map
  }
  o.isMap = St
  function Bt(ur) {
    return rt(ur) === '[object Set]'
  }
  Bt.working = typeof Set < 'u' && Bt(new Set())
  function Mt(ur) {
    return typeof Set > 'u' ? !1 : Bt.working ? Bt(ur) : ur instanceof Set
  }
  o.isSet = Mt
  function Ut(ur) {
    return rt(ur) === '[object WeakMap]'
  }
  Ut.working = typeof WeakMap < 'u' && Ut(new WeakMap())
  function Wt(ur) {
    return typeof WeakMap > 'u'
      ? !1
      : Ut.working
      ? Ut(ur)
      : ur instanceof WeakMap
  }
  o.isWeakMap = Wt
  function Tt(ur) {
    return rt(ur) === '[object WeakSet]'
  }
  Tt.working = typeof WeakSet < 'u' && Tt(new WeakSet())
  function kt(ur) {
    return Tt(ur)
  }
  o.isWeakSet = kt
  function Ot(ur) {
    return rt(ur) === '[object ArrayBuffer]'
  }
  Ot.working = typeof ArrayBuffer < 'u' && Ot(new ArrayBuffer())
  function Nt(ur) {
    return typeof ArrayBuffer > 'u'
      ? !1
      : Ot.working
      ? Ot(ur)
      : ur instanceof ArrayBuffer
  }
  o.isArrayBuffer = Nt
  function $t(ur) {
    return rt(ur) === '[object DataView]'
  }
  $t.working =
    typeof ArrayBuffer < 'u' &&
    typeof DataView < 'u' &&
    $t(new DataView(new ArrayBuffer(1), 0, 1))
  function Pt(ur) {
    return typeof DataView > 'u'
      ? !1
      : $t.working
      ? $t(ur)
      : ur instanceof DataView
  }
  o.isDataView = Pt
  var Ft = typeof SharedArrayBuffer < 'u' ? SharedArrayBuffer : void 0
  function Vt(ur) {
    return rt(ur) === '[object SharedArrayBuffer]'
  }
  function Xt(ur) {
    return typeof Ft > 'u'
      ? !1
      : (typeof Vt.working > 'u' && (Vt.working = Vt(new Ft())),
        Vt.working ? Vt(ur) : ur instanceof Ft)
  }
  o.isSharedArrayBuffer = Xt
  function Yt(ur) {
    return rt(ur) === '[object AsyncFunction]'
  }
  o.isAsyncFunction = Yt
  function xt(ur) {
    return rt(ur) === '[object Map Iterator]'
  }
  o.isMapIterator = xt
  function It(ur) {
    return rt(ur) === '[object Set Iterator]'
  }
  o.isSetIterator = It
  function Kt(ur) {
    return rt(ur) === '[object Generator]'
  }
  o.isGeneratorObject = Kt
  function Qt(ur) {
    return rt(ur) === '[object WebAssembly.Module]'
  }
  o.isWebAssemblyCompiledModule = Qt
  function Ht(ur) {
    return ut(ur, nt)
  }
  o.isNumberObject = Ht
  function Lt(ur) {
    return ut(ur, it)
  }
  o.isStringObject = Lt
  function tr(ur) {
    return ut(ur, ot)
  }
  o.isBooleanObject = tr
  function lr(ur) {
    return et && ut(ur, at)
  }
  o.isBigIntObject = lr
  function yr(ur) {
    return tt && ut(ur, st)
  }
  o.isSymbolObject = yr
  function mr(ur) {
    return Ht(ur) || Lt(ur) || tr(ur) || lr(ur) || yr(ur)
  }
  o.isBoxedPrimitive = mr
  function Er(ur) {
    return typeof Uint8Array < 'u' && (Nt(ur) || Xt(ur))
  }
  ;(o.isAnyArrayBuffer = Er),
    ['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(ur) {
      Object.defineProperty(o, ur, {
        enumerable: !1,
        value: function() {
          throw new Error(ur + ' is not supported in userland')
        },
      })
    })
})(types)
var isBufferBrowser = function(a) {
    return (
      a &&
      typeof a == 'object' &&
      typeof a.copy == 'function' &&
      typeof a.fill == 'function' &&
      typeof a.readUInt8 == 'function'
    )
  },
  inherits_browser = { exports: {} }
typeof Object.create == 'function'
  ? (inherits_browser.exports = function(a, s) {
      s &&
        ((a.super_ = s),
        (a.prototype = Object.create(s.prototype, {
          constructor: {
            value: a,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })))
    })
  : (inherits_browser.exports = function(a, s) {
      if (s) {
        a.super_ = s
        var $ = function() {}
        ;($.prototype = s.prototype),
          (a.prototype = new $()),
          (a.prototype.constructor = a)
      }
    })
var inherits_browserExports = inherits_browser.exports
;(function(o) {
  var a = {},
    s =
      Object.getOwnPropertyDescriptors ||
      function(Ft) {
        for (var Vt = Object.keys(Ft), Xt = {}, Yt = 0; Yt < Vt.length; Yt++)
          Xt[Vt[Yt]] = Object.getOwnPropertyDescriptor(Ft, Vt[Yt])
        return Xt
      },
    $ = /%[sdj%]/g
  ;(o.format = function(Pt) {
    if (!ht(Pt)) {
      for (var Ft = [], Vt = 0; Vt < arguments.length; Vt++)
        Ft.push(tt(arguments[Vt]))
      return Ft.join(' ')
    }
    for (
      var Vt = 1,
        Xt = arguments,
        Yt = Xt.length,
        xt = String(Pt).replace($, function(Kt) {
          if (Kt === '%%') return '%'
          if (Vt >= Yt) return Kt
          switch (Kt) {
            case '%s':
              return String(Xt[Vt++])
            case '%d':
              return Number(Xt[Vt++])
            case '%j':
              try {
                return JSON.stringify(Xt[Vt++])
              } catch {
                return '[Circular]'
              }
            default:
              return Kt
          }
        }),
        It = Xt[Vt];
      Vt < Yt;
      It = Xt[++Vt]
    )
      vt(It) || !Dt(It) ? (xt += ' ' + It) : (xt += ' ' + tt(It))
    return xt
  }),
    (o.deprecate = function(Pt, Ft) {
      if (typeof process < 'u' && process.noDeprecation === !0) return Pt
      if (typeof process > 'u')
        return function() {
          return o.deprecate(Pt, Ft).apply(this, arguments)
        }
      var Vt = !1
      function Xt() {
        if (!Vt) {
          if (process.throwDeprecation) throw new Error(Ft)
          process.traceDeprecation ? console.trace(Ft) : console.error(Ft),
            (Vt = !0)
        }
        return Pt.apply(this, arguments)
      }
      return Xt
    })
  var j = {},
    _e = /^$/
  if (a.NODE_DEBUG) {
    var et = a.NODE_DEBUG
    ;(et = et
      .replace(/[|\\{}()[\]^$+?.]/g, '\\$&')
      .replace(/\*/g, '.*')
      .replace(/,/g, '$|^')
      .toUpperCase()),
      (_e = new RegExp('^' + et + '$', 'i'))
  }
  o.debuglog = function(Pt) {
    if (((Pt = Pt.toUpperCase()), !j[Pt]))
      if (_e.test(Pt)) {
        var Ft = process.pid
        j[Pt] = function() {
          var Vt = o.format.apply(o, arguments)
          console.error('%s %d: %s', Pt, Ft, Vt)
        }
      } else j[Pt] = function() {}
    return j[Pt]
  }
  function tt(Pt, Ft) {
    var Vt = { seen: [], stylize: nt }
    return (
      arguments.length >= 3 && (Vt.depth = arguments[2]),
      arguments.length >= 4 && (Vt.colors = arguments[3]),
      mt(Ft) ? (Vt.showHidden = Ft) : Ft && o._extend(Vt, Ft),
      wt(Vt.showHidden) && (Vt.showHidden = !1),
      wt(Vt.depth) && (Vt.depth = 2),
      wt(Vt.colors) && (Vt.colors = !1),
      wt(Vt.customInspect) && (Vt.customInspect = !0),
      Vt.colors && (Vt.stylize = rt),
      ot(Vt, Pt, Vt.depth)
    )
  }
  ;(o.inspect = tt),
    (tt.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39],
    }),
    (tt.styles = {
      special: 'cyan',
      number: 'yellow',
      boolean: 'yellow',
      undefined: 'grey',
      null: 'bold',
      string: 'green',
      date: 'magenta',
      regexp: 'red',
    })
  function rt(Pt, Ft) {
    var Vt = tt.styles[Ft]
    return Vt
      ? '\x1B[' + tt.colors[Vt][0] + 'm' + Pt + '\x1B[' + tt.colors[Vt][1] + 'm'
      : Pt
  }
  function nt(Pt, Ft) {
    return Pt
  }
  function it(Pt) {
    var Ft = {}
    return (
      Pt.forEach(function(Vt, Xt) {
        Ft[Vt] = !0
      }),
      Ft
    )
  }
  function ot(Pt, Ft, Vt) {
    if (
      Pt.customInspect &&
      Ft &&
      St(Ft.inspect) &&
      Ft.inspect !== o.inspect &&
      !(Ft.constructor && Ft.constructor.prototype === Ft)
    ) {
      var Xt = Ft.inspect(Vt, Pt)
      return ht(Xt) || (Xt = ot(Pt, Xt, Vt)), Xt
    }
    var Yt = at(Pt, Ft)
    if (Yt) return Yt
    var xt = Object.keys(Ft),
      It = it(xt)
    if (
      (Pt.showHidden && (xt = Object.getOwnPropertyNames(Ft)),
      Et(Ft) && (xt.indexOf('message') >= 0 || xt.indexOf('description') >= 0))
    )
      return st(Ft)
    if (xt.length === 0) {
      if (St(Ft)) {
        var Kt = Ft.name ? ': ' + Ft.name : ''
        return Pt.stylize('[Function' + Kt + ']', 'special')
      }
      if (Ct(Ft))
        return Pt.stylize(RegExp.prototype.toString.call(Ft), 'regexp')
      if (jt(Ft)) return Pt.stylize(Date.prototype.toString.call(Ft), 'date')
      if (Et(Ft)) return st(Ft)
    }
    var Qt = '',
      Ht = !1,
      Lt = ['{', '}']
    if ((ft(Ft) && ((Ht = !0), (Lt = ['[', ']'])), St(Ft))) {
      var tr = Ft.name ? ': ' + Ft.name : ''
      Qt = ' [Function' + tr + ']'
    }
    if (
      (Ct(Ft) && (Qt = ' ' + RegExp.prototype.toString.call(Ft)),
      jt(Ft) && (Qt = ' ' + Date.prototype.toUTCString.call(Ft)),
      Et(Ft) && (Qt = ' ' + st(Ft)),
      xt.length === 0 && (!Ht || Ft.length == 0))
    )
      return Lt[0] + Qt + Lt[1]
    if (Vt < 0)
      return Ct(Ft)
        ? Pt.stylize(RegExp.prototype.toString.call(Ft), 'regexp')
        : Pt.stylize('[Object]', 'special')
    Pt.seen.push(Ft)
    var lr
    return (
      Ht
        ? (lr = ut(Pt, Ft, Vt, It, xt))
        : (lr = xt.map(function(yr) {
            return ct(Pt, Ft, Vt, It, yr, Ht)
          })),
      Pt.seen.pop(),
      dt(lr, Qt, Lt)
    )
  }
  function at(Pt, Ft) {
    if (wt(Ft)) return Pt.stylize('undefined', 'undefined')
    if (ht(Ft)) {
      var Vt =
        "'" +
        JSON.stringify(Ft)
          .replace(/^"|"$/g, '')
          .replace(/'/g, "\\'")
          .replace(/\\"/g, '"') +
        "'"
      return Pt.stylize(Vt, 'string')
    }
    if (pt(Ft)) return Pt.stylize('' + Ft, 'number')
    if (mt(Ft)) return Pt.stylize('' + Ft, 'boolean')
    if (vt(Ft)) return Pt.stylize('null', 'null')
  }
  function st(Pt) {
    return '[' + Error.prototype.toString.call(Pt) + ']'
  }
  function ut(Pt, Ft, Vt, Xt, Yt) {
    for (var xt = [], It = 0, Kt = Ft.length; It < Kt; ++It)
      kt(Ft, String(It))
        ? xt.push(ct(Pt, Ft, Vt, Xt, String(It), !0))
        : xt.push('')
    return (
      Yt.forEach(function(Qt) {
        Qt.match(/^\d+$/) || xt.push(ct(Pt, Ft, Vt, Xt, Qt, !0))
      }),
      xt
    )
  }
  function ct(Pt, Ft, Vt, Xt, Yt, xt) {
    var It, Kt, Qt
    if (
      ((Qt = Object.getOwnPropertyDescriptor(Ft, Yt) || { value: Ft[Yt] }),
      Qt.get
        ? Qt.set
          ? (Kt = Pt.stylize('[Getter/Setter]', 'special'))
          : (Kt = Pt.stylize('[Getter]', 'special'))
        : Qt.set && (Kt = Pt.stylize('[Setter]', 'special')),
      kt(Xt, Yt) || (It = '[' + Yt + ']'),
      Kt ||
        (Pt.seen.indexOf(Qt.value) < 0
          ? (vt(Vt)
              ? (Kt = ot(Pt, Qt.value, null))
              : (Kt = ot(Pt, Qt.value, Vt - 1)),
            Kt.indexOf(`
`) > -1 &&
              (xt
                ? (Kt = Kt.split(
                    `
`
                  )
                    .map(function(Ht) {
                      return '  ' + Ht
                    })
                    .join(
                      `
`
                    )
                    .slice(2))
                : (Kt =
                    `
` +
                    Kt.split(
                      `
`
                    ).map(function(Ht) {
                      return '   ' + Ht
                    }).join(`
`))))
          : (Kt = Pt.stylize('[Circular]', 'special'))),
      wt(It))
    ) {
      if (xt && Yt.match(/^\d+$/)) return Kt
      ;(It = JSON.stringify('' + Yt)),
        It.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)
          ? ((It = It.slice(1, -1)), (It = Pt.stylize(It, 'name')))
          : ((It = It.replace(/'/g, "\\'")
              .replace(/\\"/g, '"')
              .replace(/(^"|"$)/g, "'")),
            (It = Pt.stylize(It, 'string')))
    }
    return It + ': ' + Kt
  }
  function dt(Pt, Ft, Vt) {
    var Xt = Pt.reduce(function(Yt, xt) {
      return (
        xt.indexOf(`
`) >= 0,
        Yt + xt.replace(/\u001b\[\d\d?m/g, '').length + 1
      )
    }, 0)
    return Xt > 60
      ? Vt[0] +
          (Ft === ''
            ? ''
            : Ft +
              `
 `) +
          ' ' +
          Pt.join(`,
  `) +
          ' ' +
          Vt[1]
      : Vt[0] + Ft + ' ' + Pt.join(', ') + ' ' + Vt[1]
  }
  o.types = types
  function ft(Pt) {
    return Array.isArray(Pt)
  }
  o.isArray = ft
  function mt(Pt) {
    return typeof Pt == 'boolean'
  }
  o.isBoolean = mt
  function vt(Pt) {
    return Pt === null
  }
  o.isNull = vt
  function yt(Pt) {
    return Pt == null
  }
  o.isNullOrUndefined = yt
  function pt(Pt) {
    return typeof Pt == 'number'
  }
  o.isNumber = pt
  function ht(Pt) {
    return typeof Pt == 'string'
  }
  o.isString = ht
  function At(Pt) {
    return typeof Pt == 'symbol'
  }
  o.isSymbol = At
  function wt(Pt) {
    return Pt === void 0
  }
  o.isUndefined = wt
  function Ct(Pt) {
    return Dt(Pt) && Mt(Pt) === '[object RegExp]'
  }
  ;(o.isRegExp = Ct), (o.types.isRegExp = Ct)
  function Dt(Pt) {
    return typeof Pt == 'object' && Pt !== null
  }
  o.isObject = Dt
  function jt(Pt) {
    return Dt(Pt) && Mt(Pt) === '[object Date]'
  }
  ;(o.isDate = jt), (o.types.isDate = jt)
  function Et(Pt) {
    return Dt(Pt) && (Mt(Pt) === '[object Error]' || Pt instanceof Error)
  }
  ;(o.isError = Et), (o.types.isNativeError = Et)
  function St(Pt) {
    return typeof Pt == 'function'
  }
  o.isFunction = St
  function Bt(Pt) {
    return (
      Pt === null ||
      typeof Pt == 'boolean' ||
      typeof Pt == 'number' ||
      typeof Pt == 'string' ||
      typeof Pt == 'symbol' ||
      typeof Pt > 'u'
    )
  }
  ;(o.isPrimitive = Bt), (o.isBuffer = isBufferBrowser)
  function Mt(Pt) {
    return Object.prototype.toString.call(Pt)
  }
  function Ut(Pt) {
    return Pt < 10 ? '0' + Pt.toString(10) : Pt.toString(10)
  }
  var Wt = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec',
  ]
  function Tt() {
    var Pt = new Date(),
      Ft = [Ut(Pt.getHours()), Ut(Pt.getMinutes()), Ut(Pt.getSeconds())].join(
        ':'
      )
    return [Pt.getDate(), Wt[Pt.getMonth()], Ft].join(' ')
  }
  ;(o.log = function() {
    console.log('%s - %s', Tt(), o.format.apply(o, arguments))
  }),
    (o.inherits = inherits_browserExports),
    (o._extend = function(Pt, Ft) {
      if (!Ft || !Dt(Ft)) return Pt
      for (var Vt = Object.keys(Ft), Xt = Vt.length; Xt--; )
        Pt[Vt[Xt]] = Ft[Vt[Xt]]
      return Pt
    })
  function kt(Pt, Ft) {
    return Object.prototype.hasOwnProperty.call(Pt, Ft)
  }
  var Ot = typeof Symbol < 'u' ? Symbol('util.promisify.custom') : void 0
  ;(o.promisify = function(Ft) {
    if (typeof Ft != 'function')
      throw new TypeError('The "original" argument must be of type Function')
    if (Ot && Ft[Ot]) {
      var Vt = Ft[Ot]
      if (typeof Vt != 'function')
        throw new TypeError(
          'The "util.promisify.custom" argument must be of type Function'
        )
      return (
        Object.defineProperty(Vt, Ot, {
          value: Vt,
          enumerable: !1,
          writable: !1,
          configurable: !0,
        }),
        Vt
      )
    }
    function Vt() {
      for (
        var Xt,
          Yt,
          xt = new Promise(function(Qt, Ht) {
            ;(Xt = Qt), (Yt = Ht)
          }),
          It = [],
          Kt = 0;
        Kt < arguments.length;
        Kt++
      )
        It.push(arguments[Kt])
      It.push(function(Qt, Ht) {
        Qt ? Yt(Qt) : Xt(Ht)
      })
      try {
        Ft.apply(this, It)
      } catch (Qt) {
        Yt(Qt)
      }
      return xt
    }
    return (
      Object.setPrototypeOf(Vt, Object.getPrototypeOf(Ft)),
      Ot &&
        Object.defineProperty(Vt, Ot, {
          value: Vt,
          enumerable: !1,
          writable: !1,
          configurable: !0,
        }),
      Object.defineProperties(Vt, s(Ft))
    )
  }),
    (o.promisify.custom = Ot)
  function Nt(Pt, Ft) {
    if (!Pt) {
      var Vt = new Error('Promise was rejected with a falsy value')
      ;(Vt.reason = Pt), (Pt = Vt)
    }
    return Ft(Pt)
  }
  function $t(Pt) {
    if (typeof Pt != 'function')
      throw new TypeError('The "original" argument must be of type Function')
    function Ft() {
      for (var Vt = [], Xt = 0; Xt < arguments.length; Xt++)
        Vt.push(arguments[Xt])
      var Yt = Vt.pop()
      if (typeof Yt != 'function')
        throw new TypeError('The last argument must be of type Function')
      var xt = this,
        It = function() {
          return Yt.apply(xt, arguments)
        }
      Pt.apply(this, Vt).then(
        function(Kt) {
          process.nextTick(It.bind(null, null, Kt))
        },
        function(Kt) {
          process.nextTick(Nt.bind(null, Kt, It))
        }
      )
    }
    return (
      Object.setPrototypeOf(Ft, Object.getPrototypeOf(Pt)),
      Object.defineProperties(Ft, s(Pt)),
      Ft
    )
  }
  o.callbackify = $t
})(util$u)
var ltgt$1 = {}
;(function(o) {
  o.compare = function(st, ut) {
    if (Buffer.isBuffer(st)) {
      for (var ct = Math.min(st.length, ut.length), dt = 0; dt < ct; dt++) {
        var ft = st[dt] - ut[dt]
        if (ft) return ft
      }
      return st.length - ut.length
    }
    return st < ut ? -1 : st > ut ? 1 : 0
  }
  function a(st) {
    return st !== void 0 && st !== ''
  }
  function s(st, ut) {
    return Object.hasOwnProperty.call(st, ut)
  }
  function $(st, ut) {
    return Object.hasOwnProperty.call(st, ut) && ut
  }
  var j = (o.lowerBoundKey = function(st) {
      return (
        $(st, 'gt') ||
        $(st, 'gte') ||
        $(st, 'min') ||
        (st.reverse ? $(st, 'end') : $(st, 'start')) ||
        void 0
      )
    }),
    _e = (o.lowerBound = function(st, ut) {
      var ct = j(st)
      return ct ? st[ct] : ut
    }),
    et = (o.lowerBoundInclusive = function(st) {
      return !s(st, 'gt')
    }),
    tt = (o.upperBoundInclusive = function(st) {
      return !s(st, 'lt')
    }),
    rt = (o.lowerBoundExclusive = function(st) {
      return !et(st)
    }),
    nt = (o.upperBoundExclusive = function(st) {
      return !tt(st)
    }),
    it = (o.upperBoundKey = function(st) {
      return (
        $(st, 'lt') ||
        $(st, 'lte') ||
        $(st, 'max') ||
        (st.reverse ? $(st, 'start') : $(st, 'end')) ||
        void 0
      )
    }),
    ot = (o.upperBound = function(st, ut) {
      var ct = it(st)
      return ct ? st[ct] : ut
    })
  ;(o.start = function(st, ut) {
    return st.reverse ? ot(st, ut) : _e(st, ut)
  }),
    (o.end = function(st, ut) {
      return st.reverse ? _e(st, ut) : ot(st, ut)
    }),
    (o.startInclusive = function(st) {
      return st.reverse ? tt(st) : et(st)
    }),
    (o.endInclusive = function(st) {
      return st.reverse ? et(st) : tt(st)
    })
  function at(st) {
    return st
  }
  ;(o.toLtgt = function(st, ut, ct, dt, ft) {
    ;(ut = ut || {}), (ct = ct || at)
    var mt = arguments.length > 3,
      vt = o.lowerBoundKey(st),
      yt = o.upperBoundKey(st)
    return (
      vt
        ? vt === 'gt'
          ? (ut.gt = ct(st.gt, !1))
          : (ut.gte = ct(st[vt], !1))
        : mt && (ut.gte = ct(dt, !1)),
      yt
        ? yt === 'lt'
          ? (ut.lt = ct(st.lt, !0))
          : (ut.lte = ct(st[yt], !0))
        : mt && (ut.lte = ct(ft, !0)),
      st.reverse != null && (ut.reverse = !!st.reverse),
      s(ut, 'max') && delete ut.max,
      s(ut, 'min') && delete ut.min,
      s(ut, 'start') && delete ut.start,
      s(ut, 'end') && delete ut.end,
      ut
    )
  }),
    (o.contains = function(st, ut, ct) {
      ct = ct || o.compare
      var dt = _e(st)
      if (a(dt)) {
        var ft = ct(ut, dt)
        if (ft < 0 || (ft === 0 && rt(st))) return !1
      }
      var mt = ot(st)
      if (a(mt)) {
        var ft = ct(ut, mt)
        if (ft > 0 || (ft === 0 && nt(st))) return !1
      }
      return !0
    }),
    (o.filter = function(st, ut) {
      return function(ct) {
        return o.contains(st, ct, ut)
      }
    })
})(ltgt$1)
var util$t = util$u,
  AbstractIterator = abstractLeveldown.AbstractIterator,
  ltgt = ltgt$1,
  iterator = Iterator$2
function Iterator$2(o, a) {
  a || (a = {}),
    (this.options = a),
    AbstractIterator.call(this, o),
    (this._order = a.reverse ? 'DESC' : 'ASC'),
    (this._limit = a.limit),
    (this._count = 0),
    (this._done = !1)
  var s = ltgt.lowerBound(a),
    $ = ltgt.upperBound(a)
  try {
    this._keyRange =
      s || $
        ? this.db.makeKeyRange({
            lower: s,
            upper: $,
            excludeLower: ltgt.lowerBoundExclusive(a),
            excludeUpper: ltgt.upperBoundExclusive(a),
          })
        : null
  } catch {
    this._keyRangeError = !0
  }
  this.callback = null
}
util$t.inherits(Iterator$2, AbstractIterator)
Iterator$2.prototype.createIterator = function() {
  var o = this
  o.iterator = o.db.iterate(
    function() {
      o.onItem.apply(o, arguments)
    },
    {
      keyRange: o._keyRange,
      autoContinue: !1,
      order: o._order,
      onError: function(a) {
        console.log('horrible error', a)
      },
    }
  )
}
Iterator$2.prototype.onItem = function(o, a, s) {
  if (!a && this.callback) {
    this.callback(), (this.callback = !1)
    return
  }
  var $ = !0
  this._limit && this._limit > 0 && this._count++ >= this._limit && ($ = !1),
    $ && this.callback(!1, a.key, a.value),
    a && a.continue()
}
Iterator$2.prototype._next = function(o) {
  if (!o) return new Error('next() requires a callback argument')
  if (this._keyRangeError) return o()
  this._started || (this.createIterator(), (this._started = !0)),
    (this.callback = o)
}
var Buffer$4 = buffer$1.Buffer,
  isbuffer = isBuffer$2
function isBuffer$2(o) {
  return (
    Buffer$4.isBuffer(o) ||
    /\[object (.+Array|Array.+)\]/.test(Object.prototype.toString.call(o))
  )
}
var shim$3 = { exports: {} },
  foreach$1,
  hasRequiredForeach$1
function requireForeach$1() {
  if (hasRequiredForeach$1) return foreach$1
  hasRequiredForeach$1 = 1
  var o = Object.prototype.hasOwnProperty,
    a = Object.prototype.toString,
    s = function($) {
      var j =
        (typeof $ == 'function' && !($ instanceof RegExp)) ||
        a.call($) === '[object Function]'
      return (
        !j &&
          typeof window < 'u' &&
          (j =
            $ === window.setTimeout ||
            $ === window.alert ||
            $ === window.confirm ||
            $ === window.prompt),
        j
      )
    }
  return (
    (foreach$1 = function(j, _e) {
      if (!s(_e)) throw new TypeError('iterator must be a function')
      var et,
        tt,
        rt = typeof j == 'string',
        nt = j.length,
        it = arguments.length > 2 ? arguments[2] : null
      if (nt === +nt)
        for (et = 0; et < nt; et++)
          it === null
            ? _e(rt ? j.charAt(et) : j[et], et, j)
            : _e.call(it, rt ? j.charAt(et) : j[et], et, j)
      else
        for (tt in j)
          o.call(j, tt) &&
            (it === null ? _e(j[tt], tt, j) : _e.call(it, j[tt], tt, j))
    }),
    foreach$1
  )
}
var isArguments$1, hasRequiredIsArguments$1
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1) return isArguments$1
  hasRequiredIsArguments$1 = 1
  var o = Object.prototype.toString
  return (
    (isArguments$1 = function(s) {
      var $ = o.call(s),
        j = $ === '[object Arguments]'
      return (
        j ||
          (j =
            $ !== '[object Array]' &&
            s !== null &&
            typeof s == 'object' &&
            typeof s.length == 'number' &&
            s.length >= 0 &&
            o.call(s.callee) === '[object Function]'),
        j
      )
    }),
    isArguments$1
  )
}
var hasRequiredShim$3
function requireShim$3() {
  return (
    hasRequiredShim$3 ||
      ((hasRequiredShim$3 = 1),
      (function() {
        var o = Object.prototype.hasOwnProperty,
          a = Object.prototype.toString,
          s = requireForeach$1(),
          $ = requireIsArguments$1(),
          j = !{ toString: null }.propertyIsEnumerable('toString'),
          _e = function() {}.propertyIsEnumerable('prototype'),
          et = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor',
          ],
          tt
        ;(tt = function(nt) {
          var it = nt !== null && typeof nt == 'object',
            ot = a.call(nt) === '[object Function]',
            at = $(nt),
            st = []
          if (!it && !ot && !at)
            throw new TypeError('Object.keys called on a non-object')
          if (at)
            s(nt, function(mt) {
              st.push(mt)
            })
          else {
            var ut,
              ct = _e && ot
            for (ut in nt)
              !(ct && ut === 'prototype') && o.call(nt, ut) && st.push(ut)
          }
          if (j) {
            var dt = nt.constructor,
              ft = dt && dt.prototype === nt
            s(et, function(mt) {
              !(ft && mt === 'constructor') && o.call(nt, mt) && st.push(mt)
            })
          }
          return st
        }),
          (shim$3.exports = tt)
      })()),
    shim$3.exports
  )
}
var objectKeys$2 = Object.keys || requireShim$3(),
  hasKeys_1$2 = hasKeys$5
function hasKeys$5(o) {
  return o !== null && (typeof o == 'object' || typeof o == 'function')
}
var Keys$1 = objectKeys$2,
  hasKeys$4 = hasKeys_1$2,
  xtend$d = extend$c
function extend$c() {
  for (var o = {}, a = 0; a < arguments.length; a++) {
    var s = arguments[a]
    if (hasKeys$4(s))
      for (var $ = Keys$1(s), j = 0; j < $.length; j++) {
        var _e = $[j]
        o[_e] = s[_e]
      }
  }
  return o
}
var typedarrayToBuffer = function(o) {
    return typeof Buffer._augment == 'function' && Buffer.TYPED_ARRAY_SUPPORT
      ? Buffer._augment(o)
      : new Buffer(o)
  },
  levelJs = Level,
  IDB = idbstoreExports,
  AbstractLevelDOWN$1 = abstractLeveldown.AbstractLevelDOWN,
  util$s = util$u,
  Iterator$1 = iterator,
  isBuffer$1 = isbuffer,
  xtend$c = xtend$d,
  toBuffer = typedarrayToBuffer
function Level(o) {
  if (!(this instanceof Level)) return new Level(o)
  if (!o) throw new Error('constructor requires at least a location argument')
  ;(this.IDBOptions = {}), (this.location = o)
}
util$s.inherits(Level, AbstractLevelDOWN$1)
Level.prototype._open = function(o, a) {
  var s = this,
    $ = {
      storeName: this.location,
      autoIncrement: !1,
      keyPath: null,
      onStoreReady: function() {
        a && a(null, s.idb)
      },
      onError: function(j) {
        a && a(j)
      },
    }
  xtend$c($, o), (this.IDBOptions = $), (this.idb = new IDB($))
}
Level.prototype._get = function(o, a, s) {
  this.idb.get(
    o,
    function($) {
      if ($ === void 0) return s(new Error('NotFound'))
      var j = !0
      return (
        a.asBuffer === !1 && (j = !1),
        a.raw && (j = !1),
        j &&
          ($ instanceof Uint8Array
            ? ($ = toBuffer($))
            : ($ = new Buffer(String($)))),
        s(null, $, o)
      )
    },
    s
  )
}
Level.prototype._del = function(o, a, s) {
  this.idb.remove(o, s, s)
}
Level.prototype._put = function(o, a, s, $) {
  a instanceof ArrayBuffer && (a = toBuffer(new Uint8Array(a)))
  var j = this.convertEncoding(o, a, s)
  Buffer.isBuffer(j.value) &&
    (typeof a.toArrayBuffer == 'function'
      ? (j.value = new Uint8Array(a.toArrayBuffer()))
      : (j.value = new Uint8Array(a))),
    this.idb.put(
      j.key,
      j.value,
      function() {
        $()
      },
      $
    )
}
Level.prototype.convertEncoding = function(o, a, s) {
  if (s.raw) return { key: o, value: a }
  if (a) {
    var $ = a.toString()
    $ === 'NaN' && (a = 'NaN')
  }
  var j = s.valueEncoding,
    _e = { key: o, value: a }
  return (
    a &&
      (!j || j !== 'binary') &&
      typeof _e.value != 'object' &&
      (_e.value = $),
    _e
  )
}
Level.prototype.iterator = function(o) {
  return typeof o != 'object' && (o = {}), new Iterator$1(this.idb, o)
}
Level.prototype._batch = function(o, a, s) {
  var $,
    j,
    _e,
    et,
    tt = []
  if (o.length === 0) return setTimeout(s, 0)
  for ($ = 0; $ < o.length; $++) {
    ;(_e = {}), (et = o[$]), (tt[$] = _e)
    var rt = this.convertEncoding(et.key, et.value, a)
    ;(et.key = rt.key), (et.value = rt.value)
    for (j in et)
      j === 'type' && et[j] == 'del' ? (_e[j] = 'remove') : (_e[j] = et[j])
  }
  return this.idb.batch(
    tt,
    function() {
      s()
    },
    s
  )
}
Level.prototype._close = function(o) {
  this.idb.db.close(), o()
}
Level.prototype._approximateSize = function(o, a, s) {
  var $ = new Error('Not implemented')
  if (s) return s($)
  throw $
}
Level.prototype._isBuffer = function(o) {
  return Buffer.isBuffer(o)
}
Level.destroy = function(o, a) {
  if (typeof o == 'object')
    var s = o.IDBOptions.storePrefix || 'IDBWrapper-',
      $ = o.location
  else
    var s = 'IDBWrapper-',
      $ = o
  var j = indexedDB.deleteDatabase(s + $)
  ;(j.onsuccess = function() {
    a()
  }),
    (j.onerror = function(_e) {
      a(_e)
    })
}
Level.prototype._checkKeyValue = function(o, a) {
  if (o == null) return new Error(a + ' cannot be `null` or `undefined`')
  if (o == null) return new Error(a + ' cannot be `null` or `undefined`')
  if (isBuffer$1(o) && o.byteLength === 0)
    return new Error(a + ' cannot be an empty ArrayBuffer')
  if (String(o) === '') return new Error(a + ' cannot be an empty String')
  if (o.length === 0) return new Error(a + ' cannot be an empty Array')
}
var levelup$1 = { exports: {} },
  xtend$b = extend$b
function extend$b() {
  for (var o = {}, a = 0; a < arguments.length; a++) {
    var s = arguments[a]
    for (var $ in s) s.hasOwnProperty($) && (o[$] = s[$])
  }
  return o
}
var prr$3 = { exports: {} }
/*!
 * prr
 * (c) 2013 Rod Vagg <rod@vagg.org>
 * https://github.com/rvagg/prr
 * License: MIT
 */ ;(function(o) {
  ;(function(a, s, $) {
    o.exports ? (o.exports = $()) : (s[a] = $())
  })('prr', commonjsGlobal$1, function() {
    var a =
        typeof Object.defineProperty == 'function'
          ? function(j, _e, et) {
              return Object.defineProperty(j, _e, et), j
            }
          : function(j, _e, et) {
              return (j[_e] = et.value), j
            },
      s = function(j, _e) {
        var et = typeof _e == 'object',
          tt = !et && typeof _e == 'string',
          rt = function(nt) {
            return et ? !!_e[nt] : tt ? _e.indexOf(nt[0]) > -1 : !1
          }
        return {
          enumerable: rt('enumerable'),
          configurable: rt('configurable'),
          writable: rt('writable'),
          value: j,
        }
      },
      $ = function(j, _e, et, tt) {
        var rt
        if (((tt = s(et, tt)), typeof _e == 'object')) {
          for (rt in _e)
            Object.hasOwnProperty.call(_e, rt) &&
              ((tt.value = _e[rt]), a(j, rt, tt))
          return j
        }
        return a(j, _e, tt)
      }
    return $
  })
})(prr$3)
var prrExports$1 = prr$3.exports,
  util$r = util$u,
  AbstractLevelDOWN = abstractLeveldown.AbstractLevelDOWN
function DeferredLevelDOWN$1(o) {
  AbstractLevelDOWN.call(this, typeof o == 'string' ? o : ''),
    (this._db = void 0),
    (this._operations = [])
}
util$r.inherits(DeferredLevelDOWN$1, AbstractLevelDOWN)
DeferredLevelDOWN$1.prototype.setDb = function(o) {
  ;(this._db = o),
    this._operations.forEach(function(a) {
      o[a.method].apply(o, a.args)
    })
}
DeferredLevelDOWN$1.prototype._open = function(o, a) {
  return process.nextTick(a)
}
DeferredLevelDOWN$1.prototype._operation = function(o, a) {
  if (this._db) return this._db[o].apply(this._db, a)
  this._operations.push({ method: o, args: a })
}
'put get del batch approximateSize'.split(' ').forEach(function(o) {
  DeferredLevelDOWN$1.prototype['_' + o] = function() {
    this._operation(o, arguments)
  }
})
DeferredLevelDOWN$1.prototype._isBuffer = function(o) {
  return Buffer.isBuffer(o)
}
DeferredLevelDOWN$1.prototype._iterator = function() {
  throw new TypeError('not implemented')
}
var deferredLeveldown = DeferredLevelDOWN$1,
  errno$3 = { exports: {} },
  prr$2 = { exports: {} }
/*!
 * prr
 * (c) 2013 Rod Vagg <rod@vagg.org>
 * https://github.com/rvagg/prr
 * License: MIT
 */ ;(function(o) {
  ;(function(a, s, $) {
    o.exports ? (o.exports = $()) : (s[a] = $())
  })('prr', commonjsGlobal$1, function() {
    var a =
        typeof Object.defineProperty == 'function'
          ? function(j, _e, et) {
              return Object.defineProperty(j, _e, et), j
            }
          : function(j, _e, et) {
              return (j[_e] = et.value), j
            },
      s = function(j, _e) {
        var et = typeof _e == 'object',
          tt = !et && typeof _e == 'string',
          rt = function(nt) {
            return et ? !!_e[nt] : tt ? _e.indexOf(nt[0]) > -1 : !1
          }
        return {
          enumerable: rt('enumerable'),
          configurable: rt('configurable'),
          writable: rt('writable'),
          value: j,
        }
      },
      $ = function(j, _e, et, tt) {
        var rt
        if (((tt = s(et, tt)), typeof _e == 'object')) {
          for (rt in _e)
            Object.hasOwnProperty.call(_e, rt) &&
              ((tt.value = _e[rt]), a(j, rt, tt))
          return j
        }
        return a(j, _e, tt)
      }
    return $
  })
})(prr$2)
var prrExports = prr$2.exports,
  prr$1 = prrExports
function init(o, a, s) {
  a && typeof a != 'string' && (a = a.message || a.name),
    prr$1(
      this,
      { type: o, name: o, cause: typeof a != 'string' ? a : s, message: a },
      'ewr'
    )
}
function CustomError(o, a) {
  Error.call(this),
    Error.captureStackTrace && Error.captureStackTrace(this, this.constructor),
    init.call(this, 'CustomError', o, a)
}
CustomError.prototype = new Error()
function createError$1(o, a, s) {
  var $ = function(j, _e) {
    init.call(this, a, j, _e),
      a == 'FilesystemError' &&
        ((this.code = this.cause.code),
        (this.path = this.cause.path),
        (this.errno = this.cause.errno),
        (this.message =
          (o.errno[this.cause.errno]
            ? o.errno[this.cause.errno].description
            : this.cause.message) +
          (this.cause.path ? ' [' + this.cause.path + ']' : ''))),
      Error.call(this),
      Error.captureStackTrace && Error.captureStackTrace(this, $)
  }
  return ($.prototype = s ? new s() : new CustomError()), $
}
var custom = function(o) {
  var a = function(s, $) {
    return createError$1(o, s, $)
  }
  return { CustomError, FilesystemError: a('FilesystemError'), createError: a }
}
;(function(o) {
  var a = (o.exports.all = [
    { errno: -2, code: 'ENOENT', description: 'no such file or directory' },
    { errno: -1, code: 'UNKNOWN', description: 'unknown error' },
    { errno: 0, code: 'OK', description: 'success' },
    { errno: 1, code: 'EOF', description: 'end of file' },
    { errno: 2, code: 'EADDRINFO', description: 'getaddrinfo error' },
    { errno: 3, code: 'EACCES', description: 'permission denied' },
    {
      errno: 4,
      code: 'EAGAIN',
      description: 'resource temporarily unavailable',
    },
    { errno: 5, code: 'EADDRINUSE', description: 'address already in use' },
    { errno: 6, code: 'EADDRNOTAVAIL', description: 'address not available' },
    {
      errno: 7,
      code: 'EAFNOSUPPORT',
      description: 'address family not supported',
    },
    {
      errno: 8,
      code: 'EALREADY',
      description: 'connection already in progress',
    },
    { errno: 9, code: 'EBADF', description: 'bad file descriptor' },
    { errno: 10, code: 'EBUSY', description: 'resource busy or locked' },
    {
      errno: 11,
      code: 'ECONNABORTED',
      description: 'software caused connection abort',
    },
    { errno: 12, code: 'ECONNREFUSED', description: 'connection refused' },
    { errno: 13, code: 'ECONNRESET', description: 'connection reset by peer' },
    {
      errno: 14,
      code: 'EDESTADDRREQ',
      description: 'destination address required',
    },
    {
      errno: 15,
      code: 'EFAULT',
      description: 'bad address in system call argument',
    },
    { errno: 16, code: 'EHOSTUNREACH', description: 'host is unreachable' },
    { errno: 17, code: 'EINTR', description: 'interrupted system call' },
    { errno: 18, code: 'EINVAL', description: 'invalid argument' },
    { errno: 19, code: 'EISCONN', description: 'socket is already connected' },
    { errno: 20, code: 'EMFILE', description: 'too many open files' },
    { errno: 21, code: 'EMSGSIZE', description: 'message too long' },
    { errno: 22, code: 'ENETDOWN', description: 'network is down' },
    { errno: 23, code: 'ENETUNREACH', description: 'network is unreachable' },
    { errno: 24, code: 'ENFILE', description: 'file table overflow' },
    { errno: 25, code: 'ENOBUFS', description: 'no buffer space available' },
    { errno: 26, code: 'ENOMEM', description: 'not enough memory' },
    { errno: 27, code: 'ENOTDIR', description: 'not a directory' },
    {
      errno: 28,
      code: 'EISDIR',
      description: 'illegal operation on a directory',
    },
    { errno: 29, code: 'ENONET', description: 'machine is not on the network' },
    { errno: 31, code: 'ENOTCONN', description: 'socket is not connected' },
    {
      errno: 32,
      code: 'ENOTSOCK',
      description: 'socket operation on non-socket',
    },
    {
      errno: 33,
      code: 'ENOTSUP',
      description: 'operation not supported on socket',
    },
    { errno: 34, code: 'ENOENT', description: 'no such file or directory' },
    { errno: 35, code: 'ENOSYS', description: 'function not implemented' },
    { errno: 36, code: 'EPIPE', description: 'broken pipe' },
    { errno: 37, code: 'EPROTO', description: 'protocol error' },
    {
      errno: 38,
      code: 'EPROTONOSUPPORT',
      description: 'protocol not supported',
    },
    {
      errno: 39,
      code: 'EPROTOTYPE',
      description: 'protocol wrong type for socket',
    },
    { errno: 40, code: 'ETIMEDOUT', description: 'connection timed out' },
    { errno: 41, code: 'ECHARSET', description: 'invalid Unicode character' },
    {
      errno: 42,
      code: 'EAIFAMNOSUPPORT',
      description: 'address family for hostname not supported',
    },
    {
      errno: 44,
      code: 'EAISERVICE',
      description: 'servname not supported for ai_socktype',
    },
    {
      errno: 45,
      code: 'EAISOCKTYPE',
      description: 'ai_socktype not supported',
    },
    {
      errno: 46,
      code: 'ESHUTDOWN',
      description: 'cannot send after transport endpoint shutdown',
    },
    { errno: 47, code: 'EEXIST', description: 'file already exists' },
    { errno: 48, code: 'ESRCH', description: 'no such process' },
    { errno: 49, code: 'ENAMETOOLONG', description: 'name too long' },
    { errno: 50, code: 'EPERM', description: 'operation not permitted' },
    {
      errno: 51,
      code: 'ELOOP',
      description: 'too many symbolic links encountered',
    },
    {
      errno: 52,
      code: 'EXDEV',
      description: 'cross-device link not permitted',
    },
    { errno: 53, code: 'ENOTEMPTY', description: 'directory not empty' },
    { errno: 54, code: 'ENOSPC', description: 'no space left on device' },
    { errno: 55, code: 'EIO', description: 'i/o error' },
    { errno: 56, code: 'EROFS', description: 'read-only file system' },
    { errno: 57, code: 'ENODEV', description: 'no such device' },
    { errno: 58, code: 'ESPIPE', description: 'invalid seek' },
    { errno: 59, code: 'ECANCELED', description: 'operation canceled' },
  ])
  ;(o.exports.errno = {}),
    (o.exports.code = {}),
    a.forEach(function(s) {
      ;(o.exports.errno[s.errno] = s), (o.exports.code[s.code] = s)
    }),
    (o.exports.custom = custom(o.exports)),
    (o.exports.create = o.exports.custom.createError)
})(errno$3)
var errnoExports = errno$3.exports,
  createError = errnoExports.create,
  LevelUPError$1 = createError('LevelUPError'),
  NotFoundError$1 = createError('NotFoundError', LevelUPError$1)
NotFoundError$1.prototype.notFound = !0
NotFoundError$1.prototype.status = 404
var errors$1 = {
    LevelUPError: LevelUPError$1,
    InitializationError: createError('InitializationError', LevelUPError$1),
    OpenError: createError('OpenError', LevelUPError$1),
    ReadError: createError('ReadError', LevelUPError$1),
    WriteError: createError('WriteError', LevelUPError$1),
    NotFoundError: NotFoundError$1,
    EncodingError: createError('EncodingError', LevelUPError$1),
  },
  readable$3 = { exports: {} },
  streamBrowser$1,
  hasRequiredStreamBrowser
function requireStreamBrowser() {
  return (
    hasRequiredStreamBrowser ||
      ((hasRequiredStreamBrowser = 1),
      (streamBrowser$1 = eventsExports.EventEmitter)),
    streamBrowser$1
  )
}
const __viteBrowserExternal = {},
  __viteBrowserExternal$1 = Object.freeze(
    Object.defineProperty(
      { __proto__: null, default: __viteBrowserExternal },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  require$$0$3 = getAugmentedNamespace(__viteBrowserExternal$1)
var buffer_list, hasRequiredBuffer_list
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list
  hasRequiredBuffer_list = 1
  function o(ut, ct) {
    var dt = Object.keys(ut)
    if (Object.getOwnPropertySymbols) {
      var ft = Object.getOwnPropertySymbols(ut)
      ct &&
        (ft = ft.filter(function(mt) {
          return Object.getOwnPropertyDescriptor(ut, mt).enumerable
        })),
        dt.push.apply(dt, ft)
    }
    return dt
  }
  function a(ut) {
    for (var ct = 1; ct < arguments.length; ct++) {
      var dt = arguments[ct] != null ? arguments[ct] : {}
      ct % 2
        ? o(Object(dt), !0).forEach(function(ft) {
            s(ut, ft, dt[ft])
          })
        : Object.getOwnPropertyDescriptors
        ? Object.defineProperties(ut, Object.getOwnPropertyDescriptors(dt))
        : o(Object(dt)).forEach(function(ft) {
            Object.defineProperty(
              ut,
              ft,
              Object.getOwnPropertyDescriptor(dt, ft)
            )
          })
    }
    return ut
  }
  function s(ut, ct, dt) {
    return (
      (ct = et(ct)),
      ct in ut
        ? Object.defineProperty(ut, ct, {
            value: dt,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (ut[ct] = dt),
      ut
    )
  }
  function $(ut, ct) {
    if (!(ut instanceof ct))
      throw new TypeError('Cannot call a class as a function')
  }
  function j(ut, ct) {
    for (var dt = 0; dt < ct.length; dt++) {
      var ft = ct[dt]
      ;(ft.enumerable = ft.enumerable || !1),
        (ft.configurable = !0),
        'value' in ft && (ft.writable = !0),
        Object.defineProperty(ut, et(ft.key), ft)
    }
  }
  function _e(ut, ct, dt) {
    return (
      ct && j(ut.prototype, ct),
      Object.defineProperty(ut, 'prototype', { writable: !1 }),
      ut
    )
  }
  function et(ut) {
    var ct = tt(ut, 'string')
    return typeof ct == 'symbol' ? ct : String(ct)
  }
  function tt(ut, ct) {
    if (typeof ut != 'object' || ut === null) return ut
    var dt = ut[Symbol.toPrimitive]
    if (dt !== void 0) {
      var ft = dt.call(ut, ct || 'default')
      if (typeof ft != 'object') return ft
      throw new TypeError('@@toPrimitive must return a primitive value.')
    }
    return (ct === 'string' ? String : Number)(ut)
  }
  var rt = buffer$1,
    nt = rt.Buffer,
    it = require$$0$3,
    ot = it.inspect,
    at = (ot && ot.custom) || 'inspect'
  function st(ut, ct, dt) {
    nt.prototype.copy.call(ut, ct, dt)
  }
  return (
    (buffer_list = (function() {
      function ut() {
        $(this, ut), (this.head = null), (this.tail = null), (this.length = 0)
      }
      return (
        _e(ut, [
          {
            key: 'push',
            value: function(dt) {
              var ft = { data: dt, next: null }
              this.length > 0 ? (this.tail.next = ft) : (this.head = ft),
                (this.tail = ft),
                ++this.length
            },
          },
          {
            key: 'unshift',
            value: function(dt) {
              var ft = { data: dt, next: this.head }
              this.length === 0 && (this.tail = ft),
                (this.head = ft),
                ++this.length
            },
          },
          {
            key: 'shift',
            value: function() {
              if (this.length !== 0) {
                var dt = this.head.data
                return (
                  this.length === 1
                    ? (this.head = this.tail = null)
                    : (this.head = this.head.next),
                  --this.length,
                  dt
                )
              }
            },
          },
          {
            key: 'clear',
            value: function() {
              ;(this.head = this.tail = null), (this.length = 0)
            },
          },
          {
            key: 'join',
            value: function(dt) {
              if (this.length === 0) return ''
              for (var ft = this.head, mt = '' + ft.data; (ft = ft.next); )
                mt += dt + ft.data
              return mt
            },
          },
          {
            key: 'concat',
            value: function(dt) {
              if (this.length === 0) return nt.alloc(0)
              for (
                var ft = nt.allocUnsafe(dt >>> 0), mt = this.head, vt = 0;
                mt;

              )
                st(mt.data, ft, vt), (vt += mt.data.length), (mt = mt.next)
              return ft
            },
          },
          {
            key: 'consume',
            value: function(dt, ft) {
              var mt
              return (
                dt < this.head.data.length
                  ? ((mt = this.head.data.slice(0, dt)),
                    (this.head.data = this.head.data.slice(dt)))
                  : dt === this.head.data.length
                  ? (mt = this.shift())
                  : (mt = ft ? this._getString(dt) : this._getBuffer(dt)),
                mt
              )
            },
          },
          {
            key: 'first',
            value: function() {
              return this.head.data
            },
          },
          {
            key: '_getString',
            value: function(dt) {
              var ft = this.head,
                mt = 1,
                vt = ft.data
              for (dt -= vt.length; (ft = ft.next); ) {
                var yt = ft.data,
                  pt = dt > yt.length ? yt.length : dt
                if (
                  (pt === yt.length ? (vt += yt) : (vt += yt.slice(0, dt)),
                  (dt -= pt),
                  dt === 0)
                ) {
                  pt === yt.length
                    ? (++mt,
                      ft.next
                        ? (this.head = ft.next)
                        : (this.head = this.tail = null))
                    : ((this.head = ft), (ft.data = yt.slice(pt)))
                  break
                }
                ++mt
              }
              return (this.length -= mt), vt
            },
          },
          {
            key: '_getBuffer',
            value: function(dt) {
              var ft = nt.allocUnsafe(dt),
                mt = this.head,
                vt = 1
              for (mt.data.copy(ft), dt -= mt.data.length; (mt = mt.next); ) {
                var yt = mt.data,
                  pt = dt > yt.length ? yt.length : dt
                if (
                  (yt.copy(ft, ft.length - dt, 0, pt), (dt -= pt), dt === 0)
                ) {
                  pt === yt.length
                    ? (++vt,
                      mt.next
                        ? (this.head = mt.next)
                        : (this.head = this.tail = null))
                    : ((this.head = mt), (mt.data = yt.slice(pt)))
                  break
                }
                ++vt
              }
              return (this.length -= vt), ft
            },
          },
          {
            key: at,
            value: function(dt, ft) {
              return ot(this, a(a({}, ft), {}, { depth: 0, customInspect: !1 }))
            },
          },
        ]),
        ut
      )
    })()),
    buffer_list
  )
}
var destroy_1$1, hasRequiredDestroy
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1$1
  hasRequiredDestroy = 1
  function o(et, tt) {
    var rt = this,
      nt = this._readableState && this._readableState.destroyed,
      it = this._writableState && this._writableState.destroyed
    return nt || it
      ? (tt
          ? tt(et)
          : et &&
            (this._writableState
              ? this._writableState.errorEmitted ||
                ((this._writableState.errorEmitted = !0),
                process.nextTick(j, this, et))
              : process.nextTick(j, this, et)),
        this)
      : (this._readableState && (this._readableState.destroyed = !0),
        this._writableState && (this._writableState.destroyed = !0),
        this._destroy(et || null, function(ot) {
          !tt && ot
            ? rt._writableState
              ? rt._writableState.errorEmitted
                ? process.nextTick(s, rt)
                : ((rt._writableState.errorEmitted = !0),
                  process.nextTick(a, rt, ot))
              : process.nextTick(a, rt, ot)
            : tt
            ? (process.nextTick(s, rt), tt(ot))
            : process.nextTick(s, rt)
        }),
        this)
  }
  function a(et, tt) {
    j(et, tt), s(et)
  }
  function s(et) {
    ;(et._writableState && !et._writableState.emitClose) ||
      (et._readableState && !et._readableState.emitClose) ||
      et.emit('close')
  }
  function $() {
    this._readableState &&
      ((this._readableState.destroyed = !1),
      (this._readableState.reading = !1),
      (this._readableState.ended = !1),
      (this._readableState.endEmitted = !1)),
      this._writableState &&
        ((this._writableState.destroyed = !1),
        (this._writableState.ended = !1),
        (this._writableState.ending = !1),
        (this._writableState.finalCalled = !1),
        (this._writableState.prefinished = !1),
        (this._writableState.finished = !1),
        (this._writableState.errorEmitted = !1))
  }
  function j(et, tt) {
    et.emit('error', tt)
  }
  function _e(et, tt) {
    var rt = et._readableState,
      nt = et._writableState
    ;(rt && rt.autoDestroy) || (nt && nt.autoDestroy)
      ? et.destroy(tt)
      : et.emit('error', tt)
  }
  return (
    (destroy_1$1 = { destroy: o, undestroy: $, errorOrDestroy: _e }),
    destroy_1$1
  )
}
var errorsBrowser = {},
  hasRequiredErrorsBrowser
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser
  hasRequiredErrorsBrowser = 1
  function o(tt, rt) {
    ;(tt.prototype = Object.create(rt.prototype)),
      (tt.prototype.constructor = tt),
      (tt.__proto__ = rt)
  }
  var a = {}
  function s(tt, rt, nt) {
    nt || (nt = Error)
    function it(at, st, ut) {
      return typeof rt == 'string' ? rt : rt(at, st, ut)
    }
    var ot = (function(at) {
      o(st, at)
      function st(ut, ct, dt) {
        return at.call(this, it(ut, ct, dt)) || this
      }
      return st
    })(nt)
    ;(ot.prototype.name = nt.name), (ot.prototype.code = tt), (a[tt] = ot)
  }
  function $(tt, rt) {
    if (Array.isArray(tt)) {
      var nt = tt.length
      return (
        (tt = tt.map(function(it) {
          return String(it)
        })),
        nt > 2
          ? 'one of '
              .concat(rt, ' ')
              .concat(tt.slice(0, nt - 1).join(', '), ', or ') + tt[nt - 1]
          : nt === 2
          ? 'one of '
              .concat(rt, ' ')
              .concat(tt[0], ' or ')
              .concat(tt[1])
          : 'of '.concat(rt, ' ').concat(tt[0])
      )
    } else return 'of '.concat(rt, ' ').concat(String(tt))
  }
  function j(tt, rt, nt) {
    return tt.substr(0, rt.length) === rt
  }
  function _e(tt, rt, nt) {
    return (
      (nt === void 0 || nt > tt.length) && (nt = tt.length),
      tt.substring(nt - rt.length, nt) === rt
    )
  }
  function et(tt, rt, nt) {
    return (
      typeof nt != 'number' && (nt = 0),
      nt + rt.length > tt.length ? !1 : tt.indexOf(rt, nt) !== -1
    )
  }
  return (
    s(
      'ERR_INVALID_OPT_VALUE',
      function(tt, rt) {
        return 'The value "' + rt + '" is invalid for option "' + tt + '"'
      },
      TypeError
    ),
    s(
      'ERR_INVALID_ARG_TYPE',
      function(tt, rt, nt) {
        var it
        typeof rt == 'string' && j(rt, 'not ')
          ? ((it = 'must not be'), (rt = rt.replace(/^not /, '')))
          : (it = 'must be')
        var ot
        if (_e(tt, ' argument'))
          ot = 'The '
            .concat(tt, ' ')
            .concat(it, ' ')
            .concat($(rt, 'type'))
        else {
          var at = et(tt, '.') ? 'property' : 'argument'
          ot = 'The "'
            .concat(tt, '" ')
            .concat(at, ' ')
            .concat(it, ' ')
            .concat($(rt, 'type'))
        }
        return (ot += '. Received type '.concat(typeof nt)), ot
      },
      TypeError
    ),
    s('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF'),
    s('ERR_METHOD_NOT_IMPLEMENTED', function(tt) {
      return 'The ' + tt + ' method is not implemented'
    }),
    s('ERR_STREAM_PREMATURE_CLOSE', 'Premature close'),
    s('ERR_STREAM_DESTROYED', function(tt) {
      return 'Cannot call ' + tt + ' after a stream was destroyed'
    }),
    s('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times'),
    s('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable'),
    s('ERR_STREAM_WRITE_AFTER_END', 'write after end'),
    s(
      'ERR_STREAM_NULL_VALUES',
      'May not write null values to stream',
      TypeError
    ),
    s(
      'ERR_UNKNOWN_ENCODING',
      function(tt) {
        return 'Unknown encoding: ' + tt
      },
      TypeError
    ),
    s('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event'),
    (errorsBrowser.codes = a),
    errorsBrowser
  )
}
var state, hasRequiredState
function requireState() {
  if (hasRequiredState) return state
  hasRequiredState = 1
  var o = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE
  function a($, j, _e) {
    return $.highWaterMark != null ? $.highWaterMark : j ? $[_e] : null
  }
  function s($, j, _e, et) {
    var tt = a(j, et, _e)
    if (tt != null) {
      if (!(isFinite(tt) && Math.floor(tt) === tt) || tt < 0) {
        var rt = et ? _e : 'highWaterMark'
        throw new o(rt, tt)
      }
      return Math.floor(tt)
    }
    return $.objectMode ? 16 : 16 * 1024
  }
  return (state = { getHighWaterMark: s }), state
}
var browser$1, hasRequiredBrowser
function requireBrowser() {
  if (hasRequiredBrowser) return browser$1
  hasRequiredBrowser = 1
  var o = {}
  browser$1 = a
  function a($, j) {
    if (s('noDeprecation')) return $
    var _e = !1
    function et() {
      if (!_e) {
        if (s('throwDeprecation')) throw new Error(j)
        s('traceDeprecation') ? console.trace(j) : console.warn(j), (_e = !0)
      }
      return $.apply(this, arguments)
    }
    return et
  }
  function s($) {
    try {
      if (!o.localStorage) return !1
    } catch {
      return !1
    }
    var j = o.localStorage[$]
    return j == null ? !1 : String(j).toLowerCase() === 'true'
  }
  return browser$1
}
var _stream_writable$5, hasRequired_stream_writable$5
function require_stream_writable$5() {
  if (hasRequired_stream_writable$5) return _stream_writable$5
  hasRequired_stream_writable$5 = 1
  var o = {}
  _stream_writable$5 = Ct
  function a(Yt) {
    var xt = this
    ;(this.next = null),
      (this.entry = null),
      (this.finish = function() {
        Xt(xt, Yt)
      })
  }
  var s
  Ct.WritableState = At
  var $ = { deprecate: requireBrowser() },
    j = requireStreamBrowser(),
    _e = buffer$1.Buffer,
    et =
      (typeof o < 'u'
        ? o
        : typeof window < 'u'
        ? window
        : typeof self < 'u'
        ? self
        : {}
      ).Uint8Array || function() {}
  function tt(Yt) {
    return _e.from(Yt)
  }
  function rt(Yt) {
    return _e.isBuffer(Yt) || Yt instanceof et
  }
  var nt = requireDestroy(),
    it = requireState(),
    ot = it.getHighWaterMark,
    at = requireErrorsBrowser().codes,
    st = at.ERR_INVALID_ARG_TYPE,
    ut = at.ERR_METHOD_NOT_IMPLEMENTED,
    ct = at.ERR_MULTIPLE_CALLBACK,
    dt = at.ERR_STREAM_CANNOT_PIPE,
    ft = at.ERR_STREAM_DESTROYED,
    mt = at.ERR_STREAM_NULL_VALUES,
    vt = at.ERR_STREAM_WRITE_AFTER_END,
    yt = at.ERR_UNKNOWN_ENCODING,
    pt = nt.errorOrDestroy
  inherits_browserExports(Ct, j)
  function ht() {}
  function At(Yt, xt, It) {
    ;(s = s || require_stream_duplex$5()),
      (Yt = Yt || {}),
      typeof It != 'boolean' && (It = xt instanceof s),
      (this.objectMode = !!Yt.objectMode),
      It && (this.objectMode = this.objectMode || !!Yt.writableObjectMode),
      (this.highWaterMark = ot(this, Yt, 'writableHighWaterMark', It)),
      (this.finalCalled = !1),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1),
      (this.destroyed = !1)
    var Kt = Yt.decodeStrings === !1
    ;(this.decodeStrings = !Kt),
      (this.defaultEncoding = Yt.defaultEncoding || 'utf8'),
      (this.length = 0),
      (this.writing = !1),
      (this.corked = 0),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function(Qt) {
        Wt(xt, Qt)
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.bufferedRequest = null),
      (this.lastBufferedRequest = null),
      (this.pendingcb = 0),
      (this.prefinished = !1),
      (this.errorEmitted = !1),
      (this.emitClose = Yt.emitClose !== !1),
      (this.autoDestroy = !!Yt.autoDestroy),
      (this.bufferedRequestCount = 0),
      (this.corkedRequestsFree = new a(this))
  }
  ;(At.prototype.getBuffer = function() {
    for (var xt = this.bufferedRequest, It = []; xt; )
      It.push(xt), (xt = xt.next)
    return It
  }),
    (function() {
      try {
        Object.defineProperty(At.prototype, 'buffer', {
          get: $.deprecate(
            function() {
              return this.getBuffer()
            },
            '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
            'DEP0003'
          ),
        })
      } catch {}
    })()
  var wt
  typeof Symbol == 'function' &&
  Symbol.hasInstance &&
  typeof Function.prototype[Symbol.hasInstance] == 'function'
    ? ((wt = Function.prototype[Symbol.hasInstance]),
      Object.defineProperty(Ct, Symbol.hasInstance, {
        value: function(xt) {
          return wt.call(this, xt)
            ? !0
            : this !== Ct
            ? !1
            : xt && xt._writableState instanceof At
        },
      }))
    : (wt = function(xt) {
        return xt instanceof this
      })
  function Ct(Yt) {
    s = s || require_stream_duplex$5()
    var xt = this instanceof s
    if (!xt && !wt.call(Ct, this)) return new Ct(Yt)
    ;(this._writableState = new At(Yt, this, xt)),
      (this.writable = !0),
      Yt &&
        (typeof Yt.write == 'function' && (this._write = Yt.write),
        typeof Yt.writev == 'function' && (this._writev = Yt.writev),
        typeof Yt.destroy == 'function' && (this._destroy = Yt.destroy),
        typeof Yt.final == 'function' && (this._final = Yt.final)),
      j.call(this)
  }
  Ct.prototype.pipe = function() {
    pt(this, new dt())
  }
  function Dt(Yt, xt) {
    var It = new vt()
    pt(Yt, It), process.nextTick(xt, It)
  }
  function jt(Yt, xt, It, Kt) {
    var Qt
    return (
      It === null
        ? (Qt = new mt())
        : typeof It != 'string' &&
          !xt.objectMode &&
          (Qt = new st('chunk', ['string', 'Buffer'], It)),
      Qt ? (pt(Yt, Qt), process.nextTick(Kt, Qt), !1) : !0
    )
  }
  ;(Ct.prototype.write = function(Yt, xt, It) {
    var Kt = this._writableState,
      Qt = !1,
      Ht = !Kt.objectMode && rt(Yt)
    return (
      Ht && !_e.isBuffer(Yt) && (Yt = tt(Yt)),
      typeof xt == 'function' && ((It = xt), (xt = null)),
      Ht ? (xt = 'buffer') : xt || (xt = Kt.defaultEncoding),
      typeof It != 'function' && (It = ht),
      Kt.ending
        ? Dt(this, It)
        : (Ht || jt(this, Kt, Yt, It)) &&
          (Kt.pendingcb++, (Qt = St(this, Kt, Ht, Yt, xt, It))),
      Qt
    )
  }),
    (Ct.prototype.cork = function() {
      this._writableState.corked++
    }),
    (Ct.prototype.uncork = function() {
      var Yt = this._writableState
      Yt.corked &&
        (Yt.corked--,
        !Yt.writing &&
          !Yt.corked &&
          !Yt.bufferProcessing &&
          Yt.bufferedRequest &&
          Ot(this, Yt))
    }),
    (Ct.prototype.setDefaultEncoding = function(xt) {
      if (
        (typeof xt == 'string' && (xt = xt.toLowerCase()),
        !(
          [
            'hex',
            'utf8',
            'utf-8',
            'ascii',
            'binary',
            'base64',
            'ucs2',
            'ucs-2',
            'utf16le',
            'utf-16le',
            'raw',
          ].indexOf((xt + '').toLowerCase()) > -1
        ))
      )
        throw new yt(xt)
      return (this._writableState.defaultEncoding = xt), this
    }),
    Object.defineProperty(Ct.prototype, 'writableBuffer', {
      enumerable: !1,
      get: function() {
        return this._writableState && this._writableState.getBuffer()
      },
    })
  function Et(Yt, xt, It) {
    return (
      !Yt.objectMode &&
        Yt.decodeStrings !== !1 &&
        typeof xt == 'string' &&
        (xt = _e.from(xt, It)),
      xt
    )
  }
  Object.defineProperty(Ct.prototype, 'writableHighWaterMark', {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark
    },
  })
  function St(Yt, xt, It, Kt, Qt, Ht) {
    if (!It) {
      var Lt = Et(xt, Kt, Qt)
      Kt !== Lt && ((It = !0), (Qt = 'buffer'), (Kt = Lt))
    }
    var tr = xt.objectMode ? 1 : Kt.length
    xt.length += tr
    var lr = xt.length < xt.highWaterMark
    if ((lr || (xt.needDrain = !0), xt.writing || xt.corked)) {
      var yr = xt.lastBufferedRequest
      ;(xt.lastBufferedRequest = {
        chunk: Kt,
        encoding: Qt,
        isBuf: It,
        callback: Ht,
        next: null,
      }),
        yr
          ? (yr.next = xt.lastBufferedRequest)
          : (xt.bufferedRequest = xt.lastBufferedRequest),
        (xt.bufferedRequestCount += 1)
    } else Bt(Yt, xt, !1, tr, Kt, Qt, Ht)
    return lr
  }
  function Bt(Yt, xt, It, Kt, Qt, Ht, Lt) {
    ;(xt.writelen = Kt),
      (xt.writecb = Lt),
      (xt.writing = !0),
      (xt.sync = !0),
      xt.destroyed
        ? xt.onwrite(new ft('write'))
        : It
        ? Yt._writev(Qt, xt.onwrite)
        : Yt._write(Qt, Ht, xt.onwrite),
      (xt.sync = !1)
  }
  function Mt(Yt, xt, It, Kt, Qt) {
    --xt.pendingcb,
      It
        ? (process.nextTick(Qt, Kt),
          process.nextTick(Ft, Yt, xt),
          (Yt._writableState.errorEmitted = !0),
          pt(Yt, Kt))
        : (Qt(Kt),
          (Yt._writableState.errorEmitted = !0),
          pt(Yt, Kt),
          Ft(Yt, xt))
  }
  function Ut(Yt) {
    ;(Yt.writing = !1),
      (Yt.writecb = null),
      (Yt.length -= Yt.writelen),
      (Yt.writelen = 0)
  }
  function Wt(Yt, xt) {
    var It = Yt._writableState,
      Kt = It.sync,
      Qt = It.writecb
    if (typeof Qt != 'function') throw new ct()
    if ((Ut(It), xt)) Mt(Yt, It, Kt, xt, Qt)
    else {
      var Ht = Nt(It) || Yt.destroyed
      !Ht &&
        !It.corked &&
        !It.bufferProcessing &&
        It.bufferedRequest &&
        Ot(Yt, It),
        Kt ? process.nextTick(Tt, Yt, It, Ht, Qt) : Tt(Yt, It, Ht, Qt)
    }
  }
  function Tt(Yt, xt, It, Kt) {
    It || kt(Yt, xt), xt.pendingcb--, Kt(), Ft(Yt, xt)
  }
  function kt(Yt, xt) {
    xt.length === 0 && xt.needDrain && ((xt.needDrain = !1), Yt.emit('drain'))
  }
  function Ot(Yt, xt) {
    xt.bufferProcessing = !0
    var It = xt.bufferedRequest
    if (Yt._writev && It && It.next) {
      var Kt = xt.bufferedRequestCount,
        Qt = new Array(Kt),
        Ht = xt.corkedRequestsFree
      Ht.entry = It
      for (var Lt = 0, tr = !0; It; )
        (Qt[Lt] = It), It.isBuf || (tr = !1), (It = It.next), (Lt += 1)
      ;(Qt.allBuffers = tr),
        Bt(Yt, xt, !0, xt.length, Qt, '', Ht.finish),
        xt.pendingcb++,
        (xt.lastBufferedRequest = null),
        Ht.next
          ? ((xt.corkedRequestsFree = Ht.next), (Ht.next = null))
          : (xt.corkedRequestsFree = new a(xt)),
        (xt.bufferedRequestCount = 0)
    } else {
      for (; It; ) {
        var lr = It.chunk,
          yr = It.encoding,
          mr = It.callback,
          Er = xt.objectMode ? 1 : lr.length
        if (
          (Bt(Yt, xt, !1, Er, lr, yr, mr),
          (It = It.next),
          xt.bufferedRequestCount--,
          xt.writing)
        )
          break
      }
      It === null && (xt.lastBufferedRequest = null)
    }
    ;(xt.bufferedRequest = It), (xt.bufferProcessing = !1)
  }
  ;(Ct.prototype._write = function(Yt, xt, It) {
    It(new ut('_write()'))
  }),
    (Ct.prototype._writev = null),
    (Ct.prototype.end = function(Yt, xt, It) {
      var Kt = this._writableState
      return (
        typeof Yt == 'function'
          ? ((It = Yt), (Yt = null), (xt = null))
          : typeof xt == 'function' && ((It = xt), (xt = null)),
        Yt != null && this.write(Yt, xt),
        Kt.corked && ((Kt.corked = 1), this.uncork()),
        Kt.ending || Vt(this, Kt, It),
        this
      )
    }),
    Object.defineProperty(Ct.prototype, 'writableLength', {
      enumerable: !1,
      get: function() {
        return this._writableState.length
      },
    })
  function Nt(Yt) {
    return (
      Yt.ending &&
      Yt.length === 0 &&
      Yt.bufferedRequest === null &&
      !Yt.finished &&
      !Yt.writing
    )
  }
  function $t(Yt, xt) {
    Yt._final(function(It) {
      xt.pendingcb--,
        It && pt(Yt, It),
        (xt.prefinished = !0),
        Yt.emit('prefinish'),
        Ft(Yt, xt)
    })
  }
  function Pt(Yt, xt) {
    !xt.prefinished &&
      !xt.finalCalled &&
      (typeof Yt._final == 'function' && !xt.destroyed
        ? (xt.pendingcb++, (xt.finalCalled = !0), process.nextTick($t, Yt, xt))
        : ((xt.prefinished = !0), Yt.emit('prefinish')))
  }
  function Ft(Yt, xt) {
    var It = Nt(xt)
    if (
      It &&
      (Pt(Yt, xt),
      xt.pendingcb === 0 &&
        ((xt.finished = !0), Yt.emit('finish'), xt.autoDestroy))
    ) {
      var Kt = Yt._readableState
      ;(!Kt || (Kt.autoDestroy && Kt.endEmitted)) && Yt.destroy()
    }
    return It
  }
  function Vt(Yt, xt, It) {
    ;(xt.ending = !0),
      Ft(Yt, xt),
      It && (xt.finished ? process.nextTick(It) : Yt.once('finish', It)),
      (xt.ended = !0),
      (Yt.writable = !1)
  }
  function Xt(Yt, xt, It) {
    var Kt = Yt.entry
    for (Yt.entry = null; Kt; ) {
      var Qt = Kt.callback
      xt.pendingcb--, Qt(It), (Kt = Kt.next)
    }
    xt.corkedRequestsFree.next = Yt
  }
  return (
    Object.defineProperty(Ct.prototype, 'destroyed', {
      enumerable: !1,
      get: function() {
        return this._writableState === void 0
          ? !1
          : this._writableState.destroyed
      },
      set: function(xt) {
        this._writableState && (this._writableState.destroyed = xt)
      },
    }),
    (Ct.prototype.destroy = nt.destroy),
    (Ct.prototype._undestroy = nt.undestroy),
    (Ct.prototype._destroy = function(Yt, xt) {
      xt(Yt)
    }),
    _stream_writable$5
  )
}
var _stream_duplex$5, hasRequired_stream_duplex$5
function require_stream_duplex$5() {
  if (hasRequired_stream_duplex$5) return _stream_duplex$5
  hasRequired_stream_duplex$5 = 1
  var o =
    Object.keys ||
    function(nt) {
      var it = []
      for (var ot in nt) it.push(ot)
      return it
    }
  _stream_duplex$5 = et
  var a = require_stream_readable$2(),
    s = require_stream_writable$5()
  inherits_browserExports(et, a)
  for (var $ = o(s.prototype), j = 0; j < $.length; j++) {
    var _e = $[j]
    et.prototype[_e] || (et.prototype[_e] = s.prototype[_e])
  }
  function et(nt) {
    if (!(this instanceof et)) return new et(nt)
    a.call(this, nt),
      s.call(this, nt),
      (this.allowHalfOpen = !0),
      nt &&
        (nt.readable === !1 && (this.readable = !1),
        nt.writable === !1 && (this.writable = !1),
        nt.allowHalfOpen === !1 &&
          ((this.allowHalfOpen = !1), this.once('end', tt)))
  }
  Object.defineProperty(et.prototype, 'writableHighWaterMark', {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark
    },
  }),
    Object.defineProperty(et.prototype, 'writableBuffer', {
      enumerable: !1,
      get: function() {
        return this._writableState && this._writableState.getBuffer()
      },
    }),
    Object.defineProperty(et.prototype, 'writableLength', {
      enumerable: !1,
      get: function() {
        return this._writableState.length
      },
    })
  function tt() {
    this._writableState.ended || process.nextTick(rt, this)
  }
  function rt(nt) {
    nt.end()
  }
  return (
    Object.defineProperty(et.prototype, 'destroyed', {
      enumerable: !1,
      get: function() {
        return this._readableState === void 0 || this._writableState === void 0
          ? !1
          : this._readableState.destroyed && this._writableState.destroyed
      },
      set: function(it) {
        this._readableState === void 0 ||
          this._writableState === void 0 ||
          ((this._readableState.destroyed = it),
          (this._writableState.destroyed = it))
      },
    }),
    _stream_duplex$5
  )
}
var string_decoder$4 = {},
  safeBuffer$1 = { exports: {} },
  hasRequiredSafeBuffer
function requireSafeBuffer() {
  return (
    hasRequiredSafeBuffer ||
      ((hasRequiredSafeBuffer = 1),
      (function(o, a) {
        var s = buffer$1,
          $ = s.Buffer
        function j(et, tt) {
          for (var rt in et) tt[rt] = et[rt]
        }
        $.from && $.alloc && $.allocUnsafe && $.allocUnsafeSlow
          ? (o.exports = s)
          : (j(s, a), (a.Buffer = _e))
        function _e(et, tt, rt) {
          return $(et, tt, rt)
        }
        j($, _e),
          (_e.from = function(et, tt, rt) {
            if (typeof et == 'number')
              throw new TypeError('Argument must not be a number')
            return $(et, tt, rt)
          }),
          (_e.alloc = function(et, tt, rt) {
            if (typeof et != 'number')
              throw new TypeError('Argument must be a number')
            var nt = $(et)
            return (
              tt !== void 0
                ? typeof rt == 'string'
                  ? nt.fill(tt, rt)
                  : nt.fill(tt)
                : nt.fill(0),
              nt
            )
          }),
          (_e.allocUnsafe = function(et) {
            if (typeof et != 'number')
              throw new TypeError('Argument must be a number')
            return $(et)
          }),
          (_e.allocUnsafeSlow = function(et) {
            if (typeof et != 'number')
              throw new TypeError('Argument must be a number')
            return s.SlowBuffer(et)
          })
      })(safeBuffer$1, safeBuffer$1.exports)),
    safeBuffer$1.exports
  )
}
var hasRequiredString_decoder$4
function requireString_decoder$4() {
  if (hasRequiredString_decoder$4) return string_decoder$4
  hasRequiredString_decoder$4 = 1
  var o = requireSafeBuffer().Buffer,
    a =
      o.isEncoding ||
      function(ft) {
        switch (((ft = '' + ft), ft && ft.toLowerCase())) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return !0
          default:
            return !1
        }
      }
  function s(ft) {
    if (!ft) return 'utf8'
    for (var mt; ; )
      switch (ft) {
        case 'utf8':
        case 'utf-8':
          return 'utf8'
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return 'utf16le'
        case 'latin1':
        case 'binary':
          return 'latin1'
        case 'base64':
        case 'ascii':
        case 'hex':
          return ft
        default:
          if (mt) return
          ;(ft = ('' + ft).toLowerCase()), (mt = !0)
      }
  }
  function $(ft) {
    var mt = s(ft)
    if (typeof mt != 'string' && (o.isEncoding === a || !a(ft)))
      throw new Error('Unknown encoding: ' + ft)
    return mt || ft
  }
  string_decoder$4.StringDecoder = j
  function j(ft) {
    this.encoding = $(ft)
    var mt
    switch (this.encoding) {
      case 'utf16le':
        ;(this.text = ot), (this.end = at), (mt = 4)
        break
      case 'utf8':
        ;(this.fillLast = rt), (mt = 4)
        break
      case 'base64':
        ;(this.text = st), (this.end = ut), (mt = 3)
        break
      default:
        ;(this.write = ct), (this.end = dt)
        return
    }
    ;(this.lastNeed = 0),
      (this.lastTotal = 0),
      (this.lastChar = o.allocUnsafe(mt))
  }
  ;(j.prototype.write = function(ft) {
    if (ft.length === 0) return ''
    var mt, vt
    if (this.lastNeed) {
      if (((mt = this.fillLast(ft)), mt === void 0)) return ''
      ;(vt = this.lastNeed), (this.lastNeed = 0)
    } else vt = 0
    return vt < ft.length
      ? mt
        ? mt + this.text(ft, vt)
        : this.text(ft, vt)
      : mt || ''
  }),
    (j.prototype.end = it),
    (j.prototype.text = nt),
    (j.prototype.fillLast = function(ft) {
      if (this.lastNeed <= ft.length)
        return (
          ft.copy(
            this.lastChar,
            this.lastTotal - this.lastNeed,
            0,
            this.lastNeed
          ),
          this.lastChar.toString(this.encoding, 0, this.lastTotal)
        )
      ft.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, ft.length),
        (this.lastNeed -= ft.length)
    })
  function _e(ft) {
    return ft <= 127
      ? 0
      : ft >> 5 === 6
      ? 2
      : ft >> 4 === 14
      ? 3
      : ft >> 3 === 30
      ? 4
      : ft >> 6 === 2
      ? -1
      : -2
  }
  function et(ft, mt, vt) {
    var yt = mt.length - 1
    if (yt < vt) return 0
    var pt = _e(mt[yt])
    return pt >= 0
      ? (pt > 0 && (ft.lastNeed = pt - 1), pt)
      : --yt < vt || pt === -2
      ? 0
      : ((pt = _e(mt[yt])),
        pt >= 0
          ? (pt > 0 && (ft.lastNeed = pt - 2), pt)
          : --yt < vt || pt === -2
          ? 0
          : ((pt = _e(mt[yt])),
            pt >= 0
              ? (pt > 0 && (pt === 2 ? (pt = 0) : (ft.lastNeed = pt - 3)), pt)
              : 0))
  }
  function tt(ft, mt, vt) {
    if ((mt[0] & 192) !== 128) return (ft.lastNeed = 0), ''
    if (ft.lastNeed > 1 && mt.length > 1) {
      if ((mt[1] & 192) !== 128) return (ft.lastNeed = 1), ''
      if (ft.lastNeed > 2 && mt.length > 2 && (mt[2] & 192) !== 128)
        return (ft.lastNeed = 2), ''
    }
  }
  function rt(ft) {
    var mt = this.lastTotal - this.lastNeed,
      vt = tt(this, ft)
    if (vt !== void 0) return vt
    if (this.lastNeed <= ft.length)
      return (
        ft.copy(this.lastChar, mt, 0, this.lastNeed),
        this.lastChar.toString(this.encoding, 0, this.lastTotal)
      )
    ft.copy(this.lastChar, mt, 0, ft.length), (this.lastNeed -= ft.length)
  }
  function nt(ft, mt) {
    var vt = et(this, ft, mt)
    if (!this.lastNeed) return ft.toString('utf8', mt)
    this.lastTotal = vt
    var yt = ft.length - (vt - this.lastNeed)
    return ft.copy(this.lastChar, 0, yt), ft.toString('utf8', mt, yt)
  }
  function it(ft) {
    var mt = ft && ft.length ? this.write(ft) : ''
    return this.lastNeed ? mt + '' : mt
  }
  function ot(ft, mt) {
    if ((ft.length - mt) % 2 === 0) {
      var vt = ft.toString('utf16le', mt)
      if (vt) {
        var yt = vt.charCodeAt(vt.length - 1)
        if (yt >= 55296 && yt <= 56319)
          return (
            (this.lastNeed = 2),
            (this.lastTotal = 4),
            (this.lastChar[0] = ft[ft.length - 2]),
            (this.lastChar[1] = ft[ft.length - 1]),
            vt.slice(0, -1)
          )
      }
      return vt
    }
    return (
      (this.lastNeed = 1),
      (this.lastTotal = 2),
      (this.lastChar[0] = ft[ft.length - 1]),
      ft.toString('utf16le', mt, ft.length - 1)
    )
  }
  function at(ft) {
    var mt = ft && ft.length ? this.write(ft) : ''
    if (this.lastNeed) {
      var vt = this.lastTotal - this.lastNeed
      return mt + this.lastChar.toString('utf16le', 0, vt)
    }
    return mt
  }
  function st(ft, mt) {
    var vt = (ft.length - mt) % 3
    return vt === 0
      ? ft.toString('base64', mt)
      : ((this.lastNeed = 3 - vt),
        (this.lastTotal = 3),
        vt === 1
          ? (this.lastChar[0] = ft[ft.length - 1])
          : ((this.lastChar[0] = ft[ft.length - 2]),
            (this.lastChar[1] = ft[ft.length - 1])),
        ft.toString('base64', mt, ft.length - vt))
  }
  function ut(ft) {
    var mt = ft && ft.length ? this.write(ft) : ''
    return this.lastNeed
      ? mt + this.lastChar.toString('base64', 0, 3 - this.lastNeed)
      : mt
  }
  function ct(ft) {
    return ft.toString(this.encoding)
  }
  function dt(ft) {
    return ft && ft.length ? this.write(ft) : ''
  }
  return string_decoder$4
}
var endOfStream, hasRequiredEndOfStream
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream
  hasRequiredEndOfStream = 1
  var o = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE
  function a(_e) {
    var et = !1
    return function() {
      if (!et) {
        et = !0
        for (
          var tt = arguments.length, rt = new Array(tt), nt = 0;
          nt < tt;
          nt++
        )
          rt[nt] = arguments[nt]
        _e.apply(this, rt)
      }
    }
  }
  function s() {}
  function $(_e) {
    return _e.setHeader && typeof _e.abort == 'function'
  }
  function j(_e, et, tt) {
    if (typeof et == 'function') return j(_e, null, et)
    et || (et = {}), (tt = a(tt || s))
    var rt = et.readable || (et.readable !== !1 && _e.readable),
      nt = et.writable || (et.writable !== !1 && _e.writable),
      it = function() {
        _e.writable || at()
      },
      ot = _e._writableState && _e._writableState.finished,
      at = function() {
        ;(nt = !1), (ot = !0), rt || tt.call(_e)
      },
      st = _e._readableState && _e._readableState.endEmitted,
      ut = function() {
        ;(rt = !1), (st = !0), nt || tt.call(_e)
      },
      ct = function(vt) {
        tt.call(_e, vt)
      },
      dt = function() {
        var vt
        if (rt && !st)
          return (
            (!_e._readableState || !_e._readableState.ended) && (vt = new o()),
            tt.call(_e, vt)
          )
        if (nt && !ot)
          return (
            (!_e._writableState || !_e._writableState.ended) && (vt = new o()),
            tt.call(_e, vt)
          )
      },
      ft = function() {
        _e.req.on('finish', at)
      }
    return (
      $(_e)
        ? (_e.on('complete', at),
          _e.on('abort', dt),
          _e.req ? ft() : _e.on('request', ft))
        : nt && !_e._writableState && (_e.on('end', it), _e.on('close', it)),
      _e.on('end', ut),
      _e.on('finish', at),
      et.error !== !1 && _e.on('error', ct),
      _e.on('close', dt),
      function() {
        _e.removeListener('complete', at),
          _e.removeListener('abort', dt),
          _e.removeListener('request', ft),
          _e.req && _e.req.removeListener('finish', at),
          _e.removeListener('end', it),
          _e.removeListener('close', it),
          _e.removeListener('finish', at),
          _e.removeListener('end', ut),
          _e.removeListener('error', ct),
          _e.removeListener('close', dt)
      }
    )
  }
  return (endOfStream = j), endOfStream
}
var async_iterator, hasRequiredAsync_iterator
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator
  hasRequiredAsync_iterator = 1
  var o
  function a(vt, yt, pt) {
    return (
      (yt = s(yt)),
      yt in vt
        ? Object.defineProperty(vt, yt, {
            value: pt,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (vt[yt] = pt),
      vt
    )
  }
  function s(vt) {
    var yt = $(vt, 'string')
    return typeof yt == 'symbol' ? yt : String(yt)
  }
  function $(vt, yt) {
    if (typeof vt != 'object' || vt === null) return vt
    var pt = vt[Symbol.toPrimitive]
    if (pt !== void 0) {
      var ht = pt.call(vt, yt || 'default')
      if (typeof ht != 'object') return ht
      throw new TypeError('@@toPrimitive must return a primitive value.')
    }
    return (yt === 'string' ? String : Number)(vt)
  }
  var j = requireEndOfStream(),
    _e = Symbol('lastResolve'),
    et = Symbol('lastReject'),
    tt = Symbol('error'),
    rt = Symbol('ended'),
    nt = Symbol('lastPromise'),
    it = Symbol('handlePromise'),
    ot = Symbol('stream')
  function at(vt, yt) {
    return { value: vt, done: yt }
  }
  function st(vt) {
    var yt = vt[_e]
    if (yt !== null) {
      var pt = vt[ot].read()
      pt !== null &&
        ((vt[nt] = null), (vt[_e] = null), (vt[et] = null), yt(at(pt, !1)))
    }
  }
  function ut(vt) {
    process.nextTick(st, vt)
  }
  function ct(vt, yt) {
    return function(pt, ht) {
      vt.then(function() {
        if (yt[rt]) {
          pt(at(void 0, !0))
          return
        }
        yt[it](pt, ht)
      }, ht)
    }
  }
  var dt = Object.getPrototypeOf(function() {}),
    ft = Object.setPrototypeOf(
      ((o = {
        get stream() {
          return this[ot]
        },
        next: function() {
          var yt = this,
            pt = this[tt]
          if (pt !== null) return Promise.reject(pt)
          if (this[rt]) return Promise.resolve(at(void 0, !0))
          if (this[ot].destroyed)
            return new Promise(function(Ct, Dt) {
              process.nextTick(function() {
                yt[tt] ? Dt(yt[tt]) : Ct(at(void 0, !0))
              })
            })
          var ht = this[nt],
            At
          if (ht) At = new Promise(ct(ht, this))
          else {
            var wt = this[ot].read()
            if (wt !== null) return Promise.resolve(at(wt, !1))
            At = new Promise(this[it])
          }
          return (this[nt] = At), At
        },
      }),
      a(o, Symbol.asyncIterator, function() {
        return this
      }),
      a(o, 'return', function() {
        var yt = this
        return new Promise(function(pt, ht) {
          yt[ot].destroy(null, function(At) {
            if (At) {
              ht(At)
              return
            }
            pt(at(void 0, !0))
          })
        })
      }),
      o),
      dt
    ),
    mt = function(yt) {
      var pt,
        ht = Object.create(
          ft,
          ((pt = {}),
          a(pt, ot, { value: yt, writable: !0 }),
          a(pt, _e, { value: null, writable: !0 }),
          a(pt, et, { value: null, writable: !0 }),
          a(pt, tt, { value: null, writable: !0 }),
          a(pt, rt, { value: yt._readableState.endEmitted, writable: !0 }),
          a(pt, it, {
            value: function(wt, Ct) {
              var Dt = ht[ot].read()
              Dt
                ? ((ht[nt] = null),
                  (ht[_e] = null),
                  (ht[et] = null),
                  wt(at(Dt, !1)))
                : ((ht[_e] = wt), (ht[et] = Ct))
            },
            writable: !0,
          }),
          pt)
        )
      return (
        (ht[nt] = null),
        j(yt, function(At) {
          if (At && At.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
            var wt = ht[et]
            wt !== null &&
              ((ht[nt] = null), (ht[_e] = null), (ht[et] = null), wt(At)),
              (ht[tt] = At)
            return
          }
          var Ct = ht[_e]
          Ct !== null &&
            ((ht[nt] = null),
            (ht[_e] = null),
            (ht[et] = null),
            Ct(at(void 0, !0))),
            (ht[rt] = !0)
        }),
        yt.on('readable', ut.bind(null, ht)),
        ht
      )
    }
  return (async_iterator = mt), async_iterator
}
var fromBrowser, hasRequiredFromBrowser
function requireFromBrowser() {
  return (
    hasRequiredFromBrowser ||
      ((hasRequiredFromBrowser = 1),
      (fromBrowser = function() {
        throw new Error('Readable.from is not available in the browser')
      })),
    fromBrowser
  )
}
var _stream_readable$5, hasRequired_stream_readable$2
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2) return _stream_readable$5
  hasRequired_stream_readable$2 = 1
  var o = {}
  _stream_readable$5 = Dt
  var a
  ;(Dt.ReadableState = Ct), eventsExports.EventEmitter
  var s = function(Lt, tr) {
      return Lt.listeners(tr).length
    },
    $ = requireStreamBrowser(),
    j = buffer$1.Buffer,
    _e =
      (typeof o < 'u'
        ? o
        : typeof window < 'u'
        ? window
        : typeof self < 'u'
        ? self
        : {}
      ).Uint8Array || function() {}
  function et(Ht) {
    return j.from(Ht)
  }
  function tt(Ht) {
    return j.isBuffer(Ht) || Ht instanceof _e
  }
  var rt = require$$0$3,
    nt
  rt && rt.debuglog ? (nt = rt.debuglog('stream')) : (nt = function() {})
  var it = requireBuffer_list(),
    ot = requireDestroy(),
    at = requireState(),
    st = at.getHighWaterMark,
    ut = requireErrorsBrowser().codes,
    ct = ut.ERR_INVALID_ARG_TYPE,
    dt = ut.ERR_STREAM_PUSH_AFTER_EOF,
    ft = ut.ERR_METHOD_NOT_IMPLEMENTED,
    mt = ut.ERR_STREAM_UNSHIFT_AFTER_END_EVENT,
    vt,
    yt,
    pt
  inherits_browserExports(Dt, $)
  var ht = ot.errorOrDestroy,
    At = ['error', 'close', 'destroy', 'pause', 'resume']
  function wt(Ht, Lt, tr) {
    if (typeof Ht.prependListener == 'function')
      return Ht.prependListener(Lt, tr)
    !Ht._events || !Ht._events[Lt]
      ? Ht.on(Lt, tr)
      : Array.isArray(Ht._events[Lt])
      ? Ht._events[Lt].unshift(tr)
      : (Ht._events[Lt] = [tr, Ht._events[Lt]])
  }
  function Ct(Ht, Lt, tr) {
    ;(a = a || require_stream_duplex$5()),
      (Ht = Ht || {}),
      typeof tr != 'boolean' && (tr = Lt instanceof a),
      (this.objectMode = !!Ht.objectMode),
      tr && (this.objectMode = this.objectMode || !!Ht.readableObjectMode),
      (this.highWaterMark = st(this, Ht, 'readableHighWaterMark', tr)),
      (this.buffer = new it()),
      (this.length = 0),
      (this.pipes = null),
      (this.pipesCount = 0),
      (this.flowing = null),
      (this.ended = !1),
      (this.endEmitted = !1),
      (this.reading = !1),
      (this.sync = !0),
      (this.needReadable = !1),
      (this.emittedReadable = !1),
      (this.readableListening = !1),
      (this.resumeScheduled = !1),
      (this.paused = !0),
      (this.emitClose = Ht.emitClose !== !1),
      (this.autoDestroy = !!Ht.autoDestroy),
      (this.destroyed = !1),
      (this.defaultEncoding = Ht.defaultEncoding || 'utf8'),
      (this.awaitDrain = 0),
      (this.readingMore = !1),
      (this.decoder = null),
      (this.encoding = null),
      Ht.encoding &&
        (vt || (vt = requireString_decoder$4().StringDecoder),
        (this.decoder = new vt(Ht.encoding)),
        (this.encoding = Ht.encoding))
  }
  function Dt(Ht) {
    if (((a = a || require_stream_duplex$5()), !(this instanceof Dt)))
      return new Dt(Ht)
    var Lt = this instanceof a
    ;(this._readableState = new Ct(Ht, this, Lt)),
      (this.readable = !0),
      Ht &&
        (typeof Ht.read == 'function' && (this._read = Ht.read),
        typeof Ht.destroy == 'function' && (this._destroy = Ht.destroy)),
      $.call(this)
  }
  Object.defineProperty(Dt.prototype, 'destroyed', {
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed
    },
    set: function(Lt) {
      this._readableState && (this._readableState.destroyed = Lt)
    },
  }),
    (Dt.prototype.destroy = ot.destroy),
    (Dt.prototype._undestroy = ot.undestroy),
    (Dt.prototype._destroy = function(Ht, Lt) {
      Lt(Ht)
    }),
    (Dt.prototype.push = function(Ht, Lt) {
      var tr = this._readableState,
        lr
      return (
        tr.objectMode
          ? (lr = !0)
          : typeof Ht == 'string' &&
            ((Lt = Lt || tr.defaultEncoding),
            Lt !== tr.encoding && ((Ht = j.from(Ht, Lt)), (Lt = '')),
            (lr = !0)),
        jt(this, Ht, Lt, !1, lr)
      )
    }),
    (Dt.prototype.unshift = function(Ht) {
      return jt(this, Ht, null, !0, !1)
    })
  function jt(Ht, Lt, tr, lr, yr) {
    nt('readableAddChunk', Lt)
    var mr = Ht._readableState
    if (Lt === null) (mr.reading = !1), Wt(Ht, mr)
    else {
      var Er
      if ((yr || (Er = St(mr, Lt)), Er)) ht(Ht, Er)
      else if (mr.objectMode || (Lt && Lt.length > 0))
        if (
          (typeof Lt != 'string' &&
            !mr.objectMode &&
            Object.getPrototypeOf(Lt) !== j.prototype &&
            (Lt = et(Lt)),
          lr)
        )
          mr.endEmitted ? ht(Ht, new mt()) : Et(Ht, mr, Lt, !0)
        else if (mr.ended) ht(Ht, new dt())
        else {
          if (mr.destroyed) return !1
          ;(mr.reading = !1),
            mr.decoder && !tr
              ? ((Lt = mr.decoder.write(Lt)),
                mr.objectMode || Lt.length !== 0
                  ? Et(Ht, mr, Lt, !1)
                  : Ot(Ht, mr))
              : Et(Ht, mr, Lt, !1)
        }
      else lr || ((mr.reading = !1), Ot(Ht, mr))
    }
    return !mr.ended && (mr.length < mr.highWaterMark || mr.length === 0)
  }
  function Et(Ht, Lt, tr, lr) {
    Lt.flowing && Lt.length === 0 && !Lt.sync
      ? ((Lt.awaitDrain = 0), Ht.emit('data', tr))
      : ((Lt.length += Lt.objectMode ? 1 : tr.length),
        lr ? Lt.buffer.unshift(tr) : Lt.buffer.push(tr),
        Lt.needReadable && Tt(Ht)),
      Ot(Ht, Lt)
  }
  function St(Ht, Lt) {
    var tr
    return (
      !tt(Lt) &&
        typeof Lt != 'string' &&
        Lt !== void 0 &&
        !Ht.objectMode &&
        (tr = new ct('chunk', ['string', 'Buffer', 'Uint8Array'], Lt)),
      tr
    )
  }
  ;(Dt.prototype.isPaused = function() {
    return this._readableState.flowing === !1
  }),
    (Dt.prototype.setEncoding = function(Ht) {
      vt || (vt = requireString_decoder$4().StringDecoder)
      var Lt = new vt(Ht)
      ;(this._readableState.decoder = Lt),
        (this._readableState.encoding = this._readableState.decoder.encoding)
      for (var tr = this._readableState.buffer.head, lr = ''; tr !== null; )
        (lr += Lt.write(tr.data)), (tr = tr.next)
      return (
        this._readableState.buffer.clear(),
        lr !== '' && this._readableState.buffer.push(lr),
        (this._readableState.length = lr.length),
        this
      )
    })
  var Bt = 1073741824
  function Mt(Ht) {
    return (
      Ht >= Bt
        ? (Ht = Bt)
        : (Ht--,
          (Ht |= Ht >>> 1),
          (Ht |= Ht >>> 2),
          (Ht |= Ht >>> 4),
          (Ht |= Ht >>> 8),
          (Ht |= Ht >>> 16),
          Ht++),
      Ht
    )
  }
  function Ut(Ht, Lt) {
    return Ht <= 0 || (Lt.length === 0 && Lt.ended)
      ? 0
      : Lt.objectMode
      ? 1
      : Ht !== Ht
      ? Lt.flowing && Lt.length
        ? Lt.buffer.head.data.length
        : Lt.length
      : (Ht > Lt.highWaterMark && (Lt.highWaterMark = Mt(Ht)),
        Ht <= Lt.length
          ? Ht
          : Lt.ended
          ? Lt.length
          : ((Lt.needReadable = !0), 0))
  }
  Dt.prototype.read = function(Ht) {
    nt('read', Ht), (Ht = parseInt(Ht, 10))
    var Lt = this._readableState,
      tr = Ht
    if (
      (Ht !== 0 && (Lt.emittedReadable = !1),
      Ht === 0 &&
        Lt.needReadable &&
        ((Lt.highWaterMark !== 0
          ? Lt.length >= Lt.highWaterMark
          : Lt.length > 0) ||
          Lt.ended))
    )
      return (
        nt('read: emitReadable', Lt.length, Lt.ended),
        Lt.length === 0 && Lt.ended ? It(this) : Tt(this),
        null
      )
    if (((Ht = Ut(Ht, Lt)), Ht === 0 && Lt.ended))
      return Lt.length === 0 && It(this), null
    var lr = Lt.needReadable
    nt('need readable', lr),
      (Lt.length === 0 || Lt.length - Ht < Lt.highWaterMark) &&
        ((lr = !0), nt('length less than watermark', lr)),
      Lt.ended || Lt.reading
        ? ((lr = !1), nt('reading or ended', lr))
        : lr &&
          (nt('do read'),
          (Lt.reading = !0),
          (Lt.sync = !0),
          Lt.length === 0 && (Lt.needReadable = !0),
          this._read(Lt.highWaterMark),
          (Lt.sync = !1),
          Lt.reading || (Ht = Ut(tr, Lt)))
    var yr
    return (
      Ht > 0 ? (yr = xt(Ht, Lt)) : (yr = null),
      yr === null
        ? ((Lt.needReadable = Lt.length <= Lt.highWaterMark), (Ht = 0))
        : ((Lt.length -= Ht), (Lt.awaitDrain = 0)),
      Lt.length === 0 &&
        (Lt.ended || (Lt.needReadable = !0), tr !== Ht && Lt.ended && It(this)),
      yr !== null && this.emit('data', yr),
      yr
    )
  }
  function Wt(Ht, Lt) {
    if ((nt('onEofChunk'), !Lt.ended)) {
      if (Lt.decoder) {
        var tr = Lt.decoder.end()
        tr &&
          tr.length &&
          (Lt.buffer.push(tr), (Lt.length += Lt.objectMode ? 1 : tr.length))
      }
      ;(Lt.ended = !0),
        Lt.sync
          ? Tt(Ht)
          : ((Lt.needReadable = !1),
            Lt.emittedReadable || ((Lt.emittedReadable = !0), kt(Ht)))
    }
  }
  function Tt(Ht) {
    var Lt = Ht._readableState
    nt('emitReadable', Lt.needReadable, Lt.emittedReadable),
      (Lt.needReadable = !1),
      Lt.emittedReadable ||
        (nt('emitReadable', Lt.flowing),
        (Lt.emittedReadable = !0),
        process.nextTick(kt, Ht))
  }
  function kt(Ht) {
    var Lt = Ht._readableState
    nt('emitReadable_', Lt.destroyed, Lt.length, Lt.ended),
      !Lt.destroyed &&
        (Lt.length || Lt.ended) &&
        (Ht.emit('readable'), (Lt.emittedReadable = !1)),
      (Lt.needReadable =
        !Lt.flowing && !Lt.ended && Lt.length <= Lt.highWaterMark),
      Yt(Ht)
  }
  function Ot(Ht, Lt) {
    Lt.readingMore || ((Lt.readingMore = !0), process.nextTick(Nt, Ht, Lt))
  }
  function Nt(Ht, Lt) {
    for (
      ;
      !Lt.reading &&
      !Lt.ended &&
      (Lt.length < Lt.highWaterMark || (Lt.flowing && Lt.length === 0));

    ) {
      var tr = Lt.length
      if ((nt('maybeReadMore read 0'), Ht.read(0), tr === Lt.length)) break
    }
    Lt.readingMore = !1
  }
  ;(Dt.prototype._read = function(Ht) {
    ht(this, new ft('_read()'))
  }),
    (Dt.prototype.pipe = function(Ht, Lt) {
      var tr = this,
        lr = this._readableState
      switch (lr.pipesCount) {
        case 0:
          lr.pipes = Ht
          break
        case 1:
          lr.pipes = [lr.pipes, Ht]
          break
        default:
          lr.pipes.push(Ht)
          break
      }
      ;(lr.pipesCount += 1), nt('pipe count=%d opts=%j', lr.pipesCount, Lt)
      var yr =
          (!Lt || Lt.end !== !1) &&
          Ht !== process.stdout &&
          Ht !== process.stderr,
        mr = yr ? ur : zt
      lr.endEmitted ? process.nextTick(mr) : tr.once('end', mr),
        Ht.on('unpipe', Er)
      function Er(bt, Rt) {
        nt('onunpipe'),
          bt === tr &&
            Rt &&
            Rt.hasUnpiped === !1 &&
            ((Rt.hasUnpiped = !0), nr())
      }
      function ur() {
        nt('onend'), Ht.end()
      }
      var _r = $t(tr)
      Ht.on('drain', _r)
      var Rr = !1
      function nr() {
        nt('cleanup'),
          Ht.removeListener('close', br),
          Ht.removeListener('finish', Sr),
          Ht.removeListener('drain', _r),
          Ht.removeListener('error', gr),
          Ht.removeListener('unpipe', Er),
          tr.removeListener('end', ur),
          tr.removeListener('end', zt),
          tr.removeListener('data', fr),
          (Rr = !0),
          lr.awaitDrain &&
            (!Ht._writableState || Ht._writableState.needDrain) &&
            _r()
      }
      tr.on('data', fr)
      function fr(bt) {
        nt('ondata')
        var Rt = Ht.write(bt)
        nt('dest.write', Rt),
          Rt === !1 &&
            (((lr.pipesCount === 1 && lr.pipes === Ht) ||
              (lr.pipesCount > 1 && Qt(lr.pipes, Ht) !== -1)) &&
              !Rr &&
              (nt('false write response, pause', lr.awaitDrain),
              lr.awaitDrain++),
            tr.pause())
      }
      function gr(bt) {
        nt('onerror', bt),
          zt(),
          Ht.removeListener('error', gr),
          s(Ht, 'error') === 0 && ht(Ht, bt)
      }
      wt(Ht, 'error', gr)
      function br() {
        Ht.removeListener('finish', Sr), zt()
      }
      Ht.once('close', br)
      function Sr() {
        nt('onfinish'), Ht.removeListener('close', br), zt()
      }
      Ht.once('finish', Sr)
      function zt() {
        nt('unpipe'), tr.unpipe(Ht)
      }
      return (
        Ht.emit('pipe', tr), lr.flowing || (nt('pipe resume'), tr.resume()), Ht
      )
    })
  function $t(Ht) {
    return function() {
      var tr = Ht._readableState
      nt('pipeOnDrain', tr.awaitDrain),
        tr.awaitDrain && tr.awaitDrain--,
        tr.awaitDrain === 0 && s(Ht, 'data') && ((tr.flowing = !0), Yt(Ht))
    }
  }
  ;(Dt.prototype.unpipe = function(Ht) {
    var Lt = this._readableState,
      tr = { hasUnpiped: !1 }
    if (Lt.pipesCount === 0) return this
    if (Lt.pipesCount === 1)
      return Ht && Ht !== Lt.pipes
        ? this
        : (Ht || (Ht = Lt.pipes),
          (Lt.pipes = null),
          (Lt.pipesCount = 0),
          (Lt.flowing = !1),
          Ht && Ht.emit('unpipe', this, tr),
          this)
    if (!Ht) {
      var lr = Lt.pipes,
        yr = Lt.pipesCount
      ;(Lt.pipes = null), (Lt.pipesCount = 0), (Lt.flowing = !1)
      for (var mr = 0; mr < yr; mr++)
        lr[mr].emit('unpipe', this, { hasUnpiped: !1 })
      return this
    }
    var Er = Qt(Lt.pipes, Ht)
    return Er === -1
      ? this
      : (Lt.pipes.splice(Er, 1),
        (Lt.pipesCount -= 1),
        Lt.pipesCount === 1 && (Lt.pipes = Lt.pipes[0]),
        Ht.emit('unpipe', this, tr),
        this)
  }),
    (Dt.prototype.on = function(Ht, Lt) {
      var tr = $.prototype.on.call(this, Ht, Lt),
        lr = this._readableState
      return (
        Ht === 'data'
          ? ((lr.readableListening = this.listenerCount('readable') > 0),
            lr.flowing !== !1 && this.resume())
          : Ht === 'readable' &&
            !lr.endEmitted &&
            !lr.readableListening &&
            ((lr.readableListening = lr.needReadable = !0),
            (lr.flowing = !1),
            (lr.emittedReadable = !1),
            nt('on readable', lr.length, lr.reading),
            lr.length ? Tt(this) : lr.reading || process.nextTick(Ft, this)),
        tr
      )
    }),
    (Dt.prototype.addListener = Dt.prototype.on),
    (Dt.prototype.removeListener = function(Ht, Lt) {
      var tr = $.prototype.removeListener.call(this, Ht, Lt)
      return Ht === 'readable' && process.nextTick(Pt, this), tr
    }),
    (Dt.prototype.removeAllListeners = function(Ht) {
      var Lt = $.prototype.removeAllListeners.apply(this, arguments)
      return (
        (Ht === 'readable' || Ht === void 0) && process.nextTick(Pt, this), Lt
      )
    })
  function Pt(Ht) {
    var Lt = Ht._readableState
    ;(Lt.readableListening = Ht.listenerCount('readable') > 0),
      Lt.resumeScheduled && !Lt.paused
        ? (Lt.flowing = !0)
        : Ht.listenerCount('data') > 0 && Ht.resume()
  }
  function Ft(Ht) {
    nt('readable nexttick read 0'), Ht.read(0)
  }
  Dt.prototype.resume = function() {
    var Ht = this._readableState
    return (
      Ht.flowing ||
        (nt('resume'), (Ht.flowing = !Ht.readableListening), Vt(this, Ht)),
      (Ht.paused = !1),
      this
    )
  }
  function Vt(Ht, Lt) {
    Lt.resumeScheduled ||
      ((Lt.resumeScheduled = !0), process.nextTick(Xt, Ht, Lt))
  }
  function Xt(Ht, Lt) {
    nt('resume', Lt.reading),
      Lt.reading || Ht.read(0),
      (Lt.resumeScheduled = !1),
      Ht.emit('resume'),
      Yt(Ht),
      Lt.flowing && !Lt.reading && Ht.read(0)
  }
  Dt.prototype.pause = function() {
    return (
      nt('call pause flowing=%j', this._readableState.flowing),
      this._readableState.flowing !== !1 &&
        (nt('pause'), (this._readableState.flowing = !1), this.emit('pause')),
      (this._readableState.paused = !0),
      this
    )
  }
  function Yt(Ht) {
    var Lt = Ht._readableState
    for (nt('flow', Lt.flowing); Lt.flowing && Ht.read() !== null; );
  }
  ;(Dt.prototype.wrap = function(Ht) {
    var Lt = this,
      tr = this._readableState,
      lr = !1
    Ht.on('end', function() {
      if ((nt('wrapped end'), tr.decoder && !tr.ended)) {
        var Er = tr.decoder.end()
        Er && Er.length && Lt.push(Er)
      }
      Lt.push(null)
    }),
      Ht.on('data', function(Er) {
        if (
          (nt('wrapped data'),
          tr.decoder && (Er = tr.decoder.write(Er)),
          !(tr.objectMode && Er == null) &&
            !(!tr.objectMode && (!Er || !Er.length)))
        ) {
          var ur = Lt.push(Er)
          ur || ((lr = !0), Ht.pause())
        }
      })
    for (var yr in Ht)
      this[yr] === void 0 &&
        typeof Ht[yr] == 'function' &&
        (this[yr] = (function(ur) {
          return function() {
            return Ht[ur].apply(Ht, arguments)
          }
        })(yr))
    for (var mr = 0; mr < At.length; mr++)
      Ht.on(At[mr], this.emit.bind(this, At[mr]))
    return (
      (this._read = function(Er) {
        nt('wrapped _read', Er), lr && ((lr = !1), Ht.resume())
      }),
      this
    )
  }),
    typeof Symbol == 'function' &&
      (Dt.prototype[Symbol.asyncIterator] = function() {
        return yt === void 0 && (yt = requireAsync_iterator()), yt(this)
      }),
    Object.defineProperty(Dt.prototype, 'readableHighWaterMark', {
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark
      },
    }),
    Object.defineProperty(Dt.prototype, 'readableBuffer', {
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer
      },
    }),
    Object.defineProperty(Dt.prototype, 'readableFlowing', {
      enumerable: !1,
      get: function() {
        return this._readableState.flowing
      },
      set: function(Lt) {
        this._readableState && (this._readableState.flowing = Lt)
      },
    }),
    (Dt._fromList = xt),
    Object.defineProperty(Dt.prototype, 'readableLength', {
      enumerable: !1,
      get: function() {
        return this._readableState.length
      },
    })
  function xt(Ht, Lt) {
    if (Lt.length === 0) return null
    var tr
    return (
      Lt.objectMode
        ? (tr = Lt.buffer.shift())
        : !Ht || Ht >= Lt.length
        ? (Lt.decoder
            ? (tr = Lt.buffer.join(''))
            : Lt.buffer.length === 1
            ? (tr = Lt.buffer.first())
            : (tr = Lt.buffer.concat(Lt.length)),
          Lt.buffer.clear())
        : (tr = Lt.buffer.consume(Ht, Lt.decoder)),
      tr
    )
  }
  function It(Ht) {
    var Lt = Ht._readableState
    nt('endReadable', Lt.endEmitted),
      Lt.endEmitted || ((Lt.ended = !0), process.nextTick(Kt, Lt, Ht))
  }
  function Kt(Ht, Lt) {
    if (
      (nt('endReadableNT', Ht.endEmitted, Ht.length),
      !Ht.endEmitted &&
        Ht.length === 0 &&
        ((Ht.endEmitted = !0),
        (Lt.readable = !1),
        Lt.emit('end'),
        Ht.autoDestroy))
    ) {
      var tr = Lt._writableState
      ;(!tr || (tr.autoDestroy && tr.finished)) && Lt.destroy()
    }
  }
  typeof Symbol == 'function' &&
    (Dt.from = function(Ht, Lt) {
      return pt === void 0 && (pt = requireFromBrowser()), pt(Dt, Ht, Lt)
    })
  function Qt(Ht, Lt) {
    for (var tr = 0, lr = Ht.length; tr < lr; tr++) if (Ht[tr] === Lt) return tr
    return -1
  }
  return _stream_readable$5
}
var _stream_transform$5, hasRequired_stream_transform
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform$5
  ;(hasRequired_stream_transform = 1), (_stream_transform$5 = tt)
  var o = requireErrorsBrowser().codes,
    a = o.ERR_METHOD_NOT_IMPLEMENTED,
    s = o.ERR_MULTIPLE_CALLBACK,
    $ = o.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    j = o.ERR_TRANSFORM_WITH_LENGTH_0,
    _e = require_stream_duplex$5()
  inherits_browserExports(tt, _e)
  function et(it, ot) {
    var at = this._transformState
    at.transforming = !1
    var st = at.writecb
    if (st === null) return this.emit('error', new s())
    ;(at.writechunk = null),
      (at.writecb = null),
      ot != null && this.push(ot),
      st(it)
    var ut = this._readableState
    ;(ut.reading = !1),
      (ut.needReadable || ut.length < ut.highWaterMark) &&
        this._read(ut.highWaterMark)
  }
  function tt(it) {
    if (!(this instanceof tt)) return new tt(it)
    _e.call(this, it),
      (this._transformState = {
        afterTransform: et.bind(this),
        needTransform: !1,
        transforming: !1,
        writecb: null,
        writechunk: null,
        writeencoding: null,
      }),
      (this._readableState.needReadable = !0),
      (this._readableState.sync = !1),
      it &&
        (typeof it.transform == 'function' && (this._transform = it.transform),
        typeof it.flush == 'function' && (this._flush = it.flush)),
      this.on('prefinish', rt)
  }
  function rt() {
    var it = this
    typeof this._flush == 'function' && !this._readableState.destroyed
      ? this._flush(function(ot, at) {
          nt(it, ot, at)
        })
      : nt(this, null, null)
  }
  ;(tt.prototype.push = function(it, ot) {
    return (
      (this._transformState.needTransform = !1),
      _e.prototype.push.call(this, it, ot)
    )
  }),
    (tt.prototype._transform = function(it, ot, at) {
      at(new a('_transform()'))
    }),
    (tt.prototype._write = function(it, ot, at) {
      var st = this._transformState
      if (
        ((st.writecb = at),
        (st.writechunk = it),
        (st.writeencoding = ot),
        !st.transforming)
      ) {
        var ut = this._readableState
        ;(st.needTransform ||
          ut.needReadable ||
          ut.length < ut.highWaterMark) &&
          this._read(ut.highWaterMark)
      }
    }),
    (tt.prototype._read = function(it) {
      var ot = this._transformState
      ot.writechunk !== null && !ot.transforming
        ? ((ot.transforming = !0),
          this._transform(ot.writechunk, ot.writeencoding, ot.afterTransform))
        : (ot.needTransform = !0)
    }),
    (tt.prototype._destroy = function(it, ot) {
      _e.prototype._destroy.call(this, it, function(at) {
        ot(at)
      })
    })
  function nt(it, ot, at) {
    if (ot) return it.emit('error', ot)
    if ((at != null && it.push(at), it._writableState.length)) throw new j()
    if (it._transformState.transforming) throw new $()
    return it.push(null)
  }
  return _stream_transform$5
}
var _stream_passthrough$5, hasRequired_stream_passthrough
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough$5
  ;(hasRequired_stream_passthrough = 1), (_stream_passthrough$5 = a)
  var o = require_stream_transform()
  inherits_browserExports(a, o)
  function a(s) {
    if (!(this instanceof a)) return new a(s)
    o.call(this, s)
  }
  return (
    (a.prototype._transform = function(s, $, j) {
      j(null, s)
    }),
    _stream_passthrough$5
  )
}
var pipeline_1, hasRequiredPipeline
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1
  hasRequiredPipeline = 1
  var o
  function a(at) {
    var st = !1
    return function() {
      st || ((st = !0), at.apply(void 0, arguments))
    }
  }
  var s = requireErrorsBrowser().codes,
    $ = s.ERR_MISSING_ARGS,
    j = s.ERR_STREAM_DESTROYED
  function _e(at) {
    if (at) throw at
  }
  function et(at) {
    return at.setHeader && typeof at.abort == 'function'
  }
  function tt(at, st, ut, ct) {
    ct = a(ct)
    var dt = !1
    at.on('close', function() {
      dt = !0
    }),
      o === void 0 && (o = requireEndOfStream()),
      o(at, { readable: st, writable: ut }, function(mt) {
        if (mt) return ct(mt)
        ;(dt = !0), ct()
      })
    var ft = !1
    return function(mt) {
      if (!dt && !ft) {
        if (((ft = !0), et(at))) return at.abort()
        if (typeof at.destroy == 'function') return at.destroy()
        ct(mt || new j('pipe'))
      }
    }
  }
  function rt(at) {
    at()
  }
  function nt(at, st) {
    return at.pipe(st)
  }
  function it(at) {
    return !at.length || typeof at[at.length - 1] != 'function' ? _e : at.pop()
  }
  function ot() {
    for (var at = arguments.length, st = new Array(at), ut = 0; ut < at; ut++)
      st[ut] = arguments[ut]
    var ct = it(st)
    if ((Array.isArray(st[0]) && (st = st[0]), st.length < 2))
      throw new $('streams')
    var dt,
      ft = st.map(function(mt, vt) {
        var yt = vt < st.length - 1,
          pt = vt > 0
        return tt(mt, yt, pt, function(ht) {
          dt || (dt = ht), ht && ft.forEach(rt), !yt && (ft.forEach(rt), ct(dt))
        })
      })
    return st.reduce(nt)
  }
  return (pipeline_1 = ot), pipeline_1
}
var stream$1 = Stream$7,
  EE$3 = eventsExports.EventEmitter,
  inherits$7 = inherits_browserExports
inherits$7(Stream$7, EE$3)
Stream$7.Readable = require_stream_readable$2()
Stream$7.Writable = require_stream_writable$5()
Stream$7.Duplex = require_stream_duplex$5()
Stream$7.Transform = require_stream_transform()
Stream$7.PassThrough = require_stream_passthrough()
Stream$7.finished = requireEndOfStream()
Stream$7.pipeline = requirePipeline()
Stream$7.Stream = Stream$7
function Stream$7() {
  EE$3.call(this)
}
Stream$7.prototype.pipe = function(o, a) {
  var s = this
  function $(it) {
    o.writable && o.write(it) === !1 && s.pause && s.pause()
  }
  s.on('data', $)
  function j() {
    s.readable && s.resume && s.resume()
  }
  o.on('drain', j),
    !o._isStdio && (!a || a.end !== !1) && (s.on('end', et), s.on('close', tt))
  var _e = !1
  function et() {
    _e || ((_e = !0), o.end())
  }
  function tt() {
    _e || ((_e = !0), typeof o.destroy == 'function' && o.destroy())
  }
  function rt(it) {
    if ((nt(), EE$3.listenerCount(this, 'error') === 0)) throw it
  }
  s.on('error', rt), o.on('error', rt)
  function nt() {
    s.removeListener('data', $),
      o.removeListener('drain', j),
      s.removeListener('end', et),
      s.removeListener('close', tt),
      s.removeListener('error', rt),
      o.removeListener('error', rt),
      s.removeListener('end', nt),
      s.removeListener('close', nt),
      o.removeListener('close', nt)
  }
  return (
    s.on('end', nt), s.on('close', nt), o.on('close', nt), o.emit('pipe', s), o
  )
}
var isarray$4 =
    Array.isArray ||
    function(o) {
      return Object.prototype.toString.call(o) == '[object Array]'
    },
  util$q = {}
function isArray$4(o) {
  return Array.isArray
    ? Array.isArray(o)
    : objectToString(o) === '[object Array]'
}
util$q.isArray = isArray$4
function isBoolean(o) {
  return typeof o == 'boolean'
}
util$q.isBoolean = isBoolean
function isNull(o) {
  return o === null
}
util$q.isNull = isNull
function isNullOrUndefined(o) {
  return o == null
}
util$q.isNullOrUndefined = isNullOrUndefined
function isNumber(o) {
  return typeof o == 'number'
}
util$q.isNumber = isNumber
function isString$1(o) {
  return typeof o == 'string'
}
util$q.isString = isString$1
function isSymbol(o) {
  return typeof o == 'symbol'
}
util$q.isSymbol = isSymbol
function isUndefined(o) {
  return o === void 0
}
util$q.isUndefined = isUndefined
function isRegExp(o) {
  return objectToString(o) === '[object RegExp]'
}
util$q.isRegExp = isRegExp
function isObject(o) {
  return typeof o == 'object' && o !== null
}
util$q.isObject = isObject
function isDate(o) {
  return objectToString(o) === '[object Date]'
}
util$q.isDate = isDate
function isError(o) {
  return objectToString(o) === '[object Error]' || o instanceof Error
}
util$q.isError = isError
function isFunction(o) {
  return typeof o == 'function'
}
util$q.isFunction = isFunction
function isPrimitive$1(o) {
  return (
    o === null ||
    typeof o == 'boolean' ||
    typeof o == 'number' ||
    typeof o == 'string' ||
    typeof o == 'symbol' ||
    typeof o > 'u'
  )
}
util$q.isPrimitive = isPrimitive$1
util$q.isBuffer = buffer$1.Buffer.isBuffer
function objectToString(o) {
  return Object.prototype.toString.call(o)
}
var string_decoder$3 = {},
  hasRequiredString_decoder$3
function requireString_decoder$3() {
  if (hasRequiredString_decoder$3) return string_decoder$3
  hasRequiredString_decoder$3 = 1
  var o = buffer$1.Buffer,
    a =
      o.isEncoding ||
      function(tt) {
        switch (tt && tt.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return !0
          default:
            return !1
        }
      }
  function s(tt) {
    if (tt && !a(tt)) throw new Error('Unknown encoding: ' + tt)
  }
  var $ = (string_decoder$3.StringDecoder = function(tt) {
    switch (
      ((this.encoding = (tt || 'utf8').toLowerCase().replace(/[-_]/, '')),
      s(tt),
      this.encoding)
    ) {
      case 'utf8':
        this.surrogateSize = 3
        break
      case 'ucs2':
      case 'utf16le':
        ;(this.surrogateSize = 2), (this.detectIncompleteChar = _e)
        break
      case 'base64':
        ;(this.surrogateSize = 3), (this.detectIncompleteChar = et)
        break
      default:
        this.write = j
        return
    }
    ;(this.charBuffer = new o(6)),
      (this.charReceived = 0),
      (this.charLength = 0)
  })
  ;($.prototype.write = function(tt) {
    for (var rt = ''; this.charLength; ) {
      var nt =
        tt.length >= this.charLength - this.charReceived
          ? this.charLength - this.charReceived
          : tt.length
      if (
        (tt.copy(this.charBuffer, this.charReceived, 0, nt),
        (this.charReceived += nt),
        this.charReceived < this.charLength)
      )
        return ''
      ;(tt = tt.slice(nt, tt.length)),
        (rt = this.charBuffer.slice(0, this.charLength).toString(this.encoding))
      var ot = rt.charCodeAt(rt.length - 1)
      if (ot >= 55296 && ot <= 56319) {
        ;(this.charLength += this.surrogateSize), (rt = '')
        continue
      }
      if (((this.charReceived = this.charLength = 0), tt.length === 0))
        return rt
      break
    }
    this.detectIncompleteChar(tt)
    var it = tt.length
    this.charLength &&
      (tt.copy(this.charBuffer, 0, tt.length - this.charReceived, it),
      (it -= this.charReceived)),
      (rt += tt.toString(this.encoding, 0, it))
    var it = rt.length - 1,
      ot = rt.charCodeAt(it)
    if (ot >= 55296 && ot <= 56319) {
      var at = this.surrogateSize
      return (
        (this.charLength += at),
        (this.charReceived += at),
        this.charBuffer.copy(this.charBuffer, at, 0, at),
        tt.copy(this.charBuffer, 0, 0, at),
        rt.substring(0, it)
      )
    }
    return rt
  }),
    ($.prototype.detectIncompleteChar = function(tt) {
      for (var rt = tt.length >= 3 ? 3 : tt.length; rt > 0; rt--) {
        var nt = tt[tt.length - rt]
        if (rt == 1 && nt >> 5 == 6) {
          this.charLength = 2
          break
        }
        if (rt <= 2 && nt >> 4 == 14) {
          this.charLength = 3
          break
        }
        if (rt <= 3 && nt >> 3 == 30) {
          this.charLength = 4
          break
        }
      }
      this.charReceived = rt
    }),
    ($.prototype.end = function(tt) {
      var rt = ''
      if ((tt && tt.length && (rt = this.write(tt)), this.charReceived)) {
        var nt = this.charReceived,
          it = this.charBuffer,
          ot = this.encoding
        rt += it.slice(0, nt).toString(ot)
      }
      return rt
    })
  function j(tt) {
    return tt.toString(this.encoding)
  }
  function _e(tt) {
    ;(this.charReceived = tt.length % 2),
      (this.charLength = this.charReceived ? 2 : 0)
  }
  function et(tt) {
    ;(this.charReceived = tt.length % 3),
      (this.charLength = this.charReceived ? 3 : 0)
  }
  return string_decoder$3
}
var _stream_readable$4 = Readable$4,
  isArray$3 = isarray$4,
  Buffer$3 = buffer$1.Buffer
Readable$4.ReadableState = ReadableState$2
var EE$2 = eventsExports.EventEmitter
EE$2.listenerCount ||
  (EE$2.listenerCount = function(o, a) {
    return o.listeners(a).length
  })
var Stream$6 = stream$1,
  util$p = util$q
util$p.inherits = inherits_browserExports
var StringDecoder$2
util$p.inherits(Readable$4, Stream$6)
function ReadableState$2(o, a) {
  o = o || {}
  var s = o.highWaterMark
  ;(this.highWaterMark = s || s === 0 ? s : 16 * 1024),
    (this.highWaterMark = ~~this.highWaterMark),
    (this.buffer = []),
    (this.length = 0),
    (this.pipes = null),
    (this.pipesCount = 0),
    (this.flowing = !1),
    (this.ended = !1),
    (this.endEmitted = !1),
    (this.reading = !1),
    (this.calledRead = !1),
    (this.sync = !0),
    (this.needReadable = !1),
    (this.emittedReadable = !1),
    (this.readableListening = !1),
    (this.objectMode = !!o.objectMode),
    (this.defaultEncoding = o.defaultEncoding || 'utf8'),
    (this.ranOut = !1),
    (this.awaitDrain = 0),
    (this.readingMore = !1),
    (this.decoder = null),
    (this.encoding = null),
    o.encoding &&
      (StringDecoder$2 ||
        (StringDecoder$2 = requireString_decoder$3().StringDecoder),
      (this.decoder = new StringDecoder$2(o.encoding)),
      (this.encoding = o.encoding))
}
function Readable$4(o) {
  if (!(this instanceof Readable$4)) return new Readable$4(o)
  ;(this._readableState = new ReadableState$2(o)),
    (this.readable = !0),
    Stream$6.call(this)
}
Readable$4.prototype.push = function(o, a) {
  var s = this._readableState
  return (
    typeof o == 'string' &&
      !s.objectMode &&
      ((a = a || s.defaultEncoding),
      a !== s.encoding && ((o = new Buffer$3(o, a)), (a = ''))),
    readableAddChunk$2(this, s, o, a, !1)
  )
}
Readable$4.prototype.unshift = function(o) {
  var a = this._readableState
  return readableAddChunk$2(this, a, o, '', !0)
}
function readableAddChunk$2(o, a, s, $, j) {
  var _e = chunkInvalid$2(a, s)
  if (_e) o.emit('error', _e)
  else if (s == null) (a.reading = !1), a.ended || onEofChunk$2(o, a)
  else if (a.objectMode || (s && s.length > 0))
    if (a.ended && !j) {
      var et = new Error('stream.push() after EOF')
      o.emit('error', et)
    } else if (a.endEmitted && j) {
      var et = new Error('stream.unshift() after end event')
      o.emit('error', et)
    } else
      a.decoder && !j && !$ && (s = a.decoder.write(s)),
        (a.length += a.objectMode ? 1 : s.length),
        j ? a.buffer.unshift(s) : ((a.reading = !1), a.buffer.push(s)),
        a.needReadable && emitReadable$2(o),
        maybeReadMore$2(o, a)
  else j || (a.reading = !1)
  return needMoreData$2(a)
}
function needMoreData$2(o) {
  return (
    !o.ended && (o.needReadable || o.length < o.highWaterMark || o.length === 0)
  )
}
Readable$4.prototype.setEncoding = function(o) {
  StringDecoder$2 ||
    (StringDecoder$2 = requireString_decoder$3().StringDecoder),
    (this._readableState.decoder = new StringDecoder$2(o)),
    (this._readableState.encoding = o)
}
var MAX_HWM$2 = 8388608
function roundUpToNextPowerOf2$2(o) {
  if (o >= MAX_HWM$2) o = MAX_HWM$2
  else {
    o--
    for (var a = 1; a < 32; a <<= 1) o |= o >> a
    o++
  }
  return o
}
function howMuchToRead$2(o, a) {
  return a.length === 0 && a.ended
    ? 0
    : a.objectMode
    ? o === 0
      ? 0
      : 1
    : o === null || isNaN(o)
    ? a.flowing && a.buffer.length
      ? a.buffer[0].length
      : a.length
    : o <= 0
    ? 0
    : (o > a.highWaterMark && (a.highWaterMark = roundUpToNextPowerOf2$2(o)),
      o > a.length ? (a.ended ? a.length : ((a.needReadable = !0), 0)) : o)
}
Readable$4.prototype.read = function(o) {
  var a = this._readableState
  a.calledRead = !0
  var s = o,
    $
  if (
    ((typeof o != 'number' || o > 0) && (a.emittedReadable = !1),
    o === 0 && a.needReadable && (a.length >= a.highWaterMark || a.ended))
  )
    return emitReadable$2(this), null
  if (((o = howMuchToRead$2(o, a)), o === 0 && a.ended))
    return (
      ($ = null),
      a.length > 0 &&
        a.decoder &&
        (($ = fromList$2(o, a)), (a.length -= $.length)),
      a.length === 0 && endReadable$2(this),
      $
    )
  var j = a.needReadable
  return (
    a.length - o <= a.highWaterMark && (j = !0),
    (a.ended || a.reading) && (j = !1),
    j &&
      ((a.reading = !0),
      (a.sync = !0),
      a.length === 0 && (a.needReadable = !0),
      this._read(a.highWaterMark),
      (a.sync = !1)),
    j && !a.reading && (o = howMuchToRead$2(s, a)),
    o > 0 ? ($ = fromList$2(o, a)) : ($ = null),
    $ === null && ((a.needReadable = !0), (o = 0)),
    (a.length -= o),
    a.length === 0 && !a.ended && (a.needReadable = !0),
    a.ended && !a.endEmitted && a.length === 0 && endReadable$2(this),
    $
  )
}
function chunkInvalid$2(o, a) {
  var s = null
  return (
    !Buffer$3.isBuffer(a) &&
      typeof a != 'string' &&
      a !== null &&
      a !== void 0 &&
      !o.objectMode &&
      (s = new TypeError('Invalid non-string/buffer chunk')),
    s
  )
}
function onEofChunk$2(o, a) {
  if (a.decoder && !a.ended) {
    var s = a.decoder.end()
    s &&
      s.length &&
      (a.buffer.push(s), (a.length += a.objectMode ? 1 : s.length))
  }
  ;(a.ended = !0), a.length > 0 ? emitReadable$2(o) : endReadable$2(o)
}
function emitReadable$2(o) {
  var a = o._readableState
  ;(a.needReadable = !1),
    !a.emittedReadable &&
      ((a.emittedReadable = !0),
      a.sync
        ? process.nextTick(function() {
            emitReadable_$2(o)
          })
        : emitReadable_$2(o))
}
function emitReadable_$2(o) {
  o.emit('readable')
}
function maybeReadMore$2(o, a) {
  a.readingMore ||
    ((a.readingMore = !0),
    process.nextTick(function() {
      maybeReadMore_$2(o, a)
    }))
}
function maybeReadMore_$2(o, a) {
  for (
    var s = a.length;
    !a.reading &&
    !a.flowing &&
    !a.ended &&
    a.length < a.highWaterMark &&
    (o.read(0), s !== a.length);

  )
    s = a.length
  a.readingMore = !1
}
Readable$4.prototype._read = function(o) {
  this.emit('error', new Error('not implemented'))
}
Readable$4.prototype.pipe = function(o, a) {
  var s = this,
    $ = this._readableState
  switch ($.pipesCount) {
    case 0:
      $.pipes = o
      break
    case 1:
      $.pipes = [$.pipes, o]
      break
    default:
      $.pipes.push(o)
      break
  }
  $.pipesCount += 1
  var j = (!a || a.end !== !1) && o !== process.stdout && o !== process.stderr,
    _e = j ? tt : nt
  $.endEmitted ? process.nextTick(_e) : s.once('end', _e), o.on('unpipe', et)
  function et(ut) {
    ut === s && nt()
  }
  function tt() {
    o.end()
  }
  var rt = pipeOnDrain$2(s)
  o.on('drain', rt)
  function nt() {
    o.removeListener('close', ot),
      o.removeListener('finish', at),
      o.removeListener('drain', rt),
      o.removeListener('error', it),
      o.removeListener('unpipe', et),
      s.removeListener('end', tt),
      s.removeListener('end', nt),
      (!o._writableState || o._writableState.needDrain) && rt()
  }
  function it(ut) {
    st(),
      o.removeListener('error', it),
      EE$2.listenerCount(o, 'error') === 0 && o.emit('error', ut)
  }
  !o._events || !o._events.error
    ? o.on('error', it)
    : isArray$3(o._events.error)
    ? o._events.error.unshift(it)
    : (o._events.error = [it, o._events.error])
  function ot() {
    o.removeListener('finish', at), st()
  }
  o.once('close', ot)
  function at() {
    o.removeListener('close', ot), st()
  }
  o.once('finish', at)
  function st() {
    s.unpipe(o)
  }
  return (
    o.emit('pipe', s),
    $.flowing ||
      (this.on('readable', pipeOnReadable$2),
      ($.flowing = !0),
      process.nextTick(function() {
        flow$2(s)
      })),
    o
  )
}
function pipeOnDrain$2(o) {
  return function() {
    var a = o._readableState
    a.awaitDrain--, a.awaitDrain === 0 && flow$2(o)
  }
}
function flow$2(o) {
  var a = o._readableState,
    s
  a.awaitDrain = 0
  function $(j, _e, et) {
    var tt = j.write(s)
    tt === !1 && a.awaitDrain++
  }
  for (; a.pipesCount && (s = o.read()) !== null; )
    if (
      (a.pipesCount === 1 ? $(a.pipes) : forEach$2(a.pipes, $),
      o.emit('data', s),
      a.awaitDrain > 0)
    )
      return
  if (a.pipesCount === 0) {
    ;(a.flowing = !1), EE$2.listenerCount(o, 'data') > 0 && emitDataEvents$2(o)
    return
  }
  a.ranOut = !0
}
function pipeOnReadable$2() {
  this._readableState.ranOut &&
    ((this._readableState.ranOut = !1), flow$2(this))
}
Readable$4.prototype.unpipe = function(o) {
  var a = this._readableState
  if (a.pipesCount === 0) return this
  if (a.pipesCount === 1)
    return o && o !== a.pipes
      ? this
      : (o || (o = a.pipes),
        (a.pipes = null),
        (a.pipesCount = 0),
        this.removeListener('readable', pipeOnReadable$2),
        (a.flowing = !1),
        o && o.emit('unpipe', this),
        this)
  if (!o) {
    var s = a.pipes,
      $ = a.pipesCount
    ;(a.pipes = null),
      (a.pipesCount = 0),
      this.removeListener('readable', pipeOnReadable$2),
      (a.flowing = !1)
    for (var j = 0; j < $; j++) s[j].emit('unpipe', this)
    return this
  }
  var j = indexOf$2(a.pipes, o)
  return j === -1
    ? this
    : (a.pipes.splice(j, 1),
      (a.pipesCount -= 1),
      a.pipesCount === 1 && (a.pipes = a.pipes[0]),
      o.emit('unpipe', this),
      this)
}
Readable$4.prototype.on = function(o, a) {
  var s = Stream$6.prototype.on.call(this, o, a)
  if (
    (o === 'data' && !this._readableState.flowing && emitDataEvents$2(this),
    o === 'readable' && this.readable)
  ) {
    var $ = this._readableState
    $.readableListening ||
      (($.readableListening = !0),
      ($.emittedReadable = !1),
      ($.needReadable = !0),
      $.reading ? $.length && emitReadable$2(this) : this.read(0))
  }
  return s
}
Readable$4.prototype.addListener = Readable$4.prototype.on
Readable$4.prototype.resume = function() {
  emitDataEvents$2(this), this.read(0), this.emit('resume')
}
Readable$4.prototype.pause = function() {
  emitDataEvents$2(this, !0), this.emit('pause')
}
function emitDataEvents$2(o, a) {
  var s = o._readableState
  if (s.flowing) throw new Error('Cannot switch to old mode now.')
  var $ = a || !1,
    j = !1
  ;(o.readable = !0),
    (o.pipe = Stream$6.prototype.pipe),
    (o.on = o.addListener = Stream$6.prototype.on),
    o.on('readable', function() {
      j = !0
      for (var _e; !$ && (_e = o.read()) !== null; ) o.emit('data', _e)
      _e === null && ((j = !1), (o._readableState.needReadable = !0))
    }),
    (o.pause = function() {
      ;($ = !0), this.emit('pause')
    }),
    (o.resume = function() {
      ;($ = !1),
        j
          ? process.nextTick(function() {
              o.emit('readable')
            })
          : this.read(0),
        this.emit('resume')
    }),
    o.emit('readable')
}
Readable$4.prototype.wrap = function(o) {
  var a = this._readableState,
    s = !1,
    $ = this
  o.on('end', function() {
    if (a.decoder && !a.ended) {
      var et = a.decoder.end()
      et && et.length && $.push(et)
    }
    $.push(null)
  }),
    o.on('data', function(et) {
      if (
        (a.decoder && (et = a.decoder.write(et)),
        !(a.objectMode && et == null) &&
          !(!a.objectMode && (!et || !et.length)))
      ) {
        var tt = $.push(et)
        tt || ((s = !0), o.pause())
      }
    })
  for (var j in o)
    typeof o[j] == 'function' &&
      typeof this[j] > 'u' &&
      (this[j] = (function(et) {
        return function() {
          return o[et].apply(o, arguments)
        }
      })(j))
  var _e = ['error', 'close', 'destroy', 'pause', 'resume']
  return (
    forEach$2(_e, function(et) {
      o.on(et, $.emit.bind($, et))
    }),
    ($._read = function(et) {
      s && ((s = !1), o.resume())
    }),
    $
  )
}
Readable$4._fromList = fromList$2
function fromList$2(o, a) {
  var s = a.buffer,
    $ = a.length,
    j = !!a.decoder,
    _e = !!a.objectMode,
    et
  if (s.length === 0) return null
  if ($ === 0) et = null
  else if (_e) et = s.shift()
  else if (!o || o >= $)
    j ? (et = s.join('')) : (et = Buffer$3.concat(s, $)), (s.length = 0)
  else if (o < s[0].length) {
    var tt = s[0]
    ;(et = tt.slice(0, o)), (s[0] = tt.slice(o))
  } else if (o === s[0].length) et = s.shift()
  else {
    j ? (et = '') : (et = new Buffer$3(o))
    for (var rt = 0, nt = 0, it = s.length; nt < it && rt < o; nt++) {
      var tt = s[0],
        ot = Math.min(o - rt, tt.length)
      j ? (et += tt.slice(0, ot)) : tt.copy(et, rt, 0, ot),
        ot < tt.length ? (s[0] = tt.slice(ot)) : s.shift(),
        (rt += ot)
    }
  }
  return et
}
function endReadable$2(o) {
  var a = o._readableState
  if (a.length > 0) throw new Error('endReadable called on non-empty stream')
  !a.endEmitted &&
    a.calledRead &&
    ((a.ended = !0),
    process.nextTick(function() {
      !a.endEmitted &&
        a.length === 0 &&
        ((a.endEmitted = !0), (o.readable = !1), o.emit('end'))
    }))
}
function forEach$2(o, a) {
  for (var s = 0, $ = o.length; s < $; s++) a(o[s], s)
}
function indexOf$2(o, a) {
  for (var s = 0, $ = o.length; s < $; s++) if (o[s] === a) return s
  return -1
}
var _stream_duplex$4, hasRequired_stream_duplex$4
function require_stream_duplex$4() {
  if (hasRequired_stream_duplex$4) return _stream_duplex$4
  ;(hasRequired_stream_duplex$4 = 1), (_stream_duplex$4 = j)
  var o =
      Object.keys ||
      function(tt) {
        var rt = []
        for (var nt in tt) rt.push(nt)
        return rt
      },
    a = util$q
  a.inherits = inherits_browserExports
  var s = _stream_readable$4,
    $ = require_stream_writable$4()
  a.inherits(j, s),
    et(o($.prototype), function(tt) {
      j.prototype[tt] || (j.prototype[tt] = $.prototype[tt])
    })
  function j(tt) {
    if (!(this instanceof j)) return new j(tt)
    s.call(this, tt),
      $.call(this, tt),
      tt && tt.readable === !1 && (this.readable = !1),
      tt && tt.writable === !1 && (this.writable = !1),
      (this.allowHalfOpen = !0),
      tt && tt.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
      this.once('end', _e)
  }
  function _e() {
    this.allowHalfOpen ||
      this._writableState.ended ||
      process.nextTick(this.end.bind(this))
  }
  function et(tt, rt) {
    for (var nt = 0, it = tt.length; nt < it; nt++) rt(tt[nt], nt)
  }
  return _stream_duplex$4
}
var _stream_writable$4, hasRequired_stream_writable$4
function require_stream_writable$4() {
  if (hasRequired_stream_writable$4) return _stream_writable$4
  ;(hasRequired_stream_writable$4 = 1), (_stream_writable$4 = _e)
  var o = buffer$1.Buffer
  _e.WritableState = j
  var a = util$q
  a.inherits = inherits_browserExports
  var s = stream$1
  a.inherits(_e, s)
  function $(yt, pt, ht) {
    ;(this.chunk = yt), (this.encoding = pt), (this.callback = ht)
  }
  function j(yt, pt) {
    yt = yt || {}
    var ht = yt.highWaterMark
    ;(this.highWaterMark = ht || ht === 0 ? ht : 16 * 1024),
      (this.objectMode = !!yt.objectMode),
      (this.highWaterMark = ~~this.highWaterMark),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1)
    var At = yt.decodeStrings === !1
    ;(this.decodeStrings = !At),
      (this.defaultEncoding = yt.defaultEncoding || 'utf8'),
      (this.length = 0),
      (this.writing = !1),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function(wt) {
        st(pt, wt)
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.buffer = []),
      (this.errorEmitted = !1)
  }
  function _e(yt) {
    var pt = require_stream_duplex$4()
    if (!(this instanceof _e) && !(this instanceof pt)) return new _e(yt)
    ;(this._writableState = new j(yt, this)), (this.writable = !0), s.call(this)
  }
  _e.prototype.pipe = function() {
    this.emit('error', new Error('Cannot pipe. Not readable.'))
  }
  function et(yt, pt, ht) {
    var At = new Error('write after end')
    yt.emit('error', At),
      process.nextTick(function() {
        ht(At)
      })
  }
  function tt(yt, pt, ht, At) {
    var wt = !0
    if (
      !o.isBuffer(ht) &&
      typeof ht != 'string' &&
      ht !== null &&
      ht !== void 0 &&
      !pt.objectMode
    ) {
      var Ct = new TypeError('Invalid non-string/buffer chunk')
      yt.emit('error', Ct),
        process.nextTick(function() {
          At(Ct)
        }),
        (wt = !1)
    }
    return wt
  }
  _e.prototype.write = function(yt, pt, ht) {
    var At = this._writableState,
      wt = !1
    return (
      typeof pt == 'function' && ((ht = pt), (pt = null)),
      o.isBuffer(yt) ? (pt = 'buffer') : pt || (pt = At.defaultEncoding),
      typeof ht != 'function' && (ht = function() {}),
      At.ended
        ? et(this, At, ht)
        : tt(this, At, yt, ht) && (wt = nt(this, At, yt, pt, ht)),
      wt
    )
  }
  function rt(yt, pt, ht) {
    return (
      !yt.objectMode &&
        yt.decodeStrings !== !1 &&
        typeof pt == 'string' &&
        (pt = new o(pt, ht)),
      pt
    )
  }
  function nt(yt, pt, ht, At, wt) {
    ;(ht = rt(pt, ht, At)), o.isBuffer(ht) && (At = 'buffer')
    var Ct = pt.objectMode ? 1 : ht.length
    pt.length += Ct
    var Dt = pt.length < pt.highWaterMark
    return (
      Dt || (pt.needDrain = !0),
      pt.writing
        ? pt.buffer.push(new $(ht, At, wt))
        : it(yt, pt, Ct, ht, At, wt),
      Dt
    )
  }
  function it(yt, pt, ht, At, wt, Ct) {
    ;(pt.writelen = ht),
      (pt.writecb = Ct),
      (pt.writing = !0),
      (pt.sync = !0),
      yt._write(At, wt, pt.onwrite),
      (pt.sync = !1)
  }
  function ot(yt, pt, ht, At, wt) {
    ht
      ? process.nextTick(function() {
          wt(At)
        })
      : wt(At),
      (yt._writableState.errorEmitted = !0),
      yt.emit('error', At)
  }
  function at(yt) {
    ;(yt.writing = !1),
      (yt.writecb = null),
      (yt.length -= yt.writelen),
      (yt.writelen = 0)
  }
  function st(yt, pt) {
    var ht = yt._writableState,
      At = ht.sync,
      wt = ht.writecb
    if ((at(ht), pt)) ot(yt, ht, At, pt, wt)
    else {
      var Ct = ft(yt, ht)
      !Ct && !ht.bufferProcessing && ht.buffer.length && dt(yt, ht),
        At
          ? process.nextTick(function() {
              ut(yt, ht, Ct, wt)
            })
          : ut(yt, ht, Ct, wt)
    }
  }
  function ut(yt, pt, ht, At) {
    ht || ct(yt, pt), At(), ht && mt(yt, pt)
  }
  function ct(yt, pt) {
    pt.length === 0 && pt.needDrain && ((pt.needDrain = !1), yt.emit('drain'))
  }
  function dt(yt, pt) {
    pt.bufferProcessing = !0
    for (var ht = 0; ht < pt.buffer.length; ht++) {
      var At = pt.buffer[ht],
        wt = At.chunk,
        Ct = At.encoding,
        Dt = At.callback,
        jt = pt.objectMode ? 1 : wt.length
      if ((it(yt, pt, jt, wt, Ct, Dt), pt.writing)) {
        ht++
        break
      }
    }
    ;(pt.bufferProcessing = !1),
      ht < pt.buffer.length
        ? (pt.buffer = pt.buffer.slice(ht))
        : (pt.buffer.length = 0)
  }
  ;(_e.prototype._write = function(yt, pt, ht) {
    ht(new Error('not implemented'))
  }),
    (_e.prototype.end = function(yt, pt, ht) {
      var At = this._writableState
      typeof yt == 'function'
        ? ((ht = yt), (yt = null), (pt = null))
        : typeof pt == 'function' && ((ht = pt), (pt = null)),
        typeof yt < 'u' && yt !== null && this.write(yt, pt),
        !At.ending && !At.finished && vt(this, At, ht)
    })
  function ft(yt, pt) {
    return pt.ending && pt.length === 0 && !pt.finished && !pt.writing
  }
  function mt(yt, pt) {
    var ht = ft(yt, pt)
    return ht && ((pt.finished = !0), yt.emit('finish')), ht
  }
  function vt(yt, pt, ht) {
    ;(pt.ending = !0),
      mt(yt, pt),
      ht && (pt.finished ? process.nextTick(ht) : yt.once('finish', ht)),
      (pt.ended = !0)
  }
  return _stream_writable$4
}
var _stream_transform$4 = Transform$9,
  Duplex$4 = require_stream_duplex$4(),
  util$o = util$q
util$o.inherits = inherits_browserExports
util$o.inherits(Transform$9, Duplex$4)
function TransformState$3(o, a) {
  ;(this.afterTransform = function(s, $) {
    return afterTransform$4(a, s, $)
  }),
    (this.needTransform = !1),
    (this.transforming = !1),
    (this.writecb = null),
    (this.writechunk = null)
}
function afterTransform$4(o, a, s) {
  var $ = o._transformState
  $.transforming = !1
  var j = $.writecb
  if (!j) return o.emit('error', new Error('no writecb in Transform class'))
  ;($.writechunk = null), ($.writecb = null), s != null && o.push(s), j && j(a)
  var _e = o._readableState
  ;(_e.reading = !1),
    (_e.needReadable || _e.length < _e.highWaterMark) &&
      o._read(_e.highWaterMark)
}
function Transform$9(o) {
  if (!(this instanceof Transform$9)) return new Transform$9(o)
  Duplex$4.call(this, o), (this._transformState = new TransformState$3(o, this))
  var a = this
  ;(this._readableState.needReadable = !0),
    (this._readableState.sync = !1),
    this.once('finish', function() {
      typeof this._flush == 'function'
        ? this._flush(function(s) {
            done$4(a, s)
          })
        : done$4(a)
    })
}
Transform$9.prototype.push = function(o, a) {
  return (
    (this._transformState.needTransform = !1),
    Duplex$4.prototype.push.call(this, o, a)
  )
}
Transform$9.prototype._transform = function(o, a, s) {
  throw new Error('not implemented')
}
Transform$9.prototype._write = function(o, a, s) {
  var $ = this._transformState
  if (
    (($.writecb = s),
    ($.writechunk = o),
    ($.writeencoding = a),
    !$.transforming)
  ) {
    var j = this._readableState
    ;($.needTransform || j.needReadable || j.length < j.highWaterMark) &&
      this._read(j.highWaterMark)
  }
}
Transform$9.prototype._read = function(o) {
  var a = this._transformState
  a.writechunk !== null && a.writecb && !a.transforming
    ? ((a.transforming = !0),
      this._transform(a.writechunk, a.writeencoding, a.afterTransform))
    : (a.needTransform = !0)
}
function done$4(o, a) {
  if (a) return o.emit('error', a)
  var s = o._writableState
  o._readableState
  var $ = o._transformState
  if (s.length) throw new Error('calling transform done when ws.length != 0')
  if ($.transforming)
    throw new Error('calling transform done when still transforming')
  return o.push(null)
}
var _stream_passthrough$4 = PassThrough$4,
  Transform$8 = _stream_transform$4,
  util$n = util$q
util$n.inherits = inherits_browserExports
util$n.inherits(PassThrough$4, Transform$8)
function PassThrough$4(o) {
  if (!(this instanceof PassThrough$4)) return new PassThrough$4(o)
  Transform$8.call(this, o)
}
PassThrough$4.prototype._transform = function(o, a, s) {
  s(null, o)
}
;(function(o, a) {
  var s = {},
    $ = stream$1
  ;(a = o.exports = _stream_readable$4),
    (a.Stream = $),
    (a.Readable = a),
    (a.Writable = require_stream_writable$4()),
    (a.Duplex = require_stream_duplex$4()),
    (a.Transform = _stream_transform$4),
    (a.PassThrough = _stream_passthrough$4),
    !process.browser &&
      s.READABLE_STREAM === 'disable' &&
      (o.exports = stream$1)
})(readable$3, readable$3.exports)
var readableExports$3 = readable$3.exports
const name$1 = 'levelup',
  description = 'Fast & simple storage - a Node.js-style LevelDB wrapper',
  version = '0.18.6',
  contributors = [
    'Rod Vagg <r@va.gg> (https://github.com/rvagg)',
    'John Chesley <john@chesl.es> (https://github.com/chesles/)',
    'Jake Verbaten <raynos2@gmail.com> (https://github.com/raynos)',
    'Dominic Tarr <dominic.tarr@gmail.com> (https://github.com/dominictarr)',
    'Max Ogden <max@maxogden.com> (https://github.com/maxogden)',
    'Lars-Magnus Skog <lars.magnus.skog@gmail.com> (https://github.com/ralphtheninja)',
    'David Bjrklund <david.bjorklund@gmail.com> (https://github.com/kesla)',
    'Julian Gruber <julian@juliangruber.com> (https://github.com/juliangruber)',
    'Paolo Fragomeni <paolo@async.ly> (https://github.com/hij1nx)',
    'Anton Whalley <anton.whalley@nearform.com> (https://github.com/No9)',
    'Matteo Collina <matteo.collina@gmail.com> (https://github.com/mcollina)',
    'Pedro Teixeira <pedro.teixeira@gmail.com> (https://github.com/pgte)',
    'James Halliday <mail@substack.net> (https://github.com/substack)',
  ],
  repository = {
    type: 'git',
    url: 'https://github.com/rvagg/node-levelup.git',
  },
  homepage = 'https://github.com/rvagg/node-levelup',
  keywords = [
    'leveldb',
    'stream',
    'database',
    'db',
    'store',
    'storage',
    'json',
  ],
  main = 'lib/levelup.js',
  dependencies = {
    bl: '~0.8.1',
    'deferred-leveldown': '~0.2.0',
    errno: '~0.1.1',
    prr: '~0.0.0',
    'readable-stream': '~1.0.26',
    semver: '~2.3.1',
    xtend: '~3.0.0',
  },
  devDependencies = {
    leveldown: '~0.10.0',
    bustermove: '*',
    tap: '*',
    referee: '*',
    rimraf: '*',
    async: '*',
    fstream: '*',
    tar: '*',
    mkfiletree: '*',
    readfiletree: '*',
    'slow-stream': '>=0.0.4',
    delayed: '*',
    boganipsum: '*',
    du: '*',
    memdown: '*',
    'msgpack-js': '*',
  },
  browser = { leveldown: !1, 'leveldown/package': !1, semver: !1 },
  scripts = {
    test: 'tap test/*-test.js --stderr',
    functionaltests:
      'node ./test/functional/fstream-test.js && node ./test/functional/binary-data-test.js && node ./test/functional/compat-test.js',
    alltests: 'npm test && npm run-script functionaltests',
  },
  license = 'MIT',
  require$$2 = {
    name: name$1,
    description,
    version,
    contributors,
    repository,
    homepage,
    keywords,
    main,
    dependencies,
    devDependencies,
    browser,
    scripts,
    license,
  }
var extend$a = xtend$b,
  LevelUPError = errors$1.LevelUPError,
  encodingNames = [
    'hex',
    'utf8',
    'utf-8',
    'ascii',
    'binary',
    'base64',
    'ucs2',
    'ucs-2',
    'utf16le',
    'utf-16le',
  ],
  defaultOptions$3 = {
    createIfMissing: !0,
    errorIfExists: !1,
    keyEncoding: 'utf8',
    valueEncoding: 'utf8',
    compression: !0,
  },
  leveldown,
  encodings = (function() {
    function o(s) {
      return s == null || Buffer.isBuffer(s)
    }
    var a = {}
    return (
      (a.utf8 = a['utf-8'] = {
        encode: function(s) {
          return o(s) ? s : String(s)
        },
        decode: function(s) {
          return s
        },
        buffer: !1,
        type: 'utf8',
      }),
      (a.json = {
        encode: JSON.stringify,
        decode: JSON.parse,
        buffer: !1,
        type: 'json',
      }),
      encodingNames.forEach(function(s) {
        a[s] ||
          (a[s] = {
            encode: function($) {
              return o($) ? $ : new Buffer($, s)
            },
            decode: function($) {
              return process.browser ? $.toString(s) : $
            },
            buffer: !0,
            type: s,
          })
      }),
      a
    )
  })(),
  encodingOpts = (function() {
    var o = {}
    return (
      encodingNames.forEach(function(a) {
        o[a] = { valueEncoding: a }
      }),
      o
    )
  })()
function copy$1(o, a, s) {
  o.readStream()
    .pipe(a.writeStream())
    .on('close', s || function() {})
    .on(
      'error',
      s ||
        function($) {
          throw $
        }
    )
}
function getOptions$3(o, a) {
  var s = typeof a == 'string'
  return (
    !s && a && a.encoding && !a.valueEncoding && (a.valueEncoding = a.encoding),
    extend$a(
      (o && o.options) || {},
      s ? encodingOpts[a] || encodingOpts[defaultOptions$3.valueEncoding] : a
    )
  )
}
function getLevelDOWN$1() {
  if (leveldown) return leveldown
  var o = require$$2.devDependencies.leveldown,
    a = 'Could not locate LevelDOWN, try `npm install leveldown`',
    s
  try {
    s = require$$0$3.version
  } catch {
    throw new LevelUPError(a)
  }
  if (!require$$0$3.satisfies(s, o))
    throw new LevelUPError(
      'Installed version of LevelDOWN (' +
        s +
        ') does not match required version (' +
        o +
        ')'
    )
  try {
    return (leveldown = require$$0$3)
  } catch {
    throw new LevelUPError(a)
  }
}
function dispatchError$2(o, a, s) {
  return typeof s == 'function' ? s(a) : o.emit('error', a)
}
function getKeyEncoder(o, a) {
  var s = (a && a.keyEncoding) || o.keyEncoding || 'utf8'
  return encodings[s] || s
}
function getValueEncoder(o, a) {
  var s =
    (a && (a.valueEncoding || a.encoding)) ||
    o.valueEncoding ||
    o.encoding ||
    'utf8'
  return encodings[s] || s
}
function encodeKey(o, a, s) {
  return getKeyEncoder(a, s).encode(o)
}
function encodeValue(o, a, s) {
  return getValueEncoder(a, s).encode(o)
}
function decodeKey(o, a) {
  return getKeyEncoder(a).decode(o)
}
function decodeValue(o, a) {
  return getValueEncoder(a).decode(o)
}
function isValueAsBuffer(o, a) {
  return getValueEncoder(o, a).buffer
}
function isKeyAsBuffer(o, a) {
  return getKeyEncoder(o, a).buffer
}
var util$m = {
    defaultOptions: defaultOptions$3,
    copy: copy$1,
    getOptions: getOptions$3,
    getLevelDOWN: getLevelDOWN$1,
    dispatchError: dispatchError$2,
    encodeKey,
    encodeValue,
    isValueAsBuffer,
    isKeyAsBuffer,
    decodeValue,
    decodeKey,
  },
  Readable$3 = readableExports$3.Readable,
  inherits$6 = util$u.inherits,
  extend$9 = xtend$b,
  EncodingError$1 = errors$1.EncodingError,
  util$l = util$m,
  defaultOptions$2 = { keys: !0, values: !0 },
  makeKeyValueData = function(o, a) {
    return {
      key: util$l.decodeKey(o, this._options),
      value: util$l.decodeValue(a, this._options),
    }
  },
  makeKeyData = function(o) {
    return util$l.decodeKey(o, this._options)
  },
  makeValueData = function(o, a) {
    return util$l.decodeValue(a, this._options)
  },
  makeNoData = function() {
    return null
  }
function ReadStream$1(o, a, s) {
  if (!(this instanceof ReadStream$1)) return new ReadStream$1(o, a, s)
  Readable$3.call(this, { objectMode: !0, highWaterMark: o.highWaterMark }),
    (this._db = a),
    (o = this._options = extend$9(defaultOptions$2, o)),
    (this._keyEncoding = o.keyEncoding || o.encoding),
    (this._valueEncoding = o.valueEncoding || o.encoding),
    typeof this._options.start < 'u' &&
      (this._options.start = util$l.encodeKey(
        this._options.start,
        this._options
      )),
    typeof this._options.end < 'u' &&
      (this._options.end = util$l.encodeKey(this._options.end, this._options)),
    typeof this._options.limit != 'number' && (this._options.limit = -1),
    (this._options.keyAsBuffer = util$l.isKeyAsBuffer(this._options)),
    (this._options.valueAsBuffer = util$l.isValueAsBuffer(this._options)),
    (this._makeData =
      this._options.keys && this._options.values
        ? makeKeyValueData
        : this._options.keys
        ? makeKeyData
        : this._options.values
        ? makeValueData
        : makeNoData)
  var $ = this
  this._db.isOpen()
    ? (this._iterator = s(this._options))
    : this._db.once('ready', function() {
        $._destroyed || ($._iterator = s($._options))
      })
}
inherits$6(ReadStream$1, Readable$3)
ReadStream$1.prototype._read = function o() {
  var a = this
  if (!a._db.isOpen())
    return a._db.once('ready', function() {
      o.call(a)
    })
  a._destroyed ||
    a._iterator.next(function(s, $, j) {
      if (s || ($ === void 0 && j === void 0))
        return !s && !a._destroyed && a.push(null), a._cleanup(s)
      try {
        j = a._makeData($, j)
      } catch (_e) {
        return a._cleanup(new EncodingError$1(_e))
      }
      a._destroyed || a.push(j)
    })
}
ReadStream$1.prototype._cleanup = function(o) {
  if (!this._destroyed) {
    this._destroyed = !0
    var a = this
    o && a.emit('error', o),
      a._iterator
        ? a._iterator.end(function() {
            ;(a._iterator = null), a.emit('close')
          })
        : a.emit('close')
  }
}
ReadStream$1.prototype.destroy = function() {
  this._cleanup()
}
ReadStream$1.prototype.toString = function() {
  return 'LevelUP.ReadStream'
}
var readStream = ReadStream$1,
  readable$2 = { exports: {} },
  isarray$3 =
    Array.isArray ||
    function(o) {
      return Object.prototype.toString.call(o) == '[object Array]'
    },
  string_decoder$2 = {},
  hasRequiredString_decoder$2
function requireString_decoder$2() {
  if (hasRequiredString_decoder$2) return string_decoder$2
  hasRequiredString_decoder$2 = 1
  var o = buffer$1.Buffer,
    a =
      o.isEncoding ||
      function(tt) {
        switch (tt && tt.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return !0
          default:
            return !1
        }
      }
  function s(tt) {
    if (tt && !a(tt)) throw new Error('Unknown encoding: ' + tt)
  }
  var $ = (string_decoder$2.StringDecoder = function(tt) {
    switch (
      ((this.encoding = (tt || 'utf8').toLowerCase().replace(/[-_]/, '')),
      s(tt),
      this.encoding)
    ) {
      case 'utf8':
        this.surrogateSize = 3
        break
      case 'ucs2':
      case 'utf16le':
        ;(this.surrogateSize = 2), (this.detectIncompleteChar = _e)
        break
      case 'base64':
        ;(this.surrogateSize = 3), (this.detectIncompleteChar = et)
        break
      default:
        this.write = j
        return
    }
    ;(this.charBuffer = new o(6)),
      (this.charReceived = 0),
      (this.charLength = 0)
  })
  ;($.prototype.write = function(tt) {
    for (var rt = ''; this.charLength; ) {
      var nt =
        tt.length >= this.charLength - this.charReceived
          ? this.charLength - this.charReceived
          : tt.length
      if (
        (tt.copy(this.charBuffer, this.charReceived, 0, nt),
        (this.charReceived += nt),
        this.charReceived < this.charLength)
      )
        return ''
      ;(tt = tt.slice(nt, tt.length)),
        (rt = this.charBuffer.slice(0, this.charLength).toString(this.encoding))
      var ot = rt.charCodeAt(rt.length - 1)
      if (ot >= 55296 && ot <= 56319) {
        ;(this.charLength += this.surrogateSize), (rt = '')
        continue
      }
      if (((this.charReceived = this.charLength = 0), tt.length === 0))
        return rt
      break
    }
    this.detectIncompleteChar(tt)
    var it = tt.length
    this.charLength &&
      (tt.copy(this.charBuffer, 0, tt.length - this.charReceived, it),
      (it -= this.charReceived)),
      (rt += tt.toString(this.encoding, 0, it))
    var it = rt.length - 1,
      ot = rt.charCodeAt(it)
    if (ot >= 55296 && ot <= 56319) {
      var at = this.surrogateSize
      return (
        (this.charLength += at),
        (this.charReceived += at),
        this.charBuffer.copy(this.charBuffer, at, 0, at),
        tt.copy(this.charBuffer, 0, 0, at),
        rt.substring(0, it)
      )
    }
    return rt
  }),
    ($.prototype.detectIncompleteChar = function(tt) {
      for (var rt = tt.length >= 3 ? 3 : tt.length; rt > 0; rt--) {
        var nt = tt[tt.length - rt]
        if (rt == 1 && nt >> 5 == 6) {
          this.charLength = 2
          break
        }
        if (rt <= 2 && nt >> 4 == 14) {
          this.charLength = 3
          break
        }
        if (rt <= 3 && nt >> 3 == 30) {
          this.charLength = 4
          break
        }
      }
      this.charReceived = rt
    }),
    ($.prototype.end = function(tt) {
      var rt = ''
      if ((tt && tt.length && (rt = this.write(tt)), this.charReceived)) {
        var nt = this.charReceived,
          it = this.charBuffer,
          ot = this.encoding
        rt += it.slice(0, nt).toString(ot)
      }
      return rt
    })
  function j(tt) {
    return tt.toString(this.encoding)
  }
  function _e(tt) {
    ;(this.charReceived = tt.length % 2),
      (this.charLength = this.charReceived ? 2 : 0)
  }
  function et(tt) {
    ;(this.charReceived = tt.length % 3),
      (this.charLength = this.charReceived ? 3 : 0)
  }
  return string_decoder$2
}
var _stream_readable$3 = Readable$2,
  isArray$2 = isarray$3,
  Buffer$2 = buffer$1.Buffer
Readable$2.ReadableState = ReadableState$1
var EE$1 = eventsExports.EventEmitter
EE$1.listenerCount ||
  (EE$1.listenerCount = function(o, a) {
    return o.listeners(a).length
  })
var Stream$5 = stream$1,
  util$k = util$q
util$k.inherits = inherits_browserExports
var StringDecoder$1
util$k.inherits(Readable$2, Stream$5)
function ReadableState$1(o, a) {
  o = o || {}
  var s = o.highWaterMark
  ;(this.highWaterMark = s || s === 0 ? s : 16 * 1024),
    (this.highWaterMark = ~~this.highWaterMark),
    (this.buffer = []),
    (this.length = 0),
    (this.pipes = null),
    (this.pipesCount = 0),
    (this.flowing = !1),
    (this.ended = !1),
    (this.endEmitted = !1),
    (this.reading = !1),
    (this.calledRead = !1),
    (this.sync = !0),
    (this.needReadable = !1),
    (this.emittedReadable = !1),
    (this.readableListening = !1),
    (this.objectMode = !!o.objectMode),
    (this.defaultEncoding = o.defaultEncoding || 'utf8'),
    (this.ranOut = !1),
    (this.awaitDrain = 0),
    (this.readingMore = !1),
    (this.decoder = null),
    (this.encoding = null),
    o.encoding &&
      (StringDecoder$1 ||
        (StringDecoder$1 = requireString_decoder$2().StringDecoder),
      (this.decoder = new StringDecoder$1(o.encoding)),
      (this.encoding = o.encoding))
}
function Readable$2(o) {
  if (!(this instanceof Readable$2)) return new Readable$2(o)
  ;(this._readableState = new ReadableState$1(o)),
    (this.readable = !0),
    Stream$5.call(this)
}
Readable$2.prototype.push = function(o, a) {
  var s = this._readableState
  return (
    typeof o == 'string' &&
      !s.objectMode &&
      ((a = a || s.defaultEncoding),
      a !== s.encoding && ((o = new Buffer$2(o, a)), (a = ''))),
    readableAddChunk$1(this, s, o, a, !1)
  )
}
Readable$2.prototype.unshift = function(o) {
  var a = this._readableState
  return readableAddChunk$1(this, a, o, '', !0)
}
function readableAddChunk$1(o, a, s, $, j) {
  var _e = chunkInvalid$1(a, s)
  if (_e) o.emit('error', _e)
  else if (s == null) (a.reading = !1), a.ended || onEofChunk$1(o, a)
  else if (a.objectMode || (s && s.length > 0))
    if (a.ended && !j) {
      var et = new Error('stream.push() after EOF')
      o.emit('error', et)
    } else if (a.endEmitted && j) {
      var et = new Error('stream.unshift() after end event')
      o.emit('error', et)
    } else
      a.decoder && !j && !$ && (s = a.decoder.write(s)),
        (a.length += a.objectMode ? 1 : s.length),
        j ? a.buffer.unshift(s) : ((a.reading = !1), a.buffer.push(s)),
        a.needReadable && emitReadable$1(o),
        maybeReadMore$1(o, a)
  else j || (a.reading = !1)
  return needMoreData$1(a)
}
function needMoreData$1(o) {
  return (
    !o.ended && (o.needReadable || o.length < o.highWaterMark || o.length === 0)
  )
}
Readable$2.prototype.setEncoding = function(o) {
  StringDecoder$1 ||
    (StringDecoder$1 = requireString_decoder$2().StringDecoder),
    (this._readableState.decoder = new StringDecoder$1(o)),
    (this._readableState.encoding = o)
}
var MAX_HWM$1 = 8388608
function roundUpToNextPowerOf2$1(o) {
  if (o >= MAX_HWM$1) o = MAX_HWM$1
  else {
    o--
    for (var a = 1; a < 32; a <<= 1) o |= o >> a
    o++
  }
  return o
}
function howMuchToRead$1(o, a) {
  return a.length === 0 && a.ended
    ? 0
    : a.objectMode
    ? o === 0
      ? 0
      : 1
    : o === null || isNaN(o)
    ? a.flowing && a.buffer.length
      ? a.buffer[0].length
      : a.length
    : o <= 0
    ? 0
    : (o > a.highWaterMark && (a.highWaterMark = roundUpToNextPowerOf2$1(o)),
      o > a.length ? (a.ended ? a.length : ((a.needReadable = !0), 0)) : o)
}
Readable$2.prototype.read = function(o) {
  var a = this._readableState
  a.calledRead = !0
  var s = o,
    $
  if (
    ((typeof o != 'number' || o > 0) && (a.emittedReadable = !1),
    o === 0 && a.needReadable && (a.length >= a.highWaterMark || a.ended))
  )
    return emitReadable$1(this), null
  if (((o = howMuchToRead$1(o, a)), o === 0 && a.ended))
    return (
      ($ = null),
      a.length > 0 &&
        a.decoder &&
        (($ = fromList$1(o, a)), (a.length -= $.length)),
      a.length === 0 && endReadable$1(this),
      $
    )
  var j = a.needReadable
  return (
    a.length - o <= a.highWaterMark && (j = !0),
    (a.ended || a.reading) && (j = !1),
    j &&
      ((a.reading = !0),
      (a.sync = !0),
      a.length === 0 && (a.needReadable = !0),
      this._read(a.highWaterMark),
      (a.sync = !1)),
    j && !a.reading && (o = howMuchToRead$1(s, a)),
    o > 0 ? ($ = fromList$1(o, a)) : ($ = null),
    $ === null && ((a.needReadable = !0), (o = 0)),
    (a.length -= o),
    a.length === 0 && !a.ended && (a.needReadable = !0),
    a.ended && !a.endEmitted && a.length === 0 && endReadable$1(this),
    $
  )
}
function chunkInvalid$1(o, a) {
  var s = null
  return (
    !Buffer$2.isBuffer(a) &&
      typeof a != 'string' &&
      a !== null &&
      a !== void 0 &&
      !o.objectMode &&
      (s = new TypeError('Invalid non-string/buffer chunk')),
    s
  )
}
function onEofChunk$1(o, a) {
  if (a.decoder && !a.ended) {
    var s = a.decoder.end()
    s &&
      s.length &&
      (a.buffer.push(s), (a.length += a.objectMode ? 1 : s.length))
  }
  ;(a.ended = !0), a.length > 0 ? emitReadable$1(o) : endReadable$1(o)
}
function emitReadable$1(o) {
  var a = o._readableState
  ;(a.needReadable = !1),
    !a.emittedReadable &&
      ((a.emittedReadable = !0),
      a.sync
        ? process.nextTick(function() {
            emitReadable_$1(o)
          })
        : emitReadable_$1(o))
}
function emitReadable_$1(o) {
  o.emit('readable')
}
function maybeReadMore$1(o, a) {
  a.readingMore ||
    ((a.readingMore = !0),
    process.nextTick(function() {
      maybeReadMore_$1(o, a)
    }))
}
function maybeReadMore_$1(o, a) {
  for (
    var s = a.length;
    !a.reading &&
    !a.flowing &&
    !a.ended &&
    a.length < a.highWaterMark &&
    (o.read(0), s !== a.length);

  )
    s = a.length
  a.readingMore = !1
}
Readable$2.prototype._read = function(o) {
  this.emit('error', new Error('not implemented'))
}
Readable$2.prototype.pipe = function(o, a) {
  var s = this,
    $ = this._readableState
  switch ($.pipesCount) {
    case 0:
      $.pipes = o
      break
    case 1:
      $.pipes = [$.pipes, o]
      break
    default:
      $.pipes.push(o)
      break
  }
  $.pipesCount += 1
  var j = (!a || a.end !== !1) && o !== process.stdout && o !== process.stderr,
    _e = j ? tt : nt
  $.endEmitted ? process.nextTick(_e) : s.once('end', _e), o.on('unpipe', et)
  function et(ut) {
    ut === s && nt()
  }
  function tt() {
    o.end()
  }
  var rt = pipeOnDrain$1(s)
  o.on('drain', rt)
  function nt() {
    o.removeListener('close', ot),
      o.removeListener('finish', at),
      o.removeListener('drain', rt),
      o.removeListener('error', it),
      o.removeListener('unpipe', et),
      s.removeListener('end', tt),
      s.removeListener('end', nt),
      (!o._writableState || o._writableState.needDrain) && rt()
  }
  function it(ut) {
    st(),
      o.removeListener('error', it),
      EE$1.listenerCount(o, 'error') === 0 && o.emit('error', ut)
  }
  !o._events || !o._events.error
    ? o.on('error', it)
    : isArray$2(o._events.error)
    ? o._events.error.unshift(it)
    : (o._events.error = [it, o._events.error])
  function ot() {
    o.removeListener('finish', at), st()
  }
  o.once('close', ot)
  function at() {
    o.removeListener('close', ot), st()
  }
  o.once('finish', at)
  function st() {
    s.unpipe(o)
  }
  return (
    o.emit('pipe', s),
    $.flowing ||
      (this.on('readable', pipeOnReadable$1),
      ($.flowing = !0),
      process.nextTick(function() {
        flow$1(s)
      })),
    o
  )
}
function pipeOnDrain$1(o) {
  return function() {
    var a = o._readableState
    a.awaitDrain--, a.awaitDrain === 0 && flow$1(o)
  }
}
function flow$1(o) {
  var a = o._readableState,
    s
  a.awaitDrain = 0
  function $(j, _e, et) {
    var tt = j.write(s)
    tt === !1 && a.awaitDrain++
  }
  for (; a.pipesCount && (s = o.read()) !== null; )
    if (
      (a.pipesCount === 1 ? $(a.pipes) : forEach$1(a.pipes, $),
      o.emit('data', s),
      a.awaitDrain > 0)
    )
      return
  if (a.pipesCount === 0) {
    ;(a.flowing = !1), EE$1.listenerCount(o, 'data') > 0 && emitDataEvents$1(o)
    return
  }
  a.ranOut = !0
}
function pipeOnReadable$1() {
  this._readableState.ranOut &&
    ((this._readableState.ranOut = !1), flow$1(this))
}
Readable$2.prototype.unpipe = function(o) {
  var a = this._readableState
  if (a.pipesCount === 0) return this
  if (a.pipesCount === 1)
    return o && o !== a.pipes
      ? this
      : (o || (o = a.pipes),
        (a.pipes = null),
        (a.pipesCount = 0),
        this.removeListener('readable', pipeOnReadable$1),
        (a.flowing = !1),
        o && o.emit('unpipe', this),
        this)
  if (!o) {
    var s = a.pipes,
      $ = a.pipesCount
    ;(a.pipes = null),
      (a.pipesCount = 0),
      this.removeListener('readable', pipeOnReadable$1),
      (a.flowing = !1)
    for (var j = 0; j < $; j++) s[j].emit('unpipe', this)
    return this
  }
  var j = indexOf$1(a.pipes, o)
  return j === -1
    ? this
    : (a.pipes.splice(j, 1),
      (a.pipesCount -= 1),
      a.pipesCount === 1 && (a.pipes = a.pipes[0]),
      o.emit('unpipe', this),
      this)
}
Readable$2.prototype.on = function(o, a) {
  var s = Stream$5.prototype.on.call(this, o, a)
  if (
    (o === 'data' && !this._readableState.flowing && emitDataEvents$1(this),
    o === 'readable' && this.readable)
  ) {
    var $ = this._readableState
    $.readableListening ||
      (($.readableListening = !0),
      ($.emittedReadable = !1),
      ($.needReadable = !0),
      $.reading ? $.length && emitReadable$1(this) : this.read(0))
  }
  return s
}
Readable$2.prototype.addListener = Readable$2.prototype.on
Readable$2.prototype.resume = function() {
  emitDataEvents$1(this), this.read(0), this.emit('resume')
}
Readable$2.prototype.pause = function() {
  emitDataEvents$1(this, !0), this.emit('pause')
}
function emitDataEvents$1(o, a) {
  var s = o._readableState
  if (s.flowing) throw new Error('Cannot switch to old mode now.')
  var $ = a || !1,
    j = !1
  ;(o.readable = !0),
    (o.pipe = Stream$5.prototype.pipe),
    (o.on = o.addListener = Stream$5.prototype.on),
    o.on('readable', function() {
      j = !0
      for (var _e; !$ && (_e = o.read()) !== null; ) o.emit('data', _e)
      _e === null && ((j = !1), (o._readableState.needReadable = !0))
    }),
    (o.pause = function() {
      ;($ = !0), this.emit('pause')
    }),
    (o.resume = function() {
      ;($ = !1),
        j
          ? process.nextTick(function() {
              o.emit('readable')
            })
          : this.read(0),
        this.emit('resume')
    }),
    o.emit('readable')
}
Readable$2.prototype.wrap = function(o) {
  var a = this._readableState,
    s = !1,
    $ = this
  o.on('end', function() {
    if (a.decoder && !a.ended) {
      var et = a.decoder.end()
      et && et.length && $.push(et)
    }
    $.push(null)
  }),
    o.on('data', function(et) {
      if (
        (a.decoder && (et = a.decoder.write(et)),
        !(a.objectMode && et == null) &&
          !(!a.objectMode && (!et || !et.length)))
      ) {
        var tt = $.push(et)
        tt || ((s = !0), o.pause())
      }
    })
  for (var j in o)
    typeof o[j] == 'function' &&
      typeof this[j] > 'u' &&
      (this[j] = (function(et) {
        return function() {
          return o[et].apply(o, arguments)
        }
      })(j))
  var _e = ['error', 'close', 'destroy', 'pause', 'resume']
  return (
    forEach$1(_e, function(et) {
      o.on(et, $.emit.bind($, et))
    }),
    ($._read = function(et) {
      s && ((s = !1), o.resume())
    }),
    $
  )
}
Readable$2._fromList = fromList$1
function fromList$1(o, a) {
  var s = a.buffer,
    $ = a.length,
    j = !!a.decoder,
    _e = !!a.objectMode,
    et
  if (s.length === 0) return null
  if ($ === 0) et = null
  else if (_e) et = s.shift()
  else if (!o || o >= $)
    j ? (et = s.join('')) : (et = Buffer$2.concat(s, $)), (s.length = 0)
  else if (o < s[0].length) {
    var tt = s[0]
    ;(et = tt.slice(0, o)), (s[0] = tt.slice(o))
  } else if (o === s[0].length) et = s.shift()
  else {
    j ? (et = '') : (et = new Buffer$2(o))
    for (var rt = 0, nt = 0, it = s.length; nt < it && rt < o; nt++) {
      var tt = s[0],
        ot = Math.min(o - rt, tt.length)
      j ? (et += tt.slice(0, ot)) : tt.copy(et, rt, 0, ot),
        ot < tt.length ? (s[0] = tt.slice(ot)) : s.shift(),
        (rt += ot)
    }
  }
  return et
}
function endReadable$1(o) {
  var a = o._readableState
  if (a.length > 0) throw new Error('endReadable called on non-empty stream')
  !a.endEmitted &&
    a.calledRead &&
    ((a.ended = !0),
    process.nextTick(function() {
      !a.endEmitted &&
        a.length === 0 &&
        ((a.endEmitted = !0), (o.readable = !1), o.emit('end'))
    }))
}
function forEach$1(o, a) {
  for (var s = 0, $ = o.length; s < $; s++) a(o[s], s)
}
function indexOf$1(o, a) {
  for (var s = 0, $ = o.length; s < $; s++) if (o[s] === a) return s
  return -1
}
var _stream_duplex$3, hasRequired_stream_duplex$3
function require_stream_duplex$3() {
  if (hasRequired_stream_duplex$3) return _stream_duplex$3
  ;(hasRequired_stream_duplex$3 = 1), (_stream_duplex$3 = j)
  var o =
      Object.keys ||
      function(tt) {
        var rt = []
        for (var nt in tt) rt.push(nt)
        return rt
      },
    a = util$q
  a.inherits = inherits_browserExports
  var s = _stream_readable$3,
    $ = require_stream_writable$3()
  a.inherits(j, s),
    et(o($.prototype), function(tt) {
      j.prototype[tt] || (j.prototype[tt] = $.prototype[tt])
    })
  function j(tt) {
    if (!(this instanceof j)) return new j(tt)
    s.call(this, tt),
      $.call(this, tt),
      tt && tt.readable === !1 && (this.readable = !1),
      tt && tt.writable === !1 && (this.writable = !1),
      (this.allowHalfOpen = !0),
      tt && tt.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
      this.once('end', _e)
  }
  function _e() {
    this.allowHalfOpen ||
      this._writableState.ended ||
      process.nextTick(this.end.bind(this))
  }
  function et(tt, rt) {
    for (var nt = 0, it = tt.length; nt < it; nt++) rt(tt[nt], nt)
  }
  return _stream_duplex$3
}
var _stream_writable$3, hasRequired_stream_writable$3
function require_stream_writable$3() {
  if (hasRequired_stream_writable$3) return _stream_writable$3
  ;(hasRequired_stream_writable$3 = 1), (_stream_writable$3 = _e)
  var o = buffer$1.Buffer
  _e.WritableState = j
  var a = util$q
  a.inherits = inherits_browserExports
  var s = stream$1
  a.inherits(_e, s)
  function $(yt, pt, ht) {
    ;(this.chunk = yt), (this.encoding = pt), (this.callback = ht)
  }
  function j(yt, pt) {
    yt = yt || {}
    var ht = yt.highWaterMark
    ;(this.highWaterMark = ht || ht === 0 ? ht : 16 * 1024),
      (this.objectMode = !!yt.objectMode),
      (this.highWaterMark = ~~this.highWaterMark),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1)
    var At = yt.decodeStrings === !1
    ;(this.decodeStrings = !At),
      (this.defaultEncoding = yt.defaultEncoding || 'utf8'),
      (this.length = 0),
      (this.writing = !1),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function(wt) {
        st(pt, wt)
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.buffer = []),
      (this.errorEmitted = !1)
  }
  function _e(yt) {
    var pt = require_stream_duplex$3()
    if (!(this instanceof _e) && !(this instanceof pt)) return new _e(yt)
    ;(this._writableState = new j(yt, this)), (this.writable = !0), s.call(this)
  }
  _e.prototype.pipe = function() {
    this.emit('error', new Error('Cannot pipe. Not readable.'))
  }
  function et(yt, pt, ht) {
    var At = new Error('write after end')
    yt.emit('error', At),
      process.nextTick(function() {
        ht(At)
      })
  }
  function tt(yt, pt, ht, At) {
    var wt = !0
    if (
      !o.isBuffer(ht) &&
      typeof ht != 'string' &&
      ht !== null &&
      ht !== void 0 &&
      !pt.objectMode
    ) {
      var Ct = new TypeError('Invalid non-string/buffer chunk')
      yt.emit('error', Ct),
        process.nextTick(function() {
          At(Ct)
        }),
        (wt = !1)
    }
    return wt
  }
  _e.prototype.write = function(yt, pt, ht) {
    var At = this._writableState,
      wt = !1
    return (
      typeof pt == 'function' && ((ht = pt), (pt = null)),
      o.isBuffer(yt) ? (pt = 'buffer') : pt || (pt = At.defaultEncoding),
      typeof ht != 'function' && (ht = function() {}),
      At.ended
        ? et(this, At, ht)
        : tt(this, At, yt, ht) && (wt = nt(this, At, yt, pt, ht)),
      wt
    )
  }
  function rt(yt, pt, ht) {
    return (
      !yt.objectMode &&
        yt.decodeStrings !== !1 &&
        typeof pt == 'string' &&
        (pt = new o(pt, ht)),
      pt
    )
  }
  function nt(yt, pt, ht, At, wt) {
    ;(ht = rt(pt, ht, At)), o.isBuffer(ht) && (At = 'buffer')
    var Ct = pt.objectMode ? 1 : ht.length
    pt.length += Ct
    var Dt = pt.length < pt.highWaterMark
    return (
      Dt || (pt.needDrain = !0),
      pt.writing
        ? pt.buffer.push(new $(ht, At, wt))
        : it(yt, pt, Ct, ht, At, wt),
      Dt
    )
  }
  function it(yt, pt, ht, At, wt, Ct) {
    ;(pt.writelen = ht),
      (pt.writecb = Ct),
      (pt.writing = !0),
      (pt.sync = !0),
      yt._write(At, wt, pt.onwrite),
      (pt.sync = !1)
  }
  function ot(yt, pt, ht, At, wt) {
    ht
      ? process.nextTick(function() {
          wt(At)
        })
      : wt(At),
      (yt._writableState.errorEmitted = !0),
      yt.emit('error', At)
  }
  function at(yt) {
    ;(yt.writing = !1),
      (yt.writecb = null),
      (yt.length -= yt.writelen),
      (yt.writelen = 0)
  }
  function st(yt, pt) {
    var ht = yt._writableState,
      At = ht.sync,
      wt = ht.writecb
    if ((at(ht), pt)) ot(yt, ht, At, pt, wt)
    else {
      var Ct = ft(yt, ht)
      !Ct && !ht.bufferProcessing && ht.buffer.length && dt(yt, ht),
        At
          ? process.nextTick(function() {
              ut(yt, ht, Ct, wt)
            })
          : ut(yt, ht, Ct, wt)
    }
  }
  function ut(yt, pt, ht, At) {
    ht || ct(yt, pt), At(), ht && mt(yt, pt)
  }
  function ct(yt, pt) {
    pt.length === 0 && pt.needDrain && ((pt.needDrain = !1), yt.emit('drain'))
  }
  function dt(yt, pt) {
    pt.bufferProcessing = !0
    for (var ht = 0; ht < pt.buffer.length; ht++) {
      var At = pt.buffer[ht],
        wt = At.chunk,
        Ct = At.encoding,
        Dt = At.callback,
        jt = pt.objectMode ? 1 : wt.length
      if ((it(yt, pt, jt, wt, Ct, Dt), pt.writing)) {
        ht++
        break
      }
    }
    ;(pt.bufferProcessing = !1),
      ht < pt.buffer.length
        ? (pt.buffer = pt.buffer.slice(ht))
        : (pt.buffer.length = 0)
  }
  ;(_e.prototype._write = function(yt, pt, ht) {
    ht(new Error('not implemented'))
  }),
    (_e.prototype.end = function(yt, pt, ht) {
      var At = this._writableState
      typeof yt == 'function'
        ? ((ht = yt), (yt = null), (pt = null))
        : typeof pt == 'function' && ((ht = pt), (pt = null)),
        typeof yt < 'u' && yt !== null && this.write(yt, pt),
        !At.ending && !At.finished && vt(this, At, ht)
    })
  function ft(yt, pt) {
    return pt.ending && pt.length === 0 && !pt.finished && !pt.writing
  }
  function mt(yt, pt) {
    var ht = ft(yt, pt)
    return ht && ((pt.finished = !0), yt.emit('finish')), ht
  }
  function vt(yt, pt, ht) {
    ;(pt.ending = !0),
      mt(yt, pt),
      ht && (pt.finished ? process.nextTick(ht) : yt.once('finish', ht)),
      (pt.ended = !0)
  }
  return _stream_writable$3
}
var _stream_transform$3 = Transform$7,
  Duplex$3 = require_stream_duplex$3(),
  util$j = util$q
util$j.inherits = inherits_browserExports
util$j.inherits(Transform$7, Duplex$3)
function TransformState$2(o, a) {
  ;(this.afterTransform = function(s, $) {
    return afterTransform$3(a, s, $)
  }),
    (this.needTransform = !1),
    (this.transforming = !1),
    (this.writecb = null),
    (this.writechunk = null)
}
function afterTransform$3(o, a, s) {
  var $ = o._transformState
  $.transforming = !1
  var j = $.writecb
  if (!j) return o.emit('error', new Error('no writecb in Transform class'))
  ;($.writechunk = null), ($.writecb = null), s != null && o.push(s), j && j(a)
  var _e = o._readableState
  ;(_e.reading = !1),
    (_e.needReadable || _e.length < _e.highWaterMark) &&
      o._read(_e.highWaterMark)
}
function Transform$7(o) {
  if (!(this instanceof Transform$7)) return new Transform$7(o)
  Duplex$3.call(this, o), (this._transformState = new TransformState$2(o, this))
  var a = this
  ;(this._readableState.needReadable = !0),
    (this._readableState.sync = !1),
    this.once('finish', function() {
      typeof this._flush == 'function'
        ? this._flush(function(s) {
            done$3(a, s)
          })
        : done$3(a)
    })
}
Transform$7.prototype.push = function(o, a) {
  return (
    (this._transformState.needTransform = !1),
    Duplex$3.prototype.push.call(this, o, a)
  )
}
Transform$7.prototype._transform = function(o, a, s) {
  throw new Error('not implemented')
}
Transform$7.prototype._write = function(o, a, s) {
  var $ = this._transformState
  if (
    (($.writecb = s),
    ($.writechunk = o),
    ($.writeencoding = a),
    !$.transforming)
  ) {
    var j = this._readableState
    ;($.needTransform || j.needReadable || j.length < j.highWaterMark) &&
      this._read(j.highWaterMark)
  }
}
Transform$7.prototype._read = function(o) {
  var a = this._transformState
  a.writechunk !== null && a.writecb && !a.transforming
    ? ((a.transforming = !0),
      this._transform(a.writechunk, a.writeencoding, a.afterTransform))
    : (a.needTransform = !0)
}
function done$3(o, a) {
  if (a) return o.emit('error', a)
  var s = o._writableState
  o._readableState
  var $ = o._transformState
  if (s.length) throw new Error('calling transform done when ws.length != 0')
  if ($.transforming)
    throw new Error('calling transform done when still transforming')
  return o.push(null)
}
var _stream_passthrough$3 = PassThrough$3,
  Transform$6 = _stream_transform$3,
  util$i = util$q
util$i.inherits = inherits_browserExports
util$i.inherits(PassThrough$3, Transform$6)
function PassThrough$3(o) {
  if (!(this instanceof PassThrough$3)) return new PassThrough$3(o)
  Transform$6.call(this, o)
}
PassThrough$3.prototype._transform = function(o, a, s) {
  s(null, o)
}
;(function(o, a) {
  var s = {},
    $ = stream$1
  ;(a = o.exports = _stream_readable$3),
    (a.Stream = $),
    (a.Readable = a),
    (a.Writable = require_stream_writable$3()),
    (a.Duplex = require_stream_duplex$3()),
    (a.Transform = _stream_transform$3),
    (a.PassThrough = _stream_passthrough$3),
    !process.browser &&
      s.READABLE_STREAM === 'disable' &&
      (o.exports = stream$1)
})(readable$2, readable$2.exports)
var readableExports$2 = readable$2.exports,
  DuplexStream = readableExports$2.Duplex,
  util$h = util$u
function BufferList$1(o) {
  if (!(this instanceof BufferList$1)) return new BufferList$1(o)
  if (((this._bufs = []), (this.length = 0), typeof o == 'function')) {
    this._callback = o
    var a = function(s) {
      this._callback && (this._callback(s), (this._callback = null))
    }.bind(this)
    this.on('pipe', function(s) {
      s.on('error', a)
    }),
      this.on('unpipe', function(s) {
        s.removeListener('error', a)
      })
  } else
    Buffer.isBuffer(o)
      ? this.append(o)
      : Array.isArray(o) &&
        o.forEach(
          function(s) {
            Buffer.isBuffer(s) && this.append(s)
          }.bind(this)
        )
  DuplexStream.call(this)
}
util$h.inherits(BufferList$1, DuplexStream)
BufferList$1.prototype._offset = function(o) {
  for (var a = 0, s = 0, $; s < this._bufs.length; s++) {
    if ((($ = a + this._bufs[s].length), o < $)) return [s, o - a]
    a = $
  }
}
BufferList$1.prototype.append = function(o) {
  return (
    this._bufs.push(Buffer.isBuffer(o) ? o : new Buffer(o)),
    (this.length += o.length),
    this
  )
}
BufferList$1.prototype._write = function(o, a, s) {
  this.append(o), s && s()
}
BufferList$1.prototype._read = function(o) {
  if (!this.length) return this.push(null)
  ;(o = Math.min(o, this.length)), this.push(this.slice(0, o)), this.consume(o)
}
BufferList$1.prototype.end = function(o) {
  DuplexStream.prototype.end.call(this, o),
    this._callback &&
      (this._callback(null, this.slice()), (this._callback = null))
}
BufferList$1.prototype.get = function(o) {
  return this.slice(o, o + 1)[0]
}
BufferList$1.prototype.slice = function(o, a) {
  return this.copy(null, 0, o, a)
}
BufferList$1.prototype.copy = function(o, a, s, $) {
  if (
    ((typeof s != 'number' || s < 0) && (s = 0),
    (typeof $ != 'number' || $ > this.length) && ($ = this.length),
    s >= this.length)
  )
    return o || new Buffer(0)
  if ($ <= 0) return o || new Buffer(0)
  var j = !!o,
    _e = this._offset(s),
    et = $ - s,
    tt = et,
    rt = (j && a) || 0,
    nt = _e[1],
    it,
    ot
  if (s === 0 && $ == this.length) {
    if (!j) return Buffer.concat(this._bufs)
    for (ot = 0; ot < this._bufs.length; ot++)
      this._bufs[ot].copy(o, rt), (rt += this._bufs[ot].length)
    return o
  }
  if (tt <= this._bufs[_e[0]].length - nt)
    return j
      ? this._bufs[_e[0]].copy(o, a, nt, nt + tt)
      : this._bufs[_e[0]].slice(nt, nt + tt)
  for (j || (o = new Buffer(et)), ot = _e[0]; ot < this._bufs.length; ot++) {
    if (((it = this._bufs[ot].length - nt), tt > it))
      this._bufs[ot].copy(o, rt, nt)
    else {
      this._bufs[ot].copy(o, rt, nt, nt + tt)
      break
    }
    ;(rt += it), (tt -= it), nt && (nt = 0)
  }
  return o
}
BufferList$1.prototype.toString = function(o, a, s) {
  return this.slice(a, s).toString(o)
}
BufferList$1.prototype.consume = function(o) {
  for (; this._bufs.length; )
    if (o > this._bufs[0].length)
      (o -= this._bufs[0].length),
        (this.length -= this._bufs[0].length),
        this._bufs.shift()
    else {
      ;(this._bufs[0] = this._bufs[0].slice(o)), (this.length -= o)
      break
    }
  return this
}
BufferList$1.prototype.duplicate = function() {
  for (var o = 0, a = new BufferList$1(); o < this._bufs.length; o++)
    a.append(this._bufs[o])
  return a
}
BufferList$1.prototype.destroy = function() {
  ;(this._bufs.length = 0), (this.length = 0), this.push(null)
}
;(function() {
  var o = {
    readDoubleBE: 8,
    readDoubleLE: 8,
    readFloatBE: 4,
    readFloatLE: 4,
    readInt32BE: 4,
    readInt32LE: 4,
    readUInt32BE: 4,
    readUInt32LE: 4,
    readInt16BE: 2,
    readInt16LE: 2,
    readUInt16BE: 2,
    readUInt16LE: 2,
    readInt8: 1,
    readUInt8: 1,
  }
  for (var a in o)
    (function(s) {
      BufferList$1.prototype[s] = function($) {
        return this.slice($, $ + o[s])[s](0)
      }
    })(a)
})()
var bl$1 = BufferList$1,
  define_global_default$3 = {},
  Stream$4 = stream$1.Stream,
  inherits$5 = util$u.inherits,
  extend$8 = xtend$b,
  bl = bl$1,
  setImmediate$1 = define_global_default$3.setImmediate || process.nextTick,
  getOptions$2 = util$m.getOptions,
  defaultOptions$1 = { type: 'put' }
function WriteStream$1(o, a) {
  if (!(this instanceof WriteStream$1)) return new WriteStream$1(o, a)
  Stream$4.call(this),
    (this._options = extend$8(defaultOptions$1, getOptions$2(a, o))),
    (this._db = a),
    (this._buffer = []),
    (this._status = 'init'),
    (this._end = !1),
    (this.writable = !0),
    (this.readable = !1)
  var s = this,
    $ = function() {
      s.writable && ((s._status = 'ready'), s.emit('ready'), s._process())
    }
  a.isOpen() ? setImmediate$1($) : a.once('ready', $)
}
inherits$5(WriteStream$1, Stream$4)
WriteStream$1.prototype.write = function(o) {
  return this.writable
    ? (this._buffer.push(o),
      this._status != 'init' && this._processDelayed(),
      this._options.maxBufferLength &&
      this._buffer.length > this._options.maxBufferLength
        ? ((this._writeBlock = !0), !1)
        : !0)
    : !1
}
WriteStream$1.prototype.end = function(o) {
  var a = this
  o && this.write(o),
    setImmediate$1(function() {
      ;(a._end = !0), a._process()
    })
}
WriteStream$1.prototype.destroy = function() {
  ;(this.writable = !1), this.end()
}
WriteStream$1.prototype.destroySoon = function() {
  this.end()
}
WriteStream$1.prototype.add = function(o) {
  if (o.props)
    return (
      o.props.Directory
        ? o.pipe(this._db.writeStream(this._options))
        : (o.props.File || o.File || o.type == 'File') && this._write(o),
      !0
    )
}
WriteStream$1.prototype._processDelayed = function() {
  var o = this
  setImmediate$1(function() {
    o._process()
  })
}
WriteStream$1.prototype._process = function() {
  var o,
    a = this,
    s = function($) {
      if (a.writable) {
        if ((a._status != 'closed' && (a._status = 'ready'), $))
          return (a.writable = !1), a.emit('error', $)
        a._process()
      }
    }
  if (a._status != 'ready' && a.writable) {
    a._buffer.length && a._status != 'closed' && a._processDelayed()
    return
  }
  if (a._buffer.length && a.writable) {
    ;(a._status = 'writing'),
      (o = a._buffer),
      (a._buffer = []),
      a._db.batch(
        o.map(function($) {
          return {
            type: $.type || a._options.type,
            key: $.key,
            value: $.value,
            keyEncoding: $.keyEncoding || a._options.keyEncoding,
            valueEncoding:
              $.valueEncoding || $.encoding || a._options.valueEncoding,
          }
        }),
        s
      ),
      a._writeBlock && ((a._writeBlock = !1), a.emit('drain'))
    return
  }
  a._end &&
    a._status != 'closed' &&
    ((a._status = 'closed'), (a.writable = !1), a.emit('close'))
}
WriteStream$1.prototype._write = function(o) {
  var a = o.path || o.props.path,
    s = this
  a &&
    o.pipe(
      bl(function($, j) {
        if ($) return (s.writable = !1), s.emit('error', $)
        s._options.fstreamRoot &&
          a.indexOf(s._options.fstreamRoot) > -1 &&
          (a = a.substr(s._options.fstreamRoot.length + 1)),
          s.write({ key: a, value: j.slice(0) })
      })
    )
}
WriteStream$1.prototype.toString = function() {
  return 'LevelUP.WriteStream'
}
var writeStream = WriteStream$1,
  util$g = util$m,
  WriteError$1 = errors$1.WriteError,
  getOptions$1 = util$g.getOptions,
  dispatchError$1 = util$g.dispatchError
function Batch$4(o) {
  ;(this._levelup = o), (this.batch = o.db.batch()), (this.ops = [])
}
Batch$4.prototype.put = function(o, a, s) {
  s = getOptions$1(this._levelup, s)
  var $ = util$g.encodeKey(o, s),
    j = util$g.encodeValue(a, s)
  try {
    this.batch.put($, j)
  } catch (_e) {
    throw new WriteError$1(_e)
  }
  return this.ops.push({ type: 'put', key: $, value: j }), this
}
Batch$4.prototype.del = function(o, a) {
  a = getOptions$1(this._levelup, a)
  var s = util$g.encodeKey(o, a)
  try {
    this.batch.del(s)
  } catch ($) {
    throw new WriteError$1($)
  }
  return this.ops.push({ type: 'del', key: s }), this
}
Batch$4.prototype.clear = function() {
  try {
    this.batch.clear()
  } catch (o) {
    throw new WriteError$1(o)
  }
  return (this.ops = []), this
}
Batch$4.prototype.write = function(o) {
  var a = this._levelup,
    s = this.ops
  try {
    this.batch.write(function($) {
      if ($) return dispatchError$1(a, new WriteError$1($), o)
      a.emit('batch', s), o && o()
    })
  } catch ($) {
    throw new WriteError$1($)
  }
}
var batch$1 = Batch$4,
  EventEmitter$1 = eventsExports.EventEmitter,
  inherits$4 = util$u.inherits,
  extend$7 = xtend$b,
  prr = prrExports$1,
  DeferredLevelDOWN = deferredLeveldown,
  WriteError = errors$1.WriteError,
  ReadError = errors$1.ReadError,
  NotFoundError = errors$1.NotFoundError,
  OpenError = errors$1.OpenError,
  EncodingError = errors$1.EncodingError,
  InitializationError = errors$1.InitializationError,
  ReadStream = readStream,
  WriteStream = writeStream,
  util$f = util$m,
  Batch$3 = batch$1,
  getOptions = util$f.getOptions,
  defaultOptions = util$f.defaultOptions,
  getLevelDOWN = util$f.getLevelDOWN,
  dispatchError = util$f.dispatchError
function getCallback(o, a) {
  return typeof o == 'function' ? o : a
}
function LevelUP(o, a, s) {
  if (!(this instanceof LevelUP)) return new LevelUP(o, a, s)
  var $
  if (
    (EventEmitter$1.call(this),
    this.setMaxListeners(1 / 0),
    typeof o == 'function'
      ? ((a = typeof a == 'object' ? a : {}), (a.db = o), (o = null))
      : typeof o == 'object' &&
        typeof o.db == 'function' &&
        ((a = o), (o = null)),
    typeof a == 'function' && ((s = a), (a = {})),
    (!a || typeof a.db != 'function') && typeof o != 'string')
  ) {
    if (
      (($ = new InitializationError(
        'Must provide a location for the database'
      )),
      s)
    )
      return process.nextTick(function() {
        s($)
      })
    throw $
  }
  ;(a = getOptions(this, a)),
    (this.options = extend$7(defaultOptions, a)),
    (this._status = 'new'),
    prr(this, 'location', o, 'e'),
    this.open(s)
}
inherits$4(LevelUP, EventEmitter$1)
LevelUP.prototype.open = function(o) {
  var a = this,
    s,
    $
  if (this.isOpen())
    return (
      o &&
        process.nextTick(function() {
          o(null, a)
        }),
      this
    )
  if (this._isOpening())
    return (
      o &&
      this.once('open', function() {
        o(null, a)
      })
    )
  this.emit('opening'),
    (this._status = 'opening'),
    (this.db = new DeferredLevelDOWN(this.location)),
    (s = this.options.db || getLevelDOWN()),
    ($ = s(this.location)),
    $.open(this.options, function(j) {
      if (j) return dispatchError(a, new OpenError(j), o)
      a.db.setDb($),
        (a.db = $),
        (a._status = 'open'),
        o && o(null, a),
        a.emit('open'),
        a.emit('ready')
    })
}
LevelUP.prototype.close = function(o) {
  var a = this
  if (this.isOpen())
    (this._status = 'closing'),
      this.db.close(function() {
        ;(a._status = 'closed'), a.emit('closed'), o && o.apply(null, arguments)
      }),
      this.emit('closing'),
      (this.db = null)
  else {
    if (this._status == 'closed' && o) return process.nextTick(o)
    this._status == 'closing' && o
      ? this.once('closed', o)
      : this._isOpening() &&
        this.once('open', function() {
          a.close(o)
        })
  }
}
LevelUP.prototype.isOpen = function() {
  return this._status == 'open'
}
LevelUP.prototype._isOpening = function() {
  return this._status == 'opening'
}
LevelUP.prototype.isClosed = function() {
  return /^clos/.test(this._status)
}
LevelUP.prototype.get = function(o, a, s) {
  var $ = this,
    j
  if (((s = getCallback(a, s)), typeof s != 'function'))
    return dispatchError(
      this,
      new ReadError('get() requires key and callback arguments')
    )
  if (!this._isOpening() && !this.isOpen())
    return dispatchError(this, new ReadError('Database is not open'), s)
  ;(a = util$f.getOptions(this, a)),
    (j = util$f.encodeKey(o, a)),
    (a.asBuffer = util$f.isValueAsBuffer(a)),
    this.db.get(j, a, function(_e, et) {
      if (_e)
        return (
          /notfound/i.test(_e)
            ? (_e = new NotFoundError(
                'Key not found in database [' + o + ']',
                _e
              ))
            : (_e = new ReadError(_e)),
          dispatchError($, _e, s)
        )
      if (s) {
        try {
          et = util$f.decodeValue(et, a)
        } catch (tt) {
          return s(new EncodingError(tt))
        }
        s(null, et)
      }
    })
}
LevelUP.prototype.put = function(o, a, s, $) {
  var j = this,
    _e,
    et
  if ((($ = getCallback(s, $)), o == null || a === null || a === void 0))
    return dispatchError(
      this,
      new WriteError('put() requires key and value arguments'),
      $
    )
  if (!this._isOpening() && !this.isOpen())
    return dispatchError(this, new WriteError('Database is not open'), $)
  ;(s = getOptions(this, s)),
    (_e = util$f.encodeKey(o, s)),
    (et = util$f.encodeValue(a, s)),
    this.db.put(_e, et, s, function(tt) {
      if (tt) return dispatchError(j, new WriteError(tt), $)
      j.emit('put', o, a), $ && $()
    })
}
LevelUP.prototype.del = function(o, a, s) {
  var $ = this,
    j
  if (((s = getCallback(a, s)), o == null))
    return dispatchError(
      this,
      new WriteError('del() requires a key argument'),
      s
    )
  if (!this._isOpening() && !this.isOpen())
    return dispatchError(this, new WriteError('Database is not open'), s)
  ;(a = getOptions(this, a)),
    (j = util$f.encodeKey(o, a)),
    this.db.del(j, a, function(_e) {
      if (_e) return dispatchError($, new WriteError(_e), s)
      $.emit('del', o), s && s()
    })
}
LevelUP.prototype.batch = function(o, a, s) {
  var $ = this,
    j,
    _e,
    et
  if (!arguments.length) return new Batch$3(this)
  if (((s = getCallback(a, s)), !Array.isArray(o)))
    return dispatchError(
      this,
      new WriteError('batch() requires an array argument'),
      s
    )
  if (!this._isOpening() && !this.isOpen())
    return dispatchError(this, new WriteError('Database is not open'), s)
  ;(a = getOptions(this, a)),
    (j = a.keyEncoding),
    (_e = a.valueEncoding),
    (et = o.map(function(tt) {
      if (tt.type === void 0 || tt.key === void 0) return {}
      var rt = tt.keyEncoding || j,
        nt = tt.valueEncoding || tt.encoding || _e,
        it
      return (rt != 'utf8' && rt != 'binary') ||
        (nt != 'utf8' && nt != 'binary')
        ? ((it = { type: tt.type, key: util$f.encodeKey(tt.key, a, tt) }),
          tt.value !== void 0 &&
            (it.value = util$f.encodeValue(tt.value, a, tt)),
          it)
        : tt
    })),
    this.db.batch(et, a, function(tt) {
      if (tt) return dispatchError($, new WriteError(tt), s)
      $.emit('batch', o), s && s()
    })
}
LevelUP.prototype.approximateSize = function(o, a, s) {
  var $ = this,
    j,
    _e
  if (o == null || a === null || a === void 0 || typeof s != 'function')
    return dispatchError(
      this,
      new ReadError(
        'approximateSize() requires start, end and callback arguments'
      ),
      s
    )
  if (
    ((j = util$f.encodeKey(o, this.options)),
    (_e = util$f.encodeKey(a, this.options)),
    !this._isOpening() && !this.isOpen())
  )
    return dispatchError(this, new WriteError('Database is not open'), s)
  this.db.approximateSize(j, _e, function(et, tt) {
    if (et) return dispatchError($, new OpenError(et), s)
    s && s(null, tt)
  })
}
LevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function(
  o
) {
  var a = this
  return (
    (o = extend$7(this.options, o)),
    new ReadStream(o, this, function(s) {
      return a.db.iterator(s)
    })
  )
}
LevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function(o) {
  return this.createReadStream(extend$7(o, { keys: !0, values: !1 }))
}
LevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function(
  o
) {
  return this.createReadStream(extend$7(o, { keys: !1, values: !0 }))
}
LevelUP.prototype.writeStream = LevelUP.prototype.createWriteStream = function(
  o
) {
  return new WriteStream(extend$7(o), this)
}
LevelUP.prototype.toString = function() {
  return 'LevelUP'
}
function utilStatic(o) {
  return function(a, s) {
    getLevelDOWN()[o](a, s || function() {})
  }
}
levelup$1.exports = LevelUP
levelup$1.exports.copy = util$f.copy
levelup$1.exports.destroy = utilStatic('destroy')
levelup$1.exports.repair = utilStatic('repair')
var levelupExports = levelup$1.exports,
  fwdStream = {},
  isarray$2 =
    Array.isArray ||
    function(o) {
      return Object.prototype.toString.call(o) == '[object Array]'
    },
  string_decoder$1 = {},
  hasRequiredString_decoder$1
function requireString_decoder$1() {
  if (hasRequiredString_decoder$1) return string_decoder$1
  hasRequiredString_decoder$1 = 1
  var o = buffer$1.Buffer,
    a =
      o.isEncoding ||
      function(tt) {
        switch (tt && tt.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return !0
          default:
            return !1
        }
      }
  function s(tt) {
    if (tt && !a(tt)) throw new Error('Unknown encoding: ' + tt)
  }
  var $ = (string_decoder$1.StringDecoder = function(tt) {
    switch (
      ((this.encoding = (tt || 'utf8').toLowerCase().replace(/[-_]/, '')),
      s(tt),
      this.encoding)
    ) {
      case 'utf8':
        this.surrogateSize = 3
        break
      case 'ucs2':
      case 'utf16le':
        ;(this.surrogateSize = 2), (this.detectIncompleteChar = _e)
        break
      case 'base64':
        ;(this.surrogateSize = 3), (this.detectIncompleteChar = et)
        break
      default:
        this.write = j
        return
    }
    ;(this.charBuffer = new o(6)),
      (this.charReceived = 0),
      (this.charLength = 0)
  })
  ;($.prototype.write = function(tt) {
    for (var rt = ''; this.charLength; ) {
      var nt =
        tt.length >= this.charLength - this.charReceived
          ? this.charLength - this.charReceived
          : tt.length
      if (
        (tt.copy(this.charBuffer, this.charReceived, 0, nt),
        (this.charReceived += nt),
        this.charReceived < this.charLength)
      )
        return ''
      ;(tt = tt.slice(nt, tt.length)),
        (rt = this.charBuffer.slice(0, this.charLength).toString(this.encoding))
      var ot = rt.charCodeAt(rt.length - 1)
      if (ot >= 55296 && ot <= 56319) {
        ;(this.charLength += this.surrogateSize), (rt = '')
        continue
      }
      if (((this.charReceived = this.charLength = 0), tt.length === 0))
        return rt
      break
    }
    this.detectIncompleteChar(tt)
    var it = tt.length
    this.charLength &&
      (tt.copy(this.charBuffer, 0, tt.length - this.charReceived, it),
      (it -= this.charReceived)),
      (rt += tt.toString(this.encoding, 0, it))
    var it = rt.length - 1,
      ot = rt.charCodeAt(it)
    if (ot >= 55296 && ot <= 56319) {
      var at = this.surrogateSize
      return (
        (this.charLength += at),
        (this.charReceived += at),
        this.charBuffer.copy(this.charBuffer, at, 0, at),
        tt.copy(this.charBuffer, 0, 0, at),
        rt.substring(0, it)
      )
    }
    return rt
  }),
    ($.prototype.detectIncompleteChar = function(tt) {
      for (var rt = tt.length >= 3 ? 3 : tt.length; rt > 0; rt--) {
        var nt = tt[tt.length - rt]
        if (rt == 1 && nt >> 5 == 6) {
          this.charLength = 2
          break
        }
        if (rt <= 2 && nt >> 4 == 14) {
          this.charLength = 3
          break
        }
        if (rt <= 3 && nt >> 3 == 30) {
          this.charLength = 4
          break
        }
      }
      this.charReceived = rt
    }),
    ($.prototype.end = function(tt) {
      var rt = ''
      if ((tt && tt.length && (rt = this.write(tt)), this.charReceived)) {
        var nt = this.charReceived,
          it = this.charBuffer,
          ot = this.encoding
        rt += it.slice(0, nt).toString(ot)
      }
      return rt
    })
  function j(tt) {
    return tt.toString(this.encoding)
  }
  function _e(tt) {
    ;(this.charReceived = tt.length % 2),
      (this.charLength = this.charReceived ? 2 : 0)
  }
  function et(tt) {
    ;(this.charReceived = tt.length % 3),
      (this.charLength = this.charReceived ? 3 : 0)
  }
  return string_decoder$1
}
var _stream_readable$2 = Readable$1,
  isArray$1 = isarray$2,
  Buffer$1 = buffer$1.Buffer
Readable$1.ReadableState = ReadableState
var EE = eventsExports.EventEmitter
EE.listenerCount ||
  (EE.listenerCount = function(o, a) {
    return o.listeners(a).length
  })
var Stream$3 = stream$1,
  util$e = util$q
util$e.inherits = inherits_browserExports
var StringDecoder
util$e.inherits(Readable$1, Stream$3)
function ReadableState(o, a) {
  o = o || {}
  var s = o.highWaterMark
  ;(this.highWaterMark = s || s === 0 ? s : 16 * 1024),
    (this.highWaterMark = ~~this.highWaterMark),
    (this.buffer = []),
    (this.length = 0),
    (this.pipes = null),
    (this.pipesCount = 0),
    (this.flowing = !1),
    (this.ended = !1),
    (this.endEmitted = !1),
    (this.reading = !1),
    (this.calledRead = !1),
    (this.sync = !0),
    (this.needReadable = !1),
    (this.emittedReadable = !1),
    (this.readableListening = !1),
    (this.objectMode = !!o.objectMode),
    (this.defaultEncoding = o.defaultEncoding || 'utf8'),
    (this.ranOut = !1),
    (this.awaitDrain = 0),
    (this.readingMore = !1),
    (this.decoder = null),
    (this.encoding = null),
    o.encoding &&
      (StringDecoder ||
        (StringDecoder = requireString_decoder$1().StringDecoder),
      (this.decoder = new StringDecoder(o.encoding)),
      (this.encoding = o.encoding))
}
function Readable$1(o) {
  if (!(this instanceof Readable$1)) return new Readable$1(o)
  ;(this._readableState = new ReadableState(o)),
    (this.readable = !0),
    Stream$3.call(this)
}
Readable$1.prototype.push = function(o, a) {
  var s = this._readableState
  return (
    typeof o == 'string' &&
      !s.objectMode &&
      ((a = a || s.defaultEncoding),
      a !== s.encoding && ((o = new Buffer$1(o, a)), (a = ''))),
    readableAddChunk(this, s, o, a, !1)
  )
}
Readable$1.prototype.unshift = function(o) {
  var a = this._readableState
  return readableAddChunk(this, a, o, '', !0)
}
function readableAddChunk(o, a, s, $, j) {
  var _e = chunkInvalid(a, s)
  if (_e) o.emit('error', _e)
  else if (s == null) (a.reading = !1), a.ended || onEofChunk(o, a)
  else if (a.objectMode || (s && s.length > 0))
    if (a.ended && !j) {
      var et = new Error('stream.push() after EOF')
      o.emit('error', et)
    } else if (a.endEmitted && j) {
      var et = new Error('stream.unshift() after end event')
      o.emit('error', et)
    } else
      a.decoder && !j && !$ && (s = a.decoder.write(s)),
        (a.length += a.objectMode ? 1 : s.length),
        j ? a.buffer.unshift(s) : ((a.reading = !1), a.buffer.push(s)),
        a.needReadable && emitReadable(o),
        maybeReadMore(o, a)
  else j || (a.reading = !1)
  return needMoreData(a)
}
function needMoreData(o) {
  return (
    !o.ended && (o.needReadable || o.length < o.highWaterMark || o.length === 0)
  )
}
Readable$1.prototype.setEncoding = function(o) {
  StringDecoder || (StringDecoder = requireString_decoder$1().StringDecoder),
    (this._readableState.decoder = new StringDecoder(o)),
    (this._readableState.encoding = o)
}
var MAX_HWM = 8388608
function roundUpToNextPowerOf2(o) {
  if (o >= MAX_HWM) o = MAX_HWM
  else {
    o--
    for (var a = 1; a < 32; a <<= 1) o |= o >> a
    o++
  }
  return o
}
function howMuchToRead(o, a) {
  return a.length === 0 && a.ended
    ? 0
    : a.objectMode
    ? o === 0
      ? 0
      : 1
    : o === null || isNaN(o)
    ? a.flowing && a.buffer.length
      ? a.buffer[0].length
      : a.length
    : o <= 0
    ? 0
    : (o > a.highWaterMark && (a.highWaterMark = roundUpToNextPowerOf2(o)),
      o > a.length ? (a.ended ? a.length : ((a.needReadable = !0), 0)) : o)
}
Readable$1.prototype.read = function(o) {
  var a = this._readableState
  a.calledRead = !0
  var s = o,
    $
  if (
    ((typeof o != 'number' || o > 0) && (a.emittedReadable = !1),
    o === 0 && a.needReadable && (a.length >= a.highWaterMark || a.ended))
  )
    return emitReadable(this), null
  if (((o = howMuchToRead(o, a)), o === 0 && a.ended))
    return (
      ($ = null),
      a.length > 0 &&
        a.decoder &&
        (($ = fromList(o, a)), (a.length -= $.length)),
      a.length === 0 && endReadable(this),
      $
    )
  var j = a.needReadable
  return (
    a.length - o <= a.highWaterMark && (j = !0),
    (a.ended || a.reading) && (j = !1),
    j &&
      ((a.reading = !0),
      (a.sync = !0),
      a.length === 0 && (a.needReadable = !0),
      this._read(a.highWaterMark),
      (a.sync = !1)),
    j && !a.reading && (o = howMuchToRead(s, a)),
    o > 0 ? ($ = fromList(o, a)) : ($ = null),
    $ === null && ((a.needReadable = !0), (o = 0)),
    (a.length -= o),
    a.length === 0 && !a.ended && (a.needReadable = !0),
    a.ended && !a.endEmitted && a.length === 0 && endReadable(this),
    $
  )
}
function chunkInvalid(o, a) {
  var s = null
  return (
    !Buffer$1.isBuffer(a) &&
      typeof a != 'string' &&
      a !== null &&
      a !== void 0 &&
      !o.objectMode &&
      (s = new TypeError('Invalid non-string/buffer chunk')),
    s
  )
}
function onEofChunk(o, a) {
  if (a.decoder && !a.ended) {
    var s = a.decoder.end()
    s &&
      s.length &&
      (a.buffer.push(s), (a.length += a.objectMode ? 1 : s.length))
  }
  ;(a.ended = !0), a.length > 0 ? emitReadable(o) : endReadable(o)
}
function emitReadable(o) {
  var a = o._readableState
  ;(a.needReadable = !1),
    !a.emittedReadable &&
      ((a.emittedReadable = !0),
      a.sync
        ? process.nextTick(function() {
            emitReadable_(o)
          })
        : emitReadable_(o))
}
function emitReadable_(o) {
  o.emit('readable')
}
function maybeReadMore(o, a) {
  a.readingMore ||
    ((a.readingMore = !0),
    process.nextTick(function() {
      maybeReadMore_(o, a)
    }))
}
function maybeReadMore_(o, a) {
  for (
    var s = a.length;
    !a.reading &&
    !a.flowing &&
    !a.ended &&
    a.length < a.highWaterMark &&
    (o.read(0), s !== a.length);

  )
    s = a.length
  a.readingMore = !1
}
Readable$1.prototype._read = function(o) {
  this.emit('error', new Error('not implemented'))
}
Readable$1.prototype.pipe = function(o, a) {
  var s = this,
    $ = this._readableState
  switch ($.pipesCount) {
    case 0:
      $.pipes = o
      break
    case 1:
      $.pipes = [$.pipes, o]
      break
    default:
      $.pipes.push(o)
      break
  }
  $.pipesCount += 1
  var j = (!a || a.end !== !1) && o !== process.stdout && o !== process.stderr,
    _e = j ? tt : nt
  $.endEmitted ? process.nextTick(_e) : s.once('end', _e), o.on('unpipe', et)
  function et(ut) {
    ut === s && nt()
  }
  function tt() {
    o.end()
  }
  var rt = pipeOnDrain(s)
  o.on('drain', rt)
  function nt() {
    o.removeListener('close', ot),
      o.removeListener('finish', at),
      o.removeListener('drain', rt),
      o.removeListener('error', it),
      o.removeListener('unpipe', et),
      s.removeListener('end', tt),
      s.removeListener('end', nt),
      (!o._writableState || o._writableState.needDrain) && rt()
  }
  function it(ut) {
    st(),
      o.removeListener('error', it),
      EE.listenerCount(o, 'error') === 0 && o.emit('error', ut)
  }
  !o._events || !o._events.error
    ? o.on('error', it)
    : isArray$1(o._events.error)
    ? o._events.error.unshift(it)
    : (o._events.error = [it, o._events.error])
  function ot() {
    o.removeListener('finish', at), st()
  }
  o.once('close', ot)
  function at() {
    o.removeListener('close', ot), st()
  }
  o.once('finish', at)
  function st() {
    s.unpipe(o)
  }
  return (
    o.emit('pipe', s),
    $.flowing ||
      (this.on('readable', pipeOnReadable),
      ($.flowing = !0),
      process.nextTick(function() {
        flow(s)
      })),
    o
  )
}
function pipeOnDrain(o) {
  return function() {
    var a = o._readableState
    a.awaitDrain--, a.awaitDrain === 0 && flow(o)
  }
}
function flow(o) {
  var a = o._readableState,
    s
  a.awaitDrain = 0
  function $(j, _e, et) {
    var tt = j.write(s)
    tt === !1 && a.awaitDrain++
  }
  for (; a.pipesCount && (s = o.read()) !== null; )
    if (
      (a.pipesCount === 1 ? $(a.pipes) : forEach(a.pipes, $),
      o.emit('data', s),
      a.awaitDrain > 0)
    )
      return
  if (a.pipesCount === 0) {
    ;(a.flowing = !1), EE.listenerCount(o, 'data') > 0 && emitDataEvents(o)
    return
  }
  a.ranOut = !0
}
function pipeOnReadable() {
  this._readableState.ranOut && ((this._readableState.ranOut = !1), flow(this))
}
Readable$1.prototype.unpipe = function(o) {
  var a = this._readableState
  if (a.pipesCount === 0) return this
  if (a.pipesCount === 1)
    return o && o !== a.pipes
      ? this
      : (o || (o = a.pipes),
        (a.pipes = null),
        (a.pipesCount = 0),
        this.removeListener('readable', pipeOnReadable),
        (a.flowing = !1),
        o && o.emit('unpipe', this),
        this)
  if (!o) {
    var s = a.pipes,
      $ = a.pipesCount
    ;(a.pipes = null),
      (a.pipesCount = 0),
      this.removeListener('readable', pipeOnReadable),
      (a.flowing = !1)
    for (var j = 0; j < $; j++) s[j].emit('unpipe', this)
    return this
  }
  var j = indexOf(a.pipes, o)
  return j === -1
    ? this
    : (a.pipes.splice(j, 1),
      (a.pipesCount -= 1),
      a.pipesCount === 1 && (a.pipes = a.pipes[0]),
      o.emit('unpipe', this),
      this)
}
Readable$1.prototype.on = function(o, a) {
  var s = Stream$3.prototype.on.call(this, o, a)
  if (
    (o === 'data' && !this._readableState.flowing && emitDataEvents(this),
    o === 'readable' && this.readable)
  ) {
    var $ = this._readableState
    $.readableListening ||
      (($.readableListening = !0),
      ($.emittedReadable = !1),
      ($.needReadable = !0),
      $.reading ? $.length && emitReadable(this) : this.read(0))
  }
  return s
}
Readable$1.prototype.addListener = Readable$1.prototype.on
Readable$1.prototype.resume = function() {
  emitDataEvents(this), this.read(0), this.emit('resume')
}
Readable$1.prototype.pause = function() {
  emitDataEvents(this, !0), this.emit('pause')
}
function emitDataEvents(o, a) {
  var s = o._readableState
  if (s.flowing) throw new Error('Cannot switch to old mode now.')
  var $ = a || !1,
    j = !1
  ;(o.readable = !0),
    (o.pipe = Stream$3.prototype.pipe),
    (o.on = o.addListener = Stream$3.prototype.on),
    o.on('readable', function() {
      j = !0
      for (var _e; !$ && (_e = o.read()) !== null; ) o.emit('data', _e)
      _e === null && ((j = !1), (o._readableState.needReadable = !0))
    }),
    (o.pause = function() {
      ;($ = !0), this.emit('pause')
    }),
    (o.resume = function() {
      ;($ = !1),
        j
          ? process.nextTick(function() {
              o.emit('readable')
            })
          : this.read(0),
        this.emit('resume')
    }),
    o.emit('readable')
}
Readable$1.prototype.wrap = function(o) {
  var a = this._readableState,
    s = !1,
    $ = this
  o.on('end', function() {
    if (a.decoder && !a.ended) {
      var et = a.decoder.end()
      et && et.length && $.push(et)
    }
    $.push(null)
  }),
    o.on('data', function(et) {
      if (
        (a.decoder && (et = a.decoder.write(et)),
        !(a.objectMode && et == null) &&
          !(!a.objectMode && (!et || !et.length)))
      ) {
        var tt = $.push(et)
        tt || ((s = !0), o.pause())
      }
    })
  for (var j in o)
    typeof o[j] == 'function' &&
      typeof this[j] > 'u' &&
      (this[j] = (function(et) {
        return function() {
          return o[et].apply(o, arguments)
        }
      })(j))
  var _e = ['error', 'close', 'destroy', 'pause', 'resume']
  return (
    forEach(_e, function(et) {
      o.on(et, $.emit.bind($, et))
    }),
    ($._read = function(et) {
      s && ((s = !1), o.resume())
    }),
    $
  )
}
Readable$1._fromList = fromList
function fromList(o, a) {
  var s = a.buffer,
    $ = a.length,
    j = !!a.decoder,
    _e = !!a.objectMode,
    et
  if (s.length === 0) return null
  if ($ === 0) et = null
  else if (_e) et = s.shift()
  else if (!o || o >= $)
    j ? (et = s.join('')) : (et = Buffer$1.concat(s, $)), (s.length = 0)
  else if (o < s[0].length) {
    var tt = s[0]
    ;(et = tt.slice(0, o)), (s[0] = tt.slice(o))
  } else if (o === s[0].length) et = s.shift()
  else {
    j ? (et = '') : (et = new Buffer$1(o))
    for (var rt = 0, nt = 0, it = s.length; nt < it && rt < o; nt++) {
      var tt = s[0],
        ot = Math.min(o - rt, tt.length)
      j ? (et += tt.slice(0, ot)) : tt.copy(et, rt, 0, ot),
        ot < tt.length ? (s[0] = tt.slice(ot)) : s.shift(),
        (rt += ot)
    }
  }
  return et
}
function endReadable(o) {
  var a = o._readableState
  if (a.length > 0) throw new Error('endReadable called on non-empty stream')
  !a.endEmitted &&
    a.calledRead &&
    ((a.ended = !0),
    process.nextTick(function() {
      !a.endEmitted &&
        a.length === 0 &&
        ((a.endEmitted = !0), (o.readable = !1), o.emit('end'))
    }))
}
function forEach(o, a) {
  for (var s = 0, $ = o.length; s < $; s++) a(o[s], s)
}
function indexOf(o, a) {
  for (var s = 0, $ = o.length; s < $; s++) if (o[s] === a) return s
  return -1
}
var _stream_duplex$2, hasRequired_stream_duplex$2
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2) return _stream_duplex$2
  ;(hasRequired_stream_duplex$2 = 1), (_stream_duplex$2 = j)
  var o =
      Object.keys ||
      function(tt) {
        var rt = []
        for (var nt in tt) rt.push(nt)
        return rt
      },
    a = util$q
  a.inherits = inherits_browserExports
  var s = _stream_readable$2,
    $ = require_stream_writable$2()
  a.inherits(j, s),
    et(o($.prototype), function(tt) {
      j.prototype[tt] || (j.prototype[tt] = $.prototype[tt])
    })
  function j(tt) {
    if (!(this instanceof j)) return new j(tt)
    s.call(this, tt),
      $.call(this, tt),
      tt && tt.readable === !1 && (this.readable = !1),
      tt && tt.writable === !1 && (this.writable = !1),
      (this.allowHalfOpen = !0),
      tt && tt.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
      this.once('end', _e)
  }
  function _e() {
    this.allowHalfOpen ||
      this._writableState.ended ||
      process.nextTick(this.end.bind(this))
  }
  function et(tt, rt) {
    for (var nt = 0, it = tt.length; nt < it; nt++) rt(tt[nt], nt)
  }
  return _stream_duplex$2
}
var _stream_writable$2, hasRequired_stream_writable$2
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2) return _stream_writable$2
  ;(hasRequired_stream_writable$2 = 1), (_stream_writable$2 = _e)
  var o = buffer$1.Buffer
  _e.WritableState = j
  var a = util$q
  a.inherits = inherits_browserExports
  var s = stream$1
  a.inherits(_e, s)
  function $(yt, pt, ht) {
    ;(this.chunk = yt), (this.encoding = pt), (this.callback = ht)
  }
  function j(yt, pt) {
    yt = yt || {}
    var ht = yt.highWaterMark
    ;(this.highWaterMark = ht || ht === 0 ? ht : 16 * 1024),
      (this.objectMode = !!yt.objectMode),
      (this.highWaterMark = ~~this.highWaterMark),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1)
    var At = yt.decodeStrings === !1
    ;(this.decodeStrings = !At),
      (this.defaultEncoding = yt.defaultEncoding || 'utf8'),
      (this.length = 0),
      (this.writing = !1),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function(wt) {
        st(pt, wt)
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.buffer = []),
      (this.errorEmitted = !1)
  }
  function _e(yt) {
    var pt = require_stream_duplex$2()
    if (!(this instanceof _e) && !(this instanceof pt)) return new _e(yt)
    ;(this._writableState = new j(yt, this)), (this.writable = !0), s.call(this)
  }
  _e.prototype.pipe = function() {
    this.emit('error', new Error('Cannot pipe. Not readable.'))
  }
  function et(yt, pt, ht) {
    var At = new Error('write after end')
    yt.emit('error', At),
      process.nextTick(function() {
        ht(At)
      })
  }
  function tt(yt, pt, ht, At) {
    var wt = !0
    if (
      !o.isBuffer(ht) &&
      typeof ht != 'string' &&
      ht !== null &&
      ht !== void 0 &&
      !pt.objectMode
    ) {
      var Ct = new TypeError('Invalid non-string/buffer chunk')
      yt.emit('error', Ct),
        process.nextTick(function() {
          At(Ct)
        }),
        (wt = !1)
    }
    return wt
  }
  _e.prototype.write = function(yt, pt, ht) {
    var At = this._writableState,
      wt = !1
    return (
      typeof pt == 'function' && ((ht = pt), (pt = null)),
      o.isBuffer(yt) ? (pt = 'buffer') : pt || (pt = At.defaultEncoding),
      typeof ht != 'function' && (ht = function() {}),
      At.ended
        ? et(this, At, ht)
        : tt(this, At, yt, ht) && (wt = nt(this, At, yt, pt, ht)),
      wt
    )
  }
  function rt(yt, pt, ht) {
    return (
      !yt.objectMode &&
        yt.decodeStrings !== !1 &&
        typeof pt == 'string' &&
        (pt = new o(pt, ht)),
      pt
    )
  }
  function nt(yt, pt, ht, At, wt) {
    ;(ht = rt(pt, ht, At)), o.isBuffer(ht) && (At = 'buffer')
    var Ct = pt.objectMode ? 1 : ht.length
    pt.length += Ct
    var Dt = pt.length < pt.highWaterMark
    return (
      Dt || (pt.needDrain = !0),
      pt.writing
        ? pt.buffer.push(new $(ht, At, wt))
        : it(yt, pt, Ct, ht, At, wt),
      Dt
    )
  }
  function it(yt, pt, ht, At, wt, Ct) {
    ;(pt.writelen = ht),
      (pt.writecb = Ct),
      (pt.writing = !0),
      (pt.sync = !0),
      yt._write(At, wt, pt.onwrite),
      (pt.sync = !1)
  }
  function ot(yt, pt, ht, At, wt) {
    ht
      ? process.nextTick(function() {
          wt(At)
        })
      : wt(At),
      (yt._writableState.errorEmitted = !0),
      yt.emit('error', At)
  }
  function at(yt) {
    ;(yt.writing = !1),
      (yt.writecb = null),
      (yt.length -= yt.writelen),
      (yt.writelen = 0)
  }
  function st(yt, pt) {
    var ht = yt._writableState,
      At = ht.sync,
      wt = ht.writecb
    if ((at(ht), pt)) ot(yt, ht, At, pt, wt)
    else {
      var Ct = ft(yt, ht)
      !Ct && !ht.bufferProcessing && ht.buffer.length && dt(yt, ht),
        At
          ? process.nextTick(function() {
              ut(yt, ht, Ct, wt)
            })
          : ut(yt, ht, Ct, wt)
    }
  }
  function ut(yt, pt, ht, At) {
    ht || ct(yt, pt), At(), ht && mt(yt, pt)
  }
  function ct(yt, pt) {
    pt.length === 0 && pt.needDrain && ((pt.needDrain = !1), yt.emit('drain'))
  }
  function dt(yt, pt) {
    pt.bufferProcessing = !0
    for (var ht = 0; ht < pt.buffer.length; ht++) {
      var At = pt.buffer[ht],
        wt = At.chunk,
        Ct = At.encoding,
        Dt = At.callback,
        jt = pt.objectMode ? 1 : wt.length
      if ((it(yt, pt, jt, wt, Ct, Dt), pt.writing)) {
        ht++
        break
      }
    }
    ;(pt.bufferProcessing = !1),
      ht < pt.buffer.length
        ? (pt.buffer = pt.buffer.slice(ht))
        : (pt.buffer.length = 0)
  }
  ;(_e.prototype._write = function(yt, pt, ht) {
    ht(new Error('not implemented'))
  }),
    (_e.prototype.end = function(yt, pt, ht) {
      var At = this._writableState
      typeof yt == 'function'
        ? ((ht = yt), (yt = null), (pt = null))
        : typeof pt == 'function' && ((ht = pt), (pt = null)),
        typeof yt < 'u' && yt !== null && this.write(yt, pt),
        !At.ending && !At.finished && vt(this, At, ht)
    })
  function ft(yt, pt) {
    return pt.ending && pt.length === 0 && !pt.finished && !pt.writing
  }
  function mt(yt, pt) {
    var ht = ft(yt, pt)
    return ht && ((pt.finished = !0), yt.emit('finish')), ht
  }
  function vt(yt, pt, ht) {
    ;(pt.ending = !0),
      mt(yt, pt),
      ht && (pt.finished ? process.nextTick(ht) : yt.once('finish', ht)),
      (pt.ended = !0)
  }
  return _stream_writable$2
}
var writable$1 = require_stream_writable$2(),
  readable$1 = { exports: {} },
  _stream_transform$2 = Transform$5,
  Duplex$2 = require_stream_duplex$2(),
  util$d = util$q
util$d.inherits = inherits_browserExports
util$d.inherits(Transform$5, Duplex$2)
function TransformState$1(o, a) {
  ;(this.afterTransform = function(s, $) {
    return afterTransform$2(a, s, $)
  }),
    (this.needTransform = !1),
    (this.transforming = !1),
    (this.writecb = null),
    (this.writechunk = null)
}
function afterTransform$2(o, a, s) {
  var $ = o._transformState
  $.transforming = !1
  var j = $.writecb
  if (!j) return o.emit('error', new Error('no writecb in Transform class'))
  ;($.writechunk = null), ($.writecb = null), s != null && o.push(s), j && j(a)
  var _e = o._readableState
  ;(_e.reading = !1),
    (_e.needReadable || _e.length < _e.highWaterMark) &&
      o._read(_e.highWaterMark)
}
function Transform$5(o) {
  if (!(this instanceof Transform$5)) return new Transform$5(o)
  Duplex$2.call(this, o), (this._transformState = new TransformState$1(o, this))
  var a = this
  ;(this._readableState.needReadable = !0),
    (this._readableState.sync = !1),
    this.once('finish', function() {
      typeof this._flush == 'function'
        ? this._flush(function(s) {
            done$2(a, s)
          })
        : done$2(a)
    })
}
Transform$5.prototype.push = function(o, a) {
  return (
    (this._transformState.needTransform = !1),
    Duplex$2.prototype.push.call(this, o, a)
  )
}
Transform$5.prototype._transform = function(o, a, s) {
  throw new Error('not implemented')
}
Transform$5.prototype._write = function(o, a, s) {
  var $ = this._transformState
  if (
    (($.writecb = s),
    ($.writechunk = o),
    ($.writeencoding = a),
    !$.transforming)
  ) {
    var j = this._readableState
    ;($.needTransform || j.needReadable || j.length < j.highWaterMark) &&
      this._read(j.highWaterMark)
  }
}
Transform$5.prototype._read = function(o) {
  var a = this._transformState
  a.writechunk !== null && a.writecb && !a.transforming
    ? ((a.transforming = !0),
      this._transform(a.writechunk, a.writeencoding, a.afterTransform))
    : (a.needTransform = !0)
}
function done$2(o, a) {
  if (a) return o.emit('error', a)
  var s = o._writableState
  o._readableState
  var $ = o._transformState
  if (s.length) throw new Error('calling transform done when ws.length != 0')
  if ($.transforming)
    throw new Error('calling transform done when still transforming')
  return o.push(null)
}
var _stream_passthrough$2 = PassThrough$2,
  Transform$4 = _stream_transform$2,
  util$c = util$q
util$c.inherits = inherits_browserExports
util$c.inherits(PassThrough$2, Transform$4)
function PassThrough$2(o) {
  if (!(this instanceof PassThrough$2)) return new PassThrough$2(o)
  Transform$4.call(this, o)
}
PassThrough$2.prototype._transform = function(o, a, s) {
  s(null, o)
}
;(function(o, a) {
  var s = {},
    $ = stream$1
  ;(a = o.exports = _stream_readable$2),
    (a.Stream = $),
    (a.Readable = a),
    (a.Writable = require_stream_writable$2()),
    (a.Duplex = require_stream_duplex$2()),
    (a.Transform = _stream_transform$2),
    (a.PassThrough = _stream_passthrough$2),
    !process.browser &&
      s.READABLE_STREAM === 'disable' &&
      (o.exports = stream$1)
})(readable$1, readable$1.exports)
var readableExports$1 = readable$1.exports,
  duplex = require_stream_duplex$2()
;(function(o) {
  var a = writable$1,
    s = readableExports$1,
    $ = duplex,
    j = new Buffer(0),
    _e = function() {},
    et = function(nt) {
      return typeof nt == 'function'
        ? nt
        : function(it) {
            it(null, nt)
          }
    },
    tt = function(nt, it) {
      var ot = !1,
        at = !1
      return (
        (nt._read = function() {
          ot = !0
        }),
        (nt.destroy = function() {
          at = !0
        }),
        it(function(st, ut) {
          if (st) return nt.emit('error', st)
          var ct = function() {
            for (var dt; (dt = ut.read()) !== null; ) (ot = !1), nt.push(dt)
          }
          if (
            (ut.on('readable', function() {
              ot && ct()
            }),
            ut.on('end', function() {
              ct(), nt.push(null)
            }),
            ut.on('error', function(dt) {
              nt.emit('error', dt)
            }),
            ut.on('close', function() {
              ct(),
                process.nextTick(function() {
                  nt.emit('close')
                })
            }),
            (nt._read = function() {
              ;(ot = !0), ct()
            }),
            (nt.destroy = function() {
              at || ((at = !0), ut.destroy && ut.destroy())
            }),
            at)
          ) {
            ;(at = !1), nt.destroy()
            return
          }
          ot && ct()
        }),
        nt
      )
    },
    rt = function(nt, it) {
      var ot = _e,
        at = !1
      return (
        (nt._write = function(st, ut, ct) {
          ot = ct
        }),
        (nt.destroy = function() {
          at = !0
        }),
        nt.write(j),
        it(function(st, ut) {
          if (st) return nt.emit('error', st)
          ut.on('close', function() {
            nt.emit('close')
          }),
            ut.on('error', function(dt) {
              nt.emit('error', dt)
            }),
            (nt._write = function(dt, ft, mt) {
              if (dt === j) return mt()
              ut.write(dt, ft, mt)
            })
          var ct = nt.emit
          if (
            (ut.on('finish', function() {
              ct.call(nt, 'finish')
            }),
            (nt.destroy = function() {
              at || ((at = !0), ut.destroy && ut.destroy())
            }),
            (nt.emit = function(dt) {
              if (dt !== 'finish') return ct.apply(nt, arguments)
              ut.end()
            }),
            at)
          ) {
            ;(at = !1), nt.destroy()
            return
          }
          ot()
        }),
        nt
      )
    }
  ;(o.readable = function(nt, it) {
    return arguments.length === 1
      ? o.readable(null, nt)
      : (nt || (nt = {}), tt(new s(nt), et(it)))
  }),
    (o.writable = function(nt, it) {
      return arguments.length === 1
        ? o.writable(null, nt)
        : (nt || (nt = {}), rt(new a(nt), et(it)))
    }),
    (o.duplex = function(nt, it, ot) {
      if (arguments.length === 2) return o.duplex(null, nt, it)
      nt || (nt = {})
      var at = new $(nt)
      return rt(at, et(it)), tt(at, et(ot)), at
    })
})(fwdStream)
var sub = { exports: {} },
  stringRange = {}
;(function(o) {
  var a = (o.range = function($) {
    return $ == null ? {} : typeof a == 'string' ? { min: a, max: a + '' } : $
  })
  o.prefix = function($, j, _e) {
    $ = o.range($)
    var et = {}
    return (
      (_e = _e || ''),
      $ instanceof RegExp || typeof $ == 'function'
        ? ((et.min = j),
          (et.max = j + _e),
          (et.inner = function(tt) {
            var rt = tt.substring(j.length)
            return $.test ? $.test(rt) : $(rt)
          }))
        : typeof $ == 'object' &&
          ((et.min = j + ($.min || $.start || '')),
          (et.max = j + ($.max || $.end || _e || '~')),
          (et.reverse = !!$.reverse)),
      et
    )
  }
  var s = (o.checker = function($) {
    if (($ || ($ = {}), typeof $ == 'string'))
      return function(j) {
        return j.indexOf($) == 0
      }
    if ($ instanceof RegExp)
      return function(j) {
        return $.test(j)
      }
    if (typeof $ == 'object')
      return function(j) {
        var _e = $.min || $.start,
          et = $.max || $.end
        return (
          (j = String(j)),
          (!_e || j >= _e) &&
            (!et || j <= et) &&
            (!$.inner || ($.inner.test ? $.inner.test(j) : $.inner(j)))
        )
      }
    if (typeof $ == 'function') return $
  })
  o.satisfies = function($, j) {
    return s(j)($)
  }
})(stringRange)
var clone$1 = { exports: {} }
;(function(o) {
  function a(j) {
    return Object.prototype.toString.call(j)
  }
  var s = {
    isArray: function(j) {
      return (
        Array.isArray(j) || (typeof j == 'object' && a(j) === '[object Array]')
      )
    },
    isDate: function(j) {
      return typeof j == 'object' && a(j) === '[object Date]'
    },
    isRegExp: function(j) {
      return typeof j == 'object' && a(j) === '[object RegExp]'
    },
    getRegExpFlags: function(j) {
      var _e = ''
      return (
        j.global && (_e += 'g'),
        j.ignoreCase && (_e += 'i'),
        j.multiline && (_e += 'm'),
        _e
      )
    },
  }
  o.exports = $
  function $(j, _e, et, tt) {
    var rt = [],
      nt = [],
      it = typeof Buffer < 'u'
    typeof _e > 'u' && (_e = !0), typeof et > 'u' && (et = 1 / 0)
    function ot(at, st) {
      if (at === null) return null
      if (st == 0) return at
      var ut, ct
      if (typeof at != 'object') return at
      if (s.isArray(at)) ut = []
      else if (s.isRegExp(at))
        (ut = new RegExp(at.source, s.getRegExpFlags(at))),
          at.lastIndex && (ut.lastIndex = at.lastIndex)
      else if (s.isDate(at)) ut = new Date(at.getTime())
      else {
        if (it && Buffer.isBuffer(at))
          return (ut = new Buffer(at.length)), at.copy(ut), ut
        typeof tt > 'u'
          ? ((ct = Object.getPrototypeOf(at)), (ut = Object.create(ct)))
          : ((ut = Object.create(tt)), (ct = tt))
      }
      if (_e) {
        var dt = rt.indexOf(at)
        if (dt != -1) return nt[dt]
        rt.push(at), nt.push(ut)
      }
      for (var ft in at) {
        var mt
        ct && (mt = Object.getOwnPropertyDescriptor(ct, ft)),
          !(mt && mt.set == null) && (ut[ft] = ot(at[ft], st - 1))
      }
      return ut
    }
    return ot(j, et)
  }
  $.clonePrototype = function(j) {
    if (j === null) return null
    var _e = function() {}
    return (_e.prototype = j), new _e()
  }
})(clone$1)
var cloneExports = clone$1.exports,
  clone = cloneExports,
  levelFixRange$1 = function(a) {
    a = clone(a)
    var s = a.reverse,
      $ = a.max || a.end,
      j = a.min || a.start,
      _e = [j, $]
    return (
      j != null && $ != null && _e.sort(),
      s && (_e = _e.reverse()),
      (a.start = _e[0]),
      (a.end = _e[1]),
      delete a.min,
      delete a.max,
      a
    )
  },
  shim$2 = { exports: {} },
  is = { exports: {} },
  hasRequiredIs
function requireIs() {
  if (hasRequiredIs) return is.exports
  hasRequiredIs = 1
  /**!
   * is
   * the definitive JavaScript type testing library
   *
   * @copyright 2013 Enrico Marino
   * @license MIT
   */ var o = Object.prototype,
    a = o.hasOwnProperty,
    s = o.toString,
    $ = function(et) {
      return et !== et
    },
    j = { boolean: 1, number: 1, string: 1, undefined: 1 },
    _e = (is.exports = {})
  return (
    (_e.a = _e.type = function(et, tt) {
      return typeof et === tt
    }),
    (_e.defined = function(et) {
      return et !== void 0
    }),
    (_e.empty = function(et) {
      var tt = s.call(et),
        rt
      if (tt === '[object Array]' || tt === '[object Arguments]')
        return et.length === 0
      if (tt === '[object Object]') {
        for (rt in et) if (a.call(et, rt)) return !1
        return !0
      }
      return tt === '[object String]' ? et === '' : !1
    }),
    (_e.equal = function(et, tt) {
      var rt = s.call(et),
        nt
      if (rt !== s.call(tt)) return !1
      if (rt === '[object Object]') {
        for (nt in et) if (!_e.equal(et[nt], tt[nt])) return !1
        return !0
      }
      if (rt === '[object Array]') {
        if (((nt = et.length), nt !== tt.length)) return !1
        for (; --nt; ) if (!_e.equal(et[nt], tt[nt])) return !1
        return !0
      }
      return rt === '[object Function]'
        ? et.prototype === tt.prototype
        : rt === '[object Date]'
        ? et.getTime() === tt.getTime()
        : et === tt
    }),
    (_e.hosted = function(et, tt) {
      var rt = typeof tt[et]
      return rt === 'object' ? !!tt[et] : !j[rt]
    }),
    (_e.instance = _e.instanceof = function(et, tt) {
      return et instanceof tt
    }),
    (_e.null = function(et) {
      return et === null
    }),
    (_e.undefined = function(et) {
      return et === void 0
    }),
    (_e.arguments = function(et) {
      var tt = s.call(et) === '[object Arguments]',
        rt =
          !_e.array(et) && _e.arraylike(et) && _e.object(et) && _e.fn(et.callee)
      return tt || rt
    }),
    (_e.array = function(et) {
      return s.call(et) === '[object Array]'
    }),
    (_e.arguments.empty = function(et) {
      return _e.arguments(et) && et.length === 0
    }),
    (_e.array.empty = function(et) {
      return _e.array(et) && et.length === 0
    }),
    (_e.arraylike = function(et) {
      return (
        !!et &&
        !_e.boolean(et) &&
        a.call(et, 'length') &&
        isFinite(et.length) &&
        _e.number(et.length) &&
        et.length >= 0
      )
    }),
    (_e.boolean = function(et) {
      return s.call(et) === '[object Boolean]'
    }),
    (_e.false = function(et) {
      return _e.boolean(et) && (et === !1 || et.valueOf() === !1)
    }),
    (_e.true = function(et) {
      return _e.boolean(et) && (et === !0 || et.valueOf() === !0)
    }),
    (_e.date = function(et) {
      return s.call(et) === '[object Date]'
    }),
    (_e.element = function(et) {
      return (
        et !== void 0 &&
        typeof HTMLElement < 'u' &&
        et instanceof HTMLElement &&
        et.nodeType === 1
      )
    }),
    (_e.error = function(et) {
      return s.call(et) === '[object Error]'
    }),
    (_e.fn = _e.function = function(et) {
      var tt = typeof window < 'u' && et === window.alert
      return tt || s.call(et) === '[object Function]'
    }),
    (_e.number = function(et) {
      return s.call(et) === '[object Number]'
    }),
    (_e.infinite = function(et) {
      return et === 1 / 0 || et === -1 / 0
    }),
    (_e.decimal = function(et) {
      return _e.number(et) && !$(et) && !_e.infinite(et) && et % 1 !== 0
    }),
    (_e.divisibleBy = function(et, tt) {
      var rt = _e.infinite(et),
        nt = _e.infinite(tt),
        it = _e.number(et) && !$(et) && _e.number(tt) && !$(tt) && tt !== 0
      return rt || nt || (it && et % tt === 0)
    }),
    (_e.int = function(et) {
      return _e.number(et) && !$(et) && et % 1 === 0
    }),
    (_e.maximum = function(et, tt) {
      if ($(et)) throw new TypeError('NaN is not a valid value')
      if (!_e.arraylike(tt))
        throw new TypeError('second argument must be array-like')
      for (var rt = tt.length; --rt >= 0; ) if (et < tt[rt]) return !1
      return !0
    }),
    (_e.minimum = function(et, tt) {
      if ($(et)) throw new TypeError('NaN is not a valid value')
      if (!_e.arraylike(tt))
        throw new TypeError('second argument must be array-like')
      for (var rt = tt.length; --rt >= 0; ) if (et > tt[rt]) return !1
      return !0
    }),
    (_e.nan = function(et) {
      return !_e.number(et) || et !== et
    }),
    (_e.even = function(et) {
      return _e.infinite(et) || (_e.number(et) && et === et && et % 2 === 0)
    }),
    (_e.odd = function(et) {
      return _e.infinite(et) || (_e.number(et) && et === et && et % 2 !== 0)
    }),
    (_e.ge = function(et, tt) {
      if ($(et) || $(tt)) throw new TypeError('NaN is not a valid value')
      return !_e.infinite(et) && !_e.infinite(tt) && et >= tt
    }),
    (_e.gt = function(et, tt) {
      if ($(et) || $(tt)) throw new TypeError('NaN is not a valid value')
      return !_e.infinite(et) && !_e.infinite(tt) && et > tt
    }),
    (_e.le = function(et, tt) {
      if ($(et) || $(tt)) throw new TypeError('NaN is not a valid value')
      return !_e.infinite(et) && !_e.infinite(tt) && et <= tt
    }),
    (_e.lt = function(et, tt) {
      if ($(et) || $(tt)) throw new TypeError('NaN is not a valid value')
      return !_e.infinite(et) && !_e.infinite(tt) && et < tt
    }),
    (_e.within = function(et, tt, rt) {
      if ($(et) || $(tt) || $(rt))
        throw new TypeError('NaN is not a valid value')
      if (!_e.number(et) || !_e.number(tt) || !_e.number(rt))
        throw new TypeError('all arguments must be numbers')
      var nt = _e.infinite(et) || _e.infinite(tt) || _e.infinite(rt)
      return nt || (et >= tt && et <= rt)
    }),
    (_e.object = function(et) {
      return et && s.call(et) === '[object Object]'
    }),
    (_e.hash = function(et) {
      return (
        _e.object(et) &&
        et.constructor === Object &&
        !et.nodeType &&
        !et.setInterval
      )
    }),
    (_e.regexp = function(et) {
      return s.call(et) === '[object RegExp]'
    }),
    (_e.string = function(et) {
      return s.call(et) === '[object String]'
    }),
    is.exports
  )
}
var foreach, hasRequiredForeach
function requireForeach() {
  if (hasRequiredForeach) return foreach
  hasRequiredForeach = 1
  var o = Object.prototype.hasOwnProperty,
    a = Object.prototype.toString
  return (
    (foreach = function($, j, _e) {
      if (a.call(j) !== '[object Function]')
        throw new TypeError('iterator must be a function')
      var et = $.length
      if (et === +et) for (var tt = 0; tt < et; tt++) j.call(_e, $[tt], tt, $)
      else for (var rt in $) o.call($, rt) && j.call(_e, $[rt], rt, $)
    }),
    foreach
  )
}
var hasRequiredShim$2
function requireShim$2() {
  return (
    hasRequiredShim$2 ||
      ((hasRequiredShim$2 = 1),
      (function() {
        var o = Object.prototype.hasOwnProperty,
          a = requireIs(),
          s = requireForeach(),
          $ = !{ toString: null }.propertyIsEnumerable('toString'),
          j = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor',
          ],
          _e
        ;(_e = function(tt) {
          if (!a.object(tt) && !a.array(tt))
            throw new TypeError('Object.keys called on a non-object')
          var rt,
            nt = []
          for (rt in tt) o.call(tt, rt) && nt.push(rt)
          return (
            $ &&
              s(j, function(it) {
                o.call(tt, it) && nt.push(it)
              }),
            nt
          )
        }),
          (shim$2.exports = _e)
      })()),
    shim$2.exports
  )
}
var objectKeys$1 = Object.keys || requireShim$2(),
  hasKeys_1$1 = hasKeys$3
function hasKeys$3(o) {
  return o !== null && (typeof o == 'object' || typeof o == 'function')
}
var Keys = objectKeys$1,
  hasKeys$2 = hasKeys_1$1,
  xtend$a = extend$6
function extend$6() {
  for (var o = {}, a = 0; a < arguments.length; a++) {
    var s = arguments[a]
    if (hasKeys$2(s))
      for (var $ = Keys(s), j = 0; j < $.length; j++) {
        var _e = $[j]
        o[_e] = s[_e]
      }
  }
  return o
}
function addOperation(o, a, s, $) {
  var j = { type: o, key: a, value: s, options: $ }
  return (
    $ && $.prefix && ((j.prefix = $.prefix), delete $.prefix),
    this._operations.push(j),
    this
  )
}
function Batch$2(o) {
  ;(this._operations = []),
    (this._sdb = o),
    (this.put = addOperation.bind(this, 'put')),
    (this.del = addOperation.bind(this, 'del'))
}
var B = Batch$2.prototype
B.clear = function() {
  this._operations = []
}
B.write = function(o) {
  this._sdb.batch(this._operations, o)
}
var batch = Batch$2,
  EventEmitter = eventsExports.EventEmitter,
  inherits$3 = util$u.inherits,
  ranges$1 = stringRange,
  fixRange$1 = levelFixRange$1,
  xtend$9 = xtend$a,
  Batch$1 = batch
inherits$3(SubDB, EventEmitter)
function SubDB(o, a, s) {
  if (
    (typeof s == 'string' &&
      (console.error('db.sublevel(name, seperator<string>) is depreciated'),
      console.error('use db.sublevel(name, {sep: separator})) if you must'),
      (s = { sep: s })),
    !(this instanceof SubDB))
  )
    return new SubDB(o, a, s)
  if (!o) throw new Error('must provide db')
  if (!a) throw new Error('must provide prefix')
  ;(s = s || {}),
    (s.sep = s.sep || ''),
    (this._parent = o),
    (this._options = s),
    (this.options = s),
    (this._prefix = a),
    (this._root = root(this)),
    (o.sublevels[a] = this),
    (this.sublevels = {}),
    (this.methods = {})
  var $ = this
  this.hooks = {
    pre: function() {
      return $.pre.apply($, arguments)
    },
    post: function() {
      return $.post.apply($, arguments)
    },
  }
}
var SDB = SubDB.prototype
SDB._key = function(o) {
  var a = this._options.sep
  return a + this._prefix + a + o
}
SDB._getOptsAndCb = function(o, a) {
  return (
    typeof o == 'function' && ((a = o), (o = {})),
    { opts: xtend$9(o, this._options), cb: a }
  )
}
SDB.sublevel = function(o, a) {
  return this.sublevels[o]
    ? this.sublevels[o]
    : new SubDB(this, o, a || this._options)
}
SDB.put = function(o, a, s, $) {
  var j = this._getOptsAndCb(s, $)
  this._root.put(this.prefix(o), a, j.opts, j.cb)
}
SDB.get = function(o, a, s) {
  var $ = this._getOptsAndCb(a, s)
  this._root.get(this.prefix(o), $.opts, $.cb)
}
SDB.del = function(o, a, s) {
  var $ = this._getOptsAndCb(a, s)
  this._root.del(this.prefix(o), $.opts, $.cb)
}
SDB.batch = function(o, a, s) {
  if (!Array.isArray(o)) return new Batch$1(this)
  var $ = this,
    j = this._getOptsAndCb(a, s)
  o.forEach(function(_e) {
    typeof _e.prefix == 'string'
      ? (_e.key = _e.prefix + _e.key)
      : (_e.key = (_e.prefix || $).prefix(_e.key)),
      _e.prefix && (_e.prefix = null)
  }),
    this._root.batch(o, j.opts, j.cb)
}
SDB._getKeyEncoding = function() {
  if (this.options.keyEncoding) return this.options.keyEncoding
  if (this._parent && this._parent._getKeyEncoding)
    return this._parent._getKeyEncoding()
}
SDB._getValueEncoding = function() {
  if (this.options.valueEncoding) return this.options.valueEncoding
  if (this._parent && this._parent._getValueEncoding)
    return this._parent._getValueEncoding()
}
SDB.prefix = function(o) {
  var a = this._options.sep
  return this._parent.prefix() + a + this._prefix + a + (o || '')
}
SDB.keyStream = SDB.createKeyStream = function(o) {
  return (o = o || {}), (o.keys = !0), (o.values = !1), this.createReadStream(o)
}
SDB.valueStream = SDB.createValueStream = function(o) {
  return (
    (o = o || {}),
    (o.keys = !1),
    (o.values = !0),
    (o.keys = !1),
    this.createReadStream(o)
  )
}
function selectivelyMerge(o, a) {
  ;[
    'valueEncoding',
    'encoding',
    'keyEncoding',
    'reverse',
    'values',
    'keys',
    'limit',
    'fillCache',
  ].forEach(function(s) {
    a.hasOwnProperty(s) && (o[s] = a[s])
  })
}
SDB.readStream = SDB.createReadStream = function(o) {
  o = o || {}
  var a = root(this),
    s = this.prefix(),
    $ = ranges$1.prefix(o, s)
  selectivelyMerge($, xtend$9(o, this._options))
  var j = a.createReadStream($)
  if ($.values === !1) {
    var _e = j.read
    if (_e)
      j.read = function(tt) {
        var rt = _e.call(this, tt)
        return rt && (rt = rt.substring(s.length)), rt
      }
    else {
      var et = j.emit
      j.emit = function(tt, rt) {
        tt === 'data'
          ? et.call(this, 'data', rt.substring(s.length))
          : et.call(this, tt, rt)
      }
    }
    return j
  } else {
    if ($.keys === !1) return j
    var _e = j.read
    return (
      _e
        ? (j.read = function(rt) {
            var nt = _e.call(this, rt)
            return nt && (nt.key = nt.key.substring(s.length)), nt
          })
        : j.on('data', function(rt) {
            rt.key = rt.key.substring(s.length)
          }),
      j
    )
  }
}
SDB.writeStream = SDB.createWriteStream = function() {
  var o = root(this),
    a = this.prefix(),
    s = o.createWriteStream.apply(o, arguments),
    $ = s.write,
    j = this._options.encoding,
    _e = this._options.valueEncoding,
    et = this._options.keyEncoding,
    tt = !j && !_e && !et
  return (
    (s.write = tt
      ? function(rt) {
          return (rt.key = a + rt.key), $.call(s, rt)
        }
      : function(rt) {
          return (
            (rt.key = a + rt.key),
            j && typeof rt.encoding > 'u' && (rt.encoding = j),
            _e && typeof rt.valueEncoding > 'u' && (rt.valueEncoding = _e),
            et && typeof rt.keyEncoding > 'u' && (rt.keyEncoding = et),
            $.call(s, rt)
          )
        }),
    s
  )
}
SDB.approximateSize = function() {
  var o = root(db)
  return o.approximateSize.apply(o, arguments)
}
function root(o) {
  return o._parent ? root(o._parent) : o
}
SDB.pre = function(o, a) {
  a || ((a = o), (o = null)),
    (o = ranges$1.prefix(o, this.prefix(), this._options.sep))
  var s = root(this._parent),
    $ = this.prefix()
  return s.hooks.pre(fixRange$1(o), function(j, _e, et) {
    a(
      { key: j.key.substring($.length), value: j.value, type: j.type },
      function(tt, rt) {
        _e(tt, tt.prefix ? rt : rt || $)
      },
      et
    )
  })
}
SDB.post = function(o, a) {
  a || ((a = o), (o = null))
  var s = root(this._parent),
    $ = this.prefix()
  return (
    (o = ranges$1.prefix(o, $, this._options.sep)),
    s.hooks.post(fixRange$1(o), function(j) {
      a({ key: j.key.substring($.length), value: j.value, type: j.type })
    })
  )
}
sub.exports = SubDB
var subExports = sub.exports,
  ranges = stringRange,
  levelHooks = function(o) {
    if (o.hooks) return
    var a = [],
      s = []
    function $(at) {
      return (
        at &&
        (typeof at == 'string'
          ? at
          : typeof at.prefix == 'string'
          ? at.prefix
          : typeof at.prefix == 'function'
          ? at.prefix()
          : '')
      )
    }
    function j(at) {
      if (at && at._getKeyEncoding) return at._getKeyEncoding(at)
    }
    function _e(at) {
      if (at && at._getValueEncoding) return at._getValueEncoding(at)
    }
    function et(at, st) {
      return function() {
        var ut = at.indexOf(st)
        return ~ut ? (at.splice(ut, 1), !0) : !1
      }
    }
    o.hooks = {
      post: function(at, st) {
        st || ((st = at), (at = ''))
        var ut = { test: ranges.checker(at), hook: st }
        return a.push(ut), et(a, ut)
      },
      pre: function(at, st) {
        st || ((st = at), (at = ''))
        var ut = { test: ranges.checker(at), hook: st, safe: at.safe !== !1 }
        return s.push(ut), et(s, ut)
      },
      posthooks: a,
      prehooks: s,
    }
    function tt(at) {
      at &&
        at.type &&
        a.forEach(function(st) {
          st.test(at.key) && st.hook(at)
        })
    }
    o.on('put', function(at, st) {
      tt({ type: 'put', key: at, value: st })
    }),
      o.on('del', function(at, st) {
        tt({ type: 'del', key: at, value: st })
      }),
      o.on('batch', function(st) {
        st.forEach(tt)
      })
    var rt = o.put,
      nt = o.del,
      it = o.batch
    function ot(at, st, ut, ct) {
      try {
        st.forEach(function ft(mt, vt) {
          s.forEach(function(yt) {
            if (yt.test(String(mt.key))) {
              var pt = {
                add: function(ht, At) {
                  if (typeof ht > 'u') return this
                  if (ht === !1) return delete st[vt]
                  var wt = $(ht.prefix) || $(At) || yt.prefix || ''
                  if (
                    (wt && (ht.prefix = wt),
                    (ht.key = wt + ht.key),
                    yt.safe && yt.test(String(ht.key)))
                  )
                    throw new Error('prehook cannot insert into own range')
                  var Ct = ht.keyEncoding || j(ht.prefix),
                    Dt = ht.valueEncoding || _e(ht.prefix)
                  return (
                    Ct && (ht.keyEncoding = Ct),
                    Dt && (ht.valueEncoding = Dt),
                    st.push(ht),
                    ft(ht, st.length - 1),
                    this
                  )
                },
                put: function(ht, At) {
                  return (
                    typeof ht == 'object' && (ht.type = 'put'), this.add(ht, At)
                  )
                },
                del: function(ht, At) {
                  return (
                    typeof ht == 'object' && (ht.type = 'del'), this.add(ht, At)
                  )
                },
                veto: function() {
                  return this.add(!1)
                },
              }
              yt.hook.call(pt, mt, pt.add, st)
            }
          })
        })
      } catch (ft) {
        return (ct || ut)(ft)
      }
      if (
        ((st = st.filter(function(ft) {
          return ft && ft.type
        })),
        st.length == 1 && !at)
      ) {
        var dt = st[0]
        return dt.type == 'put'
          ? rt.call(o, dt.key, dt.value, ut, ct)
          : nt.call(o, dt.key, ut, ct)
      }
      return it.call(o, st, ut, ct)
    }
    ;(o.put = function(at, st, ut, ct) {
      var dt = [{ key: at, value: st, type: 'put' }]
      return ot(!1, dt, ut, ct)
    }),
      (o.del = function(at, st, ut) {
        var ct = [{ key: at, type: 'del' }]
        return ot(!1, ct, st, ut)
      }),
      (o.batch = function(at, st, ut) {
        return ot(!0, at, st, ut)
      })
  }
eventsExports.EventEmitter
process.nextTick
var SubDb = subExports,
  Batch = batch,
  fixRange = levelFixRange$1,
  Hooks = levelHooks,
  levelSublevel = function(o, a) {
    function s() {}
    s.prototype = o
    var $ = new s()
    if ($.sublevel) return $
    a = a || {}
    var j = (a.sep = a.sep || '')
    ;($._options = a),
      Hooks($),
      ($.sublevels = {}),
      ($.sublevel = function(tt, rt) {
        return $.sublevels[tt]
          ? $.sublevels[tt]
          : new SubDb($, tt, rt || this._options)
      }),
      ($.methods = {}),
      ($.prefix = function(tt) {
        return '' + (tt || '')
      }),
      ($.pre = function(tt, rt) {
        return rt || ((rt = tt), (tt = { max: j })), $.hooks.pre(tt, rt)
      }),
      ($.post = function(tt, rt) {
        return rt || ((rt = tt), (tt = { max: j })), $.hooks.post(tt, rt)
      })
    function _e(tt) {
      return function(rt) {
        return (
          (rt = rt || {}),
          (rt = fixRange(rt)),
          rt.reverse ? (rt.start = rt.start || j) : (rt.end = rt.end || j),
          tt.call($, rt)
        )
      }
    }
    ;($.readStream = $.createReadStream = _e($.createReadStream)),
      ($.keyStream = $.createKeyStream = _e($.createKeyStream)),
      ($.valuesStream = $.createValueStream = _e($.createValueStream))
    var et = $.batch
    return (
      ($.batch = function(tt, rt, nt) {
        if (!Array.isArray(tt)) return new Batch($)
        tt.forEach(function(it) {
          it.prefix &&
            (typeof it.prefix.prefix == 'function'
              ? (it.key = it.prefix.prefix(it.key))
              : typeof it.prefix == 'string' && (it.key = it.prefix + it.key))
        }),
          et.call($, tt, rt, nt)
      }),
      $
    )
  },
  isarray$1,
  hasRequiredIsarray
function requireIsarray() {
  return (
    hasRequiredIsarray ||
      ((hasRequiredIsarray = 1),
      (isarray$1 =
        Array.isArray ||
        function(o) {
          return Object.prototype.toString.call(o) == '[object Array]'
        })),
    isarray$1
  )
}
var string_decoder = {},
  hasRequiredString_decoder
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder
  hasRequiredString_decoder = 1
  var o = buffer$1.Buffer,
    a =
      o.isEncoding ||
      function(tt) {
        switch (tt && tt.toLowerCase()) {
          case 'hex':
          case 'utf8':
          case 'utf-8':
          case 'ascii':
          case 'binary':
          case 'base64':
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
          case 'raw':
            return !0
          default:
            return !1
        }
      }
  function s(tt) {
    if (tt && !a(tt)) throw new Error('Unknown encoding: ' + tt)
  }
  var $ = (string_decoder.StringDecoder = function(tt) {
    switch (
      ((this.encoding = (tt || 'utf8').toLowerCase().replace(/[-_]/, '')),
      s(tt),
      this.encoding)
    ) {
      case 'utf8':
        this.surrogateSize = 3
        break
      case 'ucs2':
      case 'utf16le':
        ;(this.surrogateSize = 2), (this.detectIncompleteChar = _e)
        break
      case 'base64':
        ;(this.surrogateSize = 3), (this.detectIncompleteChar = et)
        break
      default:
        this.write = j
        return
    }
    ;(this.charBuffer = new o(6)),
      (this.charReceived = 0),
      (this.charLength = 0)
  })
  ;($.prototype.write = function(tt) {
    for (var rt = ''; this.charLength; ) {
      var nt =
        tt.length >= this.charLength - this.charReceived
          ? this.charLength - this.charReceived
          : tt.length
      if (
        (tt.copy(this.charBuffer, this.charReceived, 0, nt),
        (this.charReceived += nt),
        this.charReceived < this.charLength)
      )
        return ''
      ;(tt = tt.slice(nt, tt.length)),
        (rt = this.charBuffer.slice(0, this.charLength).toString(this.encoding))
      var ot = rt.charCodeAt(rt.length - 1)
      if (ot >= 55296 && ot <= 56319) {
        ;(this.charLength += this.surrogateSize), (rt = '')
        continue
      }
      if (((this.charReceived = this.charLength = 0), tt.length === 0))
        return rt
      break
    }
    this.detectIncompleteChar(tt)
    var it = tt.length
    this.charLength &&
      (tt.copy(this.charBuffer, 0, tt.length - this.charReceived, it),
      (it -= this.charReceived)),
      (rt += tt.toString(this.encoding, 0, it))
    var it = rt.length - 1,
      ot = rt.charCodeAt(it)
    if (ot >= 55296 && ot <= 56319) {
      var at = this.surrogateSize
      return (
        (this.charLength += at),
        (this.charReceived += at),
        this.charBuffer.copy(this.charBuffer, at, 0, at),
        tt.copy(this.charBuffer, 0, 0, at),
        rt.substring(0, it)
      )
    }
    return rt
  }),
    ($.prototype.detectIncompleteChar = function(tt) {
      for (var rt = tt.length >= 3 ? 3 : tt.length; rt > 0; rt--) {
        var nt = tt[tt.length - rt]
        if (rt == 1 && nt >> 5 == 6) {
          this.charLength = 2
          break
        }
        if (rt <= 2 && nt >> 4 == 14) {
          this.charLength = 3
          break
        }
        if (rt <= 3 && nt >> 3 == 30) {
          this.charLength = 4
          break
        }
      }
      this.charReceived = rt
    }),
    ($.prototype.end = function(tt) {
      var rt = ''
      if ((tt && tt.length && (rt = this.write(tt)), this.charReceived)) {
        var nt = this.charReceived,
          it = this.charBuffer,
          ot = this.encoding
        rt += it.slice(0, nt).toString(ot)
      }
      return rt
    })
  function j(tt) {
    return tt.toString(this.encoding)
  }
  function _e(tt) {
    ;(this.charReceived = tt.length % 2),
      (this.charLength = this.charReceived ? 2 : 0)
  }
  function et(tt) {
    ;(this.charReceived = tt.length % 3),
      (this.charLength = this.charReceived ? 3 : 0)
  }
  return string_decoder
}
var _stream_readable$1, hasRequired_stream_readable$1
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1
  ;(hasRequired_stream_readable$1 = 1), (_stream_readable$1 = rt)
  var o = requireIsarray(),
    a = buffer$1.Buffer
  rt.ReadableState = tt
  var s = eventsExports.EventEmitter
  s.listenerCount ||
    (s.listenerCount = function(Et, St) {
      return Et.listeners(St).length
    })
  var $ = stream$1,
    j = util$q
  j.inherits = inherits_browserExports
  var _e,
    et = require$$0$3
  et && et.debuglog ? (et = et.debuglog('stream')) : (et = function() {}),
    j.inherits(rt, $)
  function tt(Et, St) {
    var Bt = require_stream_duplex$1()
    Et = Et || {}
    var Mt = Et.highWaterMark,
      Ut = Et.objectMode ? 16 : 16 * 1024
    ;(this.highWaterMark = Mt || Mt === 0 ? Mt : Ut),
      (this.highWaterMark = ~~this.highWaterMark),
      (this.buffer = []),
      (this.length = 0),
      (this.pipes = null),
      (this.pipesCount = 0),
      (this.flowing = null),
      (this.ended = !1),
      (this.endEmitted = !1),
      (this.reading = !1),
      (this.sync = !0),
      (this.needReadable = !1),
      (this.emittedReadable = !1),
      (this.readableListening = !1),
      (this.objectMode = !!Et.objectMode),
      St instanceof Bt &&
        (this.objectMode = this.objectMode || !!Et.readableObjectMode),
      (this.defaultEncoding = Et.defaultEncoding || 'utf8'),
      (this.ranOut = !1),
      (this.awaitDrain = 0),
      (this.readingMore = !1),
      (this.decoder = null),
      (this.encoding = null),
      Et.encoding &&
        (_e || (_e = requireString_decoder().StringDecoder),
        (this.decoder = new _e(Et.encoding)),
        (this.encoding = Et.encoding))
  }
  function rt(Et) {
    if ((require_stream_duplex$1(), !(this instanceof rt))) return new rt(Et)
    ;(this._readableState = new tt(Et, this)),
      (this.readable = !0),
      $.call(this)
  }
  ;(rt.prototype.push = function(Et, St) {
    var Bt = this._readableState
    return (
      j.isString(Et) &&
        !Bt.objectMode &&
        ((St = St || Bt.defaultEncoding),
        St !== Bt.encoding && ((Et = new a(Et, St)), (St = ''))),
      nt(this, Bt, Et, St, !1)
    )
  }),
    (rt.prototype.unshift = function(Et) {
      var St = this._readableState
      return nt(this, St, Et, '', !0)
    })
  function nt(Et, St, Bt, Mt, Ut) {
    var Wt = ut(St, Bt)
    if (Wt) Et.emit('error', Wt)
    else if (j.isNullOrUndefined(Bt)) (St.reading = !1), St.ended || ct(Et, St)
    else if (St.objectMode || (Bt && Bt.length > 0))
      if (St.ended && !Ut) {
        var Tt = new Error('stream.push() after EOF')
        Et.emit('error', Tt)
      } else if (St.endEmitted && Ut) {
        var Tt = new Error('stream.unshift() after end event')
        Et.emit('error', Tt)
      } else
        St.decoder && !Ut && !Mt && (Bt = St.decoder.write(Bt)),
          Ut || (St.reading = !1),
          St.flowing && St.length === 0 && !St.sync
            ? (Et.emit('data', Bt), Et.read(0))
            : ((St.length += St.objectMode ? 1 : Bt.length),
              Ut ? St.buffer.unshift(Bt) : St.buffer.push(Bt),
              St.needReadable && dt(Et)),
          mt(Et, St)
    else Ut || (St.reading = !1)
    return it(St)
  }
  function it(Et) {
    return (
      !Et.ended &&
      (Et.needReadable || Et.length < Et.highWaterMark || Et.length === 0)
    )
  }
  rt.prototype.setEncoding = function(Et) {
    return (
      _e || (_e = requireString_decoder().StringDecoder),
      (this._readableState.decoder = new _e(Et)),
      (this._readableState.encoding = Et),
      this
    )
  }
  var ot = 8388608
  function at(Et) {
    if (Et >= ot) Et = ot
    else {
      Et--
      for (var St = 1; St < 32; St <<= 1) Et |= Et >> St
      Et++
    }
    return Et
  }
  function st(Et, St) {
    return St.length === 0 && St.ended
      ? 0
      : St.objectMode
      ? Et === 0
        ? 0
        : 1
      : isNaN(Et) || j.isNull(Et)
      ? St.flowing && St.buffer.length
        ? St.buffer[0].length
        : St.length
      : Et <= 0
      ? 0
      : (Et > St.highWaterMark && (St.highWaterMark = at(Et)),
        Et > St.length
          ? St.ended
            ? St.length
            : ((St.needReadable = !0), 0)
          : Et)
  }
  rt.prototype.read = function(Et) {
    et('read', Et)
    var St = this._readableState,
      Bt = Et
    if (
      ((!j.isNumber(Et) || Et > 0) && (St.emittedReadable = !1),
      Et === 0 &&
        St.needReadable &&
        (St.length >= St.highWaterMark || St.ended))
    )
      return (
        et('read: emitReadable', St.length, St.ended),
        St.length === 0 && St.ended ? Ct(this) : dt(this),
        null
      )
    if (((Et = st(Et, St)), Et === 0 && St.ended))
      return St.length === 0 && Ct(this), null
    var Mt = St.needReadable
    et('need readable', Mt),
      (St.length === 0 || St.length - Et < St.highWaterMark) &&
        ((Mt = !0), et('length less than watermark', Mt)),
      (St.ended || St.reading) && ((Mt = !1), et('reading or ended', Mt)),
      Mt &&
        (et('do read'),
        (St.reading = !0),
        (St.sync = !0),
        St.length === 0 && (St.needReadable = !0),
        this._read(St.highWaterMark),
        (St.sync = !1)),
      Mt && !St.reading && (Et = st(Bt, St))
    var Ut
    return (
      Et > 0 ? (Ut = wt(Et, St)) : (Ut = null),
      j.isNull(Ut) && ((St.needReadable = !0), (Et = 0)),
      (St.length -= Et),
      St.length === 0 && !St.ended && (St.needReadable = !0),
      Bt !== Et && St.ended && St.length === 0 && Ct(this),
      j.isNull(Ut) || this.emit('data', Ut),
      Ut
    )
  }
  function ut(Et, St) {
    var Bt = null
    return (
      !j.isBuffer(St) &&
        !j.isString(St) &&
        !j.isNullOrUndefined(St) &&
        !Et.objectMode &&
        (Bt = new TypeError('Invalid non-string/buffer chunk')),
      Bt
    )
  }
  function ct(Et, St) {
    if (St.decoder && !St.ended) {
      var Bt = St.decoder.end()
      Bt &&
        Bt.length &&
        (St.buffer.push(Bt), (St.length += St.objectMode ? 1 : Bt.length))
    }
    ;(St.ended = !0), dt(Et)
  }
  function dt(Et) {
    var St = Et._readableState
    ;(St.needReadable = !1),
      St.emittedReadable ||
        (et('emitReadable', St.flowing),
        (St.emittedReadable = !0),
        St.sync
          ? process.nextTick(function() {
              ft(Et)
            })
          : ft(Et))
  }
  function ft(Et) {
    et('emit readable'), Et.emit('readable'), At(Et)
  }
  function mt(Et, St) {
    St.readingMore ||
      ((St.readingMore = !0),
      process.nextTick(function() {
        vt(Et, St)
      }))
  }
  function vt(Et, St) {
    for (
      var Bt = St.length;
      !St.reading &&
      !St.flowing &&
      !St.ended &&
      St.length < St.highWaterMark &&
      (et('maybeReadMore read 0'), Et.read(0), Bt !== St.length);

    )
      Bt = St.length
    St.readingMore = !1
  }
  ;(rt.prototype._read = function(Et) {
    this.emit('error', new Error('not implemented'))
  }),
    (rt.prototype.pipe = function(Et, St) {
      var Bt = this,
        Mt = this._readableState
      switch (Mt.pipesCount) {
        case 0:
          Mt.pipes = Et
          break
        case 1:
          Mt.pipes = [Mt.pipes, Et]
          break
        default:
          Mt.pipes.push(Et)
          break
      }
      ;(Mt.pipesCount += 1), et('pipe count=%d opts=%j', Mt.pipesCount, St)
      var Ut =
          (!St || St.end !== !1) &&
          Et !== process.stdout &&
          Et !== process.stderr,
        Wt = Ut ? kt : Nt
      Mt.endEmitted ? process.nextTick(Wt) : Bt.once('end', Wt),
        Et.on('unpipe', Tt)
      function Tt(Yt) {
        et('onunpipe'), Yt === Bt && Nt()
      }
      function kt() {
        et('onend'), Et.end()
      }
      var Ot = yt(Bt)
      Et.on('drain', Ot)
      function Nt() {
        et('cleanup'),
          Et.removeListener('close', Ft),
          Et.removeListener('finish', Vt),
          Et.removeListener('drain', Ot),
          Et.removeListener('error', Pt),
          Et.removeListener('unpipe', Tt),
          Bt.removeListener('end', kt),
          Bt.removeListener('end', Nt),
          Bt.removeListener('data', $t),
          Mt.awaitDrain &&
            (!Et._writableState || Et._writableState.needDrain) &&
            Ot()
      }
      Bt.on('data', $t)
      function $t(Yt) {
        et('ondata')
        var xt = Et.write(Yt)
        xt === !1 &&
          (et('false write response, pause', Bt._readableState.awaitDrain),
          Bt._readableState.awaitDrain++,
          Bt.pause())
      }
      function Pt(Yt) {
        et('onerror', Yt),
          Xt(),
          Et.removeListener('error', Pt),
          s.listenerCount(Et, 'error') === 0 && Et.emit('error', Yt)
      }
      !Et._events || !Et._events.error
        ? Et.on('error', Pt)
        : o(Et._events.error)
        ? Et._events.error.unshift(Pt)
        : (Et._events.error = [Pt, Et._events.error])
      function Ft() {
        Et.removeListener('finish', Vt), Xt()
      }
      Et.once('close', Ft)
      function Vt() {
        et('onfinish'), Et.removeListener('close', Ft), Xt()
      }
      Et.once('finish', Vt)
      function Xt() {
        et('unpipe'), Bt.unpipe(Et)
      }
      return (
        Et.emit('pipe', Bt), Mt.flowing || (et('pipe resume'), Bt.resume()), Et
      )
    })
  function yt(Et) {
    return function() {
      var St = Et._readableState
      et('pipeOnDrain', St.awaitDrain),
        St.awaitDrain && St.awaitDrain--,
        St.awaitDrain === 0 &&
          s.listenerCount(Et, 'data') &&
          ((St.flowing = !0), At(Et))
    }
  }
  ;(rt.prototype.unpipe = function(Et) {
    var St = this._readableState
    if (St.pipesCount === 0) return this
    if (St.pipesCount === 1)
      return Et && Et !== St.pipes
        ? this
        : (Et || (Et = St.pipes),
          (St.pipes = null),
          (St.pipesCount = 0),
          (St.flowing = !1),
          Et && Et.emit('unpipe', this),
          this)
    if (!Et) {
      var Bt = St.pipes,
        Mt = St.pipesCount
      ;(St.pipes = null), (St.pipesCount = 0), (St.flowing = !1)
      for (var Ut = 0; Ut < Mt; Ut++) Bt[Ut].emit('unpipe', this)
      return this
    }
    var Ut = jt(St.pipes, Et)
    return Ut === -1
      ? this
      : (St.pipes.splice(Ut, 1),
        (St.pipesCount -= 1),
        St.pipesCount === 1 && (St.pipes = St.pipes[0]),
        Et.emit('unpipe', this),
        this)
  }),
    (rt.prototype.on = function(Et, St) {
      var Bt = $.prototype.on.call(this, Et, St)
      if (
        (Et === 'data' && this._readableState.flowing !== !1 && this.resume(),
        Et === 'readable' && this.readable)
      ) {
        var Mt = this._readableState
        if (!Mt.readableListening)
          if (
            ((Mt.readableListening = !0),
            (Mt.emittedReadable = !1),
            (Mt.needReadable = !0),
            Mt.reading)
          )
            Mt.length && dt(this)
          else {
            var Ut = this
            process.nextTick(function() {
              et('readable nexttick read 0'), Ut.read(0)
            })
          }
      }
      return Bt
    }),
    (rt.prototype.addListener = rt.prototype.on),
    (rt.prototype.resume = function() {
      var Et = this._readableState
      return (
        Et.flowing ||
          (et('resume'),
          (Et.flowing = !0),
          Et.reading || (et('resume read 0'), this.read(0)),
          pt(this, Et)),
        this
      )
    })
  function pt(Et, St) {
    St.resumeScheduled ||
      ((St.resumeScheduled = !0),
      process.nextTick(function() {
        ht(Et, St)
      }))
  }
  function ht(Et, St) {
    ;(St.resumeScheduled = !1),
      Et.emit('resume'),
      At(Et),
      St.flowing && !St.reading && Et.read(0)
  }
  rt.prototype.pause = function() {
    return (
      et('call pause flowing=%j', this._readableState.flowing),
      this._readableState.flowing !== !1 &&
        (et('pause'), (this._readableState.flowing = !1), this.emit('pause')),
      this
    )
  }
  function At(Et) {
    var St = Et._readableState
    if ((et('flow', St.flowing), St.flowing))
      do var Bt = Et.read()
      while (Bt !== null && St.flowing)
  }
  ;(rt.prototype.wrap = function(Et) {
    var St = this._readableState,
      Bt = !1,
      Mt = this
    Et.on('end', function() {
      if ((et('wrapped end'), St.decoder && !St.ended)) {
        var Tt = St.decoder.end()
        Tt && Tt.length && Mt.push(Tt)
      }
      Mt.push(null)
    }),
      Et.on('data', function(Tt) {
        if (
          (et('wrapped data'),
          St.decoder && (Tt = St.decoder.write(Tt)),
          !(!Tt || (!St.objectMode && !Tt.length)))
        ) {
          var kt = Mt.push(Tt)
          kt || ((Bt = !0), Et.pause())
        }
      })
    for (var Ut in Et)
      j.isFunction(Et[Ut]) &&
        j.isUndefined(this[Ut]) &&
        (this[Ut] = (function(Tt) {
          return function() {
            return Et[Tt].apply(Et, arguments)
          }
        })(Ut))
    var Wt = ['error', 'close', 'destroy', 'pause', 'resume']
    return (
      Dt(Wt, function(Tt) {
        Et.on(Tt, Mt.emit.bind(Mt, Tt))
      }),
      (Mt._read = function(Tt) {
        et('wrapped _read', Tt), Bt && ((Bt = !1), Et.resume())
      }),
      Mt
    )
  }),
    (rt._fromList = wt)
  function wt(Et, St) {
    var Bt = St.buffer,
      Mt = St.length,
      Ut = !!St.decoder,
      Wt = !!St.objectMode,
      Tt
    if (Bt.length === 0) return null
    if (Mt === 0) Tt = null
    else if (Wt) Tt = Bt.shift()
    else if (!Et || Et >= Mt)
      Ut ? (Tt = Bt.join('')) : (Tt = a.concat(Bt, Mt)), (Bt.length = 0)
    else if (Et < Bt[0].length) {
      var kt = Bt[0]
      ;(Tt = kt.slice(0, Et)), (Bt[0] = kt.slice(Et))
    } else if (Et === Bt[0].length) Tt = Bt.shift()
    else {
      Ut ? (Tt = '') : (Tt = new a(Et))
      for (var Ot = 0, Nt = 0, $t = Bt.length; Nt < $t && Ot < Et; Nt++) {
        var kt = Bt[0],
          Pt = Math.min(Et - Ot, kt.length)
        Ut ? (Tt += kt.slice(0, Pt)) : kt.copy(Tt, Ot, 0, Pt),
          Pt < kt.length ? (Bt[0] = kt.slice(Pt)) : Bt.shift(),
          (Ot += Pt)
      }
    }
    return Tt
  }
  function Ct(Et) {
    var St = Et._readableState
    if (St.length > 0) throw new Error('endReadable called on non-empty stream')
    St.endEmitted ||
      ((St.ended = !0),
      process.nextTick(function() {
        !St.endEmitted &&
          St.length === 0 &&
          ((St.endEmitted = !0), (Et.readable = !1), Et.emit('end'))
      }))
  }
  function Dt(Et, St) {
    for (var Bt = 0, Mt = Et.length; Bt < Mt; Bt++) St(Et[Bt], Bt)
  }
  function jt(Et, St) {
    for (var Bt = 0, Mt = Et.length; Bt < Mt; Bt++) if (Et[Bt] === St) return Bt
    return -1
  }
  return _stream_readable$1
}
var _stream_duplex$1, hasRequired_stream_duplex$1
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1
  ;(hasRequired_stream_duplex$1 = 1), (_stream_duplex$1 = j)
  var o =
      Object.keys ||
      function(tt) {
        var rt = []
        for (var nt in tt) rt.push(nt)
        return rt
      },
    a = util$q
  a.inherits = inherits_browserExports
  var s = require_stream_readable$1(),
    $ = require_stream_writable$1()
  a.inherits(j, s),
    et(o($.prototype), function(tt) {
      j.prototype[tt] || (j.prototype[tt] = $.prototype[tt])
    })
  function j(tt) {
    if (!(this instanceof j)) return new j(tt)
    s.call(this, tt),
      $.call(this, tt),
      tt && tt.readable === !1 && (this.readable = !1),
      tt && tt.writable === !1 && (this.writable = !1),
      (this.allowHalfOpen = !0),
      tt && tt.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
      this.once('end', _e)
  }
  function _e() {
    this.allowHalfOpen ||
      this._writableState.ended ||
      process.nextTick(this.end.bind(this))
  }
  function et(tt, rt) {
    for (var nt = 0, it = tt.length; nt < it; nt++) rt(tt[nt], nt)
  }
  return _stream_duplex$1
}
var _stream_writable$1, hasRequired_stream_writable$1
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1
  ;(hasRequired_stream_writable$1 = 1), (_stream_writable$1 = _e)
  var o = buffer$1.Buffer
  _e.WritableState = j
  var a = util$q
  a.inherits = inherits_browserExports
  var s = stream$1
  a.inherits(_e, s)
  function $(pt, ht, At) {
    ;(this.chunk = pt), (this.encoding = ht), (this.callback = At)
  }
  function j(pt, ht) {
    var At = require_stream_duplex$1()
    pt = pt || {}
    var wt = pt.highWaterMark,
      Ct = pt.objectMode ? 16 : 16 * 1024
    ;(this.highWaterMark = wt || wt === 0 ? wt : Ct),
      (this.objectMode = !!pt.objectMode),
      ht instanceof At &&
        (this.objectMode = this.objectMode || !!pt.writableObjectMode),
      (this.highWaterMark = ~~this.highWaterMark),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1)
    var Dt = pt.decodeStrings === !1
    ;(this.decodeStrings = !Dt),
      (this.defaultEncoding = pt.defaultEncoding || 'utf8'),
      (this.length = 0),
      (this.writing = !1),
      (this.corked = 0),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function(jt) {
        st(ht, jt)
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.buffer = []),
      (this.pendingcb = 0),
      (this.prefinished = !1),
      (this.errorEmitted = !1)
  }
  function _e(pt) {
    var ht = require_stream_duplex$1()
    if (!(this instanceof _e) && !(this instanceof ht)) return new _e(pt)
    ;(this._writableState = new j(pt, this)), (this.writable = !0), s.call(this)
  }
  _e.prototype.pipe = function() {
    this.emit('error', new Error('Cannot pipe. Not readable.'))
  }
  function et(pt, ht, At) {
    var wt = new Error('write after end')
    pt.emit('error', wt),
      process.nextTick(function() {
        At(wt)
      })
  }
  function tt(pt, ht, At, wt) {
    var Ct = !0
    if (
      !a.isBuffer(At) &&
      !a.isString(At) &&
      !a.isNullOrUndefined(At) &&
      !ht.objectMode
    ) {
      var Dt = new TypeError('Invalid non-string/buffer chunk')
      pt.emit('error', Dt),
        process.nextTick(function() {
          wt(Dt)
        }),
        (Ct = !1)
    }
    return Ct
  }
  ;(_e.prototype.write = function(pt, ht, At) {
    var wt = this._writableState,
      Ct = !1
    return (
      a.isFunction(ht) && ((At = ht), (ht = null)),
      a.isBuffer(pt) ? (ht = 'buffer') : ht || (ht = wt.defaultEncoding),
      a.isFunction(At) || (At = function() {}),
      wt.ended
        ? et(this, wt, At)
        : tt(this, wt, pt, At) &&
          (wt.pendingcb++, (Ct = nt(this, wt, pt, ht, At))),
      Ct
    )
  }),
    (_e.prototype.cork = function() {
      var pt = this._writableState
      pt.corked++
    }),
    (_e.prototype.uncork = function() {
      var pt = this._writableState
      pt.corked &&
        (pt.corked--,
        !pt.writing &&
          !pt.corked &&
          !pt.finished &&
          !pt.bufferProcessing &&
          pt.buffer.length &&
          dt(this, pt))
    })
  function rt(pt, ht, At) {
    return (
      !pt.objectMode &&
        pt.decodeStrings !== !1 &&
        a.isString(ht) &&
        (ht = new o(ht, At)),
      ht
    )
  }
  function nt(pt, ht, At, wt, Ct) {
    ;(At = rt(ht, At, wt)), a.isBuffer(At) && (wt = 'buffer')
    var Dt = ht.objectMode ? 1 : At.length
    ht.length += Dt
    var jt = ht.length < ht.highWaterMark
    return (
      jt || (ht.needDrain = !0),
      ht.writing || ht.corked
        ? ht.buffer.push(new $(At, wt, Ct))
        : it(pt, ht, !1, Dt, At, wt, Ct),
      jt
    )
  }
  function it(pt, ht, At, wt, Ct, Dt, jt) {
    ;(ht.writelen = wt),
      (ht.writecb = jt),
      (ht.writing = !0),
      (ht.sync = !0),
      At ? pt._writev(Ct, ht.onwrite) : pt._write(Ct, Dt, ht.onwrite),
      (ht.sync = !1)
  }
  function ot(pt, ht, At, wt, Ct) {
    At
      ? process.nextTick(function() {
          ht.pendingcb--, Ct(wt)
        })
      : (ht.pendingcb--, Ct(wt)),
      (pt._writableState.errorEmitted = !0),
      pt.emit('error', wt)
  }
  function at(pt) {
    ;(pt.writing = !1),
      (pt.writecb = null),
      (pt.length -= pt.writelen),
      (pt.writelen = 0)
  }
  function st(pt, ht) {
    var At = pt._writableState,
      wt = At.sync,
      Ct = At.writecb
    if ((at(At), ht)) ot(pt, At, wt, ht, Ct)
    else {
      var Dt = ft(pt, At)
      !Dt &&
        !At.corked &&
        !At.bufferProcessing &&
        At.buffer.length &&
        dt(pt, At),
        wt
          ? process.nextTick(function() {
              ut(pt, At, Dt, Ct)
            })
          : ut(pt, At, Dt, Ct)
    }
  }
  function ut(pt, ht, At, wt) {
    At || ct(pt, ht), ht.pendingcb--, wt(), vt(pt, ht)
  }
  function ct(pt, ht) {
    ht.length === 0 && ht.needDrain && ((ht.needDrain = !1), pt.emit('drain'))
  }
  function dt(pt, ht) {
    if (((ht.bufferProcessing = !0), pt._writev && ht.buffer.length > 1)) {
      for (var At = [], wt = 0; wt < ht.buffer.length; wt++)
        At.push(ht.buffer[wt].callback)
      ht.pendingcb++,
        it(pt, ht, !0, ht.length, ht.buffer, '', function(Bt) {
          for (var Mt = 0; Mt < At.length; Mt++) ht.pendingcb--, At[Mt](Bt)
        }),
        (ht.buffer = [])
    } else {
      for (var wt = 0; wt < ht.buffer.length; wt++) {
        var Ct = ht.buffer[wt],
          Dt = Ct.chunk,
          jt = Ct.encoding,
          Et = Ct.callback,
          St = ht.objectMode ? 1 : Dt.length
        if ((it(pt, ht, !1, St, Dt, jt, Et), ht.writing)) {
          wt++
          break
        }
      }
      wt < ht.buffer.length
        ? (ht.buffer = ht.buffer.slice(wt))
        : (ht.buffer.length = 0)
    }
    ht.bufferProcessing = !1
  }
  ;(_e.prototype._write = function(pt, ht, At) {
    At(new Error('not implemented'))
  }),
    (_e.prototype._writev = null),
    (_e.prototype.end = function(pt, ht, At) {
      var wt = this._writableState
      a.isFunction(pt)
        ? ((At = pt), (pt = null), (ht = null))
        : a.isFunction(ht) && ((At = ht), (ht = null)),
        a.isNullOrUndefined(pt) || this.write(pt, ht),
        wt.corked && ((wt.corked = 1), this.uncork()),
        !wt.ending && !wt.finished && yt(this, wt, At)
    })
  function ft(pt, ht) {
    return ht.ending && ht.length === 0 && !ht.finished && !ht.writing
  }
  function mt(pt, ht) {
    ht.prefinished || ((ht.prefinished = !0), pt.emit('prefinish'))
  }
  function vt(pt, ht) {
    var At = ft(pt, ht)
    return (
      At &&
        (ht.pendingcb === 0
          ? (mt(pt, ht), (ht.finished = !0), pt.emit('finish'))
          : mt(pt, ht)),
      At
    )
  }
  function yt(pt, ht, At) {
    ;(ht.ending = !0),
      vt(pt, ht),
      At && (ht.finished ? process.nextTick(At) : pt.once('finish', At)),
      (ht.ended = !0)
  }
  return _stream_writable$1
}
var writable = require_stream_writable$1(),
  readable = { exports: {} },
  _stream_transform$1 = Transform$3,
  Duplex$1 = require_stream_duplex$1(),
  util$b = util$q
util$b.inherits = inherits_browserExports
util$b.inherits(Transform$3, Duplex$1)
function TransformState(o, a) {
  ;(this.afterTransform = function(s, $) {
    return afterTransform$1(a, s, $)
  }),
    (this.needTransform = !1),
    (this.transforming = !1),
    (this.writecb = null),
    (this.writechunk = null)
}
function afterTransform$1(o, a, s) {
  var $ = o._transformState
  $.transforming = !1
  var j = $.writecb
  if (!j) return o.emit('error', new Error('no writecb in Transform class'))
  ;($.writechunk = null),
    ($.writecb = null),
    util$b.isNullOrUndefined(s) || o.push(s),
    j && j(a)
  var _e = o._readableState
  ;(_e.reading = !1),
    (_e.needReadable || _e.length < _e.highWaterMark) &&
      o._read(_e.highWaterMark)
}
function Transform$3(o) {
  if (!(this instanceof Transform$3)) return new Transform$3(o)
  Duplex$1.call(this, o), (this._transformState = new TransformState(o, this))
  var a = this
  ;(this._readableState.needReadable = !0),
    (this._readableState.sync = !1),
    this.once('prefinish', function() {
      util$b.isFunction(this._flush)
        ? this._flush(function(s) {
            done$1(a, s)
          })
        : done$1(a)
    })
}
Transform$3.prototype.push = function(o, a) {
  return (
    (this._transformState.needTransform = !1),
    Duplex$1.prototype.push.call(this, o, a)
  )
}
Transform$3.prototype._transform = function(o, a, s) {
  throw new Error('not implemented')
}
Transform$3.prototype._write = function(o, a, s) {
  var $ = this._transformState
  if (
    (($.writecb = s),
    ($.writechunk = o),
    ($.writeencoding = a),
    !$.transforming)
  ) {
    var j = this._readableState
    ;($.needTransform || j.needReadable || j.length < j.highWaterMark) &&
      this._read(j.highWaterMark)
  }
}
Transform$3.prototype._read = function(o) {
  var a = this._transformState
  !util$b.isNull(a.writechunk) && a.writecb && !a.transforming
    ? ((a.transforming = !0),
      this._transform(a.writechunk, a.writeencoding, a.afterTransform))
    : (a.needTransform = !0)
}
function done$1(o, a) {
  if (a) return o.emit('error', a)
  var s = o._writableState,
    $ = o._transformState
  if (s.length) throw new Error('calling transform done when ws.length != 0')
  if ($.transforming)
    throw new Error('calling transform done when still transforming')
  return o.push(null)
}
var _stream_passthrough$1 = PassThrough$1,
  Transform$2 = _stream_transform$1,
  util$a = util$q
util$a.inherits = inherits_browserExports
util$a.inherits(PassThrough$1, Transform$2)
function PassThrough$1(o) {
  if (!(this instanceof PassThrough$1)) return new PassThrough$1(o)
  Transform$2.call(this, o)
}
PassThrough$1.prototype._transform = function(o, a, s) {
  s(null, o)
}
;(function(o, a) {
  var s = {}
  ;(a = o.exports = require_stream_readable$1()),
    (a.Stream = stream$1),
    (a.Readable = a),
    (a.Writable = require_stream_writable$1()),
    (a.Duplex = require_stream_duplex$1()),
    (a.Transform = _stream_transform$1),
    (a.PassThrough = _stream_passthrough$1),
    !process.browser &&
      s.READABLE_STREAM === 'disable' &&
      (o.exports = stream$1)
})(readable, readable.exports)
var readableExports = readable.exports,
  levelPeek = { exports: {} },
  levelFixRange = function(a) {
    var s = a.reverse,
      $ = a.end,
      j = a.start,
      _e = [j, $]
    return (
      j != null && $ != null && _e.sort(),
      s && (_e = _e.reverse()),
      (a.start = _e[0]),
      (a.end = _e[1]),
      a
    )
  }
;(function(o, a) {
  var s = levelFixRange
  ;(a = o.exports = j), (a.first = _e), (a.last = et)
  function $(tt, rt, nt) {
    var it = []
    return (
      rt.forEach(function(ot) {
        function at(st) {
          nt(ot, st) !== !1 &&
            it.forEach(function(ut) {
              ut()
            })
        }
        tt.on(ot, at),
          it.push(function() {
            tt.removeListener(ot, at)
          })
      }),
      tt
    )
  }
  function j(tt, rt, nt) {
    ;(rt.limit = rt.reverse ? 2 : 1),
      $(tt.createReadStream(rt), ['data', 'error', 'end'], function(it, ot) {
        if (rt.reverse && ot && rt.start && ot.key.toString() > rt.start)
          return !1
        it == 'error'
          ? nt(ot)
          : it == 'end'
          ? nt(new Error('range not found'), null, null)
          : nt(null, ot.key, ot.value)
      })
  }
  function _e(tt, rt, nt) {
    return nt || ((nt = rt), (rt = {})), (rt.reverse = !1), j(tt, s(rt), nt)
  }
  function et(tt, rt, nt) {
    return (
      nt || ((nt = rt), (rt = {})),
      rt.start,
      (rt.reverse = !0),
      j(tt, s(rt), function(it, ot, at) {
        if (it) {
          var st = rt.start
          ;(rt.start = null),
            j(tt, rt, function(ut, ct, dt) {
              if (!ct) return nt(it, null, null)
              var ft = ct.toString()
              ft <= st && (!rt.end || ft >= rt.end)
                ? nt(ut, ct, dt)
                : nt(it, null, null)
            })
        } else nt(it, ot, at)
      })
    )
  }
})(levelPeek, levelPeek.exports)
var levelPeekExports = levelPeek.exports,
  once$4 = { exports: {} },
  wrappy_1 = wrappy$1
function wrappy$1(o, a) {
  if (o && a) return wrappy$1(o)(a)
  if (typeof o != 'function') throw new TypeError('need wrapper function')
  return (
    Object.keys(o).forEach(function($) {
      s[$] = o[$]
    }),
    s
  )
  function s() {
    for (var $ = new Array(arguments.length), j = 0; j < $.length; j++)
      $[j] = arguments[j]
    var _e = o.apply(this, $),
      et = $[$.length - 1]
    return (
      typeof _e == 'function' &&
        _e !== et &&
        Object.keys(et).forEach(function(tt) {
          _e[tt] = et[tt]
        }),
      _e
    )
  }
}
var wrappy = wrappy_1
once$4.exports = wrappy(once$3)
once$4.exports.strict = wrappy(onceStrict)
once$3.proto = once$3(function() {
  Object.defineProperty(Function.prototype, 'once', {
    value: function() {
      return once$3(this)
    },
    configurable: !0,
  }),
    Object.defineProperty(Function.prototype, 'onceStrict', {
      value: function() {
        return onceStrict(this)
      },
      configurable: !0,
    })
})
function once$3(o) {
  var a = function() {
    return a.called
      ? a.value
      : ((a.called = !0), (a.value = o.apply(this, arguments)))
  }
  return (a.called = !1), a
}
function onceStrict(o) {
  var a = function() {
      if (a.called) throw new Error(a.onceError)
      return (a.called = !0), (a.value = o.apply(this, arguments))
    },
    s = o.name || 'Function wrapped with `once`'
  return (
    (a.onceError = s + " shouldn't be called more than once"),
    (a.called = !1),
    a
  )
}
var onceExports = once$4.exports,
  Writable$1 = writable,
  Readable = readableExports,
  peek$1 = levelPeekExports,
  util$9 = util$u,
  once$2 = onceExports,
  EMPTY = new Buffer(0),
  ENCODER = {
    encode: function(o) {
      return typeof o == 'string' ? (o = new Buffer(o)) : o
    },
    decode: function(o) {
      return Buffer.isBuffer(o) ? o : new Buffer(o)
    },
    buffer: !0,
    type: 'raw',
  },
  noop$7 = function() {},
  pad = function(o) {
    return (o = o.toString(16)), '00000000'.slice(0, -o.length) + o
  },
  expand = function(o, a) {
    var s = new Buffer(a)
    return o.copy(s), s
  },
  levelBlobs = function(o, a) {
    a || (a = {})
    var s = {},
      $ = a.blockSize || 65536,
      j = a.batch || 100,
      _e = new Buffer($)
    o.put('\0', 'ignore', noop$7)
    var et = {},
      tt = function(it, ot, at, st, ut) {
        var ct = function() {
            --et[it].locks || delete et[it]
          },
          dt = function(ft) {
            if ((ft.locks++, !ft.block && !ot)) {
              ;(ft.block = at), ut(null, ft.block, ct)
              return
            }
            ft.block || (ft.block = new Buffer($)),
              ft.block.length < ot + at.length &&
                (ft.block = expand(ft.block, ot + at.length)),
              at.copy(ft.block, ot),
              !st &&
                ot + at.length < ft.block.length &&
                (ft.block = ft.block.slice(0, ot + at.length)),
              ut(null, ft.block, ct)
          }
        if (et[it]) return dt(et[it])
        o.get(it, { valueEncoding: ENCODER }, function(ft, mt) {
          if (ft && !ft.notFound) return ut(ft)
          et[it] || (et[it] = { locks: 0, block: mt }), dt(et[it])
        })
      },
      rt = function(it, ot) {
        if (!(this instanceof rt)) return new rt(it, ot)
        ot || (ot = {}),
          (this.name = it),
          (this.blocks = []),
          (this.batch = []),
          (this.bytesWritten = 0),
          (this.truncate = !ot.append),
          (this.append = ot.append),
          (this._shouldInitAppend = this.append && ot.start === void 0),
          (this._destroyed = !1),
          this._init(ot.start || 0),
          Writable$1.call(this)
      }
    util$9.inherits(rt, Writable$1),
      (rt.prototype._init = function(it) {
        ;(this.blockIndex = (it / $) | 0),
          (this.blockOffset = it - this.blockIndex * $),
          (this.blockLength = this.blockOffset)
      }),
      (rt.prototype._flush = function(it) {
        if (!this.batch.length) return it()
        var ot = this.batch[this.batch.length - 1].key,
          at = this.batch
        if (((this.batch = []), !this.truncate)) return o.batch(at, it)
        ;(this.truncate = !1), this._truncate(at, ot, it)
      }),
      (rt.prototype._truncate = function(it, ot, at) {
        at = once$2(at)
        var st = [],
          ut = o.createKeyStream({ start: ot, end: this.name + '' })
        ut.on('error', at),
          ut.on('data', function(ct) {
            st.push({ type: 'del', key: ct })
          }),
          ut.on('end', function() {
            st.push.apply(st, it), o.batch(st, at)
          })
      }),
      (rt.prototype._writeBlock = function(it) {
        var ot =
            this.blocks.length === 1
              ? this.blocks[0]
              : Buffer.concat(this.blocks, this.blockLength - this.blockOffset),
          at = this.blockIndex,
          st = this.blockOffset,
          ut = this
        ;(this.blockOffset = 0),
          (this.blockLength = 0),
          this.blockIndex++,
          (this.blocks = [])
        var ct = this.name + '' + pad(at),
          dt = function(ft, mt, vt) {
            return (
              ft.length &&
                ut.batch.push({
                  type: 'put',
                  key: ct,
                  value: ft,
                  valueEncoding: ENCODER,
                }),
              !mt && ut.batch.length < j ? vt() : ut._flush(vt)
            )
          }
        if ((!st && ot.length === $) || (!st && !this.append))
          return dt(ot, !1, it)
        tt(ct, st, ot, this.append, function(ft, mt, vt) {
          if (ft) return it(ft)
          dt(mt, !0, function(yt) {
            vt(), it(yt)
          })
        })
      }),
      (rt.prototype._initAppend = function(it, ot, at) {
        var st = this
        ;(this._shouldInitAppend = !1),
          s.size(this.name, function(ut, ct) {
            if (ut) return at(ut)
            st._init(ct), st._write(it, ot, at)
          })
      }),
      (rt.prototype._write = function(it, ot, at) {
        if (!it.length || this._destroyed) return at()
        if (this._shouldInitAppend) return this._initAppend(it, ot, at)
        var st = this,
          ut,
          ct = $ - this.blockLength,
          dt = function(ft) {
            if (ft) return at(ft)
            if (ut) return st._write(ut, ot, at)
            at()
          }
        if (
          (it.length > ct && ((ut = it.slice(ct)), (it = it.slice(0, ct))),
          (this.bytesWritten += it.length),
          (this.blockLength += it.length),
          this.blocks.push(it),
          it.length < ct)
        )
          return dt()
        this._writeBlock(dt)
      }),
      (rt.prototype.destroy = function() {
        this._destroyed ||
          ((this._destroyed = !0),
          process.nextTick(this.emit.bind(this, 'close')))
      }),
      (rt.prototype.end = function(it) {
        var ot = this,
          at = arguments
        it && typeof it != 'function' && (this.write(it), (it = EMPTY)),
          this.write(EMPTY, function() {
            ot._writeBlock(function(st) {
              if (st) return ot.emit('error', st)
              ot._flush(function(ut) {
                if (ut) return ot.emit('error', ut)
                Writable$1.prototype.end.apply(ot, at)
              })
            })
          })
      })
    var nt = function(it, ot) {
      ot || (ot = {})
      var at = this,
        st = ot.start || 0,
        ut = (st / $) | 0,
        ct = st - ut * $,
        dt = it + '' + pad(ut)
      ;(this.name = it),
        (this._missing = (typeof ot.end == 'number' ? ot.end : 1 / 0) - st + 1),
        (this._paused = !1),
        (this._destroyed = !1),
        (this._reader = o.createReadStream({
          start: dt,
          end: it + '',
          valueEncoding: ENCODER,
        }))
      var ft = function(mt) {
        return (
          (dt = it + '' + pad(++ut)),
          at._missing
            ? ct && ((mt = mt.slice(ct)), (ct = 0), !mt.length)
              ? !0
              : (mt.length > at._missing && (mt = mt.slice(0, at._missing)),
                (at._missing -= mt.length),
                at._pause(!at.push(mt)),
                !!at._missing)
            : !1
        )
      }
      this._reader.on('data', function(mt) {
        for (; mt.key > dt; ) if (!ft(_e)) return
        ft(mt.value)
      }),
        this._reader.on('error', function(mt) {
          at.emit('error', mt)
        }),
        this._reader.on('end', function() {
          at.push(null)
        }),
        Readable.call(this)
    }
    return (
      util$9.inherits(nt, Readable),
      (nt.prototype.destroy = function() {
        this._destroyed ||
          ((this._destroyed = !0),
          this._reader.destroy(),
          process.nextTick(this.emit.bind(this, 'close')))
      }),
      (nt.prototype._pause = function(it) {
        this._paused !== it &&
          ((this._paused = it),
          this._paused ? this._reader.pause() : this._reader.resume())
      }),
      (nt.prototype._read = function() {
        this._pause(!1)
      }),
      (s.remove = function(it, ot) {
        ot = once$2(ot || noop$7)
        var at = [],
          st = o.createKeyStream({ start: it + '', end: it + '' })
        st.on('error', ot),
          st.on('data', function(ut) {
            at.push({ type: 'del', key: ut })
          }),
          st.on('end', function() {
            o.batch(at, ot)
          })
      }),
      (s.size = function(it, ot) {
        peek$1.last(
          o,
          { start: it + '', end: it + '', valueEncoding: ENCODER },
          function(at, st, ut) {
            if (at && at.message === 'range not found') return ot(null, 0)
            if (at) return ot(at)
            if (st.slice(0, it.length + 1) !== it + '') return ot(null, 0)
            ot(
              null,
              parseInt(st.toString().slice(it.length + 1), 16) * $ + ut.length
            )
          }
        )
      }),
      (s.write = function(it, ot, at, st) {
        if (typeof at == 'function') return s.write(it, ot, null, at)
        at || (at = {}), st || (st = noop$7)
        var ut = s.createWriteStream(it, at)
        ut.on('error', st),
          ut.on('finish', function() {
            st()
          }),
          ut.write(ot),
          ut.end()
      }),
      (s.read = function(it, ot, at) {
        if (typeof ot == 'function') return s.read(it, null, ot)
        ot || (ot = {})
        var st = s.createReadStream(it, ot),
          ut = []
        st.on('error', at),
          st.on('data', function(ct) {
            ut.push(ct)
          }),
          st.on('end', function() {
            at(null, ut.length === 1 ? ut[0] : Buffer.concat(ut))
          })
      }),
      (s.createReadStream = function(it, ot) {
        return new nt(it, ot)
      }),
      (s.createWriteStream = function(it, ot) {
        return new rt(it, ot)
      }),
      s
    )
  },
  octal$2 = function(o, a) {
    return parseInt(o.toString(), a || 8)
  },
  errno$2 = {}
;(function(o) {
  var a = errnoExports
  Object.keys(a.code).forEach(function(s) {
    var $ = a.code[s]
    o[s] = function(j) {
      var _e = new Error(s + ', ' + $.description + (j ? " '" + j + "'" : ''))
      return (_e.errno = $.errno), (_e.code = s), (_e.path = j), _e
    }
  })
})(errno$2)
function assertPath$1(o) {
  if (typeof o != 'string')
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(o))
}
function normalizeStringPosix(o, a) {
  for (var s = '', $ = 0, j = -1, _e = 0, et, tt = 0; tt <= o.length; ++tt) {
    if (tt < o.length) et = o.charCodeAt(tt)
    else {
      if (et === 47) break
      et = 47
    }
    if (et === 47) {
      if (!(j === tt - 1 || _e === 1))
        if (j !== tt - 1 && _e === 2) {
          if (
            s.length < 2 ||
            $ !== 2 ||
            s.charCodeAt(s.length - 1) !== 46 ||
            s.charCodeAt(s.length - 2) !== 46
          ) {
            if (s.length > 2) {
              var rt = s.lastIndexOf('/')
              if (rt !== s.length - 1) {
                rt === -1
                  ? ((s = ''), ($ = 0))
                  : ((s = s.slice(0, rt)),
                    ($ = s.length - 1 - s.lastIndexOf('/'))),
                  (j = tt),
                  (_e = 0)
                continue
              }
            } else if (s.length === 2 || s.length === 1) {
              ;(s = ''), ($ = 0), (j = tt), (_e = 0)
              continue
            }
          }
          a && (s.length > 0 ? (s += '/..') : (s = '..'), ($ = 2))
        } else
          s.length > 0
            ? (s += '/' + o.slice(j + 1, tt))
            : (s = o.slice(j + 1, tt)),
            ($ = tt - j - 1)
      ;(j = tt), (_e = 0)
    } else et === 46 && _e !== -1 ? ++_e : (_e = -1)
  }
  return s
}
function _format(o, a) {
  var s = a.dir || a.root,
    $ = a.base || (a.name || '') + (a.ext || '')
  return s ? (s === a.root ? s + $ : s + o + $) : $
}
var posix = {
  resolve: function() {
    for (var a = '', s = !1, $, j = arguments.length - 1; j >= -1 && !s; j--) {
      var _e
      j >= 0
        ? (_e = arguments[j])
        : ($ === void 0 && ($ = process.cwd()), (_e = $)),
        assertPath$1(_e),
        _e.length !== 0 && ((a = _e + '/' + a), (s = _e.charCodeAt(0) === 47))
    }
    return (
      (a = normalizeStringPosix(a, !s)),
      s ? (a.length > 0 ? '/' + a : '/') : a.length > 0 ? a : '.'
    )
  },
  normalize: function(a) {
    if ((assertPath$1(a), a.length === 0)) return '.'
    var s = a.charCodeAt(0) === 47,
      $ = a.charCodeAt(a.length - 1) === 47
    return (
      (a = normalizeStringPosix(a, !s)),
      a.length === 0 && !s && (a = '.'),
      a.length > 0 && $ && (a += '/'),
      s ? '/' + a : a
    )
  },
  isAbsolute: function(a) {
    return assertPath$1(a), a.length > 0 && a.charCodeAt(0) === 47
  },
  join: function() {
    if (arguments.length === 0) return '.'
    for (var a, s = 0; s < arguments.length; ++s) {
      var $ = arguments[s]
      assertPath$1($), $.length > 0 && (a === void 0 ? (a = $) : (a += '/' + $))
    }
    return a === void 0 ? '.' : posix.normalize(a)
  },
  relative: function(a, s) {
    if (
      (assertPath$1(a),
      assertPath$1(s),
      a === s || ((a = posix.resolve(a)), (s = posix.resolve(s)), a === s))
    )
      return ''
    for (var $ = 1; $ < a.length && a.charCodeAt($) === 47; ++$);
    for (
      var j = a.length, _e = j - $, et = 1;
      et < s.length && s.charCodeAt(et) === 47;
      ++et
    );
    for (
      var tt = s.length, rt = tt - et, nt = _e < rt ? _e : rt, it = -1, ot = 0;
      ot <= nt;
      ++ot
    ) {
      if (ot === nt) {
        if (rt > nt) {
          if (s.charCodeAt(et + ot) === 47) return s.slice(et + ot + 1)
          if (ot === 0) return s.slice(et + ot)
        } else
          _e > nt &&
            (a.charCodeAt($ + ot) === 47 ? (it = ot) : ot === 0 && (it = 0))
        break
      }
      var at = a.charCodeAt($ + ot),
        st = s.charCodeAt(et + ot)
      if (at !== st) break
      at === 47 && (it = ot)
    }
    var ut = ''
    for (ot = $ + it + 1; ot <= j; ++ot)
      (ot === j || a.charCodeAt(ot) === 47) &&
        (ut.length === 0 ? (ut += '..') : (ut += '/..'))
    return ut.length > 0
      ? ut + s.slice(et + it)
      : ((et += it), s.charCodeAt(et) === 47 && ++et, s.slice(et))
  },
  _makeLong: function(a) {
    return a
  },
  dirname: function(a) {
    if ((assertPath$1(a), a.length === 0)) return '.'
    for (
      var s = a.charCodeAt(0), $ = s === 47, j = -1, _e = !0, et = a.length - 1;
      et >= 1;
      --et
    )
      if (((s = a.charCodeAt(et)), s === 47)) {
        if (!_e) {
          j = et
          break
        }
      } else _e = !1
    return j === -1 ? ($ ? '/' : '.') : $ && j === 1 ? '//' : a.slice(0, j)
  },
  basename: function(a, s) {
    if (s !== void 0 && typeof s != 'string')
      throw new TypeError('"ext" argument must be a string')
    assertPath$1(a)
    var $ = 0,
      j = -1,
      _e = !0,
      et
    if (s !== void 0 && s.length > 0 && s.length <= a.length) {
      if (s.length === a.length && s === a) return ''
      var tt = s.length - 1,
        rt = -1
      for (et = a.length - 1; et >= 0; --et) {
        var nt = a.charCodeAt(et)
        if (nt === 47) {
          if (!_e) {
            $ = et + 1
            break
          }
        } else
          rt === -1 && ((_e = !1), (rt = et + 1)),
            tt >= 0 &&
              (nt === s.charCodeAt(tt)
                ? --tt === -1 && (j = et)
                : ((tt = -1), (j = rt)))
      }
      return $ === j ? (j = rt) : j === -1 && (j = a.length), a.slice($, j)
    } else {
      for (et = a.length - 1; et >= 0; --et)
        if (a.charCodeAt(et) === 47) {
          if (!_e) {
            $ = et + 1
            break
          }
        } else j === -1 && ((_e = !1), (j = et + 1))
      return j === -1 ? '' : a.slice($, j)
    }
  },
  extname: function(a) {
    assertPath$1(a)
    for (
      var s = -1, $ = 0, j = -1, _e = !0, et = 0, tt = a.length - 1;
      tt >= 0;
      --tt
    ) {
      var rt = a.charCodeAt(tt)
      if (rt === 47) {
        if (!_e) {
          $ = tt + 1
          break
        }
        continue
      }
      j === -1 && ((_e = !1), (j = tt + 1)),
        rt === 46
          ? s === -1
            ? (s = tt)
            : et !== 1 && (et = 1)
          : s !== -1 && (et = -1)
    }
    return s === -1 ||
      j === -1 ||
      et === 0 ||
      (et === 1 && s === j - 1 && s === $ + 1)
      ? ''
      : a.slice(s, j)
  },
  format: function(a) {
    if (a === null || typeof a != 'object')
      throw new TypeError(
        'The "pathObject" argument must be of type Object. Received type ' +
          typeof a
      )
    return _format('/', a)
  },
  parse: function(a) {
    assertPath$1(a)
    var s = { root: '', dir: '', base: '', ext: '', name: '' }
    if (a.length === 0) return s
    var $ = a.charCodeAt(0),
      j = $ === 47,
      _e
    j ? ((s.root = '/'), (_e = 1)) : (_e = 0)
    for (
      var et = -1, tt = 0, rt = -1, nt = !0, it = a.length - 1, ot = 0;
      it >= _e;
      --it
    ) {
      if ((($ = a.charCodeAt(it)), $ === 47)) {
        if (!nt) {
          tt = it + 1
          break
        }
        continue
      }
      rt === -1 && ((nt = !1), (rt = it + 1)),
        $ === 46
          ? et === -1
            ? (et = it)
            : ot !== 1 && (ot = 1)
          : et !== -1 && (ot = -1)
    }
    return (
      et === -1 ||
      rt === -1 ||
      ot === 0 ||
      (ot === 1 && et === rt - 1 && et === tt + 1)
        ? rt !== -1 &&
          (tt === 0 && j
            ? (s.base = s.name = a.slice(1, rt))
            : (s.base = s.name = a.slice(tt, rt)))
        : (tt === 0 && j
            ? ((s.name = a.slice(1, et)), (s.base = a.slice(1, rt)))
            : ((s.name = a.slice(tt, et)), (s.base = a.slice(tt, rt))),
          (s.ext = a.slice(et, rt))),
      tt > 0 ? (s.dir = a.slice(0, tt - 1)) : j && (s.dir = '/'),
      s
    )
  },
  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null,
}
posix.posix = posix
var path$3 = posix
const Path = getDefaultExportFromCjs(path$3)
var readableBrowser = { exports: {} },
  processNextickArgs = { exports: {} }
typeof process > 'u' ||
!process.version ||
process.version.indexOf('v0.') === 0 ||
(process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0)
  ? (processNextickArgs.exports = { nextTick: nextTick$1 })
  : (processNextickArgs.exports = process)
function nextTick$1(o, a, s, $) {
  if (typeof o != 'function')
    throw new TypeError('"callback" argument must be a function')
  var j = arguments.length,
    _e,
    et
  switch (j) {
    case 0:
    case 1:
      return process.nextTick(o)
    case 2:
      return process.nextTick(function() {
        o.call(null, a)
      })
    case 3:
      return process.nextTick(function() {
        o.call(null, a, s)
      })
    case 4:
      return process.nextTick(function() {
        o.call(null, a, s, $)
      })
    default:
      for (_e = new Array(j - 1), et = 0; et < _e.length; )
        _e[et++] = arguments[et]
      return process.nextTick(function() {
        o.apply(null, _e)
      })
  }
}
var processNextickArgsExports = processNextickArgs.exports,
  toString$4 = {}.toString,
  isarray =
    Array.isArray ||
    function(o) {
      return toString$4.call(o) == '[object Array]'
    },
  streamBrowser = eventsExports.EventEmitter,
  safeBuffer = { exports: {} }
;(function(o, a) {
  var s = buffer$1,
    $ = s.Buffer
  function j(et, tt) {
    for (var rt in et) tt[rt] = et[rt]
  }
  $.from && $.alloc && $.allocUnsafe && $.allocUnsafeSlow
    ? (o.exports = s)
    : (j(s, a), (a.Buffer = _e))
  function _e(et, tt, rt) {
    return $(et, tt, rt)
  }
  j($, _e),
    (_e.from = function(et, tt, rt) {
      if (typeof et == 'number')
        throw new TypeError('Argument must not be a number')
      return $(et, tt, rt)
    }),
    (_e.alloc = function(et, tt, rt) {
      if (typeof et != 'number')
        throw new TypeError('Argument must be a number')
      var nt = $(et)
      return (
        tt !== void 0
          ? typeof rt == 'string'
            ? nt.fill(tt, rt)
            : nt.fill(tt)
          : nt.fill(0),
        nt
      )
    }),
    (_e.allocUnsafe = function(et) {
      if (typeof et != 'number')
        throw new TypeError('Argument must be a number')
      return $(et)
    }),
    (_e.allocUnsafeSlow = function(et) {
      if (typeof et != 'number')
        throw new TypeError('Argument must be a number')
      return s.SlowBuffer(et)
    })
})(safeBuffer, safeBuffer.exports)
var safeBufferExports = safeBuffer.exports,
  BufferList = { exports: {} },
  hasRequiredBufferList
function requireBufferList() {
  return (
    hasRequiredBufferList ||
      ((hasRequiredBufferList = 1),
      (function(o) {
        function a(_e, et) {
          if (!(_e instanceof et))
            throw new TypeError('Cannot call a class as a function')
        }
        var s = safeBufferExports.Buffer,
          $ = require$$0$3
        function j(_e, et, tt) {
          _e.copy(et, tt)
        }
        ;(o.exports = (function() {
          function _e() {
            a(this, _e),
              (this.head = null),
              (this.tail = null),
              (this.length = 0)
          }
          return (
            (_e.prototype.push = function(tt) {
              var rt = { data: tt, next: null }
              this.length > 0 ? (this.tail.next = rt) : (this.head = rt),
                (this.tail = rt),
                ++this.length
            }),
            (_e.prototype.unshift = function(tt) {
              var rt = { data: tt, next: this.head }
              this.length === 0 && (this.tail = rt),
                (this.head = rt),
                ++this.length
            }),
            (_e.prototype.shift = function() {
              if (this.length !== 0) {
                var tt = this.head.data
                return (
                  this.length === 1
                    ? (this.head = this.tail = null)
                    : (this.head = this.head.next),
                  --this.length,
                  tt
                )
              }
            }),
            (_e.prototype.clear = function() {
              ;(this.head = this.tail = null), (this.length = 0)
            }),
            (_e.prototype.join = function(tt) {
              if (this.length === 0) return ''
              for (var rt = this.head, nt = '' + rt.data; (rt = rt.next); )
                nt += tt + rt.data
              return nt
            }),
            (_e.prototype.concat = function(tt) {
              if (this.length === 0) return s.alloc(0)
              for (
                var rt = s.allocUnsafe(tt >>> 0), nt = this.head, it = 0;
                nt;

              )
                j(nt.data, rt, it), (it += nt.data.length), (nt = nt.next)
              return rt
            }),
            _e
          )
        })()),
          $ &&
            $.inspect &&
            $.inspect.custom &&
            (o.exports.prototype[$.inspect.custom] = function() {
              var _e = $.inspect({ length: this.length })
              return this.constructor.name + ' ' + _e
            })
      })(BufferList)),
    BufferList.exports
  )
}
var pna = processNextickArgsExports
function destroy(o, a) {
  var s = this,
    $ = this._readableState && this._readableState.destroyed,
    j = this._writableState && this._writableState.destroyed
  return $ || j
    ? (a
        ? a(o)
        : o &&
          (this._writableState
            ? this._writableState.errorEmitted ||
              ((this._writableState.errorEmitted = !0),
              pna.nextTick(emitErrorNT, this, o))
            : pna.nextTick(emitErrorNT, this, o)),
      this)
    : (this._readableState && (this._readableState.destroyed = !0),
      this._writableState && (this._writableState.destroyed = !0),
      this._destroy(o || null, function(_e) {
        !a && _e
          ? s._writableState
            ? s._writableState.errorEmitted ||
              ((s._writableState.errorEmitted = !0),
              pna.nextTick(emitErrorNT, s, _e))
            : pna.nextTick(emitErrorNT, s, _e)
          : a && a(_e)
      }),
      this)
}
function undestroy() {
  this._readableState &&
    ((this._readableState.destroyed = !1),
    (this._readableState.reading = !1),
    (this._readableState.ended = !1),
    (this._readableState.endEmitted = !1)),
    this._writableState &&
      ((this._writableState.destroyed = !1),
      (this._writableState.ended = !1),
      (this._writableState.ending = !1),
      (this._writableState.finalCalled = !1),
      (this._writableState.prefinished = !1),
      (this._writableState.finished = !1),
      (this._writableState.errorEmitted = !1))
}
function emitErrorNT(o, a) {
  o.emit('error', a)
}
var destroy_1 = { destroy, undestroy },
  _stream_writable,
  hasRequired_stream_writable
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable
  hasRequired_stream_writable = 1
  var o = {},
    a = processNextickArgsExports
  _stream_writable = dt
  function s(Tt) {
    var kt = this
    ;(this.next = null),
      (this.entry = null),
      (this.finish = function() {
        Wt(kt, Tt)
      })
  }
  var $ =
      !process.browser &&
      ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1
        ? setImmediate
        : a.nextTick,
    j
  dt.WritableState = ut
  var _e = Object.create(util$q)
  _e.inherits = inherits_browserExports
  var et = { deprecate: requireBrowser() },
    tt = streamBrowser,
    rt = safeBufferExports.Buffer,
    nt =
      (typeof o < 'u'
        ? o
        : typeof window < 'u'
        ? window
        : typeof self < 'u'
        ? self
        : {}
      ).Uint8Array || function() {}
  function it(Tt) {
    return rt.from(Tt)
  }
  function ot(Tt) {
    return rt.isBuffer(Tt) || Tt instanceof nt
  }
  var at = destroy_1
  _e.inherits(dt, tt)
  function st() {}
  function ut(Tt, kt) {
    ;(j = j || require_stream_duplex()), (Tt = Tt || {})
    var Ot = kt instanceof j
    ;(this.objectMode = !!Tt.objectMode),
      Ot && (this.objectMode = this.objectMode || !!Tt.writableObjectMode)
    var Nt = Tt.highWaterMark,
      $t = Tt.writableHighWaterMark,
      Pt = this.objectMode ? 16 : 16 * 1024
    Nt || Nt === 0
      ? (this.highWaterMark = Nt)
      : Ot && ($t || $t === 0)
      ? (this.highWaterMark = $t)
      : (this.highWaterMark = Pt),
      (this.highWaterMark = Math.floor(this.highWaterMark)),
      (this.finalCalled = !1),
      (this.needDrain = !1),
      (this.ending = !1),
      (this.ended = !1),
      (this.finished = !1),
      (this.destroyed = !1)
    var Ft = Tt.decodeStrings === !1
    ;(this.decodeStrings = !Ft),
      (this.defaultEncoding = Tt.defaultEncoding || 'utf8'),
      (this.length = 0),
      (this.writing = !1),
      (this.corked = 0),
      (this.sync = !0),
      (this.bufferProcessing = !1),
      (this.onwrite = function(Vt) {
        wt(kt, Vt)
      }),
      (this.writecb = null),
      (this.writelen = 0),
      (this.bufferedRequest = null),
      (this.lastBufferedRequest = null),
      (this.pendingcb = 0),
      (this.prefinished = !1),
      (this.errorEmitted = !1),
      (this.bufferedRequestCount = 0),
      (this.corkedRequestsFree = new s(this))
  }
  ;(ut.prototype.getBuffer = function() {
    for (var kt = this.bufferedRequest, Ot = []; kt; )
      Ot.push(kt), (kt = kt.next)
    return Ot
  }),
    (function() {
      try {
        Object.defineProperty(ut.prototype, 'buffer', {
          get: et.deprecate(
            function() {
              return this.getBuffer()
            },
            '_writableState.buffer is deprecated. Use _writableState.getBuffer instead.',
            'DEP0003'
          ),
        })
      } catch {}
    })()
  var ct
  typeof Symbol == 'function' &&
  Symbol.hasInstance &&
  typeof Function.prototype[Symbol.hasInstance] == 'function'
    ? ((ct = Function.prototype[Symbol.hasInstance]),
      Object.defineProperty(dt, Symbol.hasInstance, {
        value: function(Tt) {
          return ct.call(this, Tt)
            ? !0
            : this !== dt
            ? !1
            : Tt && Tt._writableState instanceof ut
        },
      }))
    : (ct = function(Tt) {
        return Tt instanceof this
      })
  function dt(Tt) {
    if (
      ((j = j || require_stream_duplex()),
      !ct.call(dt, this) && !(this instanceof j))
    )
      return new dt(Tt)
    ;(this._writableState = new ut(Tt, this)),
      (this.writable = !0),
      Tt &&
        (typeof Tt.write == 'function' && (this._write = Tt.write),
        typeof Tt.writev == 'function' && (this._writev = Tt.writev),
        typeof Tt.destroy == 'function' && (this._destroy = Tt.destroy),
        typeof Tt.final == 'function' && (this._final = Tt.final)),
      tt.call(this)
  }
  dt.prototype.pipe = function() {
    this.emit('error', new Error('Cannot pipe, not readable'))
  }
  function ft(Tt, kt) {
    var Ot = new Error('write after end')
    Tt.emit('error', Ot), a.nextTick(kt, Ot)
  }
  function mt(Tt, kt, Ot, Nt) {
    var $t = !0,
      Pt = !1
    return (
      Ot === null
        ? (Pt = new TypeError('May not write null values to stream'))
        : typeof Ot != 'string' &&
          Ot !== void 0 &&
          !kt.objectMode &&
          (Pt = new TypeError('Invalid non-string/buffer chunk')),
      Pt && (Tt.emit('error', Pt), a.nextTick(Nt, Pt), ($t = !1)),
      $t
    )
  }
  ;(dt.prototype.write = function(Tt, kt, Ot) {
    var Nt = this._writableState,
      $t = !1,
      Pt = !Nt.objectMode && ot(Tt)
    return (
      Pt && !rt.isBuffer(Tt) && (Tt = it(Tt)),
      typeof kt == 'function' && ((Ot = kt), (kt = null)),
      Pt ? (kt = 'buffer') : kt || (kt = Nt.defaultEncoding),
      typeof Ot != 'function' && (Ot = st),
      Nt.ended
        ? ft(this, Ot)
        : (Pt || mt(this, Nt, Tt, Ot)) &&
          (Nt.pendingcb++, ($t = yt(this, Nt, Pt, Tt, kt, Ot))),
      $t
    )
  }),
    (dt.prototype.cork = function() {
      var Tt = this._writableState
      Tt.corked++
    }),
    (dt.prototype.uncork = function() {
      var Tt = this._writableState
      Tt.corked &&
        (Tt.corked--,
        !Tt.writing &&
          !Tt.corked &&
          !Tt.bufferProcessing &&
          Tt.bufferedRequest &&
          jt(this, Tt))
    }),
    (dt.prototype.setDefaultEncoding = function(kt) {
      if (
        (typeof kt == 'string' && (kt = kt.toLowerCase()),
        !(
          [
            'hex',
            'utf8',
            'utf-8',
            'ascii',
            'binary',
            'base64',
            'ucs2',
            'ucs-2',
            'utf16le',
            'utf-16le',
            'raw',
          ].indexOf((kt + '').toLowerCase()) > -1
        ))
      )
        throw new TypeError('Unknown encoding: ' + kt)
      return (this._writableState.defaultEncoding = kt), this
    })
  function vt(Tt, kt, Ot) {
    return (
      !Tt.objectMode &&
        Tt.decodeStrings !== !1 &&
        typeof kt == 'string' &&
        (kt = rt.from(kt, Ot)),
      kt
    )
  }
  Object.defineProperty(dt.prototype, 'writableHighWaterMark', {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark
    },
  })
  function yt(Tt, kt, Ot, Nt, $t, Pt) {
    if (!Ot) {
      var Ft = vt(kt, Nt, $t)
      Nt !== Ft && ((Ot = !0), ($t = 'buffer'), (Nt = Ft))
    }
    var Vt = kt.objectMode ? 1 : Nt.length
    kt.length += Vt
    var Xt = kt.length < kt.highWaterMark
    if ((Xt || (kt.needDrain = !0), kt.writing || kt.corked)) {
      var Yt = kt.lastBufferedRequest
      ;(kt.lastBufferedRequest = {
        chunk: Nt,
        encoding: $t,
        isBuf: Ot,
        callback: Pt,
        next: null,
      }),
        Yt
          ? (Yt.next = kt.lastBufferedRequest)
          : (kt.bufferedRequest = kt.lastBufferedRequest),
        (kt.bufferedRequestCount += 1)
    } else pt(Tt, kt, !1, Vt, Nt, $t, Pt)
    return Xt
  }
  function pt(Tt, kt, Ot, Nt, $t, Pt, Ft) {
    ;(kt.writelen = Nt),
      (kt.writecb = Ft),
      (kt.writing = !0),
      (kt.sync = !0),
      Ot ? Tt._writev($t, kt.onwrite) : Tt._write($t, Pt, kt.onwrite),
      (kt.sync = !1)
  }
  function ht(Tt, kt, Ot, Nt, $t) {
    --kt.pendingcb,
      Ot
        ? (a.nextTick($t, Nt),
          a.nextTick(Mt, Tt, kt),
          (Tt._writableState.errorEmitted = !0),
          Tt.emit('error', Nt))
        : ($t(Nt),
          (Tt._writableState.errorEmitted = !0),
          Tt.emit('error', Nt),
          Mt(Tt, kt))
  }
  function At(Tt) {
    ;(Tt.writing = !1),
      (Tt.writecb = null),
      (Tt.length -= Tt.writelen),
      (Tt.writelen = 0)
  }
  function wt(Tt, kt) {
    var Ot = Tt._writableState,
      Nt = Ot.sync,
      $t = Ot.writecb
    if ((At(Ot), kt)) ht(Tt, Ot, Nt, kt, $t)
    else {
      var Pt = Et(Ot)
      !Pt &&
        !Ot.corked &&
        !Ot.bufferProcessing &&
        Ot.bufferedRequest &&
        jt(Tt, Ot),
        Nt ? $(Ct, Tt, Ot, Pt, $t) : Ct(Tt, Ot, Pt, $t)
    }
  }
  function Ct(Tt, kt, Ot, Nt) {
    Ot || Dt(Tt, kt), kt.pendingcb--, Nt(), Mt(Tt, kt)
  }
  function Dt(Tt, kt) {
    kt.length === 0 && kt.needDrain && ((kt.needDrain = !1), Tt.emit('drain'))
  }
  function jt(Tt, kt) {
    kt.bufferProcessing = !0
    var Ot = kt.bufferedRequest
    if (Tt._writev && Ot && Ot.next) {
      var Nt = kt.bufferedRequestCount,
        $t = new Array(Nt),
        Pt = kt.corkedRequestsFree
      Pt.entry = Ot
      for (var Ft = 0, Vt = !0; Ot; )
        ($t[Ft] = Ot), Ot.isBuf || (Vt = !1), (Ot = Ot.next), (Ft += 1)
      ;($t.allBuffers = Vt),
        pt(Tt, kt, !0, kt.length, $t, '', Pt.finish),
        kt.pendingcb++,
        (kt.lastBufferedRequest = null),
        Pt.next
          ? ((kt.corkedRequestsFree = Pt.next), (Pt.next = null))
          : (kt.corkedRequestsFree = new s(kt)),
        (kt.bufferedRequestCount = 0)
    } else {
      for (; Ot; ) {
        var Xt = Ot.chunk,
          Yt = Ot.encoding,
          xt = Ot.callback,
          It = kt.objectMode ? 1 : Xt.length
        if (
          (pt(Tt, kt, !1, It, Xt, Yt, xt),
          (Ot = Ot.next),
          kt.bufferedRequestCount--,
          kt.writing)
        )
          break
      }
      Ot === null && (kt.lastBufferedRequest = null)
    }
    ;(kt.bufferedRequest = Ot), (kt.bufferProcessing = !1)
  }
  ;(dt.prototype._write = function(Tt, kt, Ot) {
    Ot(new Error('_write() is not implemented'))
  }),
    (dt.prototype._writev = null),
    (dt.prototype.end = function(Tt, kt, Ot) {
      var Nt = this._writableState
      typeof Tt == 'function'
        ? ((Ot = Tt), (Tt = null), (kt = null))
        : typeof kt == 'function' && ((Ot = kt), (kt = null)),
        Tt != null && this.write(Tt, kt),
        Nt.corked && ((Nt.corked = 1), this.uncork()),
        Nt.ending || Ut(this, Nt, Ot)
    })
  function Et(Tt) {
    return (
      Tt.ending &&
      Tt.length === 0 &&
      Tt.bufferedRequest === null &&
      !Tt.finished &&
      !Tt.writing
    )
  }
  function St(Tt, kt) {
    Tt._final(function(Ot) {
      kt.pendingcb--,
        Ot && Tt.emit('error', Ot),
        (kt.prefinished = !0),
        Tt.emit('prefinish'),
        Mt(Tt, kt)
    })
  }
  function Bt(Tt, kt) {
    !kt.prefinished &&
      !kt.finalCalled &&
      (typeof Tt._final == 'function'
        ? (kt.pendingcb++, (kt.finalCalled = !0), a.nextTick(St, Tt, kt))
        : ((kt.prefinished = !0), Tt.emit('prefinish')))
  }
  function Mt(Tt, kt) {
    var Ot = Et(kt)
    return (
      Ot &&
        (Bt(Tt, kt),
        kt.pendingcb === 0 && ((kt.finished = !0), Tt.emit('finish'))),
      Ot
    )
  }
  function Ut(Tt, kt, Ot) {
    ;(kt.ending = !0),
      Mt(Tt, kt),
      Ot && (kt.finished ? a.nextTick(Ot) : Tt.once('finish', Ot)),
      (kt.ended = !0),
      (Tt.writable = !1)
  }
  function Wt(Tt, kt, Ot) {
    var Nt = Tt.entry
    for (Tt.entry = null; Nt; ) {
      var $t = Nt.callback
      kt.pendingcb--, $t(Ot), (Nt = Nt.next)
    }
    kt.corkedRequestsFree.next = Tt
  }
  return (
    Object.defineProperty(dt.prototype, 'destroyed', {
      get: function() {
        return this._writableState === void 0
          ? !1
          : this._writableState.destroyed
      },
      set: function(Tt) {
        this._writableState && (this._writableState.destroyed = Tt)
      },
    }),
    (dt.prototype.destroy = at.destroy),
    (dt.prototype._undestroy = at.undestroy),
    (dt.prototype._destroy = function(Tt, kt) {
      this.end(), kt(Tt)
    }),
    _stream_writable
  )
}
var _stream_duplex, hasRequired_stream_duplex
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex
  hasRequired_stream_duplex = 1
  var o = processNextickArgsExports,
    a =
      Object.keys ||
      function(ot) {
        var at = []
        for (var st in ot) at.push(st)
        return at
      }
  _stream_duplex = rt
  var s = Object.create(util$q)
  s.inherits = inherits_browserExports
  var $ = require_stream_readable(),
    j = require_stream_writable()
  s.inherits(rt, $)
  for (var _e = a(j.prototype), et = 0; et < _e.length; et++) {
    var tt = _e[et]
    rt.prototype[tt] || (rt.prototype[tt] = j.prototype[tt])
  }
  function rt(ot) {
    if (!(this instanceof rt)) return new rt(ot)
    $.call(this, ot),
      j.call(this, ot),
      ot && ot.readable === !1 && (this.readable = !1),
      ot && ot.writable === !1 && (this.writable = !1),
      (this.allowHalfOpen = !0),
      ot && ot.allowHalfOpen === !1 && (this.allowHalfOpen = !1),
      this.once('end', nt)
  }
  Object.defineProperty(rt.prototype, 'writableHighWaterMark', {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark
    },
  })
  function nt() {
    this.allowHalfOpen || this._writableState.ended || o.nextTick(it, this)
  }
  function it(ot) {
    ot.end()
  }
  return (
    Object.defineProperty(rt.prototype, 'destroyed', {
      get: function() {
        return this._readableState === void 0 || this._writableState === void 0
          ? !1
          : this._readableState.destroyed && this._writableState.destroyed
      },
      set: function(ot) {
        this._readableState === void 0 ||
          this._writableState === void 0 ||
          ((this._readableState.destroyed = ot),
          (this._writableState.destroyed = ot))
      },
    }),
    (rt.prototype._destroy = function(ot, at) {
      this.push(null), this.end(), o.nextTick(at, ot)
    }),
    _stream_duplex
  )
}
var _stream_readable, hasRequired_stream_readable
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable
  hasRequired_stream_readable = 1
  var o = {},
    a = processNextickArgsExports
  _stream_readable = vt
  var s = isarray,
    $
  ;(vt.ReadableState = mt), eventsExports.EventEmitter
  var j = function(xt, It) {
      return xt.listeners(It).length
    },
    _e = streamBrowser,
    et = safeBufferExports.Buffer,
    tt =
      (typeof o < 'u'
        ? o
        : typeof window < 'u'
        ? window
        : typeof self < 'u'
        ? self
        : {}
      ).Uint8Array || function() {}
  function rt(xt) {
    return et.from(xt)
  }
  function nt(xt) {
    return et.isBuffer(xt) || xt instanceof tt
  }
  var it = Object.create(util$q)
  it.inherits = inherits_browserExports
  var ot = require$$0$3,
    at = void 0
  ot && ot.debuglog ? (at = ot.debuglog('stream')) : (at = function() {})
  var st = requireBufferList(),
    ut = destroy_1,
    ct
  it.inherits(vt, _e)
  var dt = ['error', 'close', 'destroy', 'pause', 'resume']
  function ft(xt, It, Kt) {
    if (typeof xt.prependListener == 'function')
      return xt.prependListener(It, Kt)
    !xt._events || !xt._events[It]
      ? xt.on(It, Kt)
      : s(xt._events[It])
      ? xt._events[It].unshift(Kt)
      : (xt._events[It] = [Kt, xt._events[It]])
  }
  function mt(xt, It) {
    ;($ = $ || require_stream_duplex()), (xt = xt || {})
    var Kt = It instanceof $
    ;(this.objectMode = !!xt.objectMode),
      Kt && (this.objectMode = this.objectMode || !!xt.readableObjectMode)
    var Qt = xt.highWaterMark,
      Ht = xt.readableHighWaterMark,
      Lt = this.objectMode ? 16 : 16 * 1024
    Qt || Qt === 0
      ? (this.highWaterMark = Qt)
      : Kt && (Ht || Ht === 0)
      ? (this.highWaterMark = Ht)
      : (this.highWaterMark = Lt),
      (this.highWaterMark = Math.floor(this.highWaterMark)),
      (this.buffer = new st()),
      (this.length = 0),
      (this.pipes = null),
      (this.pipesCount = 0),
      (this.flowing = null),
      (this.ended = !1),
      (this.endEmitted = !1),
      (this.reading = !1),
      (this.sync = !0),
      (this.needReadable = !1),
      (this.emittedReadable = !1),
      (this.readableListening = !1),
      (this.resumeScheduled = !1),
      (this.destroyed = !1),
      (this.defaultEncoding = xt.defaultEncoding || 'utf8'),
      (this.awaitDrain = 0),
      (this.readingMore = !1),
      (this.decoder = null),
      (this.encoding = null),
      xt.encoding &&
        (ct || (ct = requireString_decoder$4().StringDecoder),
        (this.decoder = new ct(xt.encoding)),
        (this.encoding = xt.encoding))
  }
  function vt(xt) {
    if ((($ = $ || require_stream_duplex()), !(this instanceof vt)))
      return new vt(xt)
    ;(this._readableState = new mt(xt, this)),
      (this.readable = !0),
      xt &&
        (typeof xt.read == 'function' && (this._read = xt.read),
        typeof xt.destroy == 'function' && (this._destroy = xt.destroy)),
      _e.call(this)
  }
  Object.defineProperty(vt.prototype, 'destroyed', {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed
    },
    set: function(xt) {
      this._readableState && (this._readableState.destroyed = xt)
    },
  }),
    (vt.prototype.destroy = ut.destroy),
    (vt.prototype._undestroy = ut.undestroy),
    (vt.prototype._destroy = function(xt, It) {
      this.push(null), It(xt)
    }),
    (vt.prototype.push = function(xt, It) {
      var Kt = this._readableState,
        Qt
      return (
        Kt.objectMode
          ? (Qt = !0)
          : typeof xt == 'string' &&
            ((It = It || Kt.defaultEncoding),
            It !== Kt.encoding && ((xt = et.from(xt, It)), (It = '')),
            (Qt = !0)),
        yt(this, xt, It, !1, Qt)
      )
    }),
    (vt.prototype.unshift = function(xt) {
      return yt(this, xt, null, !0, !1)
    })
  function yt(xt, It, Kt, Qt, Ht) {
    var Lt = xt._readableState
    if (It === null) (Lt.reading = !1), jt(xt, Lt)
    else {
      var tr
      Ht || (tr = ht(Lt, It)),
        tr
          ? xt.emit('error', tr)
          : Lt.objectMode || (It && It.length > 0)
          ? (typeof It != 'string' &&
              !Lt.objectMode &&
              Object.getPrototypeOf(It) !== et.prototype &&
              (It = rt(It)),
            Qt
              ? Lt.endEmitted
                ? xt.emit(
                    'error',
                    new Error('stream.unshift() after end event')
                  )
                : pt(xt, Lt, It, !0)
              : Lt.ended
              ? xt.emit('error', new Error('stream.push() after EOF'))
              : ((Lt.reading = !1),
                Lt.decoder && !Kt
                  ? ((It = Lt.decoder.write(It)),
                    Lt.objectMode || It.length !== 0
                      ? pt(xt, Lt, It, !1)
                      : Bt(xt, Lt))
                  : pt(xt, Lt, It, !1)))
          : Qt || (Lt.reading = !1)
    }
    return At(Lt)
  }
  function pt(xt, It, Kt, Qt) {
    It.flowing && It.length === 0 && !It.sync
      ? (xt.emit('data', Kt), xt.read(0))
      : ((It.length += It.objectMode ? 1 : Kt.length),
        Qt ? It.buffer.unshift(Kt) : It.buffer.push(Kt),
        It.needReadable && Et(xt)),
      Bt(xt, It)
  }
  function ht(xt, It) {
    var Kt
    return (
      !nt(It) &&
        typeof It != 'string' &&
        It !== void 0 &&
        !xt.objectMode &&
        (Kt = new TypeError('Invalid non-string/buffer chunk')),
      Kt
    )
  }
  function At(xt) {
    return (
      !xt.ended &&
      (xt.needReadable || xt.length < xt.highWaterMark || xt.length === 0)
    )
  }
  ;(vt.prototype.isPaused = function() {
    return this._readableState.flowing === !1
  }),
    (vt.prototype.setEncoding = function(xt) {
      return (
        ct || (ct = requireString_decoder$4().StringDecoder),
        (this._readableState.decoder = new ct(xt)),
        (this._readableState.encoding = xt),
        this
      )
    })
  var wt = 8388608
  function Ct(xt) {
    return (
      xt >= wt
        ? (xt = wt)
        : (xt--,
          (xt |= xt >>> 1),
          (xt |= xt >>> 2),
          (xt |= xt >>> 4),
          (xt |= xt >>> 8),
          (xt |= xt >>> 16),
          xt++),
      xt
    )
  }
  function Dt(xt, It) {
    return xt <= 0 || (It.length === 0 && It.ended)
      ? 0
      : It.objectMode
      ? 1
      : xt !== xt
      ? It.flowing && It.length
        ? It.buffer.head.data.length
        : It.length
      : (xt > It.highWaterMark && (It.highWaterMark = Ct(xt)),
        xt <= It.length
          ? xt
          : It.ended
          ? It.length
          : ((It.needReadable = !0), 0))
  }
  vt.prototype.read = function(xt) {
    at('read', xt), (xt = parseInt(xt, 10))
    var It = this._readableState,
      Kt = xt
    if (
      (xt !== 0 && (It.emittedReadable = !1),
      xt === 0 &&
        It.needReadable &&
        (It.length >= It.highWaterMark || It.ended))
    )
      return (
        at('read: emitReadable', It.length, It.ended),
        It.length === 0 && It.ended ? Vt(this) : Et(this),
        null
      )
    if (((xt = Dt(xt, It)), xt === 0 && It.ended))
      return It.length === 0 && Vt(this), null
    var Qt = It.needReadable
    at('need readable', Qt),
      (It.length === 0 || It.length - xt < It.highWaterMark) &&
        ((Qt = !0), at('length less than watermark', Qt)),
      It.ended || It.reading
        ? ((Qt = !1), at('reading or ended', Qt))
        : Qt &&
          (at('do read'),
          (It.reading = !0),
          (It.sync = !0),
          It.length === 0 && (It.needReadable = !0),
          this._read(It.highWaterMark),
          (It.sync = !1),
          It.reading || (xt = Dt(Kt, It)))
    var Ht
    return (
      xt > 0 ? (Ht = Nt(xt, It)) : (Ht = null),
      Ht === null ? ((It.needReadable = !0), (xt = 0)) : (It.length -= xt),
      It.length === 0 &&
        (It.ended || (It.needReadable = !0), Kt !== xt && It.ended && Vt(this)),
      Ht !== null && this.emit('data', Ht),
      Ht
    )
  }
  function jt(xt, It) {
    if (!It.ended) {
      if (It.decoder) {
        var Kt = It.decoder.end()
        Kt &&
          Kt.length &&
          (It.buffer.push(Kt), (It.length += It.objectMode ? 1 : Kt.length))
      }
      ;(It.ended = !0), Et(xt)
    }
  }
  function Et(xt) {
    var It = xt._readableState
    ;(It.needReadable = !1),
      It.emittedReadable ||
        (at('emitReadable', It.flowing),
        (It.emittedReadable = !0),
        It.sync ? a.nextTick(St, xt) : St(xt))
  }
  function St(xt) {
    at('emit readable'), xt.emit('readable'), Ot(xt)
  }
  function Bt(xt, It) {
    It.readingMore || ((It.readingMore = !0), a.nextTick(Mt, xt, It))
  }
  function Mt(xt, It) {
    for (
      var Kt = It.length;
      !It.reading &&
      !It.flowing &&
      !It.ended &&
      It.length < It.highWaterMark &&
      (at('maybeReadMore read 0'), xt.read(0), Kt !== It.length);

    )
      Kt = It.length
    It.readingMore = !1
  }
  ;(vt.prototype._read = function(xt) {
    this.emit('error', new Error('_read() is not implemented'))
  }),
    (vt.prototype.pipe = function(xt, It) {
      var Kt = this,
        Qt = this._readableState
      switch (Qt.pipesCount) {
        case 0:
          Qt.pipes = xt
          break
        case 1:
          Qt.pipes = [Qt.pipes, xt]
          break
        default:
          Qt.pipes.push(xt)
          break
      }
      ;(Qt.pipesCount += 1), at('pipe count=%d opts=%j', Qt.pipesCount, It)
      var Ht =
          (!It || It.end !== !1) &&
          xt !== process.stdout &&
          xt !== process.stderr,
        Lt = Ht ? lr : gr
      Qt.endEmitted ? a.nextTick(Lt) : Kt.once('end', Lt), xt.on('unpipe', tr)
      function tr(br, Sr) {
        at('onunpipe'),
          br === Kt &&
            Sr &&
            Sr.hasUnpiped === !1 &&
            ((Sr.hasUnpiped = !0), Er())
      }
      function lr() {
        at('onend'), xt.end()
      }
      var yr = Ut(Kt)
      xt.on('drain', yr)
      var mr = !1
      function Er() {
        at('cleanup'),
          xt.removeListener('close', nr),
          xt.removeListener('finish', fr),
          xt.removeListener('drain', yr),
          xt.removeListener('error', Rr),
          xt.removeListener('unpipe', tr),
          Kt.removeListener('end', lr),
          Kt.removeListener('end', gr),
          Kt.removeListener('data', _r),
          (mr = !0),
          Qt.awaitDrain &&
            (!xt._writableState || xt._writableState.needDrain) &&
            yr()
      }
      var ur = !1
      Kt.on('data', _r)
      function _r(br) {
        at('ondata'), (ur = !1)
        var Sr = xt.write(br)
        Sr === !1 &&
          !ur &&
          (((Qt.pipesCount === 1 && Qt.pipes === xt) ||
            (Qt.pipesCount > 1 && Yt(Qt.pipes, xt) !== -1)) &&
            !mr &&
            (at('false write response, pause', Qt.awaitDrain),
            Qt.awaitDrain++,
            (ur = !0)),
          Kt.pause())
      }
      function Rr(br) {
        at('onerror', br),
          gr(),
          xt.removeListener('error', Rr),
          j(xt, 'error') === 0 && xt.emit('error', br)
      }
      ft(xt, 'error', Rr)
      function nr() {
        xt.removeListener('finish', fr), gr()
      }
      xt.once('close', nr)
      function fr() {
        at('onfinish'), xt.removeListener('close', nr), gr()
      }
      xt.once('finish', fr)
      function gr() {
        at('unpipe'), Kt.unpipe(xt)
      }
      return (
        xt.emit('pipe', Kt), Qt.flowing || (at('pipe resume'), Kt.resume()), xt
      )
    })
  function Ut(xt) {
    return function() {
      var It = xt._readableState
      at('pipeOnDrain', It.awaitDrain),
        It.awaitDrain && It.awaitDrain--,
        It.awaitDrain === 0 && j(xt, 'data') && ((It.flowing = !0), Ot(xt))
    }
  }
  ;(vt.prototype.unpipe = function(xt) {
    var It = this._readableState,
      Kt = { hasUnpiped: !1 }
    if (It.pipesCount === 0) return this
    if (It.pipesCount === 1)
      return xt && xt !== It.pipes
        ? this
        : (xt || (xt = It.pipes),
          (It.pipes = null),
          (It.pipesCount = 0),
          (It.flowing = !1),
          xt && xt.emit('unpipe', this, Kt),
          this)
    if (!xt) {
      var Qt = It.pipes,
        Ht = It.pipesCount
      ;(It.pipes = null), (It.pipesCount = 0), (It.flowing = !1)
      for (var Lt = 0; Lt < Ht; Lt++)
        Qt[Lt].emit('unpipe', this, { hasUnpiped: !1 })
      return this
    }
    var tr = Yt(It.pipes, xt)
    return tr === -1
      ? this
      : (It.pipes.splice(tr, 1),
        (It.pipesCount -= 1),
        It.pipesCount === 1 && (It.pipes = It.pipes[0]),
        xt.emit('unpipe', this, Kt),
        this)
  }),
    (vt.prototype.on = function(xt, It) {
      var Kt = _e.prototype.on.call(this, xt, It)
      if (xt === 'data') this._readableState.flowing !== !1 && this.resume()
      else if (xt === 'readable') {
        var Qt = this._readableState
        !Qt.endEmitted &&
          !Qt.readableListening &&
          ((Qt.readableListening = Qt.needReadable = !0),
          (Qt.emittedReadable = !1),
          Qt.reading ? Qt.length && Et(this) : a.nextTick(Wt, this))
      }
      return Kt
    }),
    (vt.prototype.addListener = vt.prototype.on)
  function Wt(xt) {
    at('readable nexttick read 0'), xt.read(0)
  }
  vt.prototype.resume = function() {
    var xt = this._readableState
    return xt.flowing || (at('resume'), (xt.flowing = !0), Tt(this, xt)), this
  }
  function Tt(xt, It) {
    It.resumeScheduled || ((It.resumeScheduled = !0), a.nextTick(kt, xt, It))
  }
  function kt(xt, It) {
    It.reading || (at('resume read 0'), xt.read(0)),
      (It.resumeScheduled = !1),
      (It.awaitDrain = 0),
      xt.emit('resume'),
      Ot(xt),
      It.flowing && !It.reading && xt.read(0)
  }
  vt.prototype.pause = function() {
    return (
      at('call pause flowing=%j', this._readableState.flowing),
      this._readableState.flowing !== !1 &&
        (at('pause'), (this._readableState.flowing = !1), this.emit('pause')),
      this
    )
  }
  function Ot(xt) {
    var It = xt._readableState
    for (at('flow', It.flowing); It.flowing && xt.read() !== null; );
  }
  ;(vt.prototype.wrap = function(xt) {
    var It = this,
      Kt = this._readableState,
      Qt = !1
    xt.on('end', function() {
      if ((at('wrapped end'), Kt.decoder && !Kt.ended)) {
        var tr = Kt.decoder.end()
        tr && tr.length && It.push(tr)
      }
      It.push(null)
    }),
      xt.on('data', function(tr) {
        if (
          (at('wrapped data'),
          Kt.decoder && (tr = Kt.decoder.write(tr)),
          !(Kt.objectMode && tr == null) &&
            !(!Kt.objectMode && (!tr || !tr.length)))
        ) {
          var lr = It.push(tr)
          lr || ((Qt = !0), xt.pause())
        }
      })
    for (var Ht in xt)
      this[Ht] === void 0 &&
        typeof xt[Ht] == 'function' &&
        (this[Ht] = (function(tr) {
          return function() {
            return xt[tr].apply(xt, arguments)
          }
        })(Ht))
    for (var Lt = 0; Lt < dt.length; Lt++)
      xt.on(dt[Lt], this.emit.bind(this, dt[Lt]))
    return (
      (this._read = function(tr) {
        at('wrapped _read', tr), Qt && ((Qt = !1), xt.resume())
      }),
      this
    )
  }),
    Object.defineProperty(vt.prototype, 'readableHighWaterMark', {
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark
      },
    }),
    (vt._fromList = Nt)
  function Nt(xt, It) {
    if (It.length === 0) return null
    var Kt
    return (
      It.objectMode
        ? (Kt = It.buffer.shift())
        : !xt || xt >= It.length
        ? (It.decoder
            ? (Kt = It.buffer.join(''))
            : It.buffer.length === 1
            ? (Kt = It.buffer.head.data)
            : (Kt = It.buffer.concat(It.length)),
          It.buffer.clear())
        : (Kt = $t(xt, It.buffer, It.decoder)),
      Kt
    )
  }
  function $t(xt, It, Kt) {
    var Qt
    return (
      xt < It.head.data.length
        ? ((Qt = It.head.data.slice(0, xt)),
          (It.head.data = It.head.data.slice(xt)))
        : xt === It.head.data.length
        ? (Qt = It.shift())
        : (Qt = Kt ? Pt(xt, It) : Ft(xt, It)),
      Qt
    )
  }
  function Pt(xt, It) {
    var Kt = It.head,
      Qt = 1,
      Ht = Kt.data
    for (xt -= Ht.length; (Kt = Kt.next); ) {
      var Lt = Kt.data,
        tr = xt > Lt.length ? Lt.length : xt
      if (
        (tr === Lt.length ? (Ht += Lt) : (Ht += Lt.slice(0, xt)),
        (xt -= tr),
        xt === 0)
      ) {
        tr === Lt.length
          ? (++Qt, Kt.next ? (It.head = Kt.next) : (It.head = It.tail = null))
          : ((It.head = Kt), (Kt.data = Lt.slice(tr)))
        break
      }
      ++Qt
    }
    return (It.length -= Qt), Ht
  }
  function Ft(xt, It) {
    var Kt = et.allocUnsafe(xt),
      Qt = It.head,
      Ht = 1
    for (Qt.data.copy(Kt), xt -= Qt.data.length; (Qt = Qt.next); ) {
      var Lt = Qt.data,
        tr = xt > Lt.length ? Lt.length : xt
      if ((Lt.copy(Kt, Kt.length - xt, 0, tr), (xt -= tr), xt === 0)) {
        tr === Lt.length
          ? (++Ht, Qt.next ? (It.head = Qt.next) : (It.head = It.tail = null))
          : ((It.head = Qt), (Qt.data = Lt.slice(tr)))
        break
      }
      ++Ht
    }
    return (It.length -= Ht), Kt
  }
  function Vt(xt) {
    var It = xt._readableState
    if (It.length > 0)
      throw new Error('"endReadable()" called on non-empty stream')
    It.endEmitted || ((It.ended = !0), a.nextTick(Xt, It, xt))
  }
  function Xt(xt, It) {
    !xt.endEmitted &&
      xt.length === 0 &&
      ((xt.endEmitted = !0), (It.readable = !1), It.emit('end'))
  }
  function Yt(xt, It) {
    for (var Kt = 0, Qt = xt.length; Kt < Qt; Kt++) if (xt[Kt] === It) return Kt
    return -1
  }
  return _stream_readable
}
var _stream_transform = Transform$1,
  Duplex = require_stream_duplex(),
  util$8 = Object.create(util$q)
util$8.inherits = inherits_browserExports
util$8.inherits(Transform$1, Duplex)
function afterTransform(o, a) {
  var s = this._transformState
  s.transforming = !1
  var $ = s.writecb
  if (!$)
    return this.emit('error', new Error('write callback called multiple times'))
  ;(s.writechunk = null), (s.writecb = null), a != null && this.push(a), $(o)
  var j = this._readableState
  ;(j.reading = !1),
    (j.needReadable || j.length < j.highWaterMark) &&
      this._read(j.highWaterMark)
}
function Transform$1(o) {
  if (!(this instanceof Transform$1)) return new Transform$1(o)
  Duplex.call(this, o),
    (this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null,
    }),
    (this._readableState.needReadable = !0),
    (this._readableState.sync = !1),
    o &&
      (typeof o.transform == 'function' && (this._transform = o.transform),
      typeof o.flush == 'function' && (this._flush = o.flush)),
    this.on('prefinish', prefinish)
}
function prefinish() {
  var o = this
  typeof this._flush == 'function'
    ? this._flush(function(a, s) {
        done(o, a, s)
      })
    : done(this, null, null)
}
Transform$1.prototype.push = function(o, a) {
  return (
    (this._transformState.needTransform = !1),
    Duplex.prototype.push.call(this, o, a)
  )
}
Transform$1.prototype._transform = function(o, a, s) {
  throw new Error('_transform() is not implemented')
}
Transform$1.prototype._write = function(o, a, s) {
  var $ = this._transformState
  if (
    (($.writecb = s),
    ($.writechunk = o),
    ($.writeencoding = a),
    !$.transforming)
  ) {
    var j = this._readableState
    ;($.needTransform || j.needReadable || j.length < j.highWaterMark) &&
      this._read(j.highWaterMark)
  }
}
Transform$1.prototype._read = function(o) {
  var a = this._transformState
  a.writechunk !== null && a.writecb && !a.transforming
    ? ((a.transforming = !0),
      this._transform(a.writechunk, a.writeencoding, a.afterTransform))
    : (a.needTransform = !0)
}
Transform$1.prototype._destroy = function(o, a) {
  var s = this
  Duplex.prototype._destroy.call(this, o, function($) {
    a($), s.emit('close')
  })
}
function done(o, a, s) {
  if (a) return o.emit('error', a)
  if ((s != null && o.push(s), o._writableState.length))
    throw new Error('Calling transform done when ws.length != 0')
  if (o._transformState.transforming)
    throw new Error('Calling transform done when still transforming')
  return o.push(null)
}
var _stream_passthrough = PassThrough,
  Transform = _stream_transform,
  util$7 = Object.create(util$q)
util$7.inherits = inherits_browserExports
util$7.inherits(PassThrough, Transform)
function PassThrough(o) {
  if (!(this instanceof PassThrough)) return new PassThrough(o)
  Transform.call(this, o)
}
PassThrough.prototype._transform = function(o, a, s) {
  s(null, o)
}
;(function(o, a) {
  ;(a = o.exports = require_stream_readable()),
    (a.Stream = a),
    (a.Readable = a),
    (a.Writable = require_stream_writable()),
    (a.Duplex = require_stream_duplex()),
    (a.Transform = _stream_transform),
    (a.PassThrough = _stream_passthrough)
})(readableBrowser, readableBrowser.exports)
var readableBrowserExports = readableBrowser.exports,
  toString$3 = Object.prototype.toString,
  isModern =
    typeof Buffer < 'u' &&
    typeof Buffer.alloc == 'function' &&
    typeof Buffer.allocUnsafe == 'function' &&
    typeof Buffer.from == 'function'
function isArrayBuffer$1(o) {
  return toString$3.call(o).slice(8, -1) === 'ArrayBuffer'
}
function fromArrayBuffer(o, a, s) {
  a >>>= 0
  var $ = o.byteLength - a
  if ($ < 0) throw new RangeError("'offset' is out of bounds")
  if (s === void 0) s = $
  else if (((s >>>= 0), s > $))
    throw new RangeError("'length' is out of bounds")
  return isModern
    ? Buffer.from(o.slice(a, a + s))
    : new Buffer(new Uint8Array(o.slice(a, a + s)))
}
function fromString(o, a) {
  if (
    ((typeof a != 'string' || a === '') && (a = 'utf8'), !Buffer.isEncoding(a))
  )
    throw new TypeError('"encoding" must be a valid string encoding')
  return isModern ? Buffer.from(o, a) : new Buffer(o, a)
}
function bufferFrom$1(o, a, s) {
  if (typeof o == 'number')
    throw new TypeError('"value" argument must not be a number')
  return isArrayBuffer$1(o)
    ? fromArrayBuffer(o, a, s)
    : typeof o == 'string'
    ? fromString(o, a)
    : isModern
    ? Buffer.from(o)
    : new Buffer(o)
}
var bufferFrom_1 = bufferFrom$1,
  typedarray = {},
  hasRequiredTypedarray
function requireTypedarray() {
  return (
    hasRequiredTypedarray ||
      ((hasRequiredTypedarray = 1),
      (function(o) {
        var a = void 0,
          s = 1e5,
          $ = (function() {
            var Ot = Object.prototype.toString,
              Nt = Object.prototype.hasOwnProperty
            return {
              Class: function($t) {
                return Ot.call($t).replace(/^\[object *|\]$/g, '')
              },
              HasProperty: function($t, Pt) {
                return Pt in $t
              },
              HasOwnProperty: function($t, Pt) {
                return Nt.call($t, Pt)
              },
              IsCallable: function($t) {
                return typeof $t == 'function'
              },
              ToInt32: function($t) {
                return $t >> 0
              },
              ToUint32: function($t) {
                return $t >>> 0
              },
            }
          })(),
          j = Math.LN2,
          _e = Math.abs,
          et = Math.floor,
          tt = Math.log,
          rt = Math.min,
          nt = Math.pow,
          it = Math.round
        function ot(Ot) {
          if (st && at) {
            var Nt = st(Ot),
              $t
            for ($t = 0; $t < Nt.length; $t += 1)
              at(Ot, Nt[$t], {
                value: Ot[Nt[$t]],
                writable: !1,
                enumerable: !1,
                configurable: !1,
              })
          }
        }
        var at
        Object.defineProperty &&
        (function() {
          try {
            return Object.defineProperty({}, 'x', {}), !0
          } catch {
            return !1
          }
        })()
          ? (at = Object.defineProperty)
          : (at = function(Ot, Nt, $t) {
              if (!Ot === Object(Ot))
                throw new TypeError(
                  'Object.defineProperty called on non-object'
                )
              return (
                $.HasProperty($t, 'get') &&
                  Object.prototype.__defineGetter__ &&
                  Object.prototype.__defineGetter__.call(Ot, Nt, $t.get),
                $.HasProperty($t, 'set') &&
                  Object.prototype.__defineSetter__ &&
                  Object.prototype.__defineSetter__.call(Ot, Nt, $t.set),
                $.HasProperty($t, 'value') && (Ot[Nt] = $t.value),
                Ot
              )
            })
        var st =
          Object.getOwnPropertyNames ||
          function(Ot) {
            if (Ot !== Object(Ot))
              throw new TypeError(
                'Object.getOwnPropertyNames called on non-object'
              )
            var Nt = [],
              $t
            for ($t in Ot) $.HasOwnProperty(Ot, $t) && Nt.push($t)
            return Nt
          }
        function ut(Ot) {
          if (!at) return
          if (Ot.length > s)
            throw new RangeError('Array too large for polyfill')
          function Nt(Pt) {
            at(Ot, Pt, {
              get: function() {
                return Ot._getter(Pt)
              },
              set: function(Ft) {
                Ot._setter(Pt, Ft)
              },
              enumerable: !0,
              configurable: !1,
            })
          }
          var $t
          for ($t = 0; $t < Ot.length; $t += 1) Nt($t)
        }
        function ct(Ot, Nt) {
          var $t = 32 - Nt
          return (Ot << $t) >> $t
        }
        function dt(Ot, Nt) {
          var $t = 32 - Nt
          return (Ot << $t) >>> $t
        }
        function ft(Ot) {
          return [Ot & 255]
        }
        function mt(Ot) {
          return ct(Ot[0], 8)
        }
        function vt(Ot) {
          return [Ot & 255]
        }
        function yt(Ot) {
          return dt(Ot[0], 8)
        }
        function pt(Ot) {
          return (Ot = it(Number(Ot))), [Ot < 0 ? 0 : Ot > 255 ? 255 : Ot & 255]
        }
        function ht(Ot) {
          return [(Ot >> 8) & 255, Ot & 255]
        }
        function At(Ot) {
          return ct((Ot[0] << 8) | Ot[1], 16)
        }
        function wt(Ot) {
          return [(Ot >> 8) & 255, Ot & 255]
        }
        function Ct(Ot) {
          return dt((Ot[0] << 8) | Ot[1], 16)
        }
        function Dt(Ot) {
          return [(Ot >> 24) & 255, (Ot >> 16) & 255, (Ot >> 8) & 255, Ot & 255]
        }
        function jt(Ot) {
          return ct((Ot[0] << 24) | (Ot[1] << 16) | (Ot[2] << 8) | Ot[3], 32)
        }
        function Et(Ot) {
          return [(Ot >> 24) & 255, (Ot >> 16) & 255, (Ot >> 8) & 255, Ot & 255]
        }
        function St(Ot) {
          return dt((Ot[0] << 24) | (Ot[1] << 16) | (Ot[2] << 8) | Ot[3], 32)
        }
        function Bt(Ot, Nt, $t) {
          var Pt = (1 << (Nt - 1)) - 1,
            Ft,
            Vt,
            Xt,
            Yt,
            xt,
            It,
            Kt
          function Qt(Ht) {
            var Lt = et(Ht),
              tr = Ht - Lt
            return tr < 0.5 ? Lt : tr > 0.5 || Lt % 2 ? Lt + 1 : Lt
          }
          for (
            Ot !== Ot
              ? ((Vt = (1 << Nt) - 1), (Xt = nt(2, $t - 1)), (Ft = 0))
              : Ot === 1 / 0 || Ot === -1 / 0
              ? ((Vt = (1 << Nt) - 1), (Xt = 0), (Ft = Ot < 0 ? 1 : 0))
              : Ot === 0
              ? ((Vt = 0), (Xt = 0), (Ft = 1 / Ot === -1 / 0 ? 1 : 0))
              : ((Ft = Ot < 0),
                (Ot = _e(Ot)),
                Ot >= nt(2, 1 - Pt)
                  ? ((Vt = rt(et(tt(Ot) / j), 1023)),
                    (Xt = Qt((Ot / nt(2, Vt)) * nt(2, $t))),
                    Xt / nt(2, $t) >= 2 && ((Vt = Vt + 1), (Xt = 1)),
                    Vt > Pt
                      ? ((Vt = (1 << Nt) - 1), (Xt = 0))
                      : ((Vt = Vt + Pt), (Xt = Xt - nt(2, $t))))
                  : ((Vt = 0), (Xt = Qt(Ot / nt(2, 1 - Pt - $t))))),
              xt = [],
              Yt = $t;
            Yt;
            Yt -= 1
          )
            xt.push(Xt % 2 ? 1 : 0), (Xt = et(Xt / 2))
          for (Yt = Nt; Yt; Yt -= 1) xt.push(Vt % 2 ? 1 : 0), (Vt = et(Vt / 2))
          for (
            xt.push(Ft ? 1 : 0), xt.reverse(), It = xt.join(''), Kt = [];
            It.length;

          )
            Kt.push(parseInt(It.substring(0, 8), 2)), (It = It.substring(8))
          return Kt
        }
        function Mt(Ot, Nt, $t) {
          var Pt = [],
            Ft,
            Vt,
            Xt,
            Yt,
            xt,
            It,
            Kt,
            Qt
          for (Ft = Ot.length; Ft; Ft -= 1)
            for (Xt = Ot[Ft - 1], Vt = 8; Vt; Vt -= 1)
              Pt.push(Xt % 2 ? 1 : 0), (Xt = Xt >> 1)
          return (
            Pt.reverse(),
            (Yt = Pt.join('')),
            (xt = (1 << (Nt - 1)) - 1),
            (It = parseInt(Yt.substring(0, 1), 2) ? -1 : 1),
            (Kt = parseInt(Yt.substring(1, 1 + Nt), 2)),
            (Qt = parseInt(Yt.substring(1 + Nt), 2)),
            Kt === (1 << Nt) - 1
              ? Qt !== 0
                ? NaN
                : It * (1 / 0)
              : Kt > 0
              ? It * nt(2, Kt - xt) * (1 + Qt / nt(2, $t))
              : Qt !== 0
              ? It * nt(2, -(xt - 1)) * (Qt / nt(2, $t))
              : It < 0
              ? -0
              : 0
          )
        }
        function Ut(Ot) {
          return Mt(Ot, 11, 52)
        }
        function Wt(Ot) {
          return Bt(Ot, 11, 52)
        }
        function Tt(Ot) {
          return Mt(Ot, 8, 23)
        }
        function kt(Ot) {
          return Bt(Ot, 8, 23)
        }
        ;(function() {
          var Ot = function(Lt) {
            if (((Lt = $.ToInt32(Lt)), Lt < 0))
              throw new RangeError(
                'ArrayBuffer size is not a small enough positive integer'
              )
            ;(this.byteLength = Lt),
              (this._bytes = []),
              (this._bytes.length = Lt)
            var tr
            for (tr = 0; tr < this.byteLength; tr += 1) this._bytes[tr] = 0
            ot(this)
          }
          o.ArrayBuffer = o.ArrayBuffer || Ot
          var Nt = function() {}
          function $t(Ht, Lt, tr) {
            var lr
            return (
              (lr = function(yr, mr, Er) {
                var ur, _r, Rr, nr
                if (!arguments.length || typeof arguments[0] == 'number') {
                  if (((this.length = $.ToInt32(arguments[0])), Er < 0))
                    throw new RangeError(
                      'ArrayBufferView size is not a small enough positive integer'
                    )
                  ;(this.byteLength = this.length * this.BYTES_PER_ELEMENT),
                    (this.buffer = new Ot(this.byteLength)),
                    (this.byteOffset = 0)
                } else if (
                  typeof arguments[0] == 'object' &&
                  arguments[0].constructor === lr
                )
                  for (
                    ur = arguments[0],
                      this.length = ur.length,
                      this.byteLength = this.length * this.BYTES_PER_ELEMENT,
                      this.buffer = new Ot(this.byteLength),
                      this.byteOffset = 0,
                      Rr = 0;
                    Rr < this.length;
                    Rr += 1
                  )
                    this._setter(Rr, ur._getter(Rr))
                else if (
                  typeof arguments[0] == 'object' &&
                  !(
                    arguments[0] instanceof Ot ||
                    $.Class(arguments[0]) === 'ArrayBuffer'
                  )
                )
                  for (
                    _r = arguments[0],
                      this.length = $.ToUint32(_r.length),
                      this.byteLength = this.length * this.BYTES_PER_ELEMENT,
                      this.buffer = new Ot(this.byteLength),
                      this.byteOffset = 0,
                      Rr = 0;
                    Rr < this.length;
                    Rr += 1
                  )
                    (nr = _r[Rr]), this._setter(Rr, Number(nr))
                else if (
                  typeof arguments[0] == 'object' &&
                  (arguments[0] instanceof Ot ||
                    $.Class(arguments[0]) === 'ArrayBuffer')
                ) {
                  if (
                    ((this.buffer = yr),
                    (this.byteOffset = $.ToUint32(mr)),
                    this.byteOffset > this.buffer.byteLength)
                  )
                    throw new RangeError('byteOffset out of range')
                  if (this.byteOffset % this.BYTES_PER_ELEMENT)
                    throw new RangeError(
                      'ArrayBuffer length minus the byteOffset is not a multiple of the element size.'
                    )
                  if (arguments.length < 3) {
                    if (
                      ((this.byteLength =
                        this.buffer.byteLength - this.byteOffset),
                      this.byteLength % this.BYTES_PER_ELEMENT)
                    )
                      throw new RangeError(
                        'length of buffer minus byteOffset not a multiple of the element size'
                      )
                    this.length = this.byteLength / this.BYTES_PER_ELEMENT
                  } else
                    (this.length = $.ToUint32(Er)),
                      (this.byteLength = this.length * this.BYTES_PER_ELEMENT)
                  if (
                    this.byteOffset + this.byteLength >
                    this.buffer.byteLength
                  )
                    throw new RangeError(
                      'byteOffset and length reference an area beyond the end of the buffer'
                    )
                } else throw new TypeError('Unexpected argument type(s)')
                ;(this.constructor = lr), ot(this), ut(this)
              }),
              (lr.prototype = new Nt()),
              (lr.prototype.BYTES_PER_ELEMENT = Ht),
              (lr.prototype._pack = Lt),
              (lr.prototype._unpack = tr),
              (lr.BYTES_PER_ELEMENT = Ht),
              (lr.prototype._getter = function(yr) {
                if (arguments.length < 1)
                  throw new SyntaxError('Not enough arguments')
                if (((yr = $.ToUint32(yr)), yr >= this.length)) return a
                var mr = [],
                  Er,
                  ur
                for (
                  Er = 0, ur = this.byteOffset + yr * this.BYTES_PER_ELEMENT;
                  Er < this.BYTES_PER_ELEMENT;
                  Er += 1, ur += 1
                )
                  mr.push(this.buffer._bytes[ur])
                return this._unpack(mr)
              }),
              (lr.prototype.get = lr.prototype._getter),
              (lr.prototype._setter = function(yr, mr) {
                if (arguments.length < 2)
                  throw new SyntaxError('Not enough arguments')
                if (((yr = $.ToUint32(yr)), yr >= this.length)) return a
                var Er = this._pack(mr),
                  ur,
                  _r
                for (
                  ur = 0, _r = this.byteOffset + yr * this.BYTES_PER_ELEMENT;
                  ur < this.BYTES_PER_ELEMENT;
                  ur += 1, _r += 1
                )
                  this.buffer._bytes[_r] = Er[ur]
              }),
              (lr.prototype.set = function(yr, mr) {
                if (arguments.length < 1)
                  throw new SyntaxError('Not enough arguments')
                var Er, ur, _r, Rr, nr, fr, gr, br, Sr, zt
                if (
                  typeof arguments[0] == 'object' &&
                  arguments[0].constructor === this.constructor
                ) {
                  if (
                    ((Er = arguments[0]),
                    (_r = $.ToUint32(arguments[1])),
                    _r + Er.length > this.length)
                  )
                    throw new RangeError(
                      'Offset plus length of array is out of range'
                    )
                  if (
                    ((br = this.byteOffset + _r * this.BYTES_PER_ELEMENT),
                    (Sr = Er.length * this.BYTES_PER_ELEMENT),
                    Er.buffer === this.buffer)
                  ) {
                    for (
                      zt = [], nr = 0, fr = Er.byteOffset;
                      nr < Sr;
                      nr += 1, fr += 1
                    )
                      zt[nr] = Er.buffer._bytes[fr]
                    for (nr = 0, gr = br; nr < Sr; nr += 1, gr += 1)
                      this.buffer._bytes[gr] = zt[nr]
                  } else
                    for (
                      nr = 0, fr = Er.byteOffset, gr = br;
                      nr < Sr;
                      nr += 1, fr += 1, gr += 1
                    )
                      this.buffer._bytes[gr] = Er.buffer._bytes[fr]
                } else if (
                  typeof arguments[0] == 'object' &&
                  typeof arguments[0].length < 'u'
                ) {
                  if (
                    ((ur = arguments[0]),
                    (Rr = $.ToUint32(ur.length)),
                    (_r = $.ToUint32(arguments[1])),
                    _r + Rr > this.length)
                  )
                    throw new RangeError(
                      'Offset plus length of array is out of range'
                    )
                  for (nr = 0; nr < Rr; nr += 1)
                    (fr = ur[nr]), this._setter(_r + nr, Number(fr))
                } else throw new TypeError('Unexpected argument type(s)')
              }),
              (lr.prototype.subarray = function(yr, mr) {
                function Er(_r, Rr, nr) {
                  return _r < Rr ? Rr : _r > nr ? nr : _r
                }
                ;(yr = $.ToInt32(yr)),
                  (mr = $.ToInt32(mr)),
                  arguments.length < 1 && (yr = 0),
                  arguments.length < 2 && (mr = this.length),
                  yr < 0 && (yr = this.length + yr),
                  mr < 0 && (mr = this.length + mr),
                  (yr = Er(yr, 0, this.length)),
                  (mr = Er(mr, 0, this.length))
                var ur = mr - yr
                return (
                  ur < 0 && (ur = 0),
                  new this.constructor(
                    this.buffer,
                    this.byteOffset + yr * this.BYTES_PER_ELEMENT,
                    ur
                  )
                )
              }),
              lr
            )
          }
          var Pt = $t(1, ft, mt),
            Ft = $t(1, vt, yt),
            Vt = $t(1, pt, yt),
            Xt = $t(2, ht, At),
            Yt = $t(2, wt, Ct),
            xt = $t(4, Dt, jt),
            It = $t(4, Et, St),
            Kt = $t(4, kt, Tt),
            Qt = $t(8, Wt, Ut)
          ;(o.Int8Array = o.Int8Array || Pt),
            (o.Uint8Array = o.Uint8Array || Ft),
            (o.Uint8ClampedArray = o.Uint8ClampedArray || Vt),
            (o.Int16Array = o.Int16Array || Xt),
            (o.Uint16Array = o.Uint16Array || Yt),
            (o.Int32Array = o.Int32Array || xt),
            (o.Uint32Array = o.Uint32Array || It),
            (o.Float32Array = o.Float32Array || Kt),
            (o.Float64Array = o.Float64Array || Qt)
        })(),
          (function() {
            function Ot(Vt, Xt) {
              return $.IsCallable(Vt.get) ? Vt.get(Xt) : Vt[Xt]
            }
            var Nt = (function() {
                var Vt = new o.Uint16Array([4660]),
                  Xt = new o.Uint8Array(Vt.buffer)
                return Ot(Xt, 0) === 18
              })(),
              $t = function(Xt, Yt, xt) {
                if (arguments.length === 0) Xt = new o.ArrayBuffer(0)
                else if (
                  !(
                    Xt instanceof o.ArrayBuffer || $.Class(Xt) === 'ArrayBuffer'
                  )
                )
                  throw new TypeError('TypeError')
                if (
                  ((this.buffer = Xt || new o.ArrayBuffer(0)),
                  (this.byteOffset = $.ToUint32(Yt)),
                  this.byteOffset > this.buffer.byteLength)
                )
                  throw new RangeError('byteOffset out of range')
                if (
                  (arguments.length < 3
                    ? (this.byteLength =
                        this.buffer.byteLength - this.byteOffset)
                    : (this.byteLength = $.ToUint32(xt)),
                  this.byteOffset + this.byteLength > this.buffer.byteLength)
                )
                  throw new RangeError(
                    'byteOffset and length reference an area beyond the end of the buffer'
                  )
                ot(this)
              }
            function Pt(Vt) {
              return function(Xt, Yt) {
                if (
                  ((Xt = $.ToUint32(Xt)),
                  Xt + Vt.BYTES_PER_ELEMENT > this.byteLength)
                )
                  throw new RangeError('Array index out of range')
                Xt += this.byteOffset
                var xt = new o.Uint8Array(
                    this.buffer,
                    Xt,
                    Vt.BYTES_PER_ELEMENT
                  ),
                  It = [],
                  Kt
                for (Kt = 0; Kt < Vt.BYTES_PER_ELEMENT; Kt += 1)
                  It.push(Ot(xt, Kt))
                return (
                  !!Yt == !!Nt && It.reverse(),
                  Ot(new Vt(new o.Uint8Array(It).buffer), 0)
                )
              }
            }
            ;($t.prototype.getUint8 = Pt(o.Uint8Array)),
              ($t.prototype.getInt8 = Pt(o.Int8Array)),
              ($t.prototype.getUint16 = Pt(o.Uint16Array)),
              ($t.prototype.getInt16 = Pt(o.Int16Array)),
              ($t.prototype.getUint32 = Pt(o.Uint32Array)),
              ($t.prototype.getInt32 = Pt(o.Int32Array)),
              ($t.prototype.getFloat32 = Pt(o.Float32Array)),
              ($t.prototype.getFloat64 = Pt(o.Float64Array))
            function Ft(Vt) {
              return function(Xt, Yt, xt) {
                if (
                  ((Xt = $.ToUint32(Xt)),
                  Xt + Vt.BYTES_PER_ELEMENT > this.byteLength)
                )
                  throw new RangeError('Array index out of range')
                var It = new Vt([Yt]),
                  Kt = new o.Uint8Array(It.buffer),
                  Qt = [],
                  Ht,
                  Lt
                for (Ht = 0; Ht < Vt.BYTES_PER_ELEMENT; Ht += 1)
                  Qt.push(Ot(Kt, Ht))
                !!xt == !!Nt && Qt.reverse(),
                  (Lt = new o.Uint8Array(
                    this.buffer,
                    Xt,
                    Vt.BYTES_PER_ELEMENT
                  )),
                  Lt.set(Qt)
              }
            }
            ;($t.prototype.setUint8 = Ft(o.Uint8Array)),
              ($t.prototype.setInt8 = Ft(o.Int8Array)),
              ($t.prototype.setUint16 = Ft(o.Uint16Array)),
              ($t.prototype.setInt16 = Ft(o.Int16Array)),
              ($t.prototype.setUint32 = Ft(o.Uint32Array)),
              ($t.prototype.setInt32 = Ft(o.Int32Array)),
              ($t.prototype.setFloat32 = Ft(o.Float32Array)),
              ($t.prototype.setFloat64 = Ft(o.Float64Array)),
              (o.DataView = o.DataView || $t)
          })()
      })(typedarray)),
    typedarray
  )
}
var Writable = readableBrowserExports.Writable,
  inherits$2 = inherits_browserExports,
  bufferFrom = bufferFrom_1
if (typeof Uint8Array > 'u') var U8 = requireTypedarray().Uint8Array
else var U8 = Uint8Array
function ConcatStream(o, a) {
  if (!(this instanceof ConcatStream)) return new ConcatStream(o, a)
  typeof o == 'function' && ((a = o), (o = {})), o || (o = {})
  var s = o.encoding,
    $ = !1
  s
    ? ((s = String(s).toLowerCase()),
      (s === 'u8' || s === 'uint8') && (s = 'uint8array'))
    : ($ = !0),
    Writable.call(this, { objectMode: !0 }),
    (this.encoding = s),
    (this.shouldInferEncoding = $),
    a &&
      this.on('finish', function() {
        a(this.getBody())
      }),
    (this.body = [])
}
var concatStream = ConcatStream
inherits$2(ConcatStream, Writable)
ConcatStream.prototype._write = function(o, a, s) {
  this.body.push(o), s()
}
ConcatStream.prototype.inferEncoding = function(o) {
  var a = o === void 0 ? this.body[0] : o
  return Buffer.isBuffer(a)
    ? 'buffer'
    : typeof Uint8Array < 'u' && a instanceof Uint8Array
    ? 'uint8array'
    : Array.isArray(a)
    ? 'array'
    : typeof a == 'string'
    ? 'string'
    : Object.prototype.toString.call(a) === '[object Object]'
    ? 'object'
    : 'buffer'
}
ConcatStream.prototype.getBody = function() {
  return !this.encoding && this.body.length === 0
    ? []
    : (this.shouldInferEncoding && (this.encoding = this.inferEncoding()),
      this.encoding === 'array'
        ? arrayConcat(this.body)
        : this.encoding === 'string'
        ? stringConcat(this.body)
        : this.encoding === 'buffer'
        ? bufferConcat(this.body)
        : this.encoding === 'uint8array'
        ? u8Concat(this.body)
        : this.body)
}
function isArrayish(o) {
  return /Array\]$/.test(Object.prototype.toString.call(o))
}
function isBufferish(o) {
  return (
    typeof o == 'string' ||
    isArrayish(o) ||
    (o && typeof o.subarray == 'function')
  )
}
function stringConcat(o) {
  for (var a = [], s = 0; s < o.length; s++) {
    var $ = o[s]
    typeof $ == 'string' || Buffer.isBuffer($)
      ? a.push($)
      : isBufferish($)
      ? a.push(bufferFrom($))
      : a.push(bufferFrom(String($)))
  }
  return (
    Buffer.isBuffer(o[0])
      ? ((a = Buffer.concat(a)), (a = a.toString('utf8')))
      : (a = a.join('')),
    a
  )
}
function bufferConcat(o) {
  for (var a = [], s = 0; s < o.length; s++) {
    var $ = o[s]
    Buffer.isBuffer($)
      ? a.push($)
      : isBufferish($)
      ? a.push(bufferFrom($))
      : a.push(bufferFrom(String($)))
  }
  return Buffer.concat(a)
}
function arrayConcat(o) {
  for (var a = [], s = 0; s < o.length; s++) a.push.apply(a, o[s])
  return a
}
function u8Concat(o) {
  for (var a = 0, s = 0; s < o.length; s++)
    typeof o[s] == 'string' && (o[s] = bufferFrom(o[s])), (a += o[s].length)
  for (var $ = new U8(a), s = 0, j = 0; s < o.length; s++)
    for (var _e = o[s], et = 0; et < _e.length; et++) $[j++] = _e[et]
  return $
}
var toDate = function(o) {
    return o ? (typeof o == 'string' ? new Date(o) : o) : new Date()
  },
  Stat = function(o) {
    ;(this.uid = o.uid || 0),
      (this.gid = o.gid || 0),
      (this.mode = o.mode || 0),
      (this.size = o.size || 0),
      (this.mtime = toDate(o.mtime)),
      (this.atime = toDate(o.atime)),
      (this.ctime = toDate(o.ctime)),
      (this.type = o.type),
      (this.target = o.target),
      (this.link = o.link),
      (this.blob = o.blob)
  }
Stat.prototype.isDirectory = function() {
  return this.type === 'directory'
}
Stat.prototype.isFile = function() {
  return this.type === 'file'
}
Stat.prototype.isBlockDevice = function() {
  return !1
}
Stat.prototype.isCharacterDevice = function() {
  return !1
}
Stat.prototype.isSymbolicLink = function() {
  return this.type === 'symlink'
}
Stat.prototype.isFIFO = function() {
  return !1
}
Stat.prototype.isSocket = function() {
  return !1
}
var stat$2 = function(o) {
    return new Stat(o)
  },
  hasKeys_1 = hasKeys$1
function hasKeys$1(o) {
  return o !== null && (typeof o == 'object' || typeof o == 'function')
}
var hasKeys = hasKeys_1,
  xtend$8 = extend$5
function extend$5() {
  for (var o = {}, a = 0; a < arguments.length; a++) {
    var s = arguments[a]
    if (hasKeys(s)) for (var $ in s) s.hasOwnProperty($) && (o[$] = s[$])
  }
  return o
}
var path$2 = path$3,
  once$1 = onceExports,
  concat = concatStream,
  octal$1 = octal$2,
  stat$1 = stat$2,
  xtend$7 = xtend$8,
  errno$1 = errno$2,
  ROOT = stat$1({ type: 'directory', mode: octal$1(777), size: 4096 }),
  normalize = function(o) {
    return (
      (o = o[0] === '/' ? o : '/' + o),
      (o = path$2.normalize(o)),
      o === '/' ? o : o[o.length - 1] === '/' ? o.slice(0, -1) : o
    )
  },
  prefix = function(o) {
    var a = o.split('/').length.toString(36)
    return '0000000000'.slice(a.length) + a + o
  },
  paths$1 = function(o) {
    var a = {}
    ;(a.normalize = normalize),
      (a.get = function($, j) {
        if ((($ = normalize($)), $ === '/'))
          return process.nextTick(j.bind(null, null, ROOT, '/'))
        o.get(prefix($), { valueEncoding: 'json' }, function(_e, et) {
          if (_e && _e.notFound) return j(errno$1.ENOENT($), null, $)
          if (_e) return j(_e, null, $)
          j(null, stat$1(et), $)
        })
      }),
      (a.writable = function($, j) {
        if ((($ = normalize($)), $ === '/'))
          return process.nextTick(j.bind(null, errno$1.EPERM($)))
        a.follow(path$2.dirname($), function(_e, et) {
          if (_e) return j(_e)
          if (!et.isDirectory()) return j(errno$1.ENOTDIR($))
          j(null, $)
        })
      }),
      (a.list = function($, j) {
        $ = normalize($)
        var _e = prefix($ === '/' ? $ : $ + '/'),
          et = o.createKeyStream({ start: _e, end: _e + '' })
        ;(j = once$1(j)),
          et.on('error', j),
          et.pipe(
            concat({ encoding: 'object' }, function(tt) {
              ;(tt = tt.map(function(rt) {
                return rt.split('/').pop()
              })),
                j(null, tt)
            })
          )
      })
    var s = function($, j) {
      var _e = '/',
        et = $.split('/').slice(1),
        tt = function() {
          a.get(path$2.join(_e, et.shift()), function(rt, nt, it) {
            if (rt) return j(rt, nt, $)
            if (((_e = nt.target || it), !et.length)) return j(null, nt, it)
            tt()
          })
        }
      tt()
    }
    return (
      (a.follow = function($, j) {
        s(normalize($), function _e(et, tt, rt) {
          if (et) return j(et, null, rt)
          if (tt.target) return a.get(tt.target, _e)
          j(null, stat$1(tt), rt)
        })
      }),
      (a.update = function($, j, _e) {
        a.get($, function(et, tt, rt) {
          if (et) return _e(et)
          if (rt === '/') return _e(errno$1.EPERM(rt))
          a.put(rt, xtend$7(tt, j), _e)
        })
      }),
      (a.put = function($, j, _e) {
        a.writable($, function(et, tt) {
          if (et) return _e(et)
          o.put(prefix(tt), stat$1(j), { valueEncoding: 'json' }, _e)
        })
      }),
      (a.del = function($, j) {
        if ((($ = normalize($)), $ === '/'))
          return process.nextTick(j.bind(null, errno$1.EPERM($)))
        o.del(prefix($), j)
      }),
      a
    )
  },
  events = eventsExports,
  watchers$1 = function() {
    var o = {},
      a = new events.EventEmitter()
    return (
      (a.watch = function(s, $) {
        return (
          o[s] || ((o[s] = new events.EventEmitter()), o[s].setMaxListeners(0)),
          $ && o[s].on('change', $),
          o[s]
        )
      }),
      (a.watcher = function(s, $) {
        var j = new events.EventEmitter(),
          _e = function() {
            j.emit('change', 'change', s)
          }
        return (
          a.watch(s, _e),
          $ && j.on('change', $),
          (j.close = function() {
            a.unwatch(s, _e)
          }),
          j
        )
      }),
      (a.unwatch = function(s, $) {
        o[s] &&
          ($
            ? o[s].removeListener('change', $)
            : o[s].removeAllListeners('change'),
          o[s].listeners('change').length || delete o[s])
      }),
      (a.change = function(s) {
        o[s] && o[s].emit('change'), a.emit('change', s)
      }),
      (a.cb = function(s, $) {
        return function(j, _e) {
          s && a.change(s), $ && $(j, _e)
        }
      }),
      a
    )
  },
  fwd = fwdStream,
  sublevel = levelSublevel,
  blobs = levelBlobs,
  peek = levelPeekExports,
  once = onceExports,
  octal = octal$2,
  errno = errno$2,
  paths = paths$1,
  watchers = watchers$1,
  nextTick = function(o, a, s) {
    process.nextTick(function() {
      o(a, s)
    })
  },
  noop$6 = function() {},
  levelFilesystem = function(o, a) {
    var s = {}
    o = sublevel(o)
    var $ = blobs(o.sublevel('blobs'), a),
      j = paths(o.sublevel('stats')),
      _e = o.sublevel('links'),
      et = watchers(),
      tt = [],
      rt = Date.now(),
      nt = function() {
        return ++rt
      }
    ;(s.mkdir = function(st, ut, ct) {
      if (typeof ut == 'function') return s.mkdir(st, null, ut)
      ut || (ut = octal(777)),
        ct || (ct = noop$6),
        j.follow(st, function(dt, ft, mt) {
          if (dt && dt.code !== 'ENOENT') return ct(dt)
          if (ft) return ct(errno.EEXIST(mt))
          j.put(mt, { type: 'directory', mode: ut, size: 4096 }, et.cb(mt, ct))
        })
    }),
      (s.rmdir = function(st, ut) {
        ut || (ut = noop$6),
          j.follow(st, function(ct, dt, ft) {
            if (ct) return ut(ct)
            s.readdir(ft, function(mt, vt) {
              if (mt) return ut(mt)
              if (vt.length) return ut(errno.ENOTEMPTY(ft))
              j.del(ft, et.cb(ft, ut))
            })
          })
      }),
      (s.readdir = function(st, ut) {
        j.follow(st, function(ct, dt, ft) {
          if (ct) return ut(ct)
          if (!dt) return ut(errno.ENOENT(ft))
          if (!dt.isDirectory()) return ut(errno.ENOTDIR(ft))
          j.list(ft, ut)
        })
      })
    var it = function(st, ut, ct) {
      ut(st, function(dt, ft, mt) {
        if (dt) return ct(dt)
        if (!ft.isFile()) return ct(null, ft)
        var vt = (ft && ft.blob) || mt
        $.size(vt, function(yt, pt) {
          if (yt) return ct(yt)
          ;(ft.size = pt), ct(null, ft)
        })
      })
    }
    ;(s.stat = function(st, ut) {
      it(st, j.follow, ut)
    }),
      (s.lstat = function(st, ut) {
        it(st, j.get, ut)
      }),
      (s.exists = function(st, ut) {
        j.follow(st, function(ct) {
          ut(!ct)
        })
      })
    var ot = function(st, ut, ct, dt) {
      dt || (dt = noop$6),
        ut(st, function(ft, mt, vt) {
          if (ft) return dt(ft)
          j.update(vt, { mode: ct }, et.cb(vt, dt))
        })
    }
    ;(s.chmod = function(st, ut, ct) {
      ot(st, j.follow, ut, ct)
    }),
      (s.lchmod = function(st, ut, ct) {
        ot(st, j.get, ut, ct)
      })
    var at = function(st, ut, ct, dt, ft) {
      ft || (ft = noop$6),
        ut(st, function(mt, vt, yt) {
          if (mt) return ft(mt)
          j.update(yt, { uid: ct, gid: dt }, et.cb(yt, ft))
        })
    }
    return (
      (s.chown = function(st, ut, ct, dt) {
        at(st, j.follow, ut, ct, dt)
      }),
      (s.lchown = function(st, ut, ct, dt) {
        at(st, j.get, ut, ct, dt)
      }),
      (s.utimes = function(st, ut, ct, dt) {
        dt || (dt = noop$6),
          j.follow(st, function(ft, mt, vt) {
            if (ft) return dt(ft)
            var yt = {}
            ut && (yt.atime = ut),
              ct && (yt.mtime = ct),
              j.update(vt, yt, et.cb(vt, dt))
          })
      }),
      (s.rename = function(st, ut, ct) {
        ct || (ct = noop$6),
          j.follow(st, function(dt, ft, mt) {
            if (dt) return ct(dt)
            var vt = function() {
              ;(ct = et.cb(ut, et.cb(mt, ct))),
                j.put(ut, ft, function(yt) {
                  if (yt) return ct(yt)
                  j.del(mt, ct)
                })
            }
            j.follow(ut, function(yt, pt, ht) {
              if (yt && yt.code !== 'ENOENT') return ct(yt)
              if (!pt) return vt()
              if (ft.isDirectory() !== pt.isDirectory())
                return ct(errno.EISDIR(mt))
              if (pt.isDirectory()) {
                s.readdir(ht, function(At, wt) {
                  if (At) return ct(At)
                  if (wt.length) return ct(errno.ENOTEMPTY(mt))
                  vt()
                })
                return
              }
              vt()
            })
          })
      }),
      (s.realpath = function(st, ut, ct) {
        if (typeof ut == 'function') return s.realpath(st, null, ut)
        j.follow(st, function(dt, ft, mt) {
          if (dt) return ct(dt)
          ct(null, mt)
        })
      }),
      (s.writeFile = function(st, ut, ct, dt) {
        if (typeof ct == 'function') return s.writeFile(st, ut, null, ct)
        typeof ct == 'string' && (ct = { encoding: ct }),
          ct || (ct = {}),
          dt || (dt = noop$6),
          Buffer.isBuffer(ut) || (ut = new Buffer(ut, ct.encoding || 'utf-8'))
        var ft = ct.flags || 'w'
        ;(ct.append = ft[0] !== 'w'),
          j.follow(st, function(mt, vt, yt) {
            if (mt && mt.code !== 'ENOENT') return dt(mt)
            if (vt && vt.isDirectory()) return dt(errno.EISDIR(yt))
            if (vt && ft[1] === 'x') return dt(errno.EEXIST(yt))
            var pt = (vt && vt.blob) || yt
            j.writable(yt, function(ht) {
              if (ht) return dt(ht)
              $.write(pt, ut, ct, function(At) {
                if (At) return dt(At)
                j.put(
                  yt,
                  {
                    ctime: vt && vt.ctime,
                    mtime: new Date(),
                    mode: ct.mode || octal(666),
                    type: 'file',
                  },
                  et.cb(yt, dt)
                )
              })
            })
          })
      }),
      (s.appendFile = function(st, ut, ct, dt) {
        if (typeof ct == 'function') return s.appendFile(st, ut, null, ct)
        typeof ct == 'string' && (ct = { encoding: ct }),
          ct || (ct = {}),
          (ct.flags = 'a'),
          s.writeFile(st, ut, ct, dt)
      }),
      (s.unlink = function(st, ut) {
        ut || (ut = noop$6),
          j.get(st, function(ct, dt, ft) {
            if (ct) return ut(ct)
            if (dt.isDirectory()) return ut(errno.EISDIR(ft))
            var mt = function(yt) {
                peek(_e, { start: yt + '', end: yt + '' }, function(pt) {
                  if (pt) return $.remove(yt, ut)
                  ut()
                })
              },
              vt = function() {
                var yt = dt.link.slice(0, dt.link.indexOf(''))
                _e.del(dt.link, function(pt) {
                  if (pt) return ut(pt)
                  mt(yt)
                })
              }
            j.del(
              ft,
              et.cb(ft, function(yt) {
                if (yt) return ut(yt)
                if (dt.link) return vt()
                _e.del(ft + '', function(pt) {
                  if (pt) return ut(pt)
                  mt(ft)
                })
              })
            )
          })
      }),
      (s.readFile = function(st, ut, ct) {
        if (typeof ut == 'function') return s.readFile(st, null, ut)
        typeof ut == 'string' && (ut = { encoding: ut }),
          ut || (ut = {}),
          ut.encoding,
          ut.flag,
          j.follow(st, function(dt, ft, mt) {
            if (dt) return ct(dt)
            if (ft.isDirectory()) return ct(errno.EISDIR(mt))
            var vt = (ft && ft.blob) || mt
            $.read(vt, function(yt, pt) {
              if (yt) return ct(yt)
              ct(null, ut.encoding ? pt.toString(ut.encoding) : pt)
            })
          })
      }),
      (s.createReadStream = function(st, ut) {
        ut || (ut = {})
        var ct = !1,
          dt = fwd.readable(function(ft) {
            j.follow(st, function(mt, vt, yt) {
              if (mt) return ft(mt)
              if (vt.isDirectory()) return ft(errno.EISDIR(yt))
              var pt = (vt && vt.blob) || yt,
                ht = $.createReadStream(pt, ut)
              dt.emit('open'),
                ht.on('end', function() {
                  process.nextTick(function() {
                    ct || dt.emit('close')
                  })
                }),
                ft(null, ht)
            })
          })
        return (
          dt.on('close', function() {
            ct = !0
          }),
          dt
        )
      }),
      (s.createWriteStream = function(st, ut) {
        ut || (ut = {})
        var ct = ut.flags || 'w',
          dt = !1,
          ft = ut.mode || octal(666)
        ut.append = ct[0] === 'a'
        var mt = fwd.writable(function(vt) {
          j.follow(st, function(yt, pt, ht) {
            if (yt && yt.code !== 'ENOENT') return vt(yt)
            if (pt && pt.isDirectory()) return vt(errno.EISDIR(ht))
            if (pt && ct[1] === 'x') return vt(errno.EEXIST(ht))
            var At = (pt && pt.blob) || ht
            j.writable(At, function(wt) {
              if (wt) return vt(wt)
              var Ct = pt ? pt.ctime : new Date(),
                Dt = { ctime: Ct, mtime: new Date(), mode: ft, type: 'file' }
              j.put(ht, Dt, function(jt) {
                if (jt) return vt(jt)
                var Et = $.createWriteStream(At, ut)
                mt.emit('open'),
                  Et.on('finish', function() {
                    ;(Dt.mtime = new Date()),
                      j.put(ht, Dt, function() {
                        et.change(ht), dt || mt.emit('close')
                      })
                  }),
                  vt(null, Et)
              })
            })
          })
        })
        return (
          mt.on('close', function() {
            dt = !0
          }),
          mt
        )
      }),
      (s.truncate = function(st, ut, ct) {
        j.follow(st, function(dt, ft, mt) {
          if (dt) return ct(dt)
          var vt = (ft && ft.blob) || mt
          $.size(vt, function(yt, pt) {
            if (yt) return ct(yt)
            j.writable(mt, function(ht) {
              if (ht) return ct(ht)
              if (((ct = once(et.cb(mt, ct))), !ut)) return $.remove(vt, ct)
              var At = $.createWriteStream(vt, { start: pt < ut ? ut - 1 : ut })
              At.on('error', ct),
                At.on('finish', ct),
                pt < ut && At.write(new Buffer([0])),
                At.end()
            })
          })
        })
      }),
      (s.watchFile = function(st, ut, ct) {
        return typeof ut == 'function'
          ? s.watchFile(st, null, ut)
          : et.watch(j.normalize(st), ct)
      }),
      (s.unwatchFile = function(st, ut) {
        et.unwatch(j.normalize(st), ut)
      }),
      (s.watch = function(st, ut, ct) {
        return typeof ut == 'function'
          ? s.watch(st, null, ut)
          : et.watcher(j.normalize(st), ct)
      }),
      (s.notify = function(st) {
        et.on('change', st)
      }),
      (s.open = function(st, ut, ct, dt) {
        if (typeof ct == 'function') return s.open(st, ut, null, ct)
        j.follow(st, function(ft, mt, vt) {
          if (ft && ft.code !== 'ENOENT') return dt(ft)
          var yt = ut[0],
            pt = ut[1] === '+' || ut[2] === '+',
            ht = (mt && mt.blob) || vt,
            At = {
              key: vt,
              blob: ht,
              mode: ct || octal(666),
              readable: yt === 'r' || ((yt === 'w' || yt === 'a') && pt),
              writable: yt === 'w' || yt === 'a' || (yt === 'r' && pt),
              append: yt === 'a',
            }
          if (yt === 'r' && ft) return dt(ft)
          if (ut[1] === 'x' && mt) return dt(errno.EEXIST(vt))
          if (mt && mt.isDirectory()) return dt(errno.EISDIR(vt))
          $.size(ht, function(wt, Ct) {
            if (wt) return dt(wt)
            At.append && (At.writePos = Ct),
              j.writable(vt, function(Dt) {
                if (Dt) return dt(Dt)
                var jt = function(St) {
                    if (St) return dt(St)
                    var Bt = tt.indexOf(null)
                    Bt === -1 && (Bt = 10 + tt.push(tt.length + 10) - 1),
                      (At.fd = Bt),
                      (tt[Bt] = At),
                      et.change(vt),
                      dt(null, At.fd)
                  },
                  Et = function(St) {
                    if (St) return dt(St)
                    if (mt) return jt()
                    j.put(ht, { ctime: mt && mt.ctime, type: 'file' }, jt)
                  }
                if (!At.append && At.writable) return $.remove(ht, Et)
                Et()
              })
          })
        })
      }),
      (s.close = function(st, ut) {
        var ct = tt[st]
        if (!ct) return nextTick(ut, errno.EBADF())
        ;(tt[st] = null), nextTick(et.cb(ct.key, ut))
      }),
      (s.write = function(st, ut, ct, dt, ft, mt) {
        var vt = tt[st]
        if ((mt || (mt = noop$6), !vt || !vt.writable))
          return nextTick(mt, errno.EBADF())
        ft === null && (ft = vt.writePos || 0)
        var yt = ut.slice(ct, ct + dt)
        ;(vt.writePos = ft + yt.length),
          $.write(vt.blob, yt, { start: ft, append: !0 }, function(pt) {
            if (pt) return mt(pt)
            mt(null, dt, ut)
          })
      }),
      (s.read = function(st, ut, ct, dt, ft, mt) {
        var vt = tt[st]
        if ((mt || (mt = noop$6), !vt || !vt.readable))
          return nextTick(mt, errno.EBADF())
        ft === null && (ft = s.readPos || 0),
          $.read(vt.blob, { start: ft, end: ft + dt - 1 }, function(yt, pt) {
            if (yt) return mt(yt)
            var ht = pt.slice(0, dt)
            ht.copy(ut, ct),
              (s.readPos = ft + ht.length),
              mt(null, ht.length, ut)
          })
      }),
      (s.fsync = function(st, ut) {
        var ct = tt[st]
        if ((ut || (ut = noop$6), !ct || !ct.writable))
          return nextTick(ut, errno.EBADF())
        nextTick(ut)
      }),
      (s.ftruncate = function(st, ut, ct) {
        var dt = tt[st]
        if ((ct || (ct = noop$6), !dt)) return nextTick(ct, errno.EBADF())
        s.truncate(dt.blob, ut, ct)
      }),
      (s.fchown = function(st, ut, ct, dt) {
        var ft = tt[st]
        if ((dt || (dt = noop$6), !ft)) return nextTick(dt, errno.EBADF())
        s.chown(ft.key, ut, ct, dt)
      }),
      (s.fchmod = function(st, ut, ct) {
        var dt = tt[st]
        if ((ct || (ct = noop$6), !dt)) return nextTick(ct, errno.EBADF())
        s.chmod(dt.key, ut, ct)
      }),
      (s.futimes = function(st, ut, ct, dt) {
        var ft = tt[st]
        if ((dt || (dt = noop$6), !ft)) return nextTick(dt, errno.EBADF())
        s.utimes(ft.key, ut, ct, dt)
      }),
      (s.fstat = function(st, ut) {
        var ct = tt[st]
        if (!ct) return nextTick(ut, errno.EBADF())
        s.stat(ct.key, ut)
      }),
      (s.symlink = function(st, ut, ct) {
        ct || (ct = noop$6),
          j.follow(st, function(dt, ft, mt) {
            if (dt) return ct(dt)
            j.get(ut, function(vt, yt) {
              if (vt && vt.code !== 'ENOENT') return ct(vt)
              if (yt) return ct(errno.EEXIST(ut))
              j.put(ut, { type: 'symlink', target: mt, mode: octal(777) }, ct)
            })
          })
      }),
      (s.readlink = function(st, ut) {
        j.get(st, function(ct, dt) {
          if (ct) return ut(ct)
          if (!dt.target) return ut(errno.EINVAL(st))
          ut(null, dt.target)
        })
      }),
      (s.link = function(st, ut, ct) {
        ct || (ct = noop$6),
          j.follow(st, function(dt, ft, mt) {
            if (dt) return ct(dt)
            if (!ft.isFile()) return ct(errno.EINVAL(mt))
            j.get(ut, function(vt, yt) {
              if (vt && vt.code !== 'ENOENT') return ct(vt)
              if (yt) return ct(errno.EEXIST(ut))
              var pt = mt + '' + nt()
              _e.put(mt + '', mt, function(ht) {
                if (ht) return ct(ht)
                _e.put(pt, mt, function(At) {
                  if (At) return ct(At)
                  j.put(
                    ut,
                    { type: 'file', link: pt, blob: mt, mode: ft.mode },
                    ct
                  )
                })
              })
            })
          })
      }),
      s
    )
  },
  leveljs = levelJs,
  levelup = levelupExports,
  fs$2 = levelFilesystem,
  db$1 = levelup('level-filesystem', { db: leveljs }),
  fs_1 = fs$2(db$1)
const fs$3 = getDefaultExportFromCjs(fs_1)
function isNodePattern(o) {
  if (typeof o > 'u') return !1
  if (typeof o != 'function') throw new TypeError('Callback must be a function')
  return !0
}
function throwError(o, a) {
  if ((typeof o == 'string' && (o = new Error(o)), typeof a == 'function'))
    return a.call(this, o)
  throw o
}
function scan(o, a, s, $, j, _e) {
  ;(a = Math.round(a)),
    (s = Math.round(s)),
    ($ = Math.round($)),
    (j = Math.round(j))
  for (let et = s; et < s + j; et++)
    for (let tt = a; tt < a + $; tt++) {
      const rt = (o.bitmap.width * et + tt) << 2
      _e.call(o, tt, et, rt)
    }
  return o
}
function* scanIterator(o, a, s, $, j) {
  ;(a = Math.round(a)),
    (s = Math.round(s)),
    ($ = Math.round($)),
    (j = Math.round(j))
  for (let _e = s; _e < s + j; _e++)
    for (let et = a; et < a + $; et++) {
      const tt = (o.bitmap.width * _e + et) << 2
      yield { x: et, y: _e, idx: tt, image: o }
    }
}
function Converter$1(o, a) {
  if (!o || !a || !o.length || !a.length) throw new Error('Bad alphabet')
  ;(this.srcAlphabet = o), (this.dstAlphabet = a)
}
Converter$1.prototype.convert = function(o) {
  var a,
    s,
    $,
    j = {},
    _e = this.srcAlphabet.length,
    et = this.dstAlphabet.length,
    tt = o.length,
    rt = typeof o == 'string' ? '' : []
  if (!this.isValid(o))
    throw new Error(
      'Number "' +
        o +
        '" contains of non-alphabetic digits (' +
        this.srcAlphabet +
        ')'
    )
  if (this.srcAlphabet === this.dstAlphabet) return o
  for (a = 0; a < tt; a++) j[a] = this.srcAlphabet.indexOf(o[a])
  do {
    for (s = 0, $ = 0, a = 0; a < tt; a++)
      (s = s * _e + j[a]),
        s >= et
          ? ((j[$++] = parseInt(s / et, 10)), (s = s % et))
          : $ > 0 && (j[$++] = 0)
    ;(tt = $), (rt = this.dstAlphabet.slice(s, s + 1).concat(rt))
  } while ($ !== 0)
  return rt
}
Converter$1.prototype.isValid = function(o) {
  for (var a = 0; a < o.length; ++a)
    if (this.srcAlphabet.indexOf(o[a]) === -1) return !1
  return !0
}
var converter = Converter$1,
  Converter = converter
function anyBase(o, a) {
  var s = new Converter(o, a)
  return function($) {
    return s.convert($)
  }
}
anyBase.BIN = '01'
anyBase.OCT = '01234567'
anyBase.DEC = '0123456789'
anyBase.HEX = '0123456789abcdef'
var anyBase_1 = anyBase
const anyBase$1 = getDefaultExportFromCjs(anyBase_1)
var pixelmatch_1 = pixelmatch
function pixelmatch(o, a, s, $, j, _e) {
  _e || (_e = {})
  for (
    var et = _e.threshold === void 0 ? 0.1 : _e.threshold,
      tt = 35215 * et * et,
      rt = 0,
      nt = 0;
    nt < j;
    nt++
  )
    for (var it = 0; it < $; it++) {
      var ot = (nt * $ + it) * 4,
        at = colorDelta(o, a, ot, ot)
      if (at > tt)
        !_e.includeAA &&
        (antialiased(o, it, nt, $, j, a) || antialiased(a, it, nt, $, j, o))
          ? s && drawPixel(s, ot, 255, 255, 0)
          : (s && drawPixel(s, ot, 255, 0, 0), rt++)
      else if (s) {
        var st = blend(grayPixel(o, ot), 0.1)
        drawPixel(s, ot, st, st, st)
      }
    }
  return rt
}
function antialiased(o, a, s, $, j, _e) {
  for (
    var et = Math.max(a - 1, 0),
      tt = Math.max(s - 1, 0),
      rt = Math.min(a + 1, $ - 1),
      nt = Math.min(s + 1, j - 1),
      it = (s * $ + a) * 4,
      ot = 0,
      at = 0,
      st = 0,
      ut = 0,
      ct = 0,
      dt,
      ft,
      mt,
      vt,
      yt = et;
    yt <= rt;
    yt++
  )
    for (var pt = tt; pt <= nt; pt++)
      if (!(yt === a && pt === s)) {
        var ht = colorDelta(o, o, it, (pt * $ + yt) * 4, !0)
        if ((ht === 0 ? ot++ : ht < 0 ? st++ : ht > 0 && at++, ot > 2))
          return !1
        _e &&
          (ht < ut && ((ut = ht), (dt = yt), (ft = pt)),
          ht > ct && ((ct = ht), (mt = yt), (vt = pt)))
      }
  return _e
    ? st === 0 || at === 0
      ? !1
      : (!antialiased(o, dt, ft, $, j) && !antialiased(_e, dt, ft, $, j)) ||
        (!antialiased(o, mt, vt, $, j) && !antialiased(_e, mt, vt, $, j))
    : !0
}
function colorDelta(o, a, s, $, j) {
  var _e = o[s + 3] / 255,
    et = a[$ + 3] / 255,
    tt = blend(o[s + 0], _e),
    rt = blend(o[s + 1], _e),
    nt = blend(o[s + 2], _e),
    it = blend(a[$ + 0], et),
    ot = blend(a[$ + 1], et),
    at = blend(a[$ + 2], et),
    st = rgb2y(tt, rt, nt) - rgb2y(it, ot, at)
  if (j) return st
  var ut = rgb2i(tt, rt, nt) - rgb2i(it, ot, at),
    ct = rgb2q(tt, rt, nt) - rgb2q(it, ot, at)
  return 0.5053 * st * st + 0.299 * ut * ut + 0.1957 * ct * ct
}
function rgb2y(o, a, s) {
  return o * 0.29889531 + a * 0.58662247 + s * 0.11448223
}
function rgb2i(o, a, s) {
  return o * 0.59597799 - a * 0.2741761 - s * 0.32180189
}
function rgb2q(o, a, s) {
  return o * 0.21147017 - a * 0.52261711 + s * 0.31114694
}
function blend(o, a) {
  return 255 + (o - 255) * a
}
function drawPixel(o, a, s, $, j) {
  ;(o[a + 0] = s), (o[a + 1] = $), (o[a + 2] = j), (o[a + 3] = 255)
}
function grayPixel(o, a) {
  var s = o[a + 3] / 255,
    $ = blend(o[a + 0], s),
    j = blend(o[a + 1], s),
    _e = blend(o[a + 2], s)
  return rgb2y($, j, _e)
}
const pixelMatch = getDefaultExportFromCjs(pixelmatch_1)
function _typeof$4(o) {
  '@babel/helpers - typeof'
  return (
    (_typeof$4 =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function(a) {
            return typeof a
          }
        : function(a) {
            return a &&
              typeof Symbol == 'function' &&
              a.constructor === Symbol &&
              a !== Symbol.prototype
              ? 'symbol'
              : typeof a
          }),
    _typeof$4(o)
  )
}
var trimLeft = /^\s+/,
  trimRight = /\s+$/
function tinycolor(o, a) {
  if (((o = o || ''), (a = a || {}), o instanceof tinycolor)) return o
  if (!(this instanceof tinycolor)) return new tinycolor(o, a)
  var s = inputToRGB(o)
  ;(this._originalInput = o),
    (this._r = s.r),
    (this._g = s.g),
    (this._b = s.b),
    (this._a = s.a),
    (this._roundA = Math.round(100 * this._a) / 100),
    (this._format = a.format || s.format),
    (this._gradientType = a.gradientType),
    this._r < 1 && (this._r = Math.round(this._r)),
    this._g < 1 && (this._g = Math.round(this._g)),
    this._b < 1 && (this._b = Math.round(this._b)),
    (this._ok = s.ok)
}
tinycolor.prototype = {
  isDark: function() {
    return this.getBrightness() < 128
  },
  isLight: function() {
    return !this.isDark()
  },
  isValid: function() {
    return this._ok
  },
  getOriginalInput: function() {
    return this._originalInput
  },
  getFormat: function() {
    return this._format
  },
  getAlpha: function() {
    return this._a
  },
  getBrightness: function() {
    var a = this.toRgb()
    return (a.r * 299 + a.g * 587 + a.b * 114) / 1e3
  },
  getLuminance: function() {
    var a = this.toRgb(),
      s,
      $,
      j,
      _e,
      et,
      tt
    return (
      (s = a.r / 255),
      ($ = a.g / 255),
      (j = a.b / 255),
      s <= 0.03928
        ? (_e = s / 12.92)
        : (_e = Math.pow((s + 0.055) / 1.055, 2.4)),
      $ <= 0.03928
        ? (et = $ / 12.92)
        : (et = Math.pow(($ + 0.055) / 1.055, 2.4)),
      j <= 0.03928
        ? (tt = j / 12.92)
        : (tt = Math.pow((j + 0.055) / 1.055, 2.4)),
      0.2126 * _e + 0.7152 * et + 0.0722 * tt
    )
  },
  setAlpha: function(a) {
    return (
      (this._a = boundAlpha(a)),
      (this._roundA = Math.round(100 * this._a) / 100),
      this
    )
  },
  toHsv: function() {
    var a = rgbToHsv(this._r, this._g, this._b)
    return { h: a.h * 360, s: a.s, v: a.v, a: this._a }
  },
  toHsvString: function() {
    var a = rgbToHsv(this._r, this._g, this._b),
      s = Math.round(a.h * 360),
      $ = Math.round(a.s * 100),
      j = Math.round(a.v * 100)
    return this._a == 1
      ? 'hsv(' + s + ', ' + $ + '%, ' + j + '%)'
      : 'hsva(' + s + ', ' + $ + '%, ' + j + '%, ' + this._roundA + ')'
  },
  toHsl: function() {
    var a = rgbToHsl(this._r, this._g, this._b)
    return { h: a.h * 360, s: a.s, l: a.l, a: this._a }
  },
  toHslString: function() {
    var a = rgbToHsl(this._r, this._g, this._b),
      s = Math.round(a.h * 360),
      $ = Math.round(a.s * 100),
      j = Math.round(a.l * 100)
    return this._a == 1
      ? 'hsl(' + s + ', ' + $ + '%, ' + j + '%)'
      : 'hsla(' + s + ', ' + $ + '%, ' + j + '%, ' + this._roundA + ')'
  },
  toHex: function(a) {
    return rgbToHex(this._r, this._g, this._b, a)
  },
  toHexString: function(a) {
    return '#' + this.toHex(a)
  },
  toHex8: function(a) {
    return rgbaToHex(this._r, this._g, this._b, this._a, a)
  },
  toHex8String: function(a) {
    return '#' + this.toHex8(a)
  },
  toRgb: function() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a,
    }
  },
  toRgbString: function() {
    return this._a == 1
      ? 'rgb(' +
          Math.round(this._r) +
          ', ' +
          Math.round(this._g) +
          ', ' +
          Math.round(this._b) +
          ')'
      : 'rgba(' +
          Math.round(this._r) +
          ', ' +
          Math.round(this._g) +
          ', ' +
          Math.round(this._b) +
          ', ' +
          this._roundA +
          ')'
  },
  toPercentageRgb: function() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + '%',
      g: Math.round(bound01(this._g, 255) * 100) + '%',
      b: Math.round(bound01(this._b, 255) * 100) + '%',
      a: this._a,
    }
  },
  toPercentageRgbString: function() {
    return this._a == 1
      ? 'rgb(' +
          Math.round(bound01(this._r, 255) * 100) +
          '%, ' +
          Math.round(bound01(this._g, 255) * 100) +
          '%, ' +
          Math.round(bound01(this._b, 255) * 100) +
          '%)'
      : 'rgba(' +
          Math.round(bound01(this._r, 255) * 100) +
          '%, ' +
          Math.round(bound01(this._g, 255) * 100) +
          '%, ' +
          Math.round(bound01(this._b, 255) * 100) +
          '%, ' +
          this._roundA +
          ')'
  },
  toName: function() {
    return this._a === 0
      ? 'transparent'
      : this._a < 1
      ? !1
      : hexNames[rgbToHex(this._r, this._g, this._b, !0)] || !1
  },
  toFilter: function(a) {
    var s = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a),
      $ = s,
      j = this._gradientType ? 'GradientType = 1, ' : ''
    if (a) {
      var _e = tinycolor(a)
      $ = '#' + rgbaToArgbHex(_e._r, _e._g, _e._b, _e._a)
    }
    return (
      'progid:DXImageTransform.Microsoft.gradient(' +
      j +
      'startColorstr=' +
      s +
      ',endColorstr=' +
      $ +
      ')'
    )
  },
  toString: function(a) {
    var s = !!a
    a = a || this._format
    var $ = !1,
      j = this._a < 1 && this._a >= 0,
      _e =
        !s &&
        j &&
        (a === 'hex' ||
          a === 'hex6' ||
          a === 'hex3' ||
          a === 'hex4' ||
          a === 'hex8' ||
          a === 'name')
    return _e
      ? a === 'name' && this._a === 0
        ? this.toName()
        : this.toRgbString()
      : (a === 'rgb' && ($ = this.toRgbString()),
        a === 'prgb' && ($ = this.toPercentageRgbString()),
        (a === 'hex' || a === 'hex6') && ($ = this.toHexString()),
        a === 'hex3' && ($ = this.toHexString(!0)),
        a === 'hex4' && ($ = this.toHex8String(!0)),
        a === 'hex8' && ($ = this.toHex8String()),
        a === 'name' && ($ = this.toName()),
        a === 'hsl' && ($ = this.toHslString()),
        a === 'hsv' && ($ = this.toHsvString()),
        $ || this.toHexString())
  },
  clone: function() {
    return tinycolor(this.toString())
  },
  _applyModification: function(a, s) {
    var $ = a.apply(null, [this].concat([].slice.call(s)))
    return (
      (this._r = $._r),
      (this._g = $._g),
      (this._b = $._b),
      this.setAlpha($._a),
      this
    )
  },
  lighten: function() {
    return this._applyModification(_lighten, arguments)
  },
  brighten: function() {
    return this._applyModification(_brighten, arguments)
  },
  darken: function() {
    return this._applyModification(_darken, arguments)
  },
  desaturate: function() {
    return this._applyModification(_desaturate, arguments)
  },
  saturate: function() {
    return this._applyModification(_saturate, arguments)
  },
  greyscale: function() {
    return this._applyModification(_greyscale, arguments)
  },
  spin: function() {
    return this._applyModification(_spin, arguments)
  },
  _applyCombination: function(a, s) {
    return a.apply(null, [this].concat([].slice.call(s)))
  },
  analogous: function() {
    return this._applyCombination(_analogous, arguments)
  },
  complement: function() {
    return this._applyCombination(_complement, arguments)
  },
  monochromatic: function() {
    return this._applyCombination(_monochromatic, arguments)
  },
  splitcomplement: function() {
    return this._applyCombination(_splitcomplement, arguments)
  },
  triad: function() {
    return this._applyCombination(polyad, [3])
  },
  tetrad: function() {
    return this._applyCombination(polyad, [4])
  },
}
tinycolor.fromRatio = function(o, a) {
  if (_typeof$4(o) == 'object') {
    var s = {}
    for (var $ in o)
      o.hasOwnProperty($) &&
        ($ === 'a' ? (s[$] = o[$]) : (s[$] = convertToPercentage(o[$])))
    o = s
  }
  return tinycolor(o, a)
}
function inputToRGB(o) {
  var a = { r: 0, g: 0, b: 0 },
    s = 1,
    $ = null,
    j = null,
    _e = null,
    et = !1,
    tt = !1
  return (
    typeof o == 'string' && (o = stringInputToObject(o)),
    _typeof$4(o) == 'object' &&
      (isValidCSSUnit(o.r) && isValidCSSUnit(o.g) && isValidCSSUnit(o.b)
        ? ((a = rgbToRgb(o.r, o.g, o.b)),
          (et = !0),
          (tt = String(o.r).substr(-1) === '%' ? 'prgb' : 'rgb'))
        : isValidCSSUnit(o.h) && isValidCSSUnit(o.s) && isValidCSSUnit(o.v)
        ? (($ = convertToPercentage(o.s)),
          (j = convertToPercentage(o.v)),
          (a = hsvToRgb(o.h, $, j)),
          (et = !0),
          (tt = 'hsv'))
        : isValidCSSUnit(o.h) &&
          isValidCSSUnit(o.s) &&
          isValidCSSUnit(o.l) &&
          (($ = convertToPercentage(o.s)),
          (_e = convertToPercentage(o.l)),
          (a = hslToRgb(o.h, $, _e)),
          (et = !0),
          (tt = 'hsl')),
      o.hasOwnProperty('a') && (s = o.a)),
    (s = boundAlpha(s)),
    {
      ok: et,
      format: o.format || tt,
      r: Math.min(255, Math.max(a.r, 0)),
      g: Math.min(255, Math.max(a.g, 0)),
      b: Math.min(255, Math.max(a.b, 0)),
      a: s,
    }
  )
}
function rgbToRgb(o, a, s) {
  return {
    r: bound01(o, 255) * 255,
    g: bound01(a, 255) * 255,
    b: bound01(s, 255) * 255,
  }
}
function rgbToHsl(o, a, s) {
  ;(o = bound01(o, 255)), (a = bound01(a, 255)), (s = bound01(s, 255))
  var $ = Math.max(o, a, s),
    j = Math.min(o, a, s),
    _e,
    et,
    tt = ($ + j) / 2
  if ($ == j) _e = et = 0
  else {
    var rt = $ - j
    switch (((et = tt > 0.5 ? rt / (2 - $ - j) : rt / ($ + j)), $)) {
      case o:
        _e = (a - s) / rt + (a < s ? 6 : 0)
        break
      case a:
        _e = (s - o) / rt + 2
        break
      case s:
        _e = (o - a) / rt + 4
        break
    }
    _e /= 6
  }
  return { h: _e, s: et, l: tt }
}
function hslToRgb(o, a, s) {
  var $, j, _e
  ;(o = bound01(o, 360)), (a = bound01(a, 100)), (s = bound01(s, 100))
  function et(nt, it, ot) {
    return (
      ot < 0 && (ot += 1),
      ot > 1 && (ot -= 1),
      ot < 1 / 6
        ? nt + (it - nt) * 6 * ot
        : ot < 1 / 2
        ? it
        : ot < 2 / 3
        ? nt + (it - nt) * (2 / 3 - ot) * 6
        : nt
    )
  }
  if (a === 0) $ = j = _e = s
  else {
    var tt = s < 0.5 ? s * (1 + a) : s + a - s * a,
      rt = 2 * s - tt
    ;($ = et(rt, tt, o + 1 / 3)),
      (j = et(rt, tt, o)),
      (_e = et(rt, tt, o - 1 / 3))
  }
  return { r: $ * 255, g: j * 255, b: _e * 255 }
}
function rgbToHsv(o, a, s) {
  ;(o = bound01(o, 255)), (a = bound01(a, 255)), (s = bound01(s, 255))
  var $ = Math.max(o, a, s),
    j = Math.min(o, a, s),
    _e,
    et,
    tt = $,
    rt = $ - j
  if (((et = $ === 0 ? 0 : rt / $), $ == j)) _e = 0
  else {
    switch ($) {
      case o:
        _e = (a - s) / rt + (a < s ? 6 : 0)
        break
      case a:
        _e = (s - o) / rt + 2
        break
      case s:
        _e = (o - a) / rt + 4
        break
    }
    _e /= 6
  }
  return { h: _e, s: et, v: tt }
}
function hsvToRgb(o, a, s) {
  ;(o = bound01(o, 360) * 6), (a = bound01(a, 100)), (s = bound01(s, 100))
  var $ = Math.floor(o),
    j = o - $,
    _e = s * (1 - a),
    et = s * (1 - j * a),
    tt = s * (1 - (1 - j) * a),
    rt = $ % 6,
    nt = [s, et, _e, _e, tt, s][rt],
    it = [tt, s, s, et, _e, _e][rt],
    ot = [_e, _e, tt, s, s, et][rt]
  return { r: nt * 255, g: it * 255, b: ot * 255 }
}
function rgbToHex(o, a, s, $) {
  var j = [
    pad2(Math.round(o).toString(16)),
    pad2(Math.round(a).toString(16)),
    pad2(Math.round(s).toString(16)),
  ]
  return $ &&
    j[0].charAt(0) == j[0].charAt(1) &&
    j[1].charAt(0) == j[1].charAt(1) &&
    j[2].charAt(0) == j[2].charAt(1)
    ? j[0].charAt(0) + j[1].charAt(0) + j[2].charAt(0)
    : j.join('')
}
function rgbaToHex(o, a, s, $, j) {
  var _e = [
    pad2(Math.round(o).toString(16)),
    pad2(Math.round(a).toString(16)),
    pad2(Math.round(s).toString(16)),
    pad2(convertDecimalToHex($)),
  ]
  return j &&
    _e[0].charAt(0) == _e[0].charAt(1) &&
    _e[1].charAt(0) == _e[1].charAt(1) &&
    _e[2].charAt(0) == _e[2].charAt(1) &&
    _e[3].charAt(0) == _e[3].charAt(1)
    ? _e[0].charAt(0) + _e[1].charAt(0) + _e[2].charAt(0) + _e[3].charAt(0)
    : _e.join('')
}
function rgbaToArgbHex(o, a, s, $) {
  var j = [
    pad2(convertDecimalToHex($)),
    pad2(Math.round(o).toString(16)),
    pad2(Math.round(a).toString(16)),
    pad2(Math.round(s).toString(16)),
  ]
  return j.join('')
}
tinycolor.equals = function(o, a) {
  return !o || !a
    ? !1
    : tinycolor(o).toRgbString() == tinycolor(a).toRgbString()
}
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random(),
  })
}
function _desaturate(o, a) {
  a = a === 0 ? 0 : a || 10
  var s = tinycolor(o).toHsl()
  return (s.s -= a / 100), (s.s = clamp01(s.s)), tinycolor(s)
}
function _saturate(o, a) {
  a = a === 0 ? 0 : a || 10
  var s = tinycolor(o).toHsl()
  return (s.s += a / 100), (s.s = clamp01(s.s)), tinycolor(s)
}
function _greyscale(o) {
  return tinycolor(o).desaturate(100)
}
function _lighten(o, a) {
  a = a === 0 ? 0 : a || 10
  var s = tinycolor(o).toHsl()
  return (s.l += a / 100), (s.l = clamp01(s.l)), tinycolor(s)
}
function _brighten(o, a) {
  a = a === 0 ? 0 : a || 10
  var s = tinycolor(o).toRgb()
  return (
    (s.r = Math.max(0, Math.min(255, s.r - Math.round(255 * -(a / 100))))),
    (s.g = Math.max(0, Math.min(255, s.g - Math.round(255 * -(a / 100))))),
    (s.b = Math.max(0, Math.min(255, s.b - Math.round(255 * -(a / 100))))),
    tinycolor(s)
  )
}
function _darken(o, a) {
  a = a === 0 ? 0 : a || 10
  var s = tinycolor(o).toHsl()
  return (s.l -= a / 100), (s.l = clamp01(s.l)), tinycolor(s)
}
function _spin(o, a) {
  var s = tinycolor(o).toHsl(),
    $ = (s.h + a) % 360
  return (s.h = $ < 0 ? 360 + $ : $), tinycolor(s)
}
function _complement(o) {
  var a = tinycolor(o).toHsl()
  return (a.h = (a.h + 180) % 360), tinycolor(a)
}
function polyad(o, a) {
  if (isNaN(a) || a <= 0)
    throw new Error('Argument to polyad must be a positive number')
  for (
    var s = tinycolor(o).toHsl(), $ = [tinycolor(o)], j = 360 / a, _e = 1;
    _e < a;
    _e++
  )
    $.push(tinycolor({ h: (s.h + _e * j) % 360, s: s.s, l: s.l }))
  return $
}
function _splitcomplement(o) {
  var a = tinycolor(o).toHsl(),
    s = a.h
  return [
    tinycolor(o),
    tinycolor({ h: (s + 72) % 360, s: a.s, l: a.l }),
    tinycolor({ h: (s + 216) % 360, s: a.s, l: a.l }),
  ]
}
function _analogous(o, a, s) {
  ;(a = a || 6), (s = s || 30)
  var $ = tinycolor(o).toHsl(),
    j = 360 / s,
    _e = [tinycolor(o)]
  for ($.h = ($.h - ((j * a) >> 1) + 720) % 360; --a; )
    ($.h = ($.h + j) % 360), _e.push(tinycolor($))
  return _e
}
function _monochromatic(o, a) {
  a = a || 6
  for (
    var s = tinycolor(o).toHsv(),
      $ = s.h,
      j = s.s,
      _e = s.v,
      et = [],
      tt = 1 / a;
    a--;

  )
    et.push(tinycolor({ h: $, s: j, v: _e })), (_e = (_e + tt) % 1)
  return et
}
tinycolor.mix = function(o, a, s) {
  s = s === 0 ? 0 : s || 50
  var $ = tinycolor(o).toRgb(),
    j = tinycolor(a).toRgb(),
    _e = s / 100,
    et = {
      r: (j.r - $.r) * _e + $.r,
      g: (j.g - $.g) * _e + $.g,
      b: (j.b - $.b) * _e + $.b,
      a: (j.a - $.a) * _e + $.a,
    }
  return tinycolor(et)
}
tinycolor.readability = function(o, a) {
  var s = tinycolor(o),
    $ = tinycolor(a)
  return (
    (Math.max(s.getLuminance(), $.getLuminance()) + 0.05) /
    (Math.min(s.getLuminance(), $.getLuminance()) + 0.05)
  )
}
tinycolor.isReadable = function(o, a, s) {
  var $ = tinycolor.readability(o, a),
    j,
    _e
  switch (((_e = !1), (j = validateWCAG2Parms(s)), j.level + j.size)) {
    case 'AAsmall':
    case 'AAAlarge':
      _e = $ >= 4.5
      break
    case 'AAlarge':
      _e = $ >= 3
      break
    case 'AAAsmall':
      _e = $ >= 7
      break
  }
  return _e
}
tinycolor.mostReadable = function(o, a, s) {
  var $ = null,
    j = 0,
    _e,
    et,
    tt,
    rt
  ;(s = s || {}), (et = s.includeFallbackColors), (tt = s.level), (rt = s.size)
  for (var nt = 0; nt < a.length; nt++)
    (_e = tinycolor.readability(o, a[nt])),
      _e > j && ((j = _e), ($ = tinycolor(a[nt])))
  return tinycolor.isReadable(o, $, { level: tt, size: rt }) || !et
    ? $
    : ((s.includeFallbackColors = !1),
      tinycolor.mostReadable(o, ['#fff', '#000'], s))
}
var names = (tinycolor.names = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '0ff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000',
    blanchedalmond: 'ffebcd',
    blue: '00f',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    burntsienna: 'ea7e5d',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '0ff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'f0f',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '789',
    lightslategrey: '789',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '0f0',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'f0f',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    rebeccapurple: '663399',
    red: 'f00',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'fff',
    whitesmoke: 'f5f5f5',
    yellow: 'ff0',
    yellowgreen: '9acd32',
  }),
  hexNames = (tinycolor.hexNames = flip(names))
function flip(o) {
  var a = {}
  for (var s in o) o.hasOwnProperty(s) && (a[o[s]] = s)
  return a
}
function boundAlpha(o) {
  return (o = parseFloat(o)), (isNaN(o) || o < 0 || o > 1) && (o = 1), o
}
function bound01(o, a) {
  isOnePointZero(o) && (o = '100%')
  var s = isPercentage(o)
  return (
    (o = Math.min(a, Math.max(0, parseFloat(o)))),
    s && (o = parseInt(o * a, 10) / 100),
    Math.abs(o - a) < 1e-6 ? 1 : (o % a) / parseFloat(a)
  )
}
function clamp01(o) {
  return Math.min(1, Math.max(0, o))
}
function parseIntFromHex(o) {
  return parseInt(o, 16)
}
function isOnePointZero(o) {
  return typeof o == 'string' && o.indexOf('.') != -1 && parseFloat(o) === 1
}
function isPercentage(o) {
  return typeof o == 'string' && o.indexOf('%') != -1
}
function pad2(o) {
  return o.length == 1 ? '0' + o : '' + o
}
function convertToPercentage(o) {
  return o <= 1 && (o = o * 100 + '%'), o
}
function convertDecimalToHex(o) {
  return Math.round(parseFloat(o) * 255).toString(16)
}
function convertHexToDecimal(o) {
  return parseIntFromHex(o) / 255
}
var matchers = (function() {
  var o = '[-\\+]?\\d+%?',
    a = '[-\\+]?\\d*\\.\\d+%?',
    s = '(?:' + a + ')|(?:' + o + ')',
    $ = '[\\s|\\(]+(' + s + ')[,|\\s]+(' + s + ')[,|\\s]+(' + s + ')\\s*\\)?',
    j =
      '[\\s|\\(]+(' +
      s +
      ')[,|\\s]+(' +
      s +
      ')[,|\\s]+(' +
      s +
      ')[,|\\s]+(' +
      s +
      ')\\s*\\)?'
  return {
    CSS_UNIT: new RegExp(s),
    rgb: new RegExp('rgb' + $),
    rgba: new RegExp('rgba' + j),
    hsl: new RegExp('hsl' + $),
    hsla: new RegExp('hsla' + j),
    hsv: new RegExp('hsv' + $),
    hsva: new RegExp('hsva' + j),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  }
})()
function isValidCSSUnit(o) {
  return !!matchers.CSS_UNIT.exec(o)
}
function stringInputToObject(o) {
  o = o
    .replace(trimLeft, '')
    .replace(trimRight, '')
    .toLowerCase()
  var a = !1
  if (names[o]) (o = names[o]), (a = !0)
  else if (o == 'transparent') return { r: 0, g: 0, b: 0, a: 0, format: 'name' }
  var s
  return (s = matchers.rgb.exec(o))
    ? { r: s[1], g: s[2], b: s[3] }
    : (s = matchers.rgba.exec(o))
    ? { r: s[1], g: s[2], b: s[3], a: s[4] }
    : (s = matchers.hsl.exec(o))
    ? { h: s[1], s: s[2], l: s[3] }
    : (s = matchers.hsla.exec(o))
    ? { h: s[1], s: s[2], l: s[3], a: s[4] }
    : (s = matchers.hsv.exec(o))
    ? { h: s[1], s: s[2], v: s[3] }
    : (s = matchers.hsva.exec(o))
    ? { h: s[1], s: s[2], v: s[3], a: s[4] }
    : (s = matchers.hex8.exec(o))
    ? {
        r: parseIntFromHex(s[1]),
        g: parseIntFromHex(s[2]),
        b: parseIntFromHex(s[3]),
        a: convertHexToDecimal(s[4]),
        format: a ? 'name' : 'hex8',
      }
    : (s = matchers.hex6.exec(o))
    ? {
        r: parseIntFromHex(s[1]),
        g: parseIntFromHex(s[2]),
        b: parseIntFromHex(s[3]),
        format: a ? 'name' : 'hex',
      }
    : (s = matchers.hex4.exec(o))
    ? {
        r: parseIntFromHex(s[1] + '' + s[1]),
        g: parseIntFromHex(s[2] + '' + s[2]),
        b: parseIntFromHex(s[3] + '' + s[3]),
        a: convertHexToDecimal(s[4] + '' + s[4]),
        format: a ? 'name' : 'hex8',
      }
    : (s = matchers.hex3.exec(o))
    ? {
        r: parseIntFromHex(s[1] + '' + s[1]),
        g: parseIntFromHex(s[2] + '' + s[2]),
        b: parseIntFromHex(s[3] + '' + s[3]),
        format: a ? 'name' : 'hex',
      }
    : !1
}
function validateWCAG2Parms(o) {
  var a, s
  return (
    (o = o || { level: 'AA', size: 'small' }),
    (a = (o.level || 'AA').toUpperCase()),
    (s = (o.size || 'small').toLowerCase()),
    a !== 'AA' && a !== 'AAA' && (a = 'AA'),
    s !== 'small' && s !== 'large' && (s = 'small'),
    { level: a, size: s }
  )
}
function ImagePHash(o, a) {
  ;(this.size = this.size || o),
    (this.smallerSize = this.smallerSize || a),
    initCoefficients(this.size)
}
ImagePHash.prototype.size = 32
ImagePHash.prototype.smallerSize = 8
ImagePHash.prototype.distance = function(o, a) {
  let s = 0
  for (let $ = 0; $ < o.length; $++) o[$] !== a[$] && s++
  return s / o.length
}
ImagePHash.prototype.getHash = function(o) {
  ;(o = o.clone().resize(this.size, this.size)), o.grayscale()
  const a = []
  for (let et = 0; et < o.bitmap.width; et++) {
    a[et] = []
    for (let tt = 0; tt < o.bitmap.height; tt++)
      a[et][tt] = intToRGBA(o.getPixelColor(et, tt)).b
  }
  const s = applyDCT(a, this.size)
  let $ = 0
  for (let et = 0; et < this.smallerSize; et++)
    for (let tt = 0; tt < this.smallerSize; tt++) $ += s[et][tt]
  const j = $ / (this.smallerSize * this.smallerSize)
  let _e = ''
  for (let et = 0; et < this.smallerSize; et++)
    for (let tt = 0; tt < this.smallerSize; tt++)
      _e += s[et][tt] > j ? '1' : '0'
  return _e
}
function intToRGBA(o) {
  const a = o & 255
  o >>>= 8
  const s = o & 255
  o >>>= 8
  const $ = o & 255
  return (o >>>= 8), { r: o & 255, g: $, b: s, a }
}
const c$1 = []
function initCoefficients(o) {
  for (let a = 1; a < o; a++) c$1[a] = 1
  c$1[0] = 1 / Math.sqrt(2)
}
function applyDCT(o, a) {
  const s = a,
    $ = []
  for (let j = 0; j < s; j++) {
    $[j] = []
    for (let _e = 0; _e < s; _e++) {
      let et = 0
      for (let tt = 0; tt < s; tt++)
        for (let rt = 0; rt < s; rt++)
          et +=
            Math.cos(((2 * tt + 1) / (2 * s)) * j * Math.PI) *
            Math.cos(((2 * rt + 1) / (2 * s)) * _e * Math.PI) *
            o[tt][rt]
      ;(et *= (c$1[j] * c$1[_e]) / 4), ($[j][_e] = et)
    }
  }
  return $
}
var define_global_default$2 = {},
  g$1 =
    (typeof globalThis < 'u' && globalThis) ||
    (typeof self < 'u' && self) ||
    (typeof define_global_default$2 < 'u' && define_global_default$2) ||
    {},
  support = {
    searchParams: 'URLSearchParams' in g$1,
    iterable: 'Symbol' in g$1 && 'iterator' in Symbol,
    blob:
      'FileReader' in g$1 &&
      'Blob' in g$1 &&
      (function() {
        try {
          return new Blob(), !0
        } catch {
          return !1
        }
      })(),
    formData: 'FormData' in g$1,
    arrayBuffer: 'ArrayBuffer' in g$1,
  }
function isDataView(o) {
  return o && DataView.prototype.isPrototypeOf(o)
}
if (support.arrayBuffer)
  var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]',
    ],
    isArrayBufferView =
      ArrayBuffer.isView ||
      function(o) {
        return o && viewClasses.indexOf(Object.prototype.toString.call(o)) > -1
      }
function normalizeName(o) {
  if (
    (typeof o != 'string' && (o = String(o)),
    /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(o) || o === '')
  )
    throw new TypeError('Invalid character in header field name: "' + o + '"')
  return o.toLowerCase()
}
function normalizeValue(o) {
  return typeof o != 'string' && (o = String(o)), o
}
function iteratorFor(o) {
  var a = {
    next: function() {
      var s = o.shift()
      return { done: s === void 0, value: s }
    },
  }
  return (
    support.iterable &&
      (a[Symbol.iterator] = function() {
        return a
      }),
    a
  )
}
function Headers(o) {
  ;(this.map = {}),
    o instanceof Headers
      ? o.forEach(function(a, s) {
          this.append(s, a)
        }, this)
      : Array.isArray(o)
      ? o.forEach(function(a) {
          if (a.length != 2)
            throw new TypeError(
              'Headers constructor: expected name/value pair to be length 2, found' +
                a.length
            )
          this.append(a[0], a[1])
        }, this)
      : o &&
        Object.getOwnPropertyNames(o).forEach(function(a) {
          this.append(a, o[a])
        }, this)
}
Headers.prototype.append = function(o, a) {
  ;(o = normalizeName(o)), (a = normalizeValue(a))
  var s = this.map[o]
  this.map[o] = s ? s + ', ' + a : a
}
Headers.prototype.delete = function(o) {
  delete this.map[normalizeName(o)]
}
Headers.prototype.get = function(o) {
  return (o = normalizeName(o)), this.has(o) ? this.map[o] : null
}
Headers.prototype.has = function(o) {
  return this.map.hasOwnProperty(normalizeName(o))
}
Headers.prototype.set = function(o, a) {
  this.map[normalizeName(o)] = normalizeValue(a)
}
Headers.prototype.forEach = function(o, a) {
  for (var s in this.map)
    this.map.hasOwnProperty(s) && o.call(a, this.map[s], s, this)
}
Headers.prototype.keys = function() {
  var o = []
  return (
    this.forEach(function(a, s) {
      o.push(s)
    }),
    iteratorFor(o)
  )
}
Headers.prototype.values = function() {
  var o = []
  return (
    this.forEach(function(a) {
      o.push(a)
    }),
    iteratorFor(o)
  )
}
Headers.prototype.entries = function() {
  var o = []
  return (
    this.forEach(function(a, s) {
      o.push([s, a])
    }),
    iteratorFor(o)
  )
}
support.iterable &&
  (Headers.prototype[Symbol.iterator] = Headers.prototype.entries)
function consumed(o) {
  if (!o._noBody) {
    if (o.bodyUsed) return Promise.reject(new TypeError('Already read'))
    o.bodyUsed = !0
  }
}
function fileReaderReady(o) {
  return new Promise(function(a, s) {
    ;(o.onload = function() {
      a(o.result)
    }),
      (o.onerror = function() {
        s(o.error)
      })
  })
}
function readBlobAsArrayBuffer(o) {
  var a = new FileReader(),
    s = fileReaderReady(a)
  return a.readAsArrayBuffer(o), s
}
function readBlobAsText(o) {
  var a = new FileReader(),
    s = fileReaderReady(a),
    $ = /charset=([A-Za-z0-9_-]+)/.exec(o.type),
    j = $ ? $[1] : 'utf-8'
  return a.readAsText(o, j), s
}
function readArrayBufferAsText(o) {
  for (
    var a = new Uint8Array(o), s = new Array(a.length), $ = 0;
    $ < a.length;
    $++
  )
    s[$] = String.fromCharCode(a[$])
  return s.join('')
}
function bufferClone(o) {
  if (o.slice) return o.slice(0)
  var a = new Uint8Array(o.byteLength)
  return a.set(new Uint8Array(o)), a.buffer
}
function Body() {
  return (
    (this.bodyUsed = !1),
    (this._initBody = function(o) {
      ;(this.bodyUsed = this.bodyUsed),
        (this._bodyInit = o),
        o
          ? typeof o == 'string'
            ? (this._bodyText = o)
            : support.blob && Blob.prototype.isPrototypeOf(o)
            ? (this._bodyBlob = o)
            : support.formData && FormData.prototype.isPrototypeOf(o)
            ? (this._bodyFormData = o)
            : support.searchParams && URLSearchParams.prototype.isPrototypeOf(o)
            ? (this._bodyText = o.toString())
            : support.arrayBuffer && support.blob && isDataView(o)
            ? ((this._bodyArrayBuffer = bufferClone(o.buffer)),
              (this._bodyInit = new Blob([this._bodyArrayBuffer])))
            : support.arrayBuffer &&
              (ArrayBuffer.prototype.isPrototypeOf(o) || isArrayBufferView(o))
            ? (this._bodyArrayBuffer = bufferClone(o))
            : (this._bodyText = o = Object.prototype.toString.call(o))
          : ((this._noBody = !0), (this._bodyText = '')),
        this.headers.get('content-type') ||
          (typeof o == 'string'
            ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
            : this._bodyBlob && this._bodyBlob.type
            ? this.headers.set('content-type', this._bodyBlob.type)
            : support.searchParams &&
              URLSearchParams.prototype.isPrototypeOf(o) &&
              this.headers.set(
                'content-type',
                'application/x-www-form-urlencoded;charset=UTF-8'
              ))
    }),
    support.blob &&
      (this.blob = function() {
        var o = consumed(this)
        if (o) return o
        if (this._bodyBlob) return Promise.resolve(this._bodyBlob)
        if (this._bodyArrayBuffer)
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        if (this._bodyFormData)
          throw new Error('could not read FormData body as blob')
        return Promise.resolve(new Blob([this._bodyText]))
      }),
    (this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var o = consumed(this)
        return (
          o ||
          (ArrayBuffer.isView(this._bodyArrayBuffer)
            ? Promise.resolve(
                this._bodyArrayBuffer.buffer.slice(
                  this._bodyArrayBuffer.byteOffset,
                  this._bodyArrayBuffer.byteOffset +
                    this._bodyArrayBuffer.byteLength
                )
              )
            : Promise.resolve(this._bodyArrayBuffer))
        )
      } else {
        if (support.blob) return this.blob().then(readBlobAsArrayBuffer)
        throw new Error('could not read as ArrayBuffer')
      }
    }),
    (this.text = function() {
      var o = consumed(this)
      if (o) return o
      if (this._bodyBlob) return readBlobAsText(this._bodyBlob)
      if (this._bodyArrayBuffer)
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      if (this._bodyFormData)
        throw new Error('could not read FormData body as text')
      return Promise.resolve(this._bodyText)
    }),
    support.formData &&
      (this.formData = function() {
        return this.text().then(decode$2)
      }),
    (this.json = function() {
      return this.text().then(JSON.parse)
    }),
    this
  )
}
var methods = [
  'CONNECT',
  'DELETE',
  'GET',
  'HEAD',
  'OPTIONS',
  'PATCH',
  'POST',
  'PUT',
  'TRACE',
]
function normalizeMethod(o) {
  var a = o.toUpperCase()
  return methods.indexOf(a) > -1 ? a : o
}
function Request(o, a) {
  if (!(this instanceof Request))
    throw new TypeError(
      'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
    )
  a = a || {}
  var s = a.body
  if (o instanceof Request) {
    if (o.bodyUsed) throw new TypeError('Already read')
    ;(this.url = o.url),
      (this.credentials = o.credentials),
      a.headers || (this.headers = new Headers(o.headers)),
      (this.method = o.method),
      (this.mode = o.mode),
      (this.signal = o.signal),
      !s && o._bodyInit != null && ((s = o._bodyInit), (o.bodyUsed = !0))
  } else this.url = String(o)
  if (
    ((this.credentials = a.credentials || this.credentials || 'same-origin'),
    (a.headers || !this.headers) && (this.headers = new Headers(a.headers)),
    (this.method = normalizeMethod(a.method || this.method || 'GET')),
    (this.mode = a.mode || this.mode || null),
    (this.signal =
      a.signal ||
      this.signal ||
      (function() {
        if ('AbortController' in g$1) {
          var _e = new AbortController()
          return _e.signal
        }
      })()),
    (this.referrer = null),
    (this.method === 'GET' || this.method === 'HEAD') && s)
  )
    throw new TypeError('Body not allowed for GET or HEAD requests')
  if (
    (this._initBody(s),
    (this.method === 'GET' || this.method === 'HEAD') &&
      (a.cache === 'no-store' || a.cache === 'no-cache'))
  ) {
    var $ = /([?&])_=[^&]*/
    if ($.test(this.url))
      this.url = this.url.replace($, '$1_=' + new Date().getTime())
    else {
      var j = /\?/
      this.url += (j.test(this.url) ? '&' : '?') + '_=' + new Date().getTime()
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit })
}
function decode$2(o) {
  var a = new FormData()
  return (
    o
      .trim()
      .split('&')
      .forEach(function(s) {
        if (s) {
          var $ = s.split('='),
            j = $.shift().replace(/\+/g, ' '),
            _e = $.join('=').replace(/\+/g, ' ')
          a.append(decodeURIComponent(j), decodeURIComponent(_e))
        }
      }),
    a
  )
}
function parseHeaders(o) {
  var a = new Headers(),
    s = o.replace(/\r?\n[\t ]+/g, ' ')
  return (
    s
      .split('\r')
      .map(function($) {
        return $.indexOf(`
`) === 0
          ? $.substr(1, $.length)
          : $
      })
      .forEach(function($) {
        var j = $.split(':'),
          _e = j.shift().trim()
        if (_e) {
          var et = j.join(':').trim()
          try {
            a.append(_e, et)
          } catch (tt) {
            console.warn('Response ' + tt.message)
          }
        }
      }),
    a
  )
}
Body.call(Request.prototype)
function Response(o, a) {
  if (!(this instanceof Response))
    throw new TypeError(
      'Please use the "new" operator, this DOM object constructor cannot be called as a function.'
    )
  if (
    (a || (a = {}),
    (this.type = 'default'),
    (this.status = a.status === void 0 ? 200 : a.status),
    this.status < 200 || this.status > 599)
  )
    throw new RangeError(
      "Failed to construct 'Response': The status provided (0) is outside the range [200, 599]."
    )
  ;(this.ok = this.status >= 200 && this.status < 300),
    (this.statusText = a.statusText === void 0 ? '' : '' + a.statusText),
    (this.headers = new Headers(a.headers)),
    (this.url = a.url || ''),
    this._initBody(o)
}
Body.call(Response.prototype)
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url,
  })
}
Response.error = function() {
  var o = new Response(null, { status: 200, statusText: '' })
  return (o.ok = !1), (o.status = 0), (o.type = 'error'), o
}
var redirectStatuses = [301, 302, 303, 307, 308]
Response.redirect = function(o, a) {
  if (redirectStatuses.indexOf(a) === -1)
    throw new RangeError('Invalid status code')
  return new Response(null, { status: a, headers: { location: o } })
}
var DOMException = g$1.DOMException
try {
  new DOMException()
} catch {
  ;(DOMException = function(a, s) {
    ;(this.message = a), (this.name = s)
    var $ = Error(a)
    this.stack = $.stack
  }),
    (DOMException.prototype = Object.create(Error.prototype)),
    (DOMException.prototype.constructor = DOMException)
}
function fetch$1(o, a) {
  return new Promise(function(s, $) {
    var j = new Request(o, a)
    if (j.signal && j.signal.aborted)
      return $(new DOMException('Aborted', 'AbortError'))
    var _e = new XMLHttpRequest()
    function et() {
      _e.abort()
    }
    ;(_e.onload = function() {
      var nt = {
        statusText: _e.statusText,
        headers: parseHeaders(_e.getAllResponseHeaders() || ''),
      }
      j.url.indexOf('file://') === 0 && (_e.status < 200 || _e.status > 599)
        ? (nt.status = 200)
        : (nt.status = _e.status),
        (nt.url =
          'responseURL' in _e
            ? _e.responseURL
            : nt.headers.get('X-Request-URL'))
      var it = 'response' in _e ? _e.response : _e.responseText
      setTimeout(function() {
        s(new Response(it, nt))
      }, 0)
    }),
      (_e.onerror = function() {
        setTimeout(function() {
          $(new TypeError('Network request failed'))
        }, 0)
      }),
      (_e.ontimeout = function() {
        setTimeout(function() {
          $(new TypeError('Network request timed out'))
        }, 0)
      }),
      (_e.onabort = function() {
        setTimeout(function() {
          $(new DOMException('Aborted', 'AbortError'))
        }, 0)
      })
    function tt(nt) {
      try {
        return nt === '' && g$1.location.href ? g$1.location.href : nt
      } catch {
        return nt
      }
    }
    if (
      (_e.open(j.method, tt(j.url), !0),
      j.credentials === 'include'
        ? (_e.withCredentials = !0)
        : j.credentials === 'omit' && (_e.withCredentials = !1),
      'responseType' in _e &&
        (support.blob
          ? (_e.responseType = 'blob')
          : support.arrayBuffer && (_e.responseType = 'arraybuffer')),
      a &&
        typeof a.headers == 'object' &&
        !(
          a.headers instanceof Headers ||
          (g$1.Headers && a.headers instanceof g$1.Headers)
        ))
    ) {
      var rt = []
      Object.getOwnPropertyNames(a.headers).forEach(function(nt) {
        rt.push(normalizeName(nt)),
          _e.setRequestHeader(nt, normalizeValue(a.headers[nt]))
      }),
        j.headers.forEach(function(nt, it) {
          rt.indexOf(it) === -1 && _e.setRequestHeader(it, nt)
        })
    } else
      j.headers.forEach(function(nt, it) {
        _e.setRequestHeader(it, nt)
      })
    j.signal &&
      (j.signal.addEventListener('abort', et),
      (_e.onreadystatechange = function() {
        _e.readyState === 4 && j.signal.removeEventListener('abort', et)
      })),
      _e.send(typeof j._bodyInit > 'u' ? null : j._bodyInit)
  })
}
fetch$1.polyfill = !0
g$1.fetch ||
  ((g$1.fetch = fetch$1),
  (g$1.Headers = Headers),
  (g$1.Request = Request),
  (g$1.Response = Response))
self.fetch.bind(self)
const request = (o, a) => {
    let { url: s, ...$ } = o
    fetch(s, $)
      .then(j => {
        if (j.ok)
          return j.arrayBuffer().catch(_e => {
            throw new Error(
              `Response is not a buffer for url ${s}. Error: ${_e.message}`
            )
          })
        throw new Error(`HTTP Status ${j.status} for url ${s}`)
      })
      .then(j => a(null, j))
      .catch(j => a(j))
  },
  AUTO = -1,
  HORIZONTAL_ALIGN_LEFT = 1,
  HORIZONTAL_ALIGN_CENTER = 2,
  HORIZONTAL_ALIGN_RIGHT = 4,
  VERTICAL_ALIGN_TOP = 8,
  VERTICAL_ALIGN_MIDDLE = 16,
  VERTICAL_ALIGN_BOTTOM = 32,
  BLEND_SOURCE_OVER = 'srcOver',
  BLEND_DESTINATION_OVER = 'dstOver',
  BLEND_MULTIPLY = 'multiply',
  BLEND_ADD = 'add',
  BLEND_SCREEN = 'screen',
  BLEND_OVERLAY = 'overlay',
  BLEND_DARKEN = 'darken',
  BLEND_LIGHTEN = 'lighten',
  BLEND_HARDLIGHT = 'hardLight',
  BLEND_DIFFERENCE = 'difference',
  BLEND_EXCLUSION = 'exclusion',
  EDGE_EXTEND = 1,
  EDGE_WRAP = 2,
  EDGE_CROP = 3,
  constants$7 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        AUTO,
        BLEND_ADD,
        BLEND_DARKEN,
        BLEND_DESTINATION_OVER,
        BLEND_DIFFERENCE,
        BLEND_EXCLUSION,
        BLEND_HARDLIGHT,
        BLEND_LIGHTEN,
        BLEND_MULTIPLY,
        BLEND_OVERLAY,
        BLEND_SCREEN,
        BLEND_SOURCE_OVER,
        EDGE_CROP,
        EDGE_EXTEND,
        EDGE_WRAP,
        HORIZONTAL_ALIGN_CENTER,
        HORIZONTAL_ALIGN_LEFT,
        HORIZONTAL_ALIGN_RIGHT,
        VERTICAL_ALIGN_BOTTOM,
        VERTICAL_ALIGN_MIDDLE,
        VERTICAL_ALIGN_TOP,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  )
function srcOver(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = (o.r * o.a + a.r * a.a * (1 - o.a)) / $,
    _e = (o.g * o.a + a.g * a.a * (1 - o.a)) / $,
    et = (o.b * o.a + a.b * a.a * (1 - o.a)) / $
  return { r: j, g: _e, b: et, a: $ }
}
function dstOver(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = (a.r * a.a + o.r * o.a * (1 - a.a)) / $,
    _e = (a.g * a.a + o.g * o.a * (1 - a.a)) / $,
    et = (a.b * a.a + o.b * o.a * (1 - a.a)) / $
  return { r: j, g: _e, b: et, a: $ }
}
function multiply(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it = (j * tt + j * (1 - a.a) + tt * (1 - o.a)) / $,
    ot = (_e * rt + _e * (1 - a.a) + rt * (1 - o.a)) / $,
    at = (et * nt + et * (1 - a.a) + nt * (1 - o.a)) / $
  return { r: it, g: ot, b: at, a: $ }
}
function add(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it = (j + tt) / $,
    ot = (_e + rt) / $,
    at = (et + nt) / $
  return { r: it, g: ot, b: at, a: $ }
}
function screen(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it = (j * a.a + tt * o.a - j * tt + j * (1 - a.a) + tt * (1 - o.a)) / $,
    ot = (_e * a.a + rt * o.a - _e * rt + _e * (1 - a.a) + rt * (1 - o.a)) / $,
    at = (et * a.a + nt * o.a - et * nt + et * (1 - a.a) + nt * (1 - o.a)) / $
  return { r: it, g: ot, b: at, a: $ }
}
function overlay(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it =
      (2 * tt <= a.a
        ? 2 * j * tt + j * (1 - a.a) + tt * (1 - o.a)
        : j * (1 + a.a) + tt * (1 + o.a) - 2 * tt * j - a.a * o.a) / $,
    ot =
      (2 * rt <= a.a
        ? 2 * _e * rt + _e * (1 - a.a) + rt * (1 - o.a)
        : _e * (1 + a.a) + rt * (1 + o.a) - 2 * rt * _e - a.a * o.a) / $,
    at =
      (2 * nt <= a.a
        ? 2 * et * nt + et * (1 - a.a) + nt * (1 - o.a)
        : et * (1 + a.a) + nt * (1 + o.a) - 2 * nt * et - a.a * o.a) / $
  return { r: it, g: ot, b: at, a: $ }
}
function darken(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it = (Math.min(j * a.a, tt * o.a) + j * (1 - a.a) + tt * (1 - o.a)) / $,
    ot = (Math.min(_e * a.a, rt * o.a) + _e * (1 - a.a) + rt * (1 - o.a)) / $,
    at = (Math.min(et * a.a, nt * o.a) + et * (1 - a.a) + nt * (1 - o.a)) / $
  return { r: it, g: ot, b: at, a: $ }
}
function lighten(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it = (Math.max(j * a.a, tt * o.a) + j * (1 - a.a) + tt * (1 - o.a)) / $,
    ot = (Math.max(_e * a.a, rt * o.a) + _e * (1 - a.a) + rt * (1 - o.a)) / $,
    at = (Math.max(et * a.a, nt * o.a) + et * (1 - a.a) + nt * (1 - o.a)) / $
  return { r: it, g: ot, b: at, a: $ }
}
function hardLight(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it =
      (2 * j <= o.a
        ? 2 * j * tt + j * (1 - a.a) + tt * (1 - o.a)
        : j * (1 + a.a) + tt * (1 + o.a) - 2 * tt * j - a.a * o.a) / $,
    ot =
      (2 * _e <= o.a
        ? 2 * _e * rt + _e * (1 - a.a) + rt * (1 - o.a)
        : _e * (1 + a.a) + rt * (1 + o.a) - 2 * rt * _e - a.a * o.a) / $,
    at =
      (2 * et <= o.a
        ? 2 * et * nt + et * (1 - a.a) + nt * (1 - o.a)
        : et * (1 + a.a) + nt * (1 + o.a) - 2 * nt * et - a.a * o.a) / $
  return { r: it, g: ot, b: at, a: $ }
}
function difference(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it = (j + tt - 2 * Math.min(j * a.a, tt * o.a)) / $,
    ot = (_e + rt - 2 * Math.min(_e * a.a, rt * o.a)) / $,
    at = (et + nt - 2 * Math.min(et * a.a, nt * o.a)) / $
  return { r: it, g: ot, b: at, a: $ }
}
function exclusion(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1
  o.a *= s
  const $ = a.a + o.a - a.a * o.a,
    j = o.r * o.a,
    _e = o.g * o.a,
    et = o.b * o.a,
    tt = a.r * a.a,
    rt = a.g * a.a,
    nt = a.b * a.a,
    it = (j * a.a + tt * o.a - 2 * j * tt + j * (1 - a.a) + tt * (1 - o.a)) / $,
    ot =
      (_e * a.a + rt * o.a - 2 * _e * rt + _e * (1 - a.a) + rt * (1 - o.a)) / $,
    at =
      (et * a.a + nt * o.a - 2 * et * nt + et * (1 - a.a) + nt * (1 - o.a)) / $
  return { r: it, g: ot, b: at, a: $ }
}
const compositeModes = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      add,
      darken,
      difference,
      dstOver,
      exclusion,
      hardLight,
      lighten,
      multiply,
      overlay,
      screen,
      srcOver,
    },
    Symbol.toStringTag,
    { value: 'Module' }
  )
)
function composite(o, a, s) {
  let $ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
    j = arguments.length > 4 ? arguments[4] : void 0
  if (
    (typeof $ == 'function' && ((j = $), ($ = {})),
    !(o instanceof this.constructor))
  )
    return throwError.call(this, 'The source must be a Jimp image', j)
  if (typeof a != 'number' || typeof s != 'number')
    return throwError.call(this, 'x and y must be numbers', j)
  let { mode: _e, opacitySource: et, opacityDest: tt } = $
  _e || (_e = BLEND_SOURCE_OVER),
    (typeof et != 'number' || et < 0 || et > 1) && (et = 1),
    (typeof tt != 'number' || tt < 0 || tt > 1) && (tt = 1)
  const rt = compositeModes[_e]
  ;(a = Math.round(a)), (s = Math.round(s))
  const nt = this
  return (
    tt !== 1 && nt.opacity(tt),
    o.scanQuiet(0, 0, o.bitmap.width, o.bitmap.height, function(it, ot, at) {
      const st = nt.getPixelIndex(a + it, s + ot, EDGE_CROP)
      if (st === -1) return
      const ut = rt(
        {
          r: this.bitmap.data[at + 0] / 255,
          g: this.bitmap.data[at + 1] / 255,
          b: this.bitmap.data[at + 2] / 255,
          a: this.bitmap.data[at + 3] / 255,
        },
        {
          r: nt.bitmap.data[st + 0] / 255,
          g: nt.bitmap.data[st + 1] / 255,
          b: nt.bitmap.data[st + 2] / 255,
          a: nt.bitmap.data[st + 3] / 255,
        },
        et
      )
      ;(nt.bitmap.data[st + 0] = this.constructor.limit255(ut.r * 255)),
        (nt.bitmap.data[st + 1] = this.constructor.limit255(ut.g * 255)),
        (nt.bitmap.data[st + 2] = this.constructor.limit255(ut.b * 255)),
        (nt.bitmap.data[st + 3] = this.constructor.limit255(ut.a * 255))
    }),
    isNodePattern(j) && j.call(this, null, this),
    this
  )
}
const promisify = function(o, a) {
    for (
      var s = arguments.length, $ = new Array(s > 2 ? s - 2 : 0), j = 2;
      j < s;
      j++
    )
      $[j - 2] = arguments[j]
    return new Promise((_e, et) => {
      $.push((tt, rt) => {
        tt && et(tt), _e(rt)
      }),
        o.bind(a)(...$)
    })
  },
  mimeTypes = {},
  findType = o => Object.entries(mimeTypes).find(a => a[1].includes(o)) || [],
  addType = (o, a) => {
    mimeTypes[o] = a
  },
  getType = o => {
    const a = o.split('/').slice(-1),
      s = a[a.length - 1].split('.').pop()
    return findType(s)[0]
  },
  getExtension = o => (mimeTypes[o.toLowerCase()] || [])[0]
var lib$5 = {},
  FsPromise = {}
Object.defineProperty(FsPromise, '__esModule', { value: !0 })
FsPromise.readFile = FsPromise.writeFileSync = FsPromise.writeFile = FsPromise.read = FsPromise.open = FsPromise.close = FsPromise.stat = FsPromise.createReadStream = FsPromise.pathExists = void 0
const fs$1 = fs_1
FsPromise.pathExists = fs$1.existsSync
FsPromise.createReadStream = fs$1.createReadStream
async function stat(o) {
  return new Promise((a, s) => {
    fs$1.stat(o, ($, j) => {
      $ ? s($) : a(j)
    })
  })
}
FsPromise.stat = stat
async function close(o) {
  return new Promise((a, s) => {
    fs$1.close(o, $ => {
      $ ? s($) : a()
    })
  })
}
FsPromise.close = close
async function open$1(o, a) {
  return new Promise((s, $) => {
    fs$1.open(o, a, (j, _e) => {
      j ? $(j) : s(_e)
    })
  })
}
FsPromise.open = open$1
async function read(o, a, s, $, j) {
  return new Promise((_e, et) => {
    fs$1.read(o, a, s, $, j, (tt, rt, nt) => {
      tt ? et(tt) : _e({ bytesRead: rt, buffer: nt })
    })
  })
}
FsPromise.read = read
async function writeFile(o, a) {
  return new Promise((s, $) => {
    fs$1.writeFile(o, a, j => {
      j ? $(j) : s()
    })
  })
}
FsPromise.writeFile = writeFile
function writeFileSync(o, a) {
  fs$1.writeFileSync(o, a)
}
FsPromise.writeFileSync = writeFileSync
async function readFile(o) {
  return new Promise((a, s) => {
    fs$1.readFile(o, ($, j) => {
      $ ? s($) : a(j)
    })
  })
}
FsPromise.readFile = readFile
var core$3 = {},
  ReadStreamTokenizer$1 = {},
  AbstractTokenizer$1 = {},
  lib$4 = {},
  EndOfFileStream = {}
;(function(o) {
  Object.defineProperty(o, '__esModule', { value: !0 }),
    (o.EndOfStreamError = o.defaultMessages = void 0),
    (o.defaultMessages = 'End-Of-Stream')
  class a extends Error {
    constructor() {
      super(o.defaultMessages)
    }
  }
  o.EndOfStreamError = a
})(EndOfFileStream)
var StreamReader = {},
  Deferred$1 = {}
Object.defineProperty(Deferred$1, '__esModule', { value: !0 })
Deferred$1.Deferred = void 0
class Deferred {
  constructor() {
    ;(this.resolve = () => null),
      (this.reject = () => null),
      (this.promise = new Promise((a, s) => {
        ;(this.reject = s), (this.resolve = a)
      }))
  }
}
Deferred$1.Deferred = Deferred
;(function(o) {
  Object.defineProperty(o, '__esModule', { value: !0 }),
    (o.StreamReader = o.EndOfStreamError = void 0)
  const a = EndOfFileStream,
    s = Deferred$1
  var $ = EndOfFileStream
  Object.defineProperty(o, 'EndOfStreamError', {
    enumerable: !0,
    get: function() {
      return $.EndOfStreamError
    },
  })
  const j = 1 * 1024 * 1024
  class _e {
    constructor(tt) {
      if (
        ((this.s = tt),
        (this.deferred = null),
        (this.endOfStream = !1),
        (this.peekQueue = []),
        !tt.read || !tt.once)
      )
        throw new Error('Expected an instance of stream.Readable')
      this.s.once('end', () => this.reject(new a.EndOfStreamError())),
        this.s.once('error', rt => this.reject(rt)),
        this.s.once('close', () => this.reject(new Error('Stream closed')))
    }
    async peek(tt, rt, nt) {
      const it = await this.read(tt, rt, nt)
      return this.peekQueue.push(tt.subarray(rt, rt + it)), it
    }
    async read(tt, rt, nt) {
      if (nt === 0) return 0
      if (this.peekQueue.length === 0 && this.endOfStream)
        throw new a.EndOfStreamError()
      let it = nt,
        ot = 0
      for (; this.peekQueue.length > 0 && it > 0; ) {
        const at = this.peekQueue.pop()
        if (!at) throw new Error('peekData should be defined')
        const st = Math.min(at.length, it)
        tt.set(at.subarray(0, st), rt + ot),
          (ot += st),
          (it -= st),
          st < at.length && this.peekQueue.push(at.subarray(st))
      }
      for (; it > 0 && !this.endOfStream; ) {
        const at = Math.min(it, j),
          st = await this.readFromStream(tt, rt + ot, at)
        if (((ot += st), st < at)) break
        it -= st
      }
      return ot
    }
    async readFromStream(tt, rt, nt) {
      const it = this.s.read(nt)
      if (it) return tt.set(it, rt), it.length
      {
        const ot = {
          buffer: tt,
          offset: rt,
          length: nt,
          deferred: new s.Deferred(),
        }
        return (
          (this.deferred = ot.deferred),
          this.s.once('readable', () => {
            this.readDeferred(ot)
          }),
          ot.deferred.promise
        )
      }
    }
    readDeferred(tt) {
      const rt = this.s.read(tt.length)
      rt
        ? (tt.buffer.set(rt, tt.offset),
          tt.deferred.resolve(rt.length),
          (this.deferred = null))
        : this.s.once('readable', () => {
            this.readDeferred(tt)
          })
    }
    reject(tt) {
      ;(this.endOfStream = !0),
        this.deferred && (this.deferred.reject(tt), (this.deferred = null))
    }
  }
  o.StreamReader = _e
})(StreamReader)
;(function(o) {
  Object.defineProperty(o, '__esModule', { value: !0 }),
    (o.StreamReader = o.EndOfStreamError = void 0)
  var a = EndOfFileStream
  Object.defineProperty(o, 'EndOfStreamError', {
    enumerable: !0,
    get: function() {
      return a.EndOfStreamError
    },
  })
  var s = StreamReader
  Object.defineProperty(o, 'StreamReader', {
    enumerable: !0,
    get: function() {
      return s.StreamReader
    },
  })
})(lib$4)
Object.defineProperty(AbstractTokenizer$1, '__esModule', { value: !0 })
AbstractTokenizer$1.AbstractTokenizer = void 0
const peek_readable_1$3 = lib$4
class AbstractTokenizer {
  constructor(a) {
    ;(this.position = 0),
      (this.numBuffer = new Uint8Array(8)),
      (this.fileInfo = a || {})
  }
  async readToken(a, s = this.position) {
    const $ = Buffer.alloc(a.len)
    if ((await this.readBuffer($, { position: s })) < a.len)
      throw new peek_readable_1$3.EndOfStreamError()
    return a.get($, 0)
  }
  async peekToken(a, s = this.position) {
    const $ = Buffer.alloc(a.len)
    if ((await this.peekBuffer($, { position: s })) < a.len)
      throw new peek_readable_1$3.EndOfStreamError()
    return a.get($, 0)
  }
  async readNumber(a) {
    if ((await this.readBuffer(this.numBuffer, { length: a.len })) < a.len)
      throw new peek_readable_1$3.EndOfStreamError()
    return a.get(this.numBuffer, 0)
  }
  async peekNumber(a) {
    if ((await this.peekBuffer(this.numBuffer, { length: a.len })) < a.len)
      throw new peek_readable_1$3.EndOfStreamError()
    return a.get(this.numBuffer, 0)
  }
  async ignore(a) {
    if (this.fileInfo.size !== void 0) {
      const s = this.fileInfo.size - this.position
      if (a > s) return (this.position += s), s
    }
    return (this.position += a), a
  }
  async close() {}
  normalizeOptions(a, s) {
    if (s && s.position !== void 0 && s.position < this.position)
      throw new Error(
        '`options.position` must be equal or greater than `tokenizer.position`'
      )
    return s
      ? {
          mayBeLess: s.mayBeLess === !0,
          offset: s.offset ? s.offset : 0,
          length: s.length ? s.length : a.length - (s.offset ? s.offset : 0),
          position: s.position ? s.position : this.position,
        }
      : { mayBeLess: !1, offset: 0, length: a.length, position: this.position }
  }
}
AbstractTokenizer$1.AbstractTokenizer = AbstractTokenizer
Object.defineProperty(ReadStreamTokenizer$1, '__esModule', { value: !0 })
ReadStreamTokenizer$1.ReadStreamTokenizer = void 0
const AbstractTokenizer_1$2 = AbstractTokenizer$1,
  peek_readable_1$2 = lib$4,
  maxBufferSize = 256e3
class ReadStreamTokenizer extends AbstractTokenizer_1$2.AbstractTokenizer {
  constructor(a, s) {
    super(s), (this.streamReader = new peek_readable_1$2.StreamReader(a))
  }
  async getFileInfo() {
    return this.fileInfo
  }
  async readBuffer(a, s) {
    const $ = this.normalizeOptions(a, s),
      j = $.position - this.position
    if (j > 0) return await this.ignore(j), this.readBuffer(a, s)
    if (j < 0)
      throw new Error(
        '`options.position` must be equal or greater than `tokenizer.position`'
      )
    if ($.length === 0) return 0
    const _e = await this.streamReader.read(a, $.offset, $.length)
    if (((this.position += _e), (!s || !s.mayBeLess) && _e < $.length))
      throw new peek_readable_1$2.EndOfStreamError()
    return _e
  }
  async peekBuffer(a, s) {
    const $ = this.normalizeOptions(a, s)
    let j = 0
    if ($.position) {
      const _e = $.position - this.position
      if (_e > 0) {
        const et = new Uint8Array($.length + _e)
        return (
          (j = await this.peekBuffer(et, { mayBeLess: $.mayBeLess })),
          a.set(et.subarray(_e), $.offset),
          j - _e
        )
      } else if (_e < 0)
        throw new Error('Cannot peek from a negative offset in a stream')
    }
    if ($.length > 0) {
      try {
        j = await this.streamReader.peek(a, $.offset, $.length)
      } catch (_e) {
        if (
          s &&
          s.mayBeLess &&
          _e instanceof peek_readable_1$2.EndOfStreamError
        )
          return 0
        throw _e
      }
      if (!$.mayBeLess && j < $.length)
        throw new peek_readable_1$2.EndOfStreamError()
    }
    return j
  }
  async ignore(a) {
    const s = Math.min(maxBufferSize, a),
      $ = new Uint8Array(s)
    let j = 0
    for (; j < a; ) {
      const _e = a - j,
        et = await this.readBuffer($, { length: Math.min(s, _e) })
      if (et < 0) return et
      j += et
    }
    return j
  }
}
ReadStreamTokenizer$1.ReadStreamTokenizer = ReadStreamTokenizer
var BufferTokenizer$1 = {}
Object.defineProperty(BufferTokenizer$1, '__esModule', { value: !0 })
BufferTokenizer$1.BufferTokenizer = void 0
const peek_readable_1$1 = lib$4,
  AbstractTokenizer_1$1 = AbstractTokenizer$1
class BufferTokenizer extends AbstractTokenizer_1$1.AbstractTokenizer {
  constructor(a, s) {
    super(s),
      (this.uint8Array = a),
      (this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : a.length)
  }
  async readBuffer(a, s) {
    if (s && s.position) {
      if (s.position < this.position)
        throw new Error(
          '`options.position` must be equal or greater than `tokenizer.position`'
        )
      this.position = s.position
    }
    const $ = await this.peekBuffer(a, s)
    return (this.position += $), $
  }
  async peekBuffer(a, s) {
    const $ = this.normalizeOptions(a, s),
      j = Math.min(this.uint8Array.length - $.position, $.length)
    if (!$.mayBeLess && j < $.length)
      throw new peek_readable_1$1.EndOfStreamError()
    return (
      a.set(this.uint8Array.subarray($.position, $.position + j), $.offset), j
    )
  }
  async close() {}
}
BufferTokenizer$1.BufferTokenizer = BufferTokenizer
;(function(o) {
  Object.defineProperty(o, '__esModule', { value: !0 }),
    (o.fromBuffer = o.fromStream = o.EndOfStreamError = void 0)
  const a = ReadStreamTokenizer$1,
    s = BufferTokenizer$1
  var $ = lib$4
  Object.defineProperty(o, 'EndOfStreamError', {
    enumerable: !0,
    get: function() {
      return $.EndOfStreamError
    },
  })
  function j(et, tt) {
    return (tt = tt || {}), new a.ReadStreamTokenizer(et, tt)
  }
  o.fromStream = j
  function _e(et, tt) {
    return new s.BufferTokenizer(et, tt)
  }
  o.fromBuffer = _e
})(core$3)
var FileTokenizer$1 = {}
Object.defineProperty(FileTokenizer$1, '__esModule', { value: !0 })
FileTokenizer$1.fromFile = FileTokenizer$1.FileTokenizer = void 0
const AbstractTokenizer_1 = AbstractTokenizer$1,
  peek_readable_1 = lib$4,
  fs = FsPromise
class FileTokenizer extends AbstractTokenizer_1.AbstractTokenizer {
  constructor(a, s) {
    super(s), (this.fd = a)
  }
  async readBuffer(a, s) {
    const $ = this.normalizeOptions(a, s)
    this.position = $.position
    const j = await fs.read(this.fd, a, $.offset, $.length, $.position)
    if (
      ((this.position += j.bytesRead),
      j.bytesRead < $.length && (!s || !s.mayBeLess))
    )
      throw new peek_readable_1.EndOfStreamError()
    return j.bytesRead
  }
  async peekBuffer(a, s) {
    const $ = this.normalizeOptions(a, s),
      j = await fs.read(this.fd, a, $.offset, $.length, $.position)
    if (!$.mayBeLess && j.bytesRead < $.length)
      throw new peek_readable_1.EndOfStreamError()
    return j.bytesRead
  }
  async close() {
    return fs.close(this.fd)
  }
}
FileTokenizer$1.FileTokenizer = FileTokenizer
async function fromFile$1(o) {
  const a = await fs.stat(o)
  if (!a.isFile) throw new Error(`File not a file: ${o}`)
  const s = await fs.open(o, 'r')
  return new FileTokenizer(s, { path: o, size: a.size })
}
FileTokenizer$1.fromFile = fromFile$1
;(function(o) {
  Object.defineProperty(o, '__esModule', { value: !0 }),
    (o.fromStream = o.fromBuffer = o.EndOfStreamError = o.fromFile = void 0)
  const a = FsPromise,
    s = core$3
  var $ = FileTokenizer$1
  Object.defineProperty(o, 'fromFile', {
    enumerable: !0,
    get: function() {
      return $.fromFile
    },
  })
  var j = core$3
  Object.defineProperty(o, 'EndOfStreamError', {
    enumerable: !0,
    get: function() {
      return j.EndOfStreamError
    },
  }),
    Object.defineProperty(o, 'fromBuffer', {
      enumerable: !0,
      get: function() {
        return j.fromBuffer
      },
    })
  async function _e(et, tt) {
    if (((tt = tt || {}), et.path)) {
      const rt = await a.stat(et.path)
      ;(tt.path = et.path), (tt.size = rt.size)
    }
    return s.fromStream(et, tt)
  }
  o.fromStream = _e
})(lib$5)
var lib$3 = {}
;(function(o) {
  Object.defineProperty(o, '__esModule', { value: !0 }),
    (o.AnsiStringType = o.StringType = o.BufferType = o.Uint8ArrayType = o.IgnoreType = o.Float80_LE = o.Float80_BE = o.Float64_LE = o.Float64_BE = o.Float32_LE = o.Float32_BE = o.Float16_LE = o.Float16_BE = o.INT64_BE = o.UINT64_BE = o.INT64_LE = o.UINT64_LE = o.INT32_LE = o.INT32_BE = o.INT24_BE = o.INT24_LE = o.INT16_LE = o.INT16_BE = o.INT8 = o.UINT32_BE = o.UINT32_LE = o.UINT24_BE = o.UINT24_LE = o.UINT16_BE = o.UINT16_LE = o.UINT8 = void 0)
  const a = ieee754
  function s(rt) {
    return new DataView(rt.buffer, rt.byteOffset)
  }
  ;(o.UINT8 = {
    len: 1,
    get(rt, nt) {
      return s(rt).getUint8(nt)
    },
    put(rt, nt, it) {
      return s(rt).setUint8(nt, it), nt + 1
    },
  }),
    (o.UINT16_LE = {
      len: 2,
      get(rt, nt) {
        return s(rt).getUint16(nt, !0)
      },
      put(rt, nt, it) {
        return s(rt).setUint16(nt, it, !0), nt + 2
      },
    }),
    (o.UINT16_BE = {
      len: 2,
      get(rt, nt) {
        return s(rt).getUint16(nt)
      },
      put(rt, nt, it) {
        return s(rt).setUint16(nt, it), nt + 2
      },
    }),
    (o.UINT24_LE = {
      len: 3,
      get(rt, nt) {
        const it = s(rt)
        return it.getUint8(nt) + (it.getUint16(nt + 1, !0) << 8)
      },
      put(rt, nt, it) {
        const ot = s(rt)
        return (
          ot.setUint8(nt, it & 255), ot.setUint16(nt + 1, it >> 8, !0), nt + 3
        )
      },
    }),
    (o.UINT24_BE = {
      len: 3,
      get(rt, nt) {
        const it = s(rt)
        return (it.getUint16(nt) << 8) + it.getUint8(nt + 2)
      },
      put(rt, nt, it) {
        const ot = s(rt)
        return ot.setUint16(nt, it >> 8), ot.setUint8(nt + 2, it & 255), nt + 3
      },
    }),
    (o.UINT32_LE = {
      len: 4,
      get(rt, nt) {
        return s(rt).getUint32(nt, !0)
      },
      put(rt, nt, it) {
        return s(rt).setUint32(nt, it, !0), nt + 4
      },
    }),
    (o.UINT32_BE = {
      len: 4,
      get(rt, nt) {
        return s(rt).getUint32(nt)
      },
      put(rt, nt, it) {
        return s(rt).setUint32(nt, it), nt + 4
      },
    }),
    (o.INT8 = {
      len: 1,
      get(rt, nt) {
        return s(rt).getInt8(nt)
      },
      put(rt, nt, it) {
        return s(rt).setInt8(nt, it), nt + 1
      },
    }),
    (o.INT16_BE = {
      len: 2,
      get(rt, nt) {
        return s(rt).getInt16(nt)
      },
      put(rt, nt, it) {
        return s(rt).setInt16(nt, it), nt + 2
      },
    }),
    (o.INT16_LE = {
      len: 2,
      get(rt, nt) {
        return s(rt).getInt16(nt, !0)
      },
      put(rt, nt, it) {
        return s(rt).setInt16(nt, it, !0), nt + 2
      },
    }),
    (o.INT24_LE = {
      len: 3,
      get(rt, nt) {
        const it = o.UINT24_LE.get(rt, nt)
        return it > 8388607 ? it - 16777216 : it
      },
      put(rt, nt, it) {
        const ot = s(rt)
        return (
          ot.setUint8(nt, it & 255), ot.setUint16(nt + 1, it >> 8, !0), nt + 3
        )
      },
    }),
    (o.INT24_BE = {
      len: 3,
      get(rt, nt) {
        const it = o.UINT24_BE.get(rt, nt)
        return it > 8388607 ? it - 16777216 : it
      },
      put(rt, nt, it) {
        const ot = s(rt)
        return ot.setUint16(nt, it >> 8), ot.setUint8(nt + 2, it & 255), nt + 3
      },
    }),
    (o.INT32_BE = {
      len: 4,
      get(rt, nt) {
        return s(rt).getInt32(nt)
      },
      put(rt, nt, it) {
        return s(rt).setInt32(nt, it), nt + 4
      },
    }),
    (o.INT32_LE = {
      len: 4,
      get(rt, nt) {
        return s(rt).getInt32(nt, !0)
      },
      put(rt, nt, it) {
        return s(rt).setInt32(nt, it, !0), nt + 4
      },
    }),
    (o.UINT64_LE = {
      len: 8,
      get(rt, nt) {
        return s(rt).getBigUint64(nt, !0)
      },
      put(rt, nt, it) {
        return s(rt).setBigUint64(nt, it, !0), nt + 8
      },
    }),
    (o.INT64_LE = {
      len: 8,
      get(rt, nt) {
        return s(rt).getBigInt64(nt, !0)
      },
      put(rt, nt, it) {
        return s(rt).setBigInt64(nt, it, !0), nt + 8
      },
    }),
    (o.UINT64_BE = {
      len: 8,
      get(rt, nt) {
        return s(rt).getBigUint64(nt)
      },
      put(rt, nt, it) {
        return s(rt).setBigUint64(nt, it), nt + 8
      },
    }),
    (o.INT64_BE = {
      len: 8,
      get(rt, nt) {
        return s(rt).getBigInt64(nt)
      },
      put(rt, nt, it) {
        return s(rt).setBigInt64(nt, it), nt + 8
      },
    }),
    (o.Float16_BE = {
      len: 2,
      get(rt, nt) {
        return a.read(rt, nt, !1, 10, this.len)
      },
      put(rt, nt, it) {
        return a.write(rt, it, nt, !1, 10, this.len), nt + this.len
      },
    }),
    (o.Float16_LE = {
      len: 2,
      get(rt, nt) {
        return a.read(rt, nt, !0, 10, this.len)
      },
      put(rt, nt, it) {
        return a.write(rt, it, nt, !0, 10, this.len), nt + this.len
      },
    }),
    (o.Float32_BE = {
      len: 4,
      get(rt, nt) {
        return s(rt).getFloat32(nt)
      },
      put(rt, nt, it) {
        return s(rt).setFloat32(nt, it), nt + 4
      },
    }),
    (o.Float32_LE = {
      len: 4,
      get(rt, nt) {
        return s(rt).getFloat32(nt, !0)
      },
      put(rt, nt, it) {
        return s(rt).setFloat32(nt, it, !0), nt + 4
      },
    }),
    (o.Float64_BE = {
      len: 8,
      get(rt, nt) {
        return s(rt).getFloat64(nt)
      },
      put(rt, nt, it) {
        return s(rt).setFloat64(nt, it), nt + 8
      },
    }),
    (o.Float64_LE = {
      len: 8,
      get(rt, nt) {
        return s(rt).getFloat64(nt, !0)
      },
      put(rt, nt, it) {
        return s(rt).setFloat64(nt, it, !0), nt + 8
      },
    }),
    (o.Float80_BE = {
      len: 10,
      get(rt, nt) {
        return a.read(rt, nt, !1, 63, this.len)
      },
      put(rt, nt, it) {
        return a.write(rt, it, nt, !1, 63, this.len), nt + this.len
      },
    }),
    (o.Float80_LE = {
      len: 10,
      get(rt, nt) {
        return a.read(rt, nt, !0, 63, this.len)
      },
      put(rt, nt, it) {
        return a.write(rt, it, nt, !0, 63, this.len), nt + this.len
      },
    })
  class $ {
    constructor(nt) {
      this.len = nt
    }
    get(nt, it) {}
  }
  o.IgnoreType = $
  class j {
    constructor(nt) {
      this.len = nt
    }
    get(nt, it) {
      return nt.subarray(it, it + this.len)
    }
  }
  o.Uint8ArrayType = j
  class _e {
    constructor(nt) {
      this.len = nt
    }
    get(nt, it) {
      return Buffer.from(nt.subarray(it, it + this.len))
    }
  }
  o.BufferType = _e
  class et {
    constructor(nt, it) {
      ;(this.len = nt), (this.encoding = it)
    }
    get(nt, it) {
      return Buffer.from(nt).toString(this.encoding, it, it + this.len)
    }
  }
  o.StringType = et
  class tt {
    constructor(nt) {
      this.len = nt
    }
    static decode(nt, it, ot) {
      let at = ''
      for (let st = it; st < ot; ++st)
        at += tt.codePointToString(tt.singleByteDecoder(nt[st]))
      return at
    }
    static inRange(nt, it, ot) {
      return it <= nt && nt <= ot
    }
    static codePointToString(nt) {
      return nt <= 65535
        ? String.fromCharCode(nt)
        : ((nt -= 65536),
          String.fromCharCode((nt >> 10) + 55296, (nt & 1023) + 56320))
    }
    static singleByteDecoder(nt) {
      if (tt.inRange(nt, 0, 127)) return nt
      const it = tt.windows1252[nt - 128]
      if (it === null) throw Error('invaliding encoding')
      return it
    }
    get(nt, it = 0) {
      return tt.decode(nt, it, it + this.len)
    }
  }
  ;(o.AnsiStringType = tt),
    (tt.windows1252 = [
      8364,
      129,
      8218,
      402,
      8222,
      8230,
      8224,
      8225,
      710,
      8240,
      352,
      8249,
      338,
      141,
      381,
      143,
      144,
      8216,
      8217,
      8220,
      8221,
      8226,
      8211,
      8212,
      732,
      8482,
      353,
      8250,
      339,
      157,
      382,
      376,
      160,
      161,
      162,
      163,
      164,
      165,
      166,
      167,
      168,
      169,
      170,
      171,
      172,
      173,
      174,
      175,
      176,
      177,
      178,
      179,
      180,
      181,
      182,
      183,
      184,
      185,
      186,
      187,
      188,
      189,
      190,
      191,
      192,
      193,
      194,
      195,
      196,
      197,
      198,
      199,
      200,
      201,
      202,
      203,
      204,
      205,
      206,
      207,
      208,
      209,
      210,
      211,
      212,
      213,
      214,
      215,
      216,
      217,
      218,
      219,
      220,
      221,
      222,
      223,
      224,
      225,
      226,
      227,
      228,
      229,
      230,
      231,
      232,
      233,
      234,
      235,
      236,
      237,
      238,
      239,
      240,
      241,
      242,
      243,
      244,
      245,
      246,
      247,
      248,
      249,
      250,
      251,
      252,
      253,
      254,
      255,
    ])
})(lib$3)
var util$6 = {}
util$6.stringToBytes = o => [...o].map(a => a.charCodeAt(0))
util$6.tarHeaderChecksumMatches = (o, a = 0) => {
  const s = parseInt(
    o
      .toString('utf8', 148, 154)
      .replace(/\0.*$/, '')
      .trim(),
    8
  )
  if (isNaN(s)) return !1
  let $ = 8 * 32
  for (let j = a; j < a + 148; j++) $ += o[j]
  for (let j = a + 156; j < a + 512; j++) $ += o[j]
  return s === $
}
util$6.uint32SyncSafeToken = {
  get: (o, a) =>
    (o[a + 3] & 127) | (o[a + 2] << 7) | (o[a + 1] << 14) | (o[a] << 21),
  len: 4,
}
var supported$1 = {
  extensions: [
    'jpg',
    'png',
    'apng',
    'gif',
    'webp',
    'flif',
    'xcf',
    'cr2',
    'cr3',
    'orf',
    'arw',
    'dng',
    'nef',
    'rw2',
    'raf',
    'tif',
    'bmp',
    'icns',
    'jxr',
    'psd',
    'indd',
    'zip',
    'tar',
    'rar',
    'gz',
    'bz2',
    '7z',
    'dmg',
    'mp4',
    'mid',
    'mkv',
    'webm',
    'mov',
    'avi',
    'mpg',
    'mp2',
    'mp3',
    'm4a',
    'oga',
    'ogg',
    'ogv',
    'opus',
    'flac',
    'wav',
    'spx',
    'amr',
    'pdf',
    'epub',
    'exe',
    'swf',
    'rtf',
    'wasm',
    'woff',
    'woff2',
    'eot',
    'ttf',
    'otf',
    'ico',
    'flv',
    'ps',
    'xz',
    'sqlite',
    'nes',
    'crx',
    'xpi',
    'cab',
    'deb',
    'ar',
    'rpm',
    'Z',
    'lz',
    'cfb',
    'mxf',
    'mts',
    'blend',
    'bpg',
    'docx',
    'pptx',
    'xlsx',
    '3gp',
    '3g2',
    'jp2',
    'jpm',
    'jpx',
    'mj2',
    'aif',
    'qcp',
    'odt',
    'ods',
    'odp',
    'xml',
    'mobi',
    'heic',
    'cur',
    'ktx',
    'ape',
    'wv',
    'dcm',
    'ics',
    'glb',
    'pcap',
    'dsf',
    'lnk',
    'alias',
    'voc',
    'ac3',
    'm4v',
    'm4p',
    'm4b',
    'f4v',
    'f4p',
    'f4b',
    'f4a',
    'mie',
    'asf',
    'ogm',
    'ogx',
    'mpc',
    'arrow',
    'shp',
    'aac',
    'mp1',
    'it',
    's3m',
    'xm',
    'ai',
    'skp',
    'avif',
    'eps',
    'lzh',
    'pgp',
    'asar',
    'stl',
    'chm',
    '3mf',
    'zst',
    'jxl',
    'vcf',
  ],
  mimeTypes: [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'image/flif',
    'image/x-xcf',
    'image/x-canon-cr2',
    'image/x-canon-cr3',
    'image/tiff',
    'image/bmp',
    'image/vnd.ms-photo',
    'image/vnd.adobe.photoshop',
    'application/x-indesign',
    'application/epub+zip',
    'application/x-xpinstall',
    'application/vnd.oasis.opendocument.text',
    'application/vnd.oasis.opendocument.spreadsheet',
    'application/vnd.oasis.opendocument.presentation',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/zip',
    'application/x-tar',
    'application/x-rar-compressed',
    'application/gzip',
    'application/x-bzip2',
    'application/x-7z-compressed',
    'application/x-apple-diskimage',
    'application/x-apache-arrow',
    'video/mp4',
    'audio/midi',
    'video/x-matroska',
    'video/webm',
    'video/quicktime',
    'video/vnd.avi',
    'audio/vnd.wave',
    'audio/qcelp',
    'audio/x-ms-asf',
    'video/x-ms-asf',
    'application/vnd.ms-asf',
    'video/mpeg',
    'video/3gpp',
    'audio/mpeg',
    'audio/mp4',
    'audio/opus',
    'video/ogg',
    'audio/ogg',
    'application/ogg',
    'audio/x-flac',
    'audio/ape',
    'audio/wavpack',
    'audio/amr',
    'application/pdf',
    'application/x-msdownload',
    'application/x-shockwave-flash',
    'application/rtf',
    'application/wasm',
    'font/woff',
    'font/woff2',
    'application/vnd.ms-fontobject',
    'font/ttf',
    'font/otf',
    'image/x-icon',
    'video/x-flv',
    'application/postscript',
    'application/eps',
    'application/x-xz',
    'application/x-sqlite3',
    'application/x-nintendo-nes-rom',
    'application/x-google-chrome-extension',
    'application/vnd.ms-cab-compressed',
    'application/x-deb',
    'application/x-unix-archive',
    'application/x-rpm',
    'application/x-compress',
    'application/x-lzip',
    'application/x-cfb',
    'application/x-mie',
    'application/mxf',
    'video/mp2t',
    'application/x-blender',
    'image/bpg',
    'image/jp2',
    'image/jpx',
    'image/jpm',
    'image/mj2',
    'audio/aiff',
    'application/xml',
    'application/x-mobipocket-ebook',
    'image/heif',
    'image/heif-sequence',
    'image/heic',
    'image/heic-sequence',
    'image/icns',
    'image/ktx',
    'application/dicom',
    'audio/x-musepack',
    'text/calendar',
    'text/vcard',
    'model/gltf-binary',
    'application/vnd.tcpdump.pcap',
    'audio/x-dsf',
    'application/x.ms.shortcut',
    'application/x.apple.alias',
    'audio/x-voc',
    'audio/vnd.dolby.dd-raw',
    'audio/x-m4a',
    'image/apng',
    'image/x-olympus-orf',
    'image/x-sony-arw',
    'image/x-adobe-dng',
    'image/x-nikon-nef',
    'image/x-panasonic-rw2',
    'image/x-fujifilm-raf',
    'video/x-m4v',
    'video/3gpp2',
    'application/x-esri-shape',
    'audio/aac',
    'audio/x-it',
    'audio/x-s3m',
    'audio/x-xm',
    'video/MP1S',
    'video/MP2P',
    'application/vnd.sketchup.skp',
    'image/avif',
    'application/x-lzh-compressed',
    'application/pgp-encrypted',
    'application/x-asar',
    'model/stl',
    'application/vnd.ms-htmlhelp',
    'model/3mf',
    'image/jxl',
    'application/zstd',
  ],
}
const Token = lib$3,
  strtok3$1 = core$3,
  { stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken } = util$6,
  supported = supported$1,
  minimumBytes = 4100
async function fromStream(o) {
  const a = await strtok3$1.fromStream(o)
  try {
    return await fromTokenizer(a)
  } finally {
    await a.close()
  }
}
async function fromBuffer(o) {
  if (
    !(o instanceof Uint8Array || o instanceof ArrayBuffer || Buffer.isBuffer(o))
  )
    throw new TypeError(
      `Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof o}\``
    )
  const a = o instanceof Buffer ? o : Buffer.from(o)
  if (!(a && a.length > 1)) return
  const s = strtok3$1.fromBuffer(a)
  return fromTokenizer(s)
}
function _check(o, a, s) {
  s = { offset: 0, ...s }
  for (const [$, j] of a.entries())
    if (s.mask) {
      if (j !== (s.mask[$] & o[$ + s.offset])) return !1
    } else if (j !== o[$ + s.offset]) return !1
  return !0
}
async function fromTokenizer(o) {
  try {
    return _fromTokenizer(o)
  } catch (a) {
    if (!(a instanceof strtok3$1.EndOfStreamError)) throw a
  }
}
async function _fromTokenizer(o) {
  let a = Buffer.alloc(minimumBytes)
  const s = 12,
    $ = (_e, et) => _check(a, _e, et),
    j = (_e, et) => $(stringToBytes(_e), et)
  if (
    (o.fileInfo.size || (o.fileInfo.size = Number.MAX_SAFE_INTEGER),
    await o.peekBuffer(a, { length: s, mayBeLess: !0 }),
    $([66, 77]))
  )
    return { ext: 'bmp', mime: 'image/bmp' }
  if ($([11, 119])) return { ext: 'ac3', mime: 'audio/vnd.dolby.dd-raw' }
  if ($([120, 1])) return { ext: 'dmg', mime: 'application/x-apple-diskimage' }
  if ($([77, 90])) return { ext: 'exe', mime: 'application/x-msdownload' }
  if ($([37, 33]))
    return (
      await o.peekBuffer(a, { length: 24, mayBeLess: !0 }),
      j('PS-Adobe-', { offset: 2 }) && j(' EPSF-', { offset: 14 })
        ? { ext: 'eps', mime: 'application/eps' }
        : { ext: 'ps', mime: 'application/postscript' }
    )
  if ($([31, 160]) || $([31, 157]))
    return { ext: 'Z', mime: 'application/x-compress' }
  if ($([255, 216, 255])) return { ext: 'jpg', mime: 'image/jpeg' }
  if ($([73, 73, 188])) return { ext: 'jxr', mime: 'image/vnd.ms-photo' }
  if ($([31, 139, 8])) return { ext: 'gz', mime: 'application/gzip' }
  if ($([66, 90, 104])) return { ext: 'bz2', mime: 'application/x-bzip2' }
  if (j('ID3')) {
    await o.ignore(6)
    const _e = await o.readToken(uint32SyncSafeToken)
    return o.position + _e > o.fileInfo.size
      ? { ext: 'mp3', mime: 'audio/mpeg' }
      : (await o.ignore(_e), fromTokenizer(o))
  }
  if (j('MP+')) return { ext: 'mpc', mime: 'audio/x-musepack' }
  if ((a[0] === 67 || a[0] === 70) && $([87, 83], { offset: 1 }))
    return { ext: 'swf', mime: 'application/x-shockwave-flash' }
  if ($([71, 73, 70])) return { ext: 'gif', mime: 'image/gif' }
  if (j('FLIF')) return { ext: 'flif', mime: 'image/flif' }
  if (j('8BPS')) return { ext: 'psd', mime: 'image/vnd.adobe.photoshop' }
  if (j('WEBP', { offset: 8 })) return { ext: 'webp', mime: 'image/webp' }
  if (j('MPCK')) return { ext: 'mpc', mime: 'audio/x-musepack' }
  if (j('FORM')) return { ext: 'aif', mime: 'audio/aiff' }
  if (j('icns', { offset: 0 })) return { ext: 'icns', mime: 'image/icns' }
  if ($([80, 75, 3, 4])) {
    try {
      for (; o.position + 30 < o.fileInfo.size; ) {
        await o.readBuffer(a, { length: 30 })
        const _e = {
          compressedSize: a.readUInt32LE(18),
          uncompressedSize: a.readUInt32LE(22),
          filenameLength: a.readUInt16LE(26),
          extraFieldLength: a.readUInt16LE(28),
        }
        if (
          ((_e.filename = await o.readToken(
            new Token.StringType(_e.filenameLength, 'utf-8')
          )),
          await o.ignore(_e.extraFieldLength),
          _e.filename === 'META-INF/mozilla.rsa')
        )
          return { ext: 'xpi', mime: 'application/x-xpinstall' }
        if (_e.filename.endsWith('.rels') || _e.filename.endsWith('.xml'))
          switch (_e.filename.split('/')[0]) {
            case '_rels':
              break
            case 'word':
              return {
                ext: 'docx',
                mime:
                  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
              }
            case 'ppt':
              return {
                ext: 'pptx',
                mime:
                  'application/vnd.openxmlformats-officedocument.presentationml.presentation',
              }
            case 'xl':
              return {
                ext: 'xlsx',
                mime:
                  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
              }
            default:
              break
          }
        if (_e.filename.startsWith('xl/'))
          return {
            ext: 'xlsx',
            mime:
              'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
          }
        if (_e.filename.startsWith('3D/') && _e.filename.endsWith('.model'))
          return { ext: '3mf', mime: 'model/3mf' }
        if (
          _e.filename === 'mimetype' &&
          _e.compressedSize === _e.uncompressedSize
        )
          switch (
            await o.readToken(new Token.StringType(_e.compressedSize, 'utf-8'))
          ) {
            case 'application/epub+zip':
              return { ext: 'epub', mime: 'application/epub+zip' }
            case 'application/vnd.oasis.opendocument.text':
              return {
                ext: 'odt',
                mime: 'application/vnd.oasis.opendocument.text',
              }
            case 'application/vnd.oasis.opendocument.spreadsheet':
              return {
                ext: 'ods',
                mime: 'application/vnd.oasis.opendocument.spreadsheet',
              }
            case 'application/vnd.oasis.opendocument.presentation':
              return {
                ext: 'odp',
                mime: 'application/vnd.oasis.opendocument.presentation',
              }
            default:
          }
        if (_e.compressedSize === 0) {
          let et = -1
          for (; et < 0 && o.position < o.fileInfo.size; )
            await o.peekBuffer(a, { mayBeLess: !0 }),
              (et = a.indexOf('504B0304', 0, 'hex')),
              await o.ignore(et >= 0 ? et : a.length)
        } else await o.ignore(_e.compressedSize)
      }
    } catch (_e) {
      if (!(_e instanceof strtok3$1.EndOfStreamError)) throw _e
    }
    return { ext: 'zip', mime: 'application/zip' }
  }
  if (j('OggS')) {
    await o.ignore(28)
    const _e = Buffer.alloc(8)
    return (
      await o.readBuffer(_e),
      _check(_e, [79, 112, 117, 115, 72, 101, 97, 100])
        ? { ext: 'opus', mime: 'audio/opus' }
        : _check(_e, [128, 116, 104, 101, 111, 114, 97])
        ? { ext: 'ogv', mime: 'video/ogg' }
        : _check(_e, [1, 118, 105, 100, 101, 111, 0])
        ? { ext: 'ogm', mime: 'video/ogg' }
        : _check(_e, [127, 70, 76, 65, 67])
        ? { ext: 'oga', mime: 'audio/ogg' }
        : _check(_e, [83, 112, 101, 101, 120, 32, 32])
        ? { ext: 'spx', mime: 'audio/ogg' }
        : _check(_e, [1, 118, 111, 114, 98, 105, 115])
        ? { ext: 'ogg', mime: 'audio/ogg' }
        : { ext: 'ogx', mime: 'application/ogg' }
    )
  }
  if (
    $([80, 75]) &&
    (a[2] === 3 || a[2] === 5 || a[2] === 7) &&
    (a[3] === 4 || a[3] === 6 || a[3] === 8)
  )
    return { ext: 'zip', mime: 'application/zip' }
  if (j('ftyp', { offset: 4 }) && a[8] & 96) {
    const _e = a
      .toString('binary', 8, 12)
      .replace('\0', ' ')
      .trim()
    switch (_e) {
      case 'avif':
        return { ext: 'avif', mime: 'image/avif' }
      case 'mif1':
        return { ext: 'heic', mime: 'image/heif' }
      case 'msf1':
        return { ext: 'heic', mime: 'image/heif-sequence' }
      case 'heic':
      case 'heix':
        return { ext: 'heic', mime: 'image/heic' }
      case 'hevc':
      case 'hevx':
        return { ext: 'heic', mime: 'image/heic-sequence' }
      case 'qt':
        return { ext: 'mov', mime: 'video/quicktime' }
      case 'M4V':
      case 'M4VH':
      case 'M4VP':
        return { ext: 'm4v', mime: 'video/x-m4v' }
      case 'M4P':
        return { ext: 'm4p', mime: 'video/mp4' }
      case 'M4B':
        return { ext: 'm4b', mime: 'audio/mp4' }
      case 'M4A':
        return { ext: 'm4a', mime: 'audio/x-m4a' }
      case 'F4V':
        return { ext: 'f4v', mime: 'video/mp4' }
      case 'F4P':
        return { ext: 'f4p', mime: 'video/mp4' }
      case 'F4A':
        return { ext: 'f4a', mime: 'audio/mp4' }
      case 'F4B':
        return { ext: 'f4b', mime: 'audio/mp4' }
      case 'crx':
        return { ext: 'cr3', mime: 'image/x-canon-cr3' }
      default:
        return _e.startsWith('3g')
          ? _e.startsWith('3g2')
            ? { ext: '3g2', mime: 'video/3gpp2' }
            : { ext: '3gp', mime: 'video/3gpp' }
          : { ext: 'mp4', mime: 'video/mp4' }
    }
  }
  if (j('MThd')) return { ext: 'mid', mime: 'audio/midi' }
  if (j('wOFF') && ($([0, 1, 0, 0], { offset: 4 }) || j('OTTO', { offset: 4 })))
    return { ext: 'woff', mime: 'font/woff' }
  if (j('wOF2') && ($([0, 1, 0, 0], { offset: 4 }) || j('OTTO', { offset: 4 })))
    return { ext: 'woff2', mime: 'font/woff2' }
  if ($([212, 195, 178, 161]) || $([161, 178, 195, 212]))
    return { ext: 'pcap', mime: 'application/vnd.tcpdump.pcap' }
  if (j('DSD ')) return { ext: 'dsf', mime: 'audio/x-dsf' }
  if (j('LZIP')) return { ext: 'lz', mime: 'application/x-lzip' }
  if (j('fLaC')) return { ext: 'flac', mime: 'audio/x-flac' }
  if ($([66, 80, 71, 251])) return { ext: 'bpg', mime: 'image/bpg' }
  if (j('wvpk')) return { ext: 'wv', mime: 'audio/wavpack' }
  if (j('%PDF')) {
    await o.ignore(1350)
    const _e = 10 * 1024 * 1024,
      et = Buffer.alloc(Math.min(_e, o.fileInfo.size))
    return (
      await o.readBuffer(et, { mayBeLess: !0 }),
      et.includes(Buffer.from('AIPrivateData'))
        ? { ext: 'ai', mime: 'application/postscript' }
        : { ext: 'pdf', mime: 'application/pdf' }
    )
  }
  if ($([0, 97, 115, 109])) return { ext: 'wasm', mime: 'application/wasm' }
  if ($([73, 73, 42, 0]))
    return j('CR', { offset: 8 })
      ? { ext: 'cr2', mime: 'image/x-canon-cr2' }
      : $([28, 0, 254, 0], { offset: 8 }) || $([31, 0, 11, 0], { offset: 8 })
      ? { ext: 'nef', mime: 'image/x-nikon-nef' }
      : $([8, 0, 0, 0], { offset: 4 }) &&
        ($([45, 0, 254, 0], { offset: 8 }) || $([39, 0, 254, 0], { offset: 8 }))
      ? { ext: 'dng', mime: 'image/x-adobe-dng' }
      : ((a = Buffer.alloc(24)),
        await o.peekBuffer(a),
        ($([16, 251, 134, 1], { offset: 4 }) ||
          $([8, 0, 0, 0], { offset: 4 })) &&
        $([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 })
          ? { ext: 'arw', mime: 'image/x-sony-arw' }
          : { ext: 'tif', mime: 'image/tiff' })
  if ($([77, 77, 0, 42])) return { ext: 'tif', mime: 'image/tiff' }
  if (j('MAC ')) return { ext: 'ape', mime: 'audio/ape' }
  if ($([26, 69, 223, 163])) {
    async function _e() {
      const it = await o.peekNumber(Token.UINT8)
      let ot = 128,
        at = 0
      for (; !(it & ot) && ot !== 0; ) ++at, (ot >>= 1)
      const st = Buffer.alloc(at + 1)
      return await o.readBuffer(st), st
    }
    async function et() {
      const it = await _e(),
        ot = await _e()
      ot[0] ^= 128 >> (ot.length - 1)
      const at = Math.min(6, ot.length)
      return {
        id: it.readUIntBE(0, it.length),
        len: ot.readUIntBE(ot.length - at, at),
      }
    }
    async function tt(it, ot) {
      for (; ot > 0; ) {
        const at = await et()
        if (at.id === 17026)
          return o.readToken(new Token.StringType(at.len, 'utf-8'))
        await o.ignore(at.len), --ot
      }
    }
    const rt = await et()
    switch (await tt(1, rt.len)) {
      case 'webm':
        return { ext: 'webm', mime: 'video/webm' }
      case 'matroska':
        return { ext: 'mkv', mime: 'video/x-matroska' }
      default:
        return
    }
  }
  if ($([82, 73, 70, 70])) {
    if ($([65, 86, 73], { offset: 8 }))
      return { ext: 'avi', mime: 'video/vnd.avi' }
    if ($([87, 65, 86, 69], { offset: 8 }))
      return { ext: 'wav', mime: 'audio/vnd.wave' }
    if ($([81, 76, 67, 77], { offset: 8 }))
      return { ext: 'qcp', mime: 'audio/qcelp' }
  }
  if (j('SQLi')) return { ext: 'sqlite', mime: 'application/x-sqlite3' }
  if ($([78, 69, 83, 26]))
    return { ext: 'nes', mime: 'application/x-nintendo-nes-rom' }
  if (j('Cr24'))
    return { ext: 'crx', mime: 'application/x-google-chrome-extension' }
  if (j('MSCF') || j('ISc('))
    return { ext: 'cab', mime: 'application/vnd.ms-cab-compressed' }
  if ($([237, 171, 238, 219])) return { ext: 'rpm', mime: 'application/x-rpm' }
  if ($([197, 208, 211, 198])) return { ext: 'eps', mime: 'application/eps' }
  if ($([40, 181, 47, 253])) return { ext: 'zst', mime: 'application/zstd' }
  if ($([79, 84, 84, 79, 0])) return { ext: 'otf', mime: 'font/otf' }
  if (j('#!AMR')) return { ext: 'amr', mime: 'audio/amr' }
  if (j('{\\rtf')) return { ext: 'rtf', mime: 'application/rtf' }
  if ($([70, 76, 86, 1])) return { ext: 'flv', mime: 'video/x-flv' }
  if (j('IMPM')) return { ext: 'it', mime: 'audio/x-it' }
  if (
    j('-lh0-', { offset: 2 }) ||
    j('-lh1-', { offset: 2 }) ||
    j('-lh2-', { offset: 2 }) ||
    j('-lh3-', { offset: 2 }) ||
    j('-lh4-', { offset: 2 }) ||
    j('-lh5-', { offset: 2 }) ||
    j('-lh6-', { offset: 2 }) ||
    j('-lh7-', { offset: 2 }) ||
    j('-lzs-', { offset: 2 }) ||
    j('-lz4-', { offset: 2 }) ||
    j('-lz5-', { offset: 2 }) ||
    j('-lhd-', { offset: 2 })
  )
    return { ext: 'lzh', mime: 'application/x-lzh-compressed' }
  if ($([0, 0, 1, 186])) {
    if ($([33], { offset: 4, mask: [241] }))
      return { ext: 'mpg', mime: 'video/MP1S' }
    if ($([68], { offset: 4, mask: [196] }))
      return { ext: 'mpg', mime: 'video/MP2P' }
  }
  if (j('ITSF')) return { ext: 'chm', mime: 'application/vnd.ms-htmlhelp' }
  if ($([253, 55, 122, 88, 90, 0]))
    return { ext: 'xz', mime: 'application/x-xz' }
  if (j('<?xml ')) return { ext: 'xml', mime: 'application/xml' }
  if ($([55, 122, 188, 175, 39, 28]))
    return { ext: '7z', mime: 'application/x-7z-compressed' }
  if ($([82, 97, 114, 33, 26, 7]) && (a[6] === 0 || a[6] === 1))
    return { ext: 'rar', mime: 'application/x-rar-compressed' }
  if (j('solid ')) return { ext: 'stl', mime: 'model/stl' }
  if (j('BLENDER')) return { ext: 'blend', mime: 'application/x-blender' }
  if (j('!<arch>'))
    return (
      await o.ignore(8),
      (await o.readToken(new Token.StringType(13, 'ascii'))) === 'debian-binary'
        ? { ext: 'deb', mime: 'application/x-deb' }
        : { ext: 'ar', mime: 'application/x-unix-archive' }
    )
  if ($([137, 80, 78, 71, 13, 10, 26, 10])) {
    await o.ignore(8)
    async function _e() {
      return {
        length: await o.readToken(Token.INT32_BE),
        type: await o.readToken(new Token.StringType(4, 'binary')),
      }
    }
    do {
      const et = await _e()
      if (et.length < 0) return
      switch (et.type) {
        case 'IDAT':
          return { ext: 'png', mime: 'image/png' }
        case 'acTL':
          return { ext: 'apng', mime: 'image/apng' }
        default:
          await o.ignore(et.length + 4)
      }
    } while (o.position + 8 < o.fileInfo.size)
    return { ext: 'png', mime: 'image/png' }
  }
  if ($([65, 82, 82, 79, 87, 49, 0, 0]))
    return { ext: 'arrow', mime: 'application/x-apache-arrow' }
  if ($([103, 108, 84, 70, 2, 0, 0, 0]))
    return { ext: 'glb', mime: 'model/gltf-binary' }
  if (
    $([102, 114, 101, 101], { offset: 4 }) ||
    $([109, 100, 97, 116], { offset: 4 }) ||
    $([109, 111, 111, 118], { offset: 4 }) ||
    $([119, 105, 100, 101], { offset: 4 })
  )
    return { ext: 'mov', mime: 'video/quicktime' }
  if ($([73, 73, 82, 79, 8, 0, 0, 0, 24]))
    return { ext: 'orf', mime: 'image/x-olympus-orf' }
  if (j('gimp xcf ')) return { ext: 'xcf', mime: 'image/x-xcf' }
  if ($([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
    return { ext: 'rw2', mime: 'image/x-panasonic-rw2' }
  if ($([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
    async function _e() {
      const et = Buffer.alloc(16)
      return (
        await o.readBuffer(et),
        { id: et, size: Number(await o.readToken(Token.UINT64_LE)) }
      )
    }
    for (await o.ignore(30); o.position + 24 < o.fileInfo.size; ) {
      const et = await _e()
      let tt = et.size - 24
      if (
        _check(et.id, [
          145,
          7,
          220,
          183,
          183,
          169,
          207,
          17,
          142,
          230,
          0,
          192,
          12,
          32,
          83,
          101,
        ])
      ) {
        const rt = Buffer.alloc(16)
        if (
          ((tt -= await o.readBuffer(rt)),
          _check(rt, [
            64,
            158,
            105,
            248,
            77,
            91,
            207,
            17,
            168,
            253,
            0,
            128,
            95,
            92,
            68,
            43,
          ]))
        )
          return { ext: 'asf', mime: 'audio/x-ms-asf' }
        if (
          _check(rt, [
            192,
            239,
            25,
            188,
            77,
            91,
            207,
            17,
            168,
            253,
            0,
            128,
            95,
            92,
            68,
            43,
          ])
        )
          return { ext: 'asf', mime: 'video/x-ms-asf' }
        break
      }
      await o.ignore(tt)
    }
    return { ext: 'asf', mime: 'application/vnd.ms-asf' }
  }
  if ($([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
    return { ext: 'ktx', mime: 'image/ktx' }
  if (
    ($([126, 16, 4]) || $([126, 24, 4])) &&
    $([48, 77, 73, 69], { offset: 4 })
  )
    return { ext: 'mie', mime: 'application/x-mie' }
  if ($([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
    return { ext: 'shp', mime: 'application/x-esri-shape' }
  if ($([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
    switch (
      (await o.ignore(20), await o.readToken(new Token.StringType(4, 'ascii')))
    ) {
      case 'jp2 ':
        return { ext: 'jp2', mime: 'image/jp2' }
      case 'jpx ':
        return { ext: 'jpx', mime: 'image/jpx' }
      case 'jpm ':
        return { ext: 'jpm', mime: 'image/jpm' }
      case 'mjp2':
        return { ext: 'mj2', mime: 'image/mj2' }
      default:
        return
    }
  if ($([255, 10]) || $([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
    return { ext: 'jxl', mime: 'image/jxl' }
  if ($([0, 0, 1, 186]) || $([0, 0, 1, 179]))
    return { ext: 'mpg', mime: 'video/mpeg' }
  if ($([0, 1, 0, 0, 0])) return { ext: 'ttf', mime: 'font/ttf' }
  if ($([0, 0, 1, 0])) return { ext: 'ico', mime: 'image/x-icon' }
  if ($([0, 0, 2, 0])) return { ext: 'cur', mime: 'image/x-icon' }
  if ($([208, 207, 17, 224, 161, 177, 26, 225]))
    return { ext: 'cfb', mime: 'application/x-cfb' }
  if (
    (await o.peekBuffer(a, {
      length: Math.min(256, o.fileInfo.size),
      mayBeLess: !0,
    }),
    j('BEGIN:'))
  ) {
    if (j('VCARD', { offset: 6 })) return { ext: 'vcf', mime: 'text/vcard' }
    if (j('VCALENDAR', { offset: 6 }))
      return { ext: 'ics', mime: 'text/calendar' }
  }
  if (j('FUJIFILMCCD-RAW')) return { ext: 'raf', mime: 'image/x-fujifilm-raf' }
  if (j('Extended Module:')) return { ext: 'xm', mime: 'audio/x-xm' }
  if (j('Creative Voice File')) return { ext: 'voc', mime: 'audio/x-voc' }
  if ($([4, 0, 0, 0]) && a.length >= 16) {
    const _e = a.readUInt32LE(12)
    if (_e > 12 && a.length >= _e + 16)
      try {
        const et = a.slice(16, _e + 16).toString()
        if (JSON.parse(et).files)
          return { ext: 'asar', mime: 'application/x-asar' }
      } catch {}
  }
  if ($([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
    return { ext: 'mxf', mime: 'application/mxf' }
  if (j('SCRM', { offset: 44 })) return { ext: 's3m', mime: 'audio/x-s3m' }
  if (
    $([71], { offset: 4 }) &&
    ($([71], { offset: 192 }) || $([71], { offset: 196 }))
  )
    return { ext: 'mts', mime: 'video/mp2t' }
  if ($([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
    return { ext: 'mobi', mime: 'application/x-mobipocket-ebook' }
  if ($([68, 73, 67, 77], { offset: 128 }))
    return { ext: 'dcm', mime: 'application/dicom' }
  if ($([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
    return { ext: 'lnk', mime: 'application/x.ms.shortcut' }
  if ($([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
    return { ext: 'alias', mime: 'application/x.apple.alias' }
  if (
    $([76, 80], { offset: 34 }) &&
    ($([0, 0, 1], { offset: 8 }) ||
      $([1, 0, 2], { offset: 8 }) ||
      $([2, 0, 2], { offset: 8 }))
  )
    return { ext: 'eot', mime: 'application/vnd.ms-fontobject' }
  if (
    $([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])
  )
    return { ext: 'indd', mime: 'application/x-indesign' }
  if (
    (await o.peekBuffer(a, {
      length: Math.min(512, o.fileInfo.size),
      mayBeLess: !0,
    }),
    tarHeaderChecksumMatches(a))
  )
    return { ext: 'tar', mime: 'application/x-tar' }
  if (
    $([
      255,
      254,
      255,
      14,
      83,
      0,
      107,
      0,
      101,
      0,
      116,
      0,
      99,
      0,
      104,
      0,
      85,
      0,
      112,
      0,
      32,
      0,
      77,
      0,
      111,
      0,
      100,
      0,
      101,
      0,
      108,
      0,
    ])
  )
    return { ext: 'skp', mime: 'application/vnd.sketchup.skp' }
  if (j('-----BEGIN PGP MESSAGE-----'))
    return { ext: 'pgp', mime: 'application/pgp-encrypted' }
  if (a.length >= 2 && $([255, 224], { offset: 0, mask: [255, 224] })) {
    if ($([16], { offset: 1, mask: [22] }))
      return $([8], { offset: 1, mask: [8] })
        ? { ext: 'aac', mime: 'audio/aac' }
        : { ext: 'aac', mime: 'audio/aac' }
    if ($([2], { offset: 1, mask: [6] }))
      return { ext: 'mp3', mime: 'audio/mpeg' }
    if ($([4], { offset: 1, mask: [6] }))
      return { ext: 'mp2', mime: 'audio/mpeg' }
    if ($([6], { offset: 1, mask: [6] }))
      return { ext: 'mp1', mime: 'audio/mpeg' }
  }
}
const stream = readableStream =>
    new Promise((resolve, reject) => {
      const stream = eval('require')('stream')
      readableStream.on('error', reject),
        readableStream.once('readable', async () => {
          const o = new stream.PassThrough()
          let a
          stream.pipeline
            ? (a = stream.pipeline(readableStream, o, () => {}))
            : (a = readableStream.pipe(o))
          const s =
            readableStream.read(minimumBytes) ||
            readableStream.read() ||
            Buffer.alloc(0)
          try {
            const $ = await fromBuffer(s)
            o.fileType = $
          } catch ($) {
            reject($)
          }
          resolve(a)
        })
    }),
  fileType$1 = { fromStream, fromTokenizer, fromBuffer, stream }
Object.defineProperty(fileType$1, 'extensions', {
  get() {
    return new Set(supported.extensions)
  },
})
Object.defineProperty(fileType$1, 'mimeTypes', {
  get() {
    return new Set(supported.mimeTypes)
  },
})
var core$2 = fileType$1
const strtok3 = lib$5,
  core$1 = core$2
async function fromFile(o) {
  const a = await strtok3.fromFile(o)
  try {
    return await core$1.fromTokenizer(a)
  } finally {
    await a.close()
  }
}
const fileType = { fromFile }
Object.assign(fileType, core$1)
Object.defineProperty(fileType, 'extensions', {
  get() {
    return core$1.extensions
  },
})
Object.defineProperty(fileType, 'mimeTypes', {
  get() {
    return core$1.mimeTypes
  },
})
var fileType_1 = fileType
const FileType = getDefaultExportFromCjs(fileType_1)
var jpeg$1 = {
  parseSections: function(o, a) {
    var s, $
    for (o.setBigEndian(!0); o.remainingLength() > 0 && $ !== 218; ) {
      if (o.nextUInt8() !== 255) throw new Error('Invalid JPEG section offset')
      ;($ = o.nextUInt8()),
        ($ >= 208 && $ <= 217) || $ === 218
          ? (s = 0)
          : (s = o.nextUInt16() - 2),
        a($, o.branch(0, s)),
        o.skip(s)
    }
  },
  getSizeFromSOFSection: function(o) {
    return o.skip(1), { height: o.nextUInt16(), width: o.nextUInt16() }
  },
  getSectionName: function(o) {
    var a, s
    switch (o) {
      case 216:
        a = 'SOI'
        break
      case 196:
        a = 'DHT'
        break
      case 219:
        a = 'DQT'
        break
      case 221:
        a = 'DRI'
        break
      case 218:
        a = 'SOS'
        break
      case 254:
        a = 'COM'
        break
      case 217:
        a = 'EOI'
        break
      default:
        o >= 224 && o <= 239
          ? ((a = 'APP'), (s = o - 224))
          : o >= 192 && o <= 207 && o !== 196 && o !== 200 && o !== 204
          ? ((a = 'SOF'), (s = o - 192))
          : o >= 208 && o <= 215 && ((a = 'RST'), (s = o - 208))
        break
    }
    var $ = { name: a }
    return typeof s == 'number' && ($.index = s), $
  },
}
function readExifValue(o, a) {
  switch (o) {
    case 1:
      return a.nextUInt8()
    case 3:
      return a.nextUInt16()
    case 4:
      return a.nextUInt32()
    case 5:
      return [a.nextUInt32(), a.nextUInt32()]
    case 6:
      return a.nextInt8()
    case 8:
      return a.nextUInt16()
    case 9:
      return a.nextUInt32()
    case 10:
      return [a.nextInt32(), a.nextInt32()]
    case 11:
      return a.nextFloat()
    case 12:
      return a.nextDouble()
    default:
      throw new Error('Invalid format while decoding: ' + o)
  }
}
function getBytesPerComponent(o) {
  switch (o) {
    case 1:
    case 2:
    case 6:
    case 7:
      return 1
    case 3:
    case 8:
      return 2
    case 4:
    case 9:
    case 11:
      return 4
    case 5:
    case 10:
    case 12:
      return 8
    default:
      return 0
  }
}
function readExifTag(o, a) {
  var s = a.nextUInt16(),
    $ = a.nextUInt16(),
    j = getBytesPerComponent($),
    _e = a.nextUInt32(),
    et = j * _e,
    tt,
    rt
  if ((et > 4 && (a = o.openWithOffset(a.nextUInt32())), $ === 2)) {
    tt = a.nextString(_e)
    var nt = tt.indexOf('\0')
    nt !== -1 && (tt = tt.substr(0, nt))
  } else if ($ === 7) tt = a.nextBuffer(_e)
  else if ($ !== 0)
    for (tt = [], rt = 0; rt < _e; ++rt) tt.push(readExifValue($, a))
  return et < 4 && a.skip(4 - et), [s, tt, $]
}
function readIFDSection(o, a, s) {
  var $ = a.nextUInt16(),
    j,
    _e
  for (_e = 0; _e < $; ++_e) (j = readExifTag(o, a)), s(j[0], j[1], j[2])
}
function readHeader(o) {
  var a = o.nextString(6)
  if (a !== 'Exif\0\0') throw new Error('Invalid EXIF header')
  var s = o.mark(),
    $ = o.nextUInt16()
  if ($ === 18761) o.setBigEndian(!1)
  else if ($ === 19789) o.setBigEndian(!0)
  else throw new Error('Invalid TIFF header')
  if (o.nextUInt16() !== 42) throw new Error('Invalid TIFF data')
  return s
}
var exif$2 = {
  IFD0: 1,
  IFD1: 2,
  GPSIFD: 3,
  SubIFD: 4,
  InteropIFD: 5,
  parseTags: function(o, a) {
    var s
    try {
      s = readHeader(o)
    } catch {
      return !1
    }
    var $,
      j,
      _e,
      et = s.openWithOffset(o.nextUInt32()),
      tt = this.IFD0
    readIFDSection(s, et, function(ut, ct, dt) {
      switch (ut) {
        case 34853:
          j = ct[0]
          break
        case 34665:
          $ = ct[0]
          break
        default:
          a(tt, ut, ct, dt)
          break
      }
    })
    var rt = et.nextUInt32()
    if (rt !== 0) {
      var nt = s.openWithOffset(rt)
      readIFDSection(s, nt, a.bind(null, this.IFD1))
    }
    if (j) {
      var it = s.openWithOffset(j)
      readIFDSection(s, it, a.bind(null, this.GPSIFD))
    }
    if ($) {
      var ot = s.openWithOffset($),
        at = this.InteropIFD
      readIFDSection(s, ot, function(ut, ct, dt) {
        ut === 40965 ? (_e = ct[0]) : a(at, ut, ct, dt)
      })
    }
    if (_e) {
      var st = s.openWithOffset(_e)
      readIFDSection(s, st, a.bind(null, this.InteropIFD))
    }
    return !0
  },
}
function parseNumber(o) {
  return parseInt(o, 10)
}
var hours = 3600,
  minutes = 60
function parseDateTimeParts(o, a) {
  ;(o = o.map(parseNumber)), (a = a.map(parseNumber))
  var s = o[0],
    $ = o[1] - 1,
    j = o[2],
    _e = a[0],
    et = a[1],
    tt = a[2],
    rt = Date.UTC(s, $, j, _e, et, tt, 0),
    nt = rt / 1e3
  return nt
}
function parseDateWithTimezoneFormat(o) {
  var a = o.substr(0, 10).split('-'),
    s = o.substr(11, 8).split(':'),
    $ = o.substr(19, 6),
    j = $.split(':').map(parseNumber),
    _e = j[0] * hours + j[1] * minutes,
    et = parseDateTimeParts(a, s)
  if (((et -= _e), typeof et == 'number' && !isNaN(et))) return et
}
function parseDateWithSpecFormat(o) {
  var a = o.split(' '),
    s = a[0].split(':'),
    $ = a[1].split(':'),
    j = parseDateTimeParts(s, $)
  if (typeof j == 'number' && !isNaN(j)) return j
}
function parseExifDate(o) {
  var a = o.length === 19 && o.charAt(4) === ':',
    s = o.length === 25 && o.charAt(10) === 'T'
  if (s) return parseDateWithTimezoneFormat(o)
  if (a) return parseDateWithSpecFormat(o)
}
var date$1 = {
    parseDateWithSpecFormat,
    parseDateWithTimezoneFormat,
    parseExifDate,
  },
  exif$1 = exif$2,
  date = date$1,
  degreeTags = [
    {
      section: exif$1.GPSIFD,
      type: 2,
      name: 'GPSLatitude',
      refType: 1,
      refName: 'GPSLatitudeRef',
      posVal: 'N',
    },
    {
      section: exif$1.GPSIFD,
      type: 4,
      name: 'GPSLongitude',
      refType: 3,
      refName: 'GPSLongitudeRef',
      posVal: 'E',
    },
  ],
  dateTags = [
    { section: exif$1.SubIFD, type: 306, name: 'ModifyDate' },
    { section: exif$1.SubIFD, type: 36867, name: 'DateTimeOriginal' },
    { section: exif$1.SubIFD, type: 36868, name: 'CreateDate' },
    { section: exif$1.SubIFD, type: 306, name: 'ModifyDate' },
  ],
  simplify$1 = {
    castDegreeValues: function(o, a) {
      degreeTags.forEach(function(s) {
        var $ = o(s)
        if ($) {
          var j = o({ section: s.section, type: s.refType, name: s.refName }),
            _e = j === s.posVal ? 1 : -1,
            et = ($[0] + $[1] / 60 + $[2] / 3600) * _e
          a(s, et)
        }
      })
    },
    castDateValues: function(o, a) {
      dateTags.forEach(function(s) {
        var $ = o(s)
        if ($) {
          var j = date.parseExifDate($)
          typeof j < 'u' && a(s, j)
        }
      })
    },
    simplifyValue: function(o, a) {
      return (
        Array.isArray(o) &&
          ((o = o.map(function(s) {
            return a === 10 || a === 5 ? s[0] / s[1] : s
          })),
          o.length === 1 && (o = o[0])),
        o
      )
    },
  },
  exifTags,
  hasRequiredExifTags
function requireExifTags() {
  return (
    hasRequiredExifTags ||
      ((hasRequiredExifTags = 1),
      (exifTags = {
        exif: {
          1: 'InteropIndex',
          2: 'InteropVersion',
          11: 'ProcessingSoftware',
          254: 'SubfileType',
          255: 'OldSubfileType',
          256: 'ImageWidth',
          257: 'ImageHeight',
          258: 'BitsPerSample',
          259: 'Compression',
          262: 'PhotometricInterpretation',
          263: 'Thresholding',
          264: 'CellWidth',
          265: 'CellLength',
          266: 'FillOrder',
          269: 'DocumentName',
          270: 'ImageDescription',
          271: 'Make',
          272: 'Model',
          273: 'StripOffsets',
          274: 'Orientation',
          277: 'SamplesPerPixel',
          278: 'RowsPerStrip',
          279: 'StripByteCounts',
          280: 'MinSampleValue',
          281: 'MaxSampleValue',
          282: 'XResolution',
          283: 'YResolution',
          284: 'PlanarConfiguration',
          285: 'PageName',
          286: 'XPosition',
          287: 'YPosition',
          288: 'FreeOffsets',
          289: 'FreeByteCounts',
          290: 'GrayResponseUnit',
          291: 'GrayResponseCurve',
          292: 'T4Options',
          293: 'T6Options',
          296: 'ResolutionUnit',
          297: 'PageNumber',
          300: 'ColorResponseUnit',
          301: 'TransferFunction',
          305: 'Software',
          306: 'ModifyDate',
          315: 'Artist',
          316: 'HostComputer',
          317: 'Predictor',
          318: 'WhitePoint',
          319: 'PrimaryChromaticities',
          320: 'ColorMap',
          321: 'HalftoneHints',
          322: 'TileWidth',
          323: 'TileLength',
          324: 'TileOffsets',
          325: 'TileByteCounts',
          326: 'BadFaxLines',
          327: 'CleanFaxData',
          328: 'ConsecutiveBadFaxLines',
          330: 'SubIFD',
          332: 'InkSet',
          333: 'InkNames',
          334: 'NumberofInks',
          336: 'DotRange',
          337: 'TargetPrinter',
          338: 'ExtraSamples',
          339: 'SampleFormat',
          340: 'SMinSampleValue',
          341: 'SMaxSampleValue',
          342: 'TransferRange',
          343: 'ClipPath',
          344: 'XClipPathUnits',
          345: 'YClipPathUnits',
          346: 'Indexed',
          347: 'JPEGTables',
          351: 'OPIProxy',
          400: 'GlobalParametersIFD',
          401: 'ProfileType',
          402: 'FaxProfile',
          403: 'CodingMethods',
          404: 'VersionYear',
          405: 'ModeNumber',
          433: 'Decode',
          434: 'DefaultImageColor',
          435: 'T82Options',
          437: 'JPEGTables',
          512: 'JPEGProc',
          513: 'ThumbnailOffset',
          514: 'ThumbnailLength',
          515: 'JPEGRestartInterval',
          517: 'JPEGLosslessPredictors',
          518: 'JPEGPointTransforms',
          519: 'JPEGQTables',
          520: 'JPEGDCTables',
          521: 'JPEGACTables',
          529: 'YCbCrCoefficients',
          530: 'YCbCrSubSampling',
          531: 'YCbCrPositioning',
          532: 'ReferenceBlackWhite',
          559: 'StripRowCounts',
          700: 'ApplicationNotes',
          999: 'USPTOMiscellaneous',
          4096: 'RelatedImageFileFormat',
          4097: 'RelatedImageWidth',
          4098: 'RelatedImageHeight',
          18246: 'Rating',
          18247: 'XP_DIP_XML',
          18248: 'StitchInfo',
          18249: 'RatingPercent',
          32781: 'ImageID',
          32931: 'WangTag1',
          32932: 'WangAnnotation',
          32933: 'WangTag3',
          32934: 'WangTag4',
          32995: 'Matteing',
          32996: 'DataType',
          32997: 'ImageDepth',
          32998: 'TileDepth',
          33405: 'Model2',
          33421: 'CFARepeatPatternDim',
          33422: 'CFAPattern2',
          33423: 'BatteryLevel',
          33424: 'KodakIFD',
          33432: 'Copyright',
          33434: 'ExposureTime',
          33437: 'FNumber',
          33445: 'MDFileTag',
          33446: 'MDScalePixel',
          33447: 'MDColorTable',
          33448: 'MDLabName',
          33449: 'MDSampleInfo',
          33450: 'MDPrepDate',
          33451: 'MDPrepTime',
          33452: 'MDFileUnits',
          33550: 'PixelScale',
          33589: 'AdventScale',
          33590: 'AdventRevision',
          33628: 'UIC1Tag',
          33629: 'UIC2Tag',
          33630: 'UIC3Tag',
          33631: 'UIC4Tag',
          33723: 'IPTC-NAA',
          33918: 'IntergraphPacketData',
          33919: 'IntergraphFlagRegisters',
          33920: 'IntergraphMatrix',
          33921: 'INGRReserved',
          33922: 'ModelTiePoint',
          34016: 'Site',
          34017: 'ColorSequence',
          34018: 'IT8Header',
          34019: 'RasterPadding',
          34020: 'BitsPerRunLength',
          34021: 'BitsPerExtendedRunLength',
          34022: 'ColorTable',
          34023: 'ImageColorIndicator',
          34024: 'BackgroundColorIndicator',
          34025: 'ImageColorValue',
          34026: 'BackgroundColorValue',
          34027: 'PixelIntensityRange',
          34028: 'TransparencyIndicator',
          34029: 'ColorCharacterization',
          34030: 'HCUsage',
          34031: 'TrapIndicator',
          34032: 'CMYKEquivalent',
          34118: 'SEMInfo',
          34152: 'AFCP_IPTC',
          34232: 'PixelMagicJBIGOptions',
          34264: 'ModelTransform',
          34306: 'WB_GRGBLevels',
          34310: 'LeafData',
          34377: 'PhotoshopSettings',
          34665: 'ExifOffset',
          34675: 'ICC_Profile',
          34687: 'TIFF_FXExtensions',
          34688: 'MultiProfiles',
          34689: 'SharedData',
          34690: 'T88Options',
          34732: 'ImageLayer',
          34735: 'GeoTiffDirectory',
          34736: 'GeoTiffDoubleParams',
          34737: 'GeoTiffAsciiParams',
          34850: 'ExposureProgram',
          34852: 'SpectralSensitivity',
          34853: 'GPSInfo',
          34855: 'ISO',
          34856: 'Opto-ElectricConvFactor',
          34857: 'Interlace',
          34858: 'TimeZoneOffset',
          34859: 'SelfTimerMode',
          34864: 'SensitivityType',
          34865: 'StandardOutputSensitivity',
          34866: 'RecommendedExposureIndex',
          34867: 'ISOSpeed',
          34868: 'ISOSpeedLatitudeyyy',
          34869: 'ISOSpeedLatitudezzz',
          34908: 'FaxRecvParams',
          34909: 'FaxSubAddress',
          34910: 'FaxRecvTime',
          34954: 'LeafSubIFD',
          36864: 'ExifVersion',
          36867: 'DateTimeOriginal',
          36868: 'CreateDate',
          37121: 'ComponentsConfiguration',
          37122: 'CompressedBitsPerPixel',
          37377: 'ShutterSpeedValue',
          37378: 'ApertureValue',
          37379: 'BrightnessValue',
          37380: 'ExposureCompensation',
          37381: 'MaxApertureValue',
          37382: 'SubjectDistance',
          37383: 'MeteringMode',
          37384: 'LightSource',
          37385: 'Flash',
          37386: 'FocalLength',
          37387: 'FlashEnergy',
          37388: 'SpatialFrequencyResponse',
          37389: 'Noise',
          37390: 'FocalPlaneXResolution',
          37391: 'FocalPlaneYResolution',
          37392: 'FocalPlaneResolutionUnit',
          37393: 'ImageNumber',
          37394: 'SecurityClassification',
          37395: 'ImageHistory',
          37396: 'SubjectArea',
          37397: 'ExposureIndex',
          37398: 'TIFF-EPStandardID',
          37399: 'SensingMethod',
          37434: 'CIP3DataFile',
          37435: 'CIP3Sheet',
          37436: 'CIP3Side',
          37439: 'StoNits',
          37500: 'MakerNote',
          37510: 'UserComment',
          37520: 'SubSecTime',
          37521: 'SubSecTimeOriginal',
          37522: 'SubSecTimeDigitized',
          37679: 'MSDocumentText',
          37680: 'MSPropertySetStorage',
          37681: 'MSDocumentTextPosition',
          37724: 'ImageSourceData',
          40091: 'XPTitle',
          40092: 'XPComment',
          40093: 'XPAuthor',
          40094: 'XPKeywords',
          40095: 'XPSubject',
          40960: 'FlashpixVersion',
          40961: 'ColorSpace',
          40962: 'ExifImageWidth',
          40963: 'ExifImageHeight',
          40964: 'RelatedSoundFile',
          40965: 'InteropOffset',
          41483: 'FlashEnergy',
          41484: 'SpatialFrequencyResponse',
          41485: 'Noise',
          41486: 'FocalPlaneXResolution',
          41487: 'FocalPlaneYResolution',
          41488: 'FocalPlaneResolutionUnit',
          41489: 'ImageNumber',
          41490: 'SecurityClassification',
          41491: 'ImageHistory',
          41492: 'SubjectLocation',
          41493: 'ExposureIndex',
          41494: 'TIFF-EPStandardID',
          41495: 'SensingMethod',
          41728: 'FileSource',
          41729: 'SceneType',
          41730: 'CFAPattern',
          41985: 'CustomRendered',
          41986: 'ExposureMode',
          41987: 'WhiteBalance',
          41988: 'DigitalZoomRatio',
          41989: 'FocalLengthIn35mmFormat',
          41990: 'SceneCaptureType',
          41991: 'GainControl',
          41992: 'Contrast',
          41993: 'Saturation',
          41994: 'Sharpness',
          41995: 'DeviceSettingDescription',
          41996: 'SubjectDistanceRange',
          42016: 'ImageUniqueID',
          42032: 'OwnerName',
          42033: 'SerialNumber',
          42034: 'LensInfo',
          42035: 'LensMake',
          42036: 'LensModel',
          42037: 'LensSerialNumber',
          42112: 'GDALMetadata',
          42113: 'GDALNoData',
          42240: 'Gamma',
          44992: 'ExpandSoftware',
          44993: 'ExpandLens',
          44994: 'ExpandFilm',
          44995: 'ExpandFilterLens',
          44996: 'ExpandScanner',
          44997: 'ExpandFlashLamp',
          48129: 'PixelFormat',
          48130: 'Transformation',
          48131: 'Uncompressed',
          48132: 'ImageType',
          48256: 'ImageWidth',
          48257: 'ImageHeight',
          48258: 'WidthResolution',
          48259: 'HeightResolution',
          48320: 'ImageOffset',
          48321: 'ImageByteCount',
          48322: 'AlphaOffset',
          48323: 'AlphaByteCount',
          48324: 'ImageDataDiscard',
          48325: 'AlphaDataDiscard',
          50215: 'OceScanjobDesc',
          50216: 'OceApplicationSelector',
          50217: 'OceIDNumber',
          50218: 'OceImageLogic',
          50255: 'Annotations',
          50341: 'PrintIM',
          50560: 'USPTOOriginalContentType',
          50706: 'DNGVersion',
          50707: 'DNGBackwardVersion',
          50708: 'UniqueCameraModel',
          50709: 'LocalizedCameraModel',
          50710: 'CFAPlaneColor',
          50711: 'CFALayout',
          50712: 'LinearizationTable',
          50713: 'BlackLevelRepeatDim',
          50714: 'BlackLevel',
          50715: 'BlackLevelDeltaH',
          50716: 'BlackLevelDeltaV',
          50717: 'WhiteLevel',
          50718: 'DefaultScale',
          50719: 'DefaultCropOrigin',
          50720: 'DefaultCropSize',
          50721: 'ColorMatrix1',
          50722: 'ColorMatrix2',
          50723: 'CameraCalibration1',
          50724: 'CameraCalibration2',
          50725: 'ReductionMatrix1',
          50726: 'ReductionMatrix2',
          50727: 'AnalogBalance',
          50728: 'AsShotNeutral',
          50729: 'AsShotWhiteXY',
          50730: 'BaselineExposure',
          50731: 'BaselineNoise',
          50732: 'BaselineSharpness',
          50733: 'BayerGreenSplit',
          50734: 'LinearResponseLimit',
          50735: 'CameraSerialNumber',
          50736: 'DNGLensInfo',
          50737: 'ChromaBlurRadius',
          50738: 'AntiAliasStrength',
          50739: 'ShadowScale',
          50740: 'DNGPrivateData',
          50741: 'MakerNoteSafety',
          50752: 'RawImageSegmentation',
          50778: 'CalibrationIlluminant1',
          50779: 'CalibrationIlluminant2',
          50780: 'BestQualityScale',
          50781: 'RawDataUniqueID',
          50784: 'AliasLayerMetadata',
          50827: 'OriginalRawFileName',
          50828: 'OriginalRawFileData',
          50829: 'ActiveArea',
          50830: 'MaskedAreas',
          50831: 'AsShotICCProfile',
          50832: 'AsShotPreProfileMatrix',
          50833: 'CurrentICCProfile',
          50834: 'CurrentPreProfileMatrix',
          50879: 'ColorimetricReference',
          50898: 'PanasonicTitle',
          50899: 'PanasonicTitle2',
          50931: 'CameraCalibrationSig',
          50932: 'ProfileCalibrationSig',
          50933: 'ProfileIFD',
          50934: 'AsShotProfileName',
          50935: 'NoiseReductionApplied',
          50936: 'ProfileName',
          50937: 'ProfileHueSatMapDims',
          50938: 'ProfileHueSatMapData1',
          50939: 'ProfileHueSatMapData2',
          50940: 'ProfileToneCurve',
          50941: 'ProfileEmbedPolicy',
          50942: 'ProfileCopyright',
          50964: 'ForwardMatrix1',
          50965: 'ForwardMatrix2',
          50966: 'PreviewApplicationName',
          50967: 'PreviewApplicationVersion',
          50968: 'PreviewSettingsName',
          50969: 'PreviewSettingsDigest',
          50970: 'PreviewColorSpace',
          50971: 'PreviewDateTime',
          50972: 'RawImageDigest',
          50973: 'OriginalRawFileDigest',
          50974: 'SubTileBlockSize',
          50975: 'RowInterleaveFactor',
          50981: 'ProfileLookTableDims',
          50982: 'ProfileLookTableData',
          51008: 'OpcodeList1',
          51009: 'OpcodeList2',
          51022: 'OpcodeList3',
          51041: 'NoiseProfile',
          51043: 'TimeCodes',
          51044: 'FrameRate',
          51058: 'TStop',
          51081: 'ReelName',
          51089: 'OriginalDefaultFinalSize',
          51090: 'OriginalBestQualitySize',
          51091: 'OriginalDefaultCropSize',
          51105: 'CameraLabel',
          51107: 'ProfileHueSatMapEncoding',
          51108: 'ProfileLookTableEncoding',
          51109: 'BaselineExposureOffset',
          51110: 'DefaultBlackRender',
          51111: 'NewRawImageDigest',
          51112: 'RawToPreviewGain',
          51125: 'DefaultUserCrop',
          59932: 'Padding',
          59933: 'OffsetSchema',
          65e3: 'OwnerName',
          65001: 'SerialNumber',
          65002: 'Lens',
          65024: 'KDC_IFD',
          65100: 'RawFile',
          65101: 'Converter',
          65102: 'WhiteBalance',
          65105: 'Exposure',
          65106: 'Shadows',
          65107: 'Brightness',
          65108: 'Contrast',
          65109: 'Saturation',
          65110: 'Sharpness',
          65111: 'Smoothness',
          65112: 'MoireFilter',
        },
        gps: {
          0: 'GPSVersionID',
          1: 'GPSLatitudeRef',
          2: 'GPSLatitude',
          3: 'GPSLongitudeRef',
          4: 'GPSLongitude',
          5: 'GPSAltitudeRef',
          6: 'GPSAltitude',
          7: 'GPSTimeStamp',
          8: 'GPSSatellites',
          9: 'GPSStatus',
          10: 'GPSMeasureMode',
          11: 'GPSDOP',
          12: 'GPSSpeedRef',
          13: 'GPSSpeed',
          14: 'GPSTrackRef',
          15: 'GPSTrack',
          16: 'GPSImgDirectionRef',
          17: 'GPSImgDirection',
          18: 'GPSMapDatum',
          19: 'GPSDestLatitudeRef',
          20: 'GPSDestLatitude',
          21: 'GPSDestLongitudeRef',
          22: 'GPSDestLongitude',
          23: 'GPSDestBearingRef',
          24: 'GPSDestBearing',
          25: 'GPSDestDistanceRef',
          26: 'GPSDestDistance',
          27: 'GPSProcessingMethod',
          28: 'GPSAreaInformation',
          29: 'GPSDateStamp',
          30: 'GPSDifferential',
          31: 'GPSHPositioningError',
        },
      })),
    exifTags
  )
}
var jpeg = jpeg$1,
  exif = exif$2,
  simplify = simplify$1
function ExifResult(o, a, s, $, j, _e, et) {
  ;(this.startMarker = o),
    (this.tags = a),
    (this.imageSize = s),
    (this.thumbnailOffset = $),
    (this.thumbnailLength = j),
    (this.thumbnailType = _e),
    (this.app1Offset = et)
}
ExifResult.prototype = {
  hasThumbnail: function(o) {
    return !this.thumbnailOffset || !this.thumbnailLength
      ? !1
      : typeof o != 'string'
      ? !0
      : o.toLowerCase().trim() === 'image/jpeg'
      ? this.thumbnailType === 6
      : o.toLowerCase().trim() === 'image/tiff'
      ? this.thumbnailType === 1
      : !1
  },
  getThumbnailOffset: function() {
    return this.app1Offset + 6 + this.thumbnailOffset
  },
  getThumbnailLength: function() {
    return this.thumbnailLength
  },
  getThumbnailBuffer: function() {
    return this._getThumbnailStream().nextBuffer(this.thumbnailLength)
  },
  _getThumbnailStream: function() {
    return this.startMarker.openWithOffset(this.getThumbnailOffset())
  },
  getImageSize: function() {
    return this.imageSize
  },
  getThumbnailSize: function() {
    var o = this._getThumbnailStream(),
      a
    return (
      jpeg.parseSections(o, function(s, $) {
        jpeg.getSectionName(s).name === 'SOF' &&
          (a = jpeg.getSizeFromSOFSection($))
      }),
      a
    )
  },
}
function Parser$7(o) {
  ;(this.stream = o),
    (this.flags = {
      readBinaryTags: !1,
      resolveTagNames: !0,
      simplifyValues: !0,
      imageSize: !0,
      hidePointers: !0,
      returnTags: !0,
    })
}
Parser$7.prototype = {
  enableBinaryFields: function(o) {
    return (this.flags.readBinaryTags = !!o), this
  },
  enablePointers: function(o) {
    return (this.flags.hidePointers = !o), this
  },
  enableTagNames: function(o) {
    return (this.flags.resolveTagNames = !!o), this
  },
  enableImageSize: function(o) {
    return (this.flags.imageSize = !!o), this
  },
  enableReturnTags: function(o) {
    return (this.flags.returnTags = !!o), this
  },
  enableSimpleValues: function(o) {
    return (this.flags.simplifyValues = !!o), this
  },
  parse: function() {
    var o = this.stream.mark(),
      a = o.openWithOffset(0),
      s = this.flags,
      $,
      j,
      _e,
      et,
      tt,
      rt,
      nt,
      it,
      ot
    return (
      s.resolveTagNames && (nt = requireExifTags()),
      s.resolveTagNames
        ? (($ = {}),
          (it = function(at) {
            return $[at.name]
          }),
          (ot = function(at, st) {
            $[at.name] = st
          }))
        : (($ = []),
          (it = function(at) {
            var st
            for (st = 0; st < $.length; ++st)
              if ($[st].type === at.type && $[st].section === at.section)
                return $.value
          }),
          (ot = function(at, st) {
            var ut
            for (ut = 0; ut < $.length; ++ut)
              if ($[ut].type === at.type && $[ut].section === at.section) {
                $.value = st
                return
              }
          })),
      jpeg.parseSections(a, function(at, st) {
        var ut,
          ct = st.offsetFrom(o)
        at === 225
          ? ((ut = exif.parseTags(st, function(dt, ft, mt, vt) {
              if (!(!s.readBinaryTags && vt === 7)) {
                if (ft === 513) {
                  if (((_e = mt[0]), s.hidePointers)) return
                } else if (ft === 514) {
                  if (((et = mt[0]), s.hidePointers)) return
                } else if (ft === 259 && ((tt = mt[0]), s.hidePointers)) return
                if (s.returnTags)
                  if (
                    (s.simplifyValues && (mt = simplify.simplifyValue(mt, vt)),
                    s.resolveTagNames)
                  ) {
                    var yt = dt === exif.GPSIFD ? nt.gps : nt.exif,
                      pt = yt[ft]
                    pt || (pt = nt.exif[ft]),
                      $.hasOwnProperty(pt) || ($[pt] = mt)
                  } else $.push({ section: dt, type: ft, value: mt })
              }
            })),
            ut && (rt = ct))
          : s.imageSize &&
            jpeg.getSectionName(at).name === 'SOF' &&
            (j = jpeg.getSizeFromSOFSection(st))
      }),
      s.simplifyValues &&
        (simplify.castDegreeValues(it, ot), simplify.castDateValues(it, ot)),
      new ExifResult(o, $, j, _e, et, tt, rt)
    )
  },
}
var parser$2 = Parser$7,
  domBufferstream,
  hasRequiredDomBufferstream
function requireDomBufferstream() {
  if (hasRequiredDomBufferstream) return domBufferstream
  hasRequiredDomBufferstream = 1
  function o(a, s, $, j, _e, et) {
    ;(this.global = _e),
      (s = s || 0),
      ($ = $ || a.byteLength - s),
      (this.arrayBuffer = a.slice(s, s + $)),
      (this.view = new _e.DataView(
        this.arrayBuffer,
        0,
        this.arrayBuffer.byteLength
      )),
      this.setBigEndian(j),
      (this.offset = 0),
      (this.parentOffset = (et || 0) + s)
  }
  return (
    (o.prototype = {
      setBigEndian: function(a) {
        this.littleEndian = !a
      },
      nextUInt8: function() {
        var a = this.view.getUint8(this.offset)
        return (this.offset += 1), a
      },
      nextInt8: function() {
        var a = this.view.getInt8(this.offset)
        return (this.offset += 1), a
      },
      nextUInt16: function() {
        var a = this.view.getUint16(this.offset, this.littleEndian)
        return (this.offset += 2), a
      },
      nextUInt32: function() {
        var a = this.view.getUint32(this.offset, this.littleEndian)
        return (this.offset += 4), a
      },
      nextInt16: function() {
        var a = this.view.getInt16(this.offset, this.littleEndian)
        return (this.offset += 2), a
      },
      nextInt32: function() {
        var a = this.view.getInt32(this.offset, this.littleEndian)
        return (this.offset += 4), a
      },
      nextFloat: function() {
        var a = this.view.getFloat32(this.offset, this.littleEndian)
        return (this.offset += 4), a
      },
      nextDouble: function() {
        var a = this.view.getFloat64(this.offset, this.littleEndian)
        return (this.offset += 8), a
      },
      nextBuffer: function(a) {
        var s = this.arrayBuffer.slice(this.offset, this.offset + a)
        return (this.offset += a), s
      },
      remainingLength: function() {
        return this.arrayBuffer.byteLength - this.offset
      },
      nextString: function(a) {
        var s = this.arrayBuffer.slice(this.offset, this.offset + a)
        return (
          (s = String.fromCharCode.apply(null, new this.global.Uint8Array(s))),
          (this.offset += a),
          s
        )
      },
      mark: function() {
        var a = this
        return {
          openWithOffset: function(s) {
            return (
              (s = (s || 0) + this.offset),
              new o(
                a.arrayBuffer,
                s,
                a.arrayBuffer.byteLength - s,
                !a.littleEndian,
                a.global,
                a.parentOffset
              )
            )
          },
          offset: this.offset,
          getParentOffset: function() {
            return a.parentOffset
          },
        }
      },
      offsetFrom: function(a) {
        return (
          this.parentOffset + this.offset - (a.offset + a.getParentOffset())
        )
      },
      skip: function(a) {
        this.offset += a
      },
      branch: function(a, s) {
        return (
          (s =
            typeof s == 'number'
              ? s
              : this.arrayBuffer.byteLength - (this.offset + a)),
          new o(
            this.arrayBuffer,
            this.offset + a,
            s,
            !this.littleEndian,
            this.global,
            this.parentOffset
          )
        )
      },
    }),
    (domBufferstream = o),
    domBufferstream
  )
}
var bufferstream, hasRequiredBufferstream
function requireBufferstream() {
  if (hasRequiredBufferstream) return bufferstream
  hasRequiredBufferstream = 1
  function o(a, s, $, j) {
    ;(this.buffer = a),
      (this.offset = s || 0),
      ($ = typeof $ == 'number' ? $ : a.length),
      (this.endPosition = this.offset + $),
      this.setBigEndian(j)
  }
  return (
    (o.prototype = {
      setBigEndian: function(a) {
        this.bigEndian = !!a
      },
      nextUInt8: function() {
        var a = this.buffer.readUInt8(this.offset)
        return (this.offset += 1), a
      },
      nextInt8: function() {
        var a = this.buffer.readInt8(this.offset)
        return (this.offset += 1), a
      },
      nextUInt16: function() {
        var a = this.bigEndian
          ? this.buffer.readUInt16BE(this.offset)
          : this.buffer.readUInt16LE(this.offset)
        return (this.offset += 2), a
      },
      nextUInt32: function() {
        var a = this.bigEndian
          ? this.buffer.readUInt32BE(this.offset)
          : this.buffer.readUInt32LE(this.offset)
        return (this.offset += 4), a
      },
      nextInt16: function() {
        var a = this.bigEndian
          ? this.buffer.readInt16BE(this.offset)
          : this.buffer.readInt16LE(this.offset)
        return (this.offset += 2), a
      },
      nextInt32: function() {
        var a = this.bigEndian
          ? this.buffer.readInt32BE(this.offset)
          : this.buffer.readInt32LE(this.offset)
        return (this.offset += 4), a
      },
      nextFloat: function() {
        var a = this.bigEndian
          ? this.buffer.readFloatBE(this.offset)
          : this.buffer.readFloatLE(this.offset)
        return (this.offset += 4), a
      },
      nextDouble: function() {
        var a = this.bigEndian
          ? this.buffer.readDoubleBE(this.offset)
          : this.buffer.readDoubleLE(this.offset)
        return (this.offset += 8), a
      },
      nextBuffer: function(a) {
        var s = this.buffer.slice(this.offset, this.offset + a)
        return (this.offset += a), s
      },
      remainingLength: function() {
        return this.endPosition - this.offset
      },
      nextString: function(a) {
        var s = this.buffer.toString('utf8', this.offset, this.offset + a)
        return (this.offset += a), s
      },
      mark: function() {
        var a = this
        return {
          openWithOffset: function(s) {
            return (
              (s = (s || 0) + this.offset),
              new o(a.buffer, s, a.endPosition - s, a.bigEndian)
            )
          },
          offset: this.offset,
        }
      },
      offsetFrom: function(a) {
        return this.offset - a.offset
      },
      skip: function(a) {
        this.offset += a
      },
      branch: function(a, s) {
        return (
          (s = typeof s == 'number' ? s : this.endPosition - (this.offset + a)),
          new o(this.buffer, this.offset + a, s, this.bigEndian)
        )
      },
    }),
    (bufferstream = o),
    bufferstream
  )
}
var Parser$6 = parser$2
function getGlobal() {
  return (0, eval)('this')
}
var exifParser = {
  create: function(o, a) {
    if (((a = a || getGlobal()), o instanceof a.ArrayBuffer)) {
      var s = requireDomBufferstream()
      return new Parser$6(new s(o, 0, o.byteLength, !0, a))
    } else {
      var $ = requireBufferstream()
      return new Parser$6(new $(o, 0, o.length, !0))
    }
  },
}
const EXIFParser = getDefaultExportFromCjs(exifParser)
async function getMIMEFromBuffer(o, a) {
  const s = await FileType.fromBuffer(o)
  return s ? s.mime : a ? getType(a) : null
}
function getExifOrientation(o) {
  return (o._exif && o._exif.tags && o._exif.tags.Orientation) || 1
}
function getExifOrientationTransformation(o) {
  const a = o.getWidth(),
    s = o.getHeight()
  switch (getExifOrientation(o)) {
    case 1:
      return null
    case 2:
      return function($, j) {
        return [a - $ - 1, j]
      }
    case 3:
      return function($, j) {
        return [a - $ - 1, s - j - 1]
      }
    case 4:
      return function($, j) {
        return [$, s - j - 1]
      }
    case 5:
      return function($, j) {
        return [j, $]
      }
    case 6:
      return function($, j) {
        return [j, s - $ - 1]
      }
    case 7:
      return function($, j) {
        return [a - j - 1, s - $ - 1]
      }
    case 8:
      return function($, j) {
        return [a - j - 1, $]
      }
    default:
      return null
  }
}
function transformBitmap(o, a, s, $) {
  const j = o.bitmap.data,
    _e = o.bitmap.width,
    et = Buffer.alloc(j.length)
  for (let tt = 0; tt < a; tt++)
    for (let rt = 0; rt < s; rt++) {
      const [nt, it] = $(tt, rt),
        ot = (a * rt + tt) << 2,
        at = (_e * it + nt) << 2,
        st = j.readUInt32BE(at)
      et.writeUInt32BE(st, ot)
    }
  ;(o.bitmap.data = et), (o.bitmap.width = a), (o.bitmap.height = s)
}
function exifRotate(o) {
  if (getExifOrientation(o) < 2) return
  const a = getExifOrientationTransformation(o),
    s = getExifOrientation(o) > 4,
    $ = s ? o.bitmap.height : o.bitmap.width,
    j = s ? o.bitmap.width : o.bitmap.height
  transformBitmap(o, $, j, a)
}
async function parseBitmap(o, a, s) {
  const $ = await getMIMEFromBuffer(o, a)
  if (typeof $ != 'string')
    return s(new Error('Could not find MIME for Buffer <' + a + '>'))
  this._originalMime = $.toLowerCase()
  try {
    const j = this.getMIME()
    if (this.constructor.decoders[j])
      this.bitmap = this.constructor.decoders[j](o)
    else return throwError.call(this, 'Unsupported MIME type: ' + j, s)
  } catch (j) {
    return s.call(this, j, this)
  }
  try {
    ;(this._exif = EXIFParser.create(o).parse()), exifRotate(this)
  } catch {}
  return s.call(this, null, this), this
}
function compositeBitmapOverBackground(o, a) {
  return new o(a.bitmap.width, a.bitmap.height, a._background).composite(
    a,
    0,
    0
  ).bitmap
}
function getBuffer(o, a) {
  if ((o === AUTO && (o = this.getMIME()), typeof o != 'string'))
    return throwError.call(this, 'mime must be a string', a)
  if (typeof a != 'function')
    return throwError.call(this, 'cb must be a function', a)
  if (
    ((o = o.toLowerCase()),
    this._rgba && this.constructor.hasAlpha[o]
      ? (this.bitmap.data = Buffer.from(this.bitmap.data))
      : (this.bitmap.data = compositeBitmapOverBackground(
          this.constructor,
          this
        ).data),
    this.constructor.encoders[o])
  ) {
    const s = this.constructor.encoders[o](this)
    s instanceof Promise
      ? s.then($ => {
          a.call(this, null, $)
        })
      : a.call(this, null, s)
  } else return throwError.call(this, 'Unsupported MIME type: ' + o, a)
  return this
}
function getBufferAsync(o) {
  return promisify(getBuffer, this, o)
}
var define_process_env_default = {}
function _defineProperty$3(o, a, s) {
  return (
    (a = _toPropertyKey(a)),
    a in o
      ? Object.defineProperty(o, a, {
          value: s,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (o[a] = s),
    o
  )
}
function _toPropertyKey(o) {
  var a = _toPrimitive(o, 'string')
  return typeof a == 'symbol' ? a : String(a)
}
function _toPrimitive(o, a) {
  if (typeof o != 'object' || o === null) return o
  var s = o[Symbol.toPrimitive]
  if (s !== void 0) {
    var $ = s.call(o, a || 'default')
    if (typeof $ != 'object') return $
    throw new TypeError('@@toPrimitive must return a primitive value.')
  }
  return (a === 'string' ? String : Number)(o)
}
const alphabet =
    '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
  maxHashLength = [NaN, NaN]
for (let o = 2; o < 65; o++) {
  const a = anyBase$1(
    anyBase$1.BIN,
    alphabet.slice(0, o)
  )(new Array(65).join('1'))
  maxHashLength.push(a.length)
}
function noop$5() {}
function isArrayBuffer(o) {
  return (
    Object.prototype.toString
      .call(o)
      .toLowerCase()
      .indexOf('arraybuffer') > -1
  )
}
function bufferFromArrayBuffer(o) {
  const a = Buffer.alloc(o.byteLength),
    s = new Uint8Array(o)
  for (let $ = 0; $ < a.length; ++$) a[$] = s[$]
  return a
}
function loadFromURL(o, a) {
  request(o, (s, $) =>
    s
      ? a(s)
      : typeof $ == 'object' && Buffer.isBuffer($)
      ? a(null, $)
      : typeof $ == 'object' && isArrayBuffer($)
      ? a(null, bufferFromArrayBuffer($))
      : new Error(`Could not load Buffer from <${o.url}>`)
  )
}
function loadBufferFromPath(o, a) {
  fs$3 && typeof fs$3.readFile == 'function' && !o.match(/^(http|ftp)s?:\/\/./)
    ? fs$3.readFile(o, a)
    : loadFromURL({ url: o }, a)
}
function isRawRGBAData(o) {
  return (
    o &&
    typeof o == 'object' &&
    typeof o.width == 'number' &&
    typeof o.height == 'number' &&
    (Buffer.isBuffer(o.data) ||
      o.data instanceof Uint8Array ||
      (typeof Uint8ClampedArray == 'function' &&
        o.data instanceof Uint8ClampedArray)) &&
    (o.data.length === o.width * o.height * 4 ||
      o.data.length === o.width * o.height * 3)
  )
}
function makeRGBABufferFromRGB(o) {
  if (o.length % 3 !== 0) throw new Error('Buffer length is incorrect')
  const a = Buffer.allocUnsafe((o.length / 3) * 4)
  let s = 0
  for (let $ = 0; $ < o.length; $++)
    (a[s] = o[$]), ($ + 1) % 3 === 0 && (a[++s] = 255), s++
  return a
}
const emptyBitmap = { data: null, width: null, height: null }
let Jimp$1 = class Rn extends EventEmitter$4 {
  constructor() {
    for (var a = arguments.length, s = new Array(a), $ = 0; $ < a; $++)
      s[$] = arguments[$]
    super(),
      _defineProperty$3(this, 'bitmap', emptyBitmap),
      _defineProperty$3(this, '_background', 0),
      _defineProperty$3(this, '_originalMime', Rn.MIME_PNG),
      _defineProperty$3(this, '_exif', null),
      _defineProperty$3(this, '_rgba', !0),
      _defineProperty$3(this, 'writeAsync', tt =>
        promisify(this.write, this, tt)
      ),
      _defineProperty$3(this, 'getBase64Async', tt =>
        promisify(this.getBase64, this, tt)
      ),
      _defineProperty$3(this, 'getBuffer', getBuffer),
      _defineProperty$3(this, 'getBufferAsync', getBufferAsync),
      _defineProperty$3(this, 'getPixelColour', this.getPixelColor),
      _defineProperty$3(this, 'setPixelColour', this.setPixelColor)
    const j = this
    let _e = noop$5
    isArrayBuffer(s[0]) && (s[0] = bufferFromArrayBuffer(s[0]))
    function et() {
      for (var tt = arguments.length, rt = new Array(tt), nt = 0; nt < tt; nt++)
        rt[nt] = arguments[nt]
      const [it] = rt,
        ot = it || {}
      ;(ot.methodName = 'constructor'),
        setTimeout(() => {
          it && _e === noop$5
            ? j.emitError('constructor', it)
            : it || j.emitMulti('constructor', 'initialized'),
            _e.call(j, ...rt)
        }, 1)
    }
    if (
      (typeof s[0] == 'number' && typeof s[1] == 'number') ||
      (parseInt(s[0], 10) && parseInt(s[1], 10))
    ) {
      const tt = parseInt(s[0], 10),
        rt = parseInt(s[1], 10)
      if (
        ((_e = s[2]),
        typeof s[2] == 'number' && ((this._background = s[2]), (_e = s[3])),
        typeof s[2] == 'string' &&
          ((this._background = Rn.cssColorToHex(s[2])), (_e = s[3])),
        typeof _e > 'u' && (_e = noop$5),
        typeof _e != 'function')
      )
        return throwError.call(this, 'cb must be a function', et)
      this.bitmap = { data: Buffer.alloc(tt * rt * 4), width: tt, height: rt }
      for (let nt = 0; nt < this.bitmap.data.length; nt += 4)
        this.bitmap.data.writeUInt32BE(this._background, nt)
      et(null, this)
    } else if (typeof s[0] == 'object' && s[0].url) {
      if (((_e = s[1] || noop$5), typeof _e != 'function'))
        return throwError.call(this, 'cb must be a function', et)
      loadFromURL(s[0], (tt, rt) => {
        if (tt) return throwError.call(this, tt, et)
        this.parseBitmap(rt, s[0].url, et)
      })
    } else if (s[0] instanceof Rn) {
      const [tt] = s
      if (
        ((_e = s[1]), typeof _e > 'u' && (_e = noop$5), typeof _e != 'function')
      )
        return throwError.call(this, 'cb must be a function', et)
      ;(this.bitmap = {
        data: Buffer.from(tt.bitmap.data),
        width: tt.bitmap.width,
        height: tt.bitmap.height,
      }),
        (this._quality = tt._quality),
        (this._deflateLevel = tt._deflateLevel),
        (this._deflateStrategy = tt._deflateStrategy),
        (this._filterType = tt._filterType),
        (this._rgba = tt._rgba),
        (this._background = tt._background),
        (this._originalMime = tt._originalMime),
        et(null, this)
    } else if (isRawRGBAData(s[0])) {
      const [tt] = s
      _e = s[1] || noop$5
      const nt =
        tt.width * tt.height * 4 === tt.data.length
          ? Buffer.from(tt.data)
          : makeRGBABufferFromRGB(tt.data)
      ;(this.bitmap = { data: nt, width: tt.width, height: tt.height }),
        et(null, this)
    } else if (typeof s[0] == 'string') {
      const tt = s[0]
      if (
        ((_e = s[1]), typeof _e > 'u' && (_e = noop$5), typeof _e != 'function')
      )
        return throwError.call(this, 'cb must be a function', et)
      loadBufferFromPath(tt, (rt, nt) => {
        if (rt) return throwError.call(this, rt, et)
        this.parseBitmap(nt, tt, et)
      })
    } else if (typeof s[0] == 'object' && Buffer.isBuffer(s[0])) {
      const tt = s[0]
      if (((_e = s[1]), typeof _e != 'function'))
        return throwError.call(this, 'cb must be a function', et)
      this.parseBitmap(tt, null, et)
    } else {
      ;(_e = s[s.length - 1]),
        typeof _e != 'function' &&
          ((_e = s[s.length - 2]), typeof _e != 'function' && (_e = noop$5))
      const tt = Rn.__extraConstructors.find(rt => rt.test(...s))
      if (tt)
        new Promise((rt, nt) => {
          tt.run.call(this, rt, nt, ...s)
        })
          .then(() => et(null, this))
          .catch(et)
      else
        return throwError.call(
          this,
          'No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.',
          et
        )
    }
  }
  parseBitmap(a, s, $) {
    parseBitmap.call(this, a, null, $)
  }
  rgba(a, s) {
    return typeof a != 'boolean'
      ? throwError.call(
          this,
          'bool must be a boolean, true for RGBA or false for RGB',
          s
        )
      : ((this._rgba = a), isNodePattern(s) && s.call(this, null, this), this)
  }
  emitMulti(a, s) {
    let $ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
    ;($ = Object.assign($, { methodName: a, eventName: s })),
      this.emit('any', $),
      a && this.emit(a, $),
      this.emit(s, $)
  }
  emitError(a, s) {
    this.emitMulti(a, 'error', s)
  }
  getHeight() {
    return this.bitmap.height
  }
  getWidth() {
    return this.bitmap.width
  }
  inspect() {
    return (
      '<Jimp ' +
      (this.bitmap === emptyBitmap
        ? 'pending...'
        : this.bitmap.width + 'x' + this.bitmap.height) +
      '>'
    )
  }
  toString() {
    return '[object Jimp]'
  }
  getMIME() {
    return this._originalMime || Rn.MIME_PNG
  }
  getExtension() {
    const a = this.getMIME()
    return getExtension(a)
  }
  write(a, s) {
    if (!fs$3 || !fs$3.createWriteStream)
      throw new Error(
        'Cant access the filesystem. You can use the getBase64 method.'
      )
    if (typeof a != 'string')
      return throwError.call(this, 'path must be a string', s)
    if ((typeof s > 'u' && (s = noop$5), typeof s != 'function'))
      return throwError.call(this, 'cb must be a function', s)
    const $ = getType(a) || this.getMIME(),
      j = Path.parse(a)
    return (
      j.dir && fs$3.mkdirSync(j.dir, { recursive: !0 }),
      this.getBuffer($, (_e, et) => {
        if (_e) return throwError.call(this, _e, s)
        const tt = fs$3.createWriteStream(a)
        tt
          .on('open', () => {
            tt.write(et), tt.end()
          })
          .on('error', rt => throwError.call(this, rt, s)),
          tt.on('finish', () => {
            s.call(this, null, this)
          })
      }),
      this
    )
  }
  getBase64(a, s) {
    return (
      a === Rn.AUTO && (a = this.getMIME()),
      typeof a != 'string'
        ? throwError.call(this, 'mime must be a string', s)
        : typeof s != 'function'
        ? throwError.call(this, 'cb must be a function', s)
        : (this.getBuffer(a, function($, j) {
            if ($) return throwError.call(this, $, s)
            const _e = 'data:' + a + ';base64,' + j.toString('base64')
            s.call(this, null, _e)
          }),
          this)
    )
  }
  hash(a, s) {
    if (
      ((a = a || 64),
      typeof a == 'function' && ((s = a), (a = 64)),
      typeof a != 'number')
    )
      return throwError.call(this, 'base must be a number', s)
    if (a < 2 || a > 64)
      return throwError.call(this, 'base must be a number between 2 and 64', s)
    let $ = this.pHash()
    for (
      $ = anyBase$1(anyBase$1.BIN, alphabet.slice(0, a))($);
      $.length < maxHashLength[a];

    )
      $ = '0' + $
    return isNodePattern(s) && s.call(this, null, $), $
  }
  pHash() {
    return new ImagePHash().getHash(this)
  }
  distanceFromHash(a) {
    const s = new ImagePHash(),
      $ = s.getHash(this)
    return s.distance($, a)
  }
  getPixelIndex(a, s, $, j) {
    let _e, et
    if (
      (typeof $ == 'function' && typeof j > 'u' && ((j = $), ($ = null)),
      $ || ($ = Rn.EDGE_EXTEND),
      typeof a != 'number' || typeof s != 'number')
    )
      return throwError.call(this, 'x and y must be numbers', j)
    ;(a = Math.round(a)),
      (s = Math.round(s)),
      (_e = a),
      (et = s),
      $ === Rn.EDGE_EXTEND &&
        (a < 0 && (_e = 0),
        a >= this.bitmap.width && (_e = this.bitmap.width - 1),
        s < 0 && (et = 0),
        s >= this.bitmap.height && (et = this.bitmap.height - 1)),
      $ === Rn.EDGE_WRAP &&
        (a < 0 && (_e = this.bitmap.width + a),
        a >= this.bitmap.width && (_e = a % this.bitmap.width),
        s < 0 && (et = this.bitmap.height + s),
        s >= this.bitmap.height && (et = s % this.bitmap.height))
    let tt = (this.bitmap.width * et + _e) << 2
    return (
      (_e < 0 || _e >= this.bitmap.width) && (tt = -1),
      (et < 0 || et >= this.bitmap.height) && (tt = -1),
      isNodePattern(j) && j.call(this, null, tt),
      tt
    )
  }
  getPixelColor(a, s, $) {
    if (typeof a != 'number' || typeof s != 'number')
      return throwError.call(this, 'x and y must be numbers', $)
    const j = this.getPixelIndex(a, s),
      _e = this.bitmap.data.readUInt32BE(j)
    return isNodePattern($) && $.call(this, null, _e), _e
  }
  setPixelColor(a, s, $, j) {
    if (typeof a != 'number' || typeof s != 'number' || typeof $ != 'number')
      return throwError.call(this, 'hex, x and y must be numbers', j)
    const _e = this.getPixelIndex(s, $)
    return (
      this.bitmap.data.writeUInt32BE(a, _e),
      isNodePattern(j) && j.call(this, null, this),
      this
    )
  }
  hasAlpha() {
    const { width: a, height: s, data: $ } = this.bitmap,
      j = (a * s) << 2
    for (let _e = 3; _e < j; _e += 4) if ($[_e] !== 255) return !0
    return !1
  }
  scanIterator(a, s, $, j) {
    return typeof a != 'number' || typeof s != 'number'
      ? throwError.call(this, 'x and y must be numbers')
      : typeof $ != 'number' || typeof j != 'number'
      ? throwError.call(this, 'w and h must be numbers')
      : scanIterator(this, a, s, $, j)
  }
}
function addConstants(o) {
  let a =
    arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp$1
  Object.entries(o).forEach(s => {
    let [$, j] = s
    a[$] = j
  })
}
function addJimpMethods(o) {
  let a =
    arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp$1
  Object.entries(o).forEach(s => {
    let [$, j] = s
    a.prototype[$] = j
  })
}
addConstants(constants$7)
addJimpMethods({ composite })
Jimp$1.__extraConstructors = []
Jimp$1.appendConstructorOption = function(o, a, s) {
  Jimp$1.__extraConstructors.push({ name: o, test: a, run: s })
}
Jimp$1.read = function() {
  for (var o = arguments.length, a = new Array(o), s = 0; s < o; s++)
    a[s] = arguments[s]
  return new Promise(($, j) => {
    new Jimp$1(...a, (_e, et) => {
      _e ? j(_e) : $(et)
    })
  })
}
Jimp$1.create = Jimp$1.read
Jimp$1.rgbaToInt = function(o, a, s, $, j) {
  if (
    typeof o != 'number' ||
    typeof a != 'number' ||
    typeof s != 'number' ||
    typeof $ != 'number'
  )
    return throwError.call(this, 'r, g, b and a must be numbers', j)
  if (o < 0 || o > 255)
    return throwError.call(this, 'r must be between 0 and 255', j)
  if (
    ((a < 0 || a > 255) &&
      throwError.call(this, 'g must be between 0 and 255', j),
    s < 0 || s > 255)
  )
    return throwError.call(this, 'b must be between 0 and 255', j)
  if ($ < 0 || $ > 255)
    return throwError.call(this, 'a must be between 0 and 255', j)
  let _e = o & 255
  return (
    (_e <<= 8),
    (_e |= a & 255),
    (_e <<= 8),
    (_e |= s & 255),
    (_e <<= 8),
    (_e |= $ & 255),
    (_e >>>= 0),
    isNodePattern(j) && j.call(this, null, _e),
    _e
  )
}
Jimp$1.intToRGBA = function(o, a) {
  if (typeof o != 'number')
    return throwError.call(this, 'i must be a number', a)
  const s = {}
  return (
    (s.r = Math.floor(o / Math.pow(256, 3))),
    (s.g = Math.floor((o - s.r * Math.pow(256, 3)) / Math.pow(256, 2))),
    (s.b = Math.floor(
      (o - s.r * Math.pow(256, 3) - s.g * Math.pow(256, 2)) / Math.pow(256, 1)
    )),
    (s.a = Math.floor(
      (o -
        s.r * Math.pow(256, 3) -
        s.g * Math.pow(256, 2) -
        s.b * Math.pow(256, 1)) /
        Math.pow(256, 0)
    )),
    isNodePattern(a) && a.call(this, null, s),
    s
  )
}
Jimp$1.cssColorToHex = function(o) {
  return (
    (o = o || 0),
    typeof o == 'number' ? Number(o) : parseInt(tinycolor(o).toHex8(), 16)
  )
}
Jimp$1.limit255 = function(o) {
  return (o = Math.max(o, 0)), (o = Math.min(o, 255)), o
}
Jimp$1.diff = function(o, a) {
  let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1
  if (!(o instanceof Jimp$1) || !(a instanceof Jimp$1))
    return throwError.call(this, 'img1 and img2 must be an Jimp images')
  const $ = o.bitmap,
    j = a.bitmap
  if (
    (($.width !== j.width || $.height !== j.height) &&
      ($.width * $.height > j.width * j.height
        ? (o = o.cloneQuiet().resize(j.width, j.height))
        : (a = a.cloneQuiet().resize($.width, $.height))),
    typeof s != 'number' || s < 0 || s > 1)
  )
    return throwError.call(this, 'threshold must be a number between 0 and 1')
  const _e = new Jimp$1($.width, $.height, 4294967295)
  return {
    percent:
      pixelMatch(
        $.data,
        j.data,
        _e.bitmap.data,
        _e.bitmap.width,
        _e.bitmap.height,
        { threshold: s }
      ) /
      (_e.bitmap.width * _e.bitmap.height),
    image: _e,
  }
}
Jimp$1.distance = function(o, a) {
  const s = new ImagePHash(),
    $ = s.getHash(o),
    j = s.getHash(a)
  return s.distance($, j)
}
Jimp$1.compareHashes = function(o, a) {
  return new ImagePHash().distance(o, a)
}
Jimp$1.colorDiff = function(o, a) {
  const s = _e => Math.pow(_e, 2),
    { max: $ } = Math,
    j = 255 * 255 * 3
  return (
    o.a !== 0 && !o.a && (o.a = 255),
    a.a !== 0 && !a.a && (a.a = 255),
    ($(s(o.r - a.r), s(o.r - a.r - o.a + a.a)) +
      $(s(o.g - a.g), s(o.g - a.g - o.a + a.a)) +
      $(s(o.b - a.b), s(o.b - a.b - o.a + a.a))) /
      j
  )
}
function jimpEvMethod(o, a, s) {
  const $ = 'before-' + a,
    j = a.replace(/e$/, '') + 'ed'
  ;(Jimp$1.prototype[o] = function() {
    let _e
    for (var et = arguments.length, tt = new Array(et), rt = 0; rt < et; rt++)
      tt[rt] = arguments[rt]
    const nt = tt[s.length - 1],
      it = this
    typeof nt == 'function'
      ? ((_e = function() {
          for (
            var at = arguments.length, st = new Array(at), ut = 0;
            ut < at;
            ut++
          )
            st[ut] = arguments[ut]
          const [ct, dt] = st
          ct ? it.emitError(o, ct) : it.emitMulti(o, j, { [o]: dt }),
            nt.apply(this, st)
        }),
        (tt[tt.length - 1] = _e))
      : (_e = !1),
      this.emitMulti(o, $)
    let ot
    try {
      ;(ot = s.apply(this, tt)), _e || this.emitMulti(o, j, { [o]: ot })
    } catch (at) {
      ;(at.methodName = o), this.emitError(o, at)
    }
    return ot
  }),
    (Jimp$1.prototype[o + 'Quiet'] = s)
}
jimpEvMethod('clone', 'clone', function(o) {
  const a = new Jimp$1(this)
  return isNodePattern(o) && o.call(a, null, a), a
})
function jimpEvChange(o, a) {
  jimpEvMethod(o, 'change', a)
}
jimpEvChange('background', function(o, a) {
  return typeof o != 'number'
    ? throwError.call(this, 'hex must be a hexadecimal rgba value', a)
    : ((this._background = o),
      isNodePattern(a) && a.call(this, null, this),
      this)
})
jimpEvChange('scan', function(o, a, s, $, j, _e) {
  if (typeof o != 'number' || typeof a != 'number')
    return throwError.call(this, 'x and y must be numbers', _e)
  if (typeof s != 'number' || typeof $ != 'number')
    return throwError.call(this, 'w and h must be numbers', _e)
  if (typeof j != 'function')
    return throwError.call(this, 'f must be a function', _e)
  const et = scan(this, o, a, s, $, j)
  return isNodePattern(_e) && _e.call(this, null, et), et
})
if (define_process_env_default.ENVIRONMENT === 'BROWSER') {
  let o
  typeof window < 'u' && typeof window == 'object' && (o = window),
    typeof self < 'u' && typeof self == 'object' && (o = self),
    (o.Jimp = Jimp$1),
    (o.Buffer = Buffer)
}
function configure(o) {
  let a =
    arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Jimp$1
  const s = {
    hasAlpha: {},
    encoders: {},
    decoders: {},
    class: {},
    constants: {},
  }
  function $(et) {
    Object.entries(et).forEach(tt => {
      let [rt, nt] = tt
      s[rt] = { ...s[rt], ...nt }
    })
  }
  function j(et) {
    const tt = et()
    Array.isArray(tt.mime)
      ? addType(...tt.mime)
      : Object.entries(tt.mime).forEach(rt => addType(...rt)),
      delete tt.mime,
      $(tt)
  }
  function _e(et) {
    const tt = et(jimpEvChange) || {}
    !tt.class && !tt.constants ? $({ class: tt }) : $(tt)
  }
  return (
    o.types &&
      (o.types.forEach(j),
      (a.decoders = { ...a.decoders, ...s.decoders }),
      (a.encoders = { ...a.encoders, ...s.encoders }),
      (a.hasAlpha = { ...a.hasAlpha, ...s.hasAlpha })),
    o.plugins && o.plugins.forEach(_e),
    addJimpMethods(s.class, a),
    addConstants(s.constants, a),
    Jimp$1
  )
}
var parserAsync = { exports: {} },
  lib$2 = {},
  binding = {},
  assert = { exports: {} },
  errors = {},
  hasRequiredErrors
function requireErrors() {
  if (hasRequiredErrors) return errors
  hasRequiredErrors = 1
  function o(ct) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (o = function(ft) {
            return typeof ft
          })
        : (o = function(ft) {
            return ft &&
              typeof Symbol == 'function' &&
              ft.constructor === Symbol &&
              ft !== Symbol.prototype
              ? 'symbol'
              : typeof ft
          }),
      o(ct)
    )
  }
  function a(ct, dt) {
    if (!(ct instanceof dt))
      throw new TypeError('Cannot call a class as a function')
  }
  function s(ct, dt) {
    return dt && (o(dt) === 'object' || typeof dt == 'function') ? dt : $(ct)
  }
  function $(ct) {
    if (ct === void 0)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      )
    return ct
  }
  function j(ct) {
    return (
      (j = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function(ft) {
            return ft.__proto__ || Object.getPrototypeOf(ft)
          }),
      j(ct)
    )
  }
  function _e(ct, dt) {
    if (typeof dt != 'function' && dt !== null)
      throw new TypeError('Super expression must either be null or a function')
    ;(ct.prototype = Object.create(dt && dt.prototype, {
      constructor: { value: ct, writable: !0, configurable: !0 },
    })),
      dt && et(ct, dt)
  }
  function et(ct, dt) {
    return (
      (et =
        Object.setPrototypeOf ||
        function(mt, vt) {
          return (mt.__proto__ = vt), mt
        }),
      et(ct, dt)
    )
  }
  var tt = {},
    rt,
    nt
  function it(ct, dt, ft) {
    ft || (ft = Error)
    function mt(yt, pt, ht) {
      return typeof dt == 'string' ? dt : dt(yt, pt, ht)
    }
    var vt = (function(yt) {
      _e(pt, yt)
      function pt(ht, At, wt) {
        var Ct
        return (
          a(this, pt),
          (Ct = s(this, j(pt).call(this, mt(ht, At, wt)))),
          (Ct.code = ct),
          Ct
        )
      }
      return pt
    })(ft)
    tt[ct] = vt
  }
  function ot(ct, dt) {
    if (Array.isArray(ct)) {
      var ft = ct.length
      return (
        (ct = ct.map(function(mt) {
          return String(mt)
        })),
        ft > 2
          ? 'one of '
              .concat(dt, ' ')
              .concat(ct.slice(0, ft - 1).join(', '), ', or ') + ct[ft - 1]
          : ft === 2
          ? 'one of '
              .concat(dt, ' ')
              .concat(ct[0], ' or ')
              .concat(ct[1])
          : 'of '.concat(dt, ' ').concat(ct[0])
      )
    } else return 'of '.concat(dt, ' ').concat(String(ct))
  }
  function at(ct, dt, ft) {
    return ct.substr(0, dt.length) === dt
  }
  function st(ct, dt, ft) {
    return (
      (ft === void 0 || ft > ct.length) && (ft = ct.length),
      ct.substring(ft - dt.length, ft) === dt
    )
  }
  function ut(ct, dt, ft) {
    return (
      typeof ft != 'number' && (ft = 0),
      ft + dt.length > ct.length ? !1 : ct.indexOf(dt, ft) !== -1
    )
  }
  return (
    it(
      'ERR_AMBIGUOUS_ARGUMENT',
      'The "%s" argument is ambiguous. %s',
      TypeError
    ),
    it(
      'ERR_INVALID_ARG_TYPE',
      function(ct, dt, ft) {
        rt === void 0 && (rt = requireAssert()),
          rt(typeof ct == 'string', "'name' must be a string")
        var mt
        typeof dt == 'string' && at(dt, 'not ')
          ? ((mt = 'must not be'), (dt = dt.replace(/^not /, '')))
          : (mt = 'must be')
        var vt
        if (st(ct, ' argument'))
          vt = 'The '
            .concat(ct, ' ')
            .concat(mt, ' ')
            .concat(ot(dt, 'type'))
        else {
          var yt = ut(ct, '.') ? 'property' : 'argument'
          vt = 'The "'
            .concat(ct, '" ')
            .concat(yt, ' ')
            .concat(mt, ' ')
            .concat(ot(dt, 'type'))
        }
        return (vt += '. Received type '.concat(o(ft))), vt
      },
      TypeError
    ),
    it(
      'ERR_INVALID_ARG_VALUE',
      function(ct, dt) {
        var ft =
          arguments.length > 2 && arguments[2] !== void 0
            ? arguments[2]
            : 'is invalid'
        nt === void 0 && (nt = util$u)
        var mt = nt.inspect(dt)
        return (
          mt.length > 128 && (mt = ''.concat(mt.slice(0, 128), '...')),
          "The argument '"
            .concat(ct, "' ")
            .concat(ft, '. Received ')
            .concat(mt)
        )
      },
      TypeError
    ),
    it(
      'ERR_INVALID_RETURN_VALUE',
      function(ct, dt, ft) {
        var mt
        return (
          ft && ft.constructor && ft.constructor.name
            ? (mt = 'instance of '.concat(ft.constructor.name))
            : (mt = 'type '.concat(o(ft))),
          'Expected '.concat(ct, ' to be returned from the "').concat(dt, '"') +
            ' function but got '.concat(mt, '.')
        )
      },
      TypeError
    ),
    it(
      'ERR_MISSING_ARGS',
      function() {
        for (
          var ct = arguments.length, dt = new Array(ct), ft = 0;
          ft < ct;
          ft++
        )
          dt[ft] = arguments[ft]
        rt === void 0 && (rt = requireAssert()),
          rt(dt.length > 0, 'At least one arg needs to be specified')
        var mt = 'The ',
          vt = dt.length
        switch (
          ((dt = dt.map(function(yt) {
            return '"'.concat(yt, '"')
          })),
          vt)
        ) {
          case 1:
            mt += ''.concat(dt[0], ' argument')
            break
          case 2:
            mt += ''.concat(dt[0], ' and ').concat(dt[1], ' arguments')
            break
          default:
            ;(mt += dt.slice(0, vt - 1).join(', ')),
              (mt += ', and '.concat(dt[vt - 1], ' arguments'))
            break
        }
        return ''.concat(mt, ' must be specified')
      },
      TypeError
    ),
    (errors.codes = tt),
    errors
  )
}
var assertion_error, hasRequiredAssertion_error
function requireAssertion_error() {
  if (hasRequiredAssertion_error) return assertion_error
  hasRequiredAssertion_error = 1
  function o(Mt) {
    for (var Ut = 1; Ut < arguments.length; Ut++) {
      var Wt = arguments[Ut] != null ? arguments[Ut] : {},
        Tt = Object.keys(Wt)
      typeof Object.getOwnPropertySymbols == 'function' &&
        (Tt = Tt.concat(
          Object.getOwnPropertySymbols(Wt).filter(function(kt) {
            return Object.getOwnPropertyDescriptor(Wt, kt).enumerable
          })
        )),
        Tt.forEach(function(kt) {
          a(Mt, kt, Wt[kt])
        })
    }
    return Mt
  }
  function a(Mt, Ut, Wt) {
    return (
      Ut in Mt
        ? Object.defineProperty(Mt, Ut, {
            value: Wt,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          })
        : (Mt[Ut] = Wt),
      Mt
    )
  }
  function s(Mt, Ut) {
    if (!(Mt instanceof Ut))
      throw new TypeError('Cannot call a class as a function')
  }
  function $(Mt, Ut) {
    for (var Wt = 0; Wt < Ut.length; Wt++) {
      var Tt = Ut[Wt]
      ;(Tt.enumerable = Tt.enumerable || !1),
        (Tt.configurable = !0),
        'value' in Tt && (Tt.writable = !0),
        Object.defineProperty(Mt, Tt.key, Tt)
    }
  }
  function j(Mt, Ut, Wt) {
    return Ut && $(Mt.prototype, Ut), Mt
  }
  function _e(Mt, Ut) {
    return Ut && (ut(Ut) === 'object' || typeof Ut == 'function') ? Ut : et(Mt)
  }
  function et(Mt) {
    if (Mt === void 0)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      )
    return Mt
  }
  function tt(Mt, Ut) {
    if (typeof Ut != 'function' && Ut !== null)
      throw new TypeError('Super expression must either be null or a function')
    ;(Mt.prototype = Object.create(Ut && Ut.prototype, {
      constructor: { value: Mt, writable: !0, configurable: !0 },
    })),
      Ut && at(Mt, Ut)
  }
  function rt(Mt) {
    var Ut = typeof Map == 'function' ? new Map() : void 0
    return (
      (rt = function(Tt) {
        if (Tt === null || !ot(Tt)) return Tt
        if (typeof Tt != 'function')
          throw new TypeError(
            'Super expression must either be null or a function'
          )
        if (typeof Ut < 'u') {
          if (Ut.has(Tt)) return Ut.get(Tt)
          Ut.set(Tt, kt)
        }
        function kt() {
          return it(Tt, arguments, st(this).constructor)
        }
        return (
          (kt.prototype = Object.create(Tt.prototype, {
            constructor: {
              value: kt,
              enumerable: !1,
              writable: !0,
              configurable: !0,
            },
          })),
          at(kt, Tt)
        )
      }),
      rt(Mt)
    )
  }
  function nt() {
    if (typeof Reflect > 'u' || !Reflect.construct || Reflect.construct.sham)
      return !1
    if (typeof Proxy == 'function') return !0
    try {
      return (
        Date.prototype.toString.call(
          Reflect.construct(Date, [], function() {})
        ),
        !0
      )
    } catch {
      return !1
    }
  }
  function it(Mt, Ut, Wt) {
    return (
      nt()
        ? (it = Reflect.construct)
        : (it = function(kt, Ot, Nt) {
            var $t = [null]
            $t.push.apply($t, Ot)
            var Pt = Function.bind.apply(kt, $t),
              Ft = new Pt()
            return Nt && at(Ft, Nt.prototype), Ft
          }),
      it.apply(null, arguments)
    )
  }
  function ot(Mt) {
    return Function.toString.call(Mt).indexOf('[native code]') !== -1
  }
  function at(Mt, Ut) {
    return (
      (at =
        Object.setPrototypeOf ||
        function(Tt, kt) {
          return (Tt.__proto__ = kt), Tt
        }),
      at(Mt, Ut)
    )
  }
  function st(Mt) {
    return (
      (st = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function(Wt) {
            return Wt.__proto__ || Object.getPrototypeOf(Wt)
          }),
      st(Mt)
    )
  }
  function ut(Mt) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (ut = function(Wt) {
            return typeof Wt
          })
        : (ut = function(Wt) {
            return Wt &&
              typeof Symbol == 'function' &&
              Wt.constructor === Symbol &&
              Wt !== Symbol.prototype
              ? 'symbol'
              : typeof Wt
          }),
      ut(Mt)
    )
  }
  var ct = util$u,
    dt = ct.inspect,
    ft = requireErrors(),
    mt = ft.codes.ERR_INVALID_ARG_TYPE
  function vt(Mt, Ut, Wt) {
    return (
      (Wt === void 0 || Wt > Mt.length) && (Wt = Mt.length),
      Mt.substring(Wt - Ut.length, Wt) === Ut
    )
  }
  function yt(Mt, Ut) {
    if (((Ut = Math.floor(Ut)), Mt.length == 0 || Ut == 0)) return ''
    var Wt = Mt.length * Ut
    for (Ut = Math.floor(Math.log(Ut) / Math.log(2)); Ut; ) (Mt += Mt), Ut--
    return (Mt += Mt.substring(0, Wt - Mt.length)), Mt
  }
  var pt = '',
    ht = '',
    At = '',
    wt = '',
    Ct = {
      deepStrictEqual: 'Expected values to be strictly deep-equal:',
      strictEqual: 'Expected values to be strictly equal:',
      strictEqualObject:
        'Expected "actual" to be reference-equal to "expected":',
      deepEqual: 'Expected values to be loosely deep-equal:',
      equal: 'Expected values to be loosely equal:',
      notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
      notStrictEqual: 'Expected "actual" to be strictly unequal to:',
      notStrictEqualObject:
        'Expected "actual" not to be reference-equal to "expected":',
      notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
      notEqual: 'Expected "actual" to be loosely unequal to:',
      notIdentical: 'Values identical but not reference-equal:',
    },
    Dt = 10
  function jt(Mt) {
    var Ut = Object.keys(Mt),
      Wt = Object.create(Object.getPrototypeOf(Mt))
    return (
      Ut.forEach(function(Tt) {
        Wt[Tt] = Mt[Tt]
      }),
      Object.defineProperty(Wt, 'message', { value: Mt.message }),
      Wt
    )
  }
  function Et(Mt) {
    return dt(Mt, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      showHidden: !1,
      breakLength: 1 / 0,
      showProxy: !1,
      sorted: !0,
      getters: !0,
    })
  }
  function St(Mt, Ut, Wt) {
    var Tt = '',
      kt = '',
      Ot = 0,
      Nt = '',
      $t = !1,
      Pt = Et(Mt),
      Ft = Pt.split(`
`),
      Vt = Et(Ut).split(`
`),
      Xt = 0,
      Yt = ''
    if (
      (Wt === 'strictEqual' &&
        ut(Mt) === 'object' &&
        ut(Ut) === 'object' &&
        Mt !== null &&
        Ut !== null &&
        (Wt = 'strictEqualObject'),
      Ft.length === 1 && Vt.length === 1 && Ft[0] !== Vt[0])
    ) {
      var xt = Ft[0].length + Vt[0].length
      if (xt <= Dt) {
        if (
          (ut(Mt) !== 'object' || Mt === null) &&
          (ut(Ut) !== 'object' || Ut === null) &&
          (Mt !== 0 || Ut !== 0)
        )
          return (
            ''.concat(
              Ct[Wt],
              `

`
            ) +
            ''.concat(Ft[0], ' !== ').concat(
              Vt[0],
              `
`
            )
          )
      } else if (Wt !== 'strictEqualObject') {
        var It =
          process.stderr && process.stderr.isTTY ? process.stderr.columns : 80
        if (xt < It) {
          for (; Ft[0][Xt] === Vt[0][Xt]; ) Xt++
          Xt > 2 &&
            ((Yt = `
  `.concat(yt(' ', Xt), '^')),
            (Xt = 0))
        }
      }
    }
    for (
      var Kt = Ft[Ft.length - 1], Qt = Vt[Vt.length - 1];
      Kt === Qt &&
      (Xt++ < 2
        ? (Nt = `
  `
            .concat(Kt)
            .concat(Nt))
        : (Tt = Kt),
      Ft.pop(),
      Vt.pop(),
      !(Ft.length === 0 || Vt.length === 0));

    )
      (Kt = Ft[Ft.length - 1]), (Qt = Vt[Vt.length - 1])
    var Ht = Math.max(Ft.length, Vt.length)
    if (Ht === 0) {
      var Lt = Pt.split(`
`)
      if (Lt.length > 30)
        for (Lt[26] = ''.concat(pt, '...').concat(wt); Lt.length > 27; )
          Lt.pop()
      return ''
        .concat(
          Ct.notIdentical,
          `

`
        )
        .concat(
          Lt.join(`
`),
          `
`
        )
    }
    Xt > 3 &&
      ((Nt = `
`
        .concat(pt, '...')
        .concat(wt)
        .concat(Nt)),
      ($t = !0)),
      Tt !== '' &&
        ((Nt = `
  `
          .concat(Tt)
          .concat(Nt)),
        (Tt = ''))
    var tr = 0,
      lr =
        Ct[Wt] +
        `
`
          .concat(ht, '+ actual')
          .concat(wt, ' ')
          .concat(At, '- expected')
          .concat(wt),
      yr = ' '.concat(pt, '...').concat(wt, ' Lines skipped')
    for (Xt = 0; Xt < Ht; Xt++) {
      var mr = Xt - Ot
      if (Ft.length < Xt + 1)
        mr > 1 &&
          Xt > 2 &&
          (mr > 4
            ? ((kt += `
`
                .concat(pt, '...')
                .concat(wt)),
              ($t = !0))
            : mr > 3 &&
              ((kt += `
  `.concat(Vt[Xt - 2])),
              tr++),
          (kt += `
  `.concat(Vt[Xt - 1])),
          tr++),
          (Ot = Xt),
          (Tt += `
`
            .concat(At, '-')
            .concat(wt, ' ')
            .concat(Vt[Xt])),
          tr++
      else if (Vt.length < Xt + 1)
        mr > 1 &&
          Xt > 2 &&
          (mr > 4
            ? ((kt += `
`
                .concat(pt, '...')
                .concat(wt)),
              ($t = !0))
            : mr > 3 &&
              ((kt += `
  `.concat(Ft[Xt - 2])),
              tr++),
          (kt += `
  `.concat(Ft[Xt - 1])),
          tr++),
          (Ot = Xt),
          (kt += `
`
            .concat(ht, '+')
            .concat(wt, ' ')
            .concat(Ft[Xt])),
          tr++
      else {
        var Er = Vt[Xt],
          ur = Ft[Xt],
          _r = ur !== Er && (!vt(ur, ',') || ur.slice(0, -1) !== Er)
        _r && vt(Er, ',') && Er.slice(0, -1) === ur && ((_r = !1), (ur += ',')),
          _r
            ? (mr > 1 &&
                Xt > 2 &&
                (mr > 4
                  ? ((kt += `
`
                      .concat(pt, '...')
                      .concat(wt)),
                    ($t = !0))
                  : mr > 3 &&
                    ((kt += `
  `.concat(Ft[Xt - 2])),
                    tr++),
                (kt += `
  `.concat(Ft[Xt - 1])),
                tr++),
              (Ot = Xt),
              (kt += `
`
                .concat(ht, '+')
                .concat(wt, ' ')
                .concat(ur)),
              (Tt += `
`
                .concat(At, '-')
                .concat(wt, ' ')
                .concat(Er)),
              (tr += 2))
            : ((kt += Tt),
              (Tt = ''),
              (mr === 1 || Xt === 0) &&
                ((kt += `
  `.concat(ur)),
                tr++))
      }
      if (tr > 20 && Xt < Ht - 2)
        return (
          ''
            .concat(lr)
            .concat(
              yr,
              `
`
            )
            .concat(
              kt,
              `
`
            )
            .concat(pt, '...')
            .concat(wt)
            .concat(
              Tt,
              `
`
            ) + ''.concat(pt, '...').concat(wt)
        )
    }
    return ''
      .concat(lr)
      .concat(
        $t ? yr : '',
        `
`
      )
      .concat(kt)
      .concat(Tt)
      .concat(Nt)
      .concat(Yt)
  }
  var Bt = (function(Mt) {
    tt(Ut, Mt)
    function Ut(Wt) {
      var Tt
      if ((s(this, Ut), ut(Wt) !== 'object' || Wt === null))
        throw new mt('options', 'Object', Wt)
      var kt = Wt.message,
        Ot = Wt.operator,
        Nt = Wt.stackStartFn,
        $t = Wt.actual,
        Pt = Wt.expected,
        Ft = Error.stackTraceLimit
      if (((Error.stackTraceLimit = 0), kt != null))
        Tt = _e(this, st(Ut).call(this, String(kt)))
      else if (
        (process.stderr &&
          process.stderr.isTTY &&
          (process.stderr &&
          process.stderr.getColorDepth &&
          process.stderr.getColorDepth() !== 1
            ? ((pt = '\x1B[34m'),
              (ht = '\x1B[32m'),
              (wt = '\x1B[39m'),
              (At = '\x1B[31m'))
            : ((pt = ''), (ht = ''), (wt = ''), (At = ''))),
        ut($t) === 'object' &&
          $t !== null &&
          ut(Pt) === 'object' &&
          Pt !== null &&
          'stack' in $t &&
          $t instanceof Error &&
          'stack' in Pt &&
          Pt instanceof Error &&
          (($t = jt($t)), (Pt = jt(Pt))),
        Ot === 'deepStrictEqual' || Ot === 'strictEqual')
      )
        Tt = _e(this, st(Ut).call(this, St($t, Pt, Ot)))
      else if (Ot === 'notDeepStrictEqual' || Ot === 'notStrictEqual') {
        var Vt = Ct[Ot],
          Xt = Et($t).split(`
`)
        if (
          (Ot === 'notStrictEqual' &&
            ut($t) === 'object' &&
            $t !== null &&
            (Vt = Ct.notStrictEqualObject),
          Xt.length > 30)
        )
          for (Xt[26] = ''.concat(pt, '...').concat(wt); Xt.length > 27; )
            Xt.pop()
        Xt.length === 1
          ? (Tt = _e(this, st(Ut).call(this, ''.concat(Vt, ' ').concat(Xt[0]))))
          : (Tt = _e(
              this,
              st(Ut).call(
                this,
                ''
                  .concat(
                    Vt,
                    `

`
                  )
                  .concat(
                    Xt.join(`
`),
                    `
`
                  )
              )
            ))
      } else {
        var Yt = Et($t),
          xt = '',
          It = Ct[Ot]
        Ot === 'notDeepEqual' || Ot === 'notEqual'
          ? ((Yt = ''
              .concat(
                Ct[Ot],
                `

`
              )
              .concat(Yt)),
            Yt.length > 1024 && (Yt = ''.concat(Yt.slice(0, 1021), '...')))
          : ((xt = ''.concat(Et(Pt))),
            Yt.length > 512 && (Yt = ''.concat(Yt.slice(0, 509), '...')),
            xt.length > 512 && (xt = ''.concat(xt.slice(0, 509), '...')),
            Ot === 'deepEqual' || Ot === 'equal'
              ? (Yt = ''
                  .concat(
                    It,
                    `

`
                  )
                  .concat(
                    Yt,
                    `

should equal

`
                  ))
              : (xt = ' '.concat(Ot, ' ').concat(xt))),
          (Tt = _e(this, st(Ut).call(this, ''.concat(Yt).concat(xt))))
      }
      return (
        (Error.stackTraceLimit = Ft),
        (Tt.generatedMessage = !kt),
        Object.defineProperty(et(Tt), 'name', {
          value: 'AssertionError [ERR_ASSERTION]',
          enumerable: !1,
          writable: !0,
          configurable: !0,
        }),
        (Tt.code = 'ERR_ASSERTION'),
        (Tt.actual = $t),
        (Tt.expected = Pt),
        (Tt.operator = Ot),
        Error.captureStackTrace && Error.captureStackTrace(et(Tt), Nt),
        Tt.stack,
        (Tt.name = 'AssertionError'),
        _e(Tt)
      )
    }
    return (
      j(Ut, [
        {
          key: 'toString',
          value: function() {
            return ''
              .concat(this.name, ' [')
              .concat(this.code, ']: ')
              .concat(this.message)
          },
        },
        {
          key: dt.custom,
          value: function(Tt, kt) {
            return dt(this, o({}, kt, { customInspect: !1, depth: 0 }))
          },
        },
      ]),
      Ut
    )
  })(rt(Error))
  return (assertion_error = Bt), assertion_error
}
var es6ObjectAssign, hasRequiredEs6ObjectAssign
function requireEs6ObjectAssign() {
  if (hasRequiredEs6ObjectAssign) return es6ObjectAssign
  hasRequiredEs6ObjectAssign = 1
  function o(s, $) {
    if (s == null)
      throw new TypeError('Cannot convert first argument to object')
    for (var j = Object(s), _e = 1; _e < arguments.length; _e++) {
      var et = arguments[_e]
      if (et != null)
        for (
          var tt = Object.keys(Object(et)), rt = 0, nt = tt.length;
          rt < nt;
          rt++
        ) {
          var it = tt[rt],
            ot = Object.getOwnPropertyDescriptor(et, it)
          ot !== void 0 && ot.enumerable && (j[it] = et[it])
        }
    }
    return j
  }
  function a() {
    Object.assign ||
      Object.defineProperty(Object, 'assign', {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: o,
      })
  }
  return (es6ObjectAssign = { assign: o, polyfill: a }), es6ObjectAssign
}
var isArguments, hasRequiredIsArguments
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments
  hasRequiredIsArguments = 1
  var o = Object.prototype.toString
  return (
    (isArguments = function(s) {
      var $ = o.call(s),
        j = $ === '[object Arguments]'
      return (
        j ||
          (j =
            $ !== '[object Array]' &&
            s !== null &&
            typeof s == 'object' &&
            typeof s.length == 'number' &&
            s.length >= 0 &&
            o.call(s.callee) === '[object Function]'),
        j
      )
    }),
    isArguments
  )
}
var implementation$2, hasRequiredImplementation$2
function requireImplementation$2() {
  if (hasRequiredImplementation$2) return implementation$2
  hasRequiredImplementation$2 = 1
  var o
  if (!Object.keys) {
    var a = Object.prototype.hasOwnProperty,
      s = Object.prototype.toString,
      $ = requireIsArguments(),
      j = Object.prototype.propertyIsEnumerable,
      _e = !j.call({ toString: null }, 'toString'),
      et = j.call(function() {}, 'prototype'),
      tt = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor',
      ],
      rt = function(at) {
        var st = at.constructor
        return st && st.prototype === at
      },
      nt = {
        $applicationCache: !0,
        $console: !0,
        $external: !0,
        $frame: !0,
        $frameElement: !0,
        $frames: !0,
        $innerHeight: !0,
        $innerWidth: !0,
        $onmozfullscreenchange: !0,
        $onmozfullscreenerror: !0,
        $outerHeight: !0,
        $outerWidth: !0,
        $pageXOffset: !0,
        $pageYOffset: !0,
        $parent: !0,
        $scrollLeft: !0,
        $scrollTop: !0,
        $scrollX: !0,
        $scrollY: !0,
        $self: !0,
        $webkitIndexedDB: !0,
        $webkitStorageInfo: !0,
        $window: !0,
      },
      it = (function() {
        if (typeof window > 'u') return !1
        for (var at in window)
          try {
            if (
              !nt['$' + at] &&
              a.call(window, at) &&
              window[at] !== null &&
              typeof window[at] == 'object'
            )
              try {
                rt(window[at])
              } catch {
                return !0
              }
          } catch {
            return !0
          }
        return !1
      })(),
      ot = function(at) {
        if (typeof window > 'u' || !it) return rt(at)
        try {
          return rt(at)
        } catch {
          return !1
        }
      }
    o = function(st) {
      var ut = st !== null && typeof st == 'object',
        ct = s.call(st) === '[object Function]',
        dt = $(st),
        ft = ut && s.call(st) === '[object String]',
        mt = []
      if (!ut && !ct && !dt)
        throw new TypeError('Object.keys called on a non-object')
      var vt = et && ct
      if (ft && st.length > 0 && !a.call(st, 0))
        for (var yt = 0; yt < st.length; ++yt) mt.push(String(yt))
      if (dt && st.length > 0)
        for (var pt = 0; pt < st.length; ++pt) mt.push(String(pt))
      else
        for (var ht in st)
          !(vt && ht === 'prototype') && a.call(st, ht) && mt.push(String(ht))
      if (_e)
        for (var At = ot(st), wt = 0; wt < tt.length; ++wt)
          !(At && tt[wt] === 'constructor') &&
            a.call(st, tt[wt]) &&
            mt.push(tt[wt])
      return mt
    }
  }
  return (implementation$2 = o), implementation$2
}
var objectKeys, hasRequiredObjectKeys
function requireObjectKeys() {
  if (hasRequiredObjectKeys) return objectKeys
  hasRequiredObjectKeys = 1
  var o = Array.prototype.slice,
    a = requireIsArguments(),
    s = Object.keys,
    $ = s
      ? function(et) {
          return s(et)
        }
      : requireImplementation$2(),
    j = Object.keys
  return (
    ($.shim = function() {
      if (Object.keys) {
        var et = (function() {
          var tt = Object.keys(arguments)
          return tt && tt.length === arguments.length
        })(1, 2)
        et ||
          (Object.keys = function(rt) {
            return a(rt) ? j(o.call(rt)) : j(rt)
          })
      } else Object.keys = $
      return Object.keys || $
    }),
    (objectKeys = $),
    objectKeys
  )
}
var defineProperties_1, hasRequiredDefineProperties
function requireDefineProperties() {
  if (hasRequiredDefineProperties) return defineProperties_1
  hasRequiredDefineProperties = 1
  var o = requireObjectKeys(),
    a = typeof Symbol == 'function' && typeof Symbol('foo') == 'symbol',
    s = Object.prototype.toString,
    $ = Array.prototype.concat,
    j = requireDefineDataProperty(),
    _e = function(nt) {
      return typeof nt == 'function' && s.call(nt) === '[object Function]'
    },
    et = requireHasPropertyDescriptors()(),
    tt = function(nt, it, ot, at) {
      if (it in nt) {
        if (at === !0) {
          if (nt[it] === ot) return
        } else if (!_e(at) || !at()) return
      }
      et ? j(nt, it, ot, !0) : j(nt, it, ot)
    },
    rt = function(nt, it) {
      var ot = arguments.length > 2 ? arguments[2] : {},
        at = o(it)
      a && (at = $.call(at, Object.getOwnPropertySymbols(it)))
      for (var st = 0; st < at.length; st += 1)
        tt(nt, at[st], it[at[st]], ot[at[st]])
    }
  return (
    (rt.supportsDescriptors = !!et),
    (defineProperties_1 = rt),
    defineProperties_1
  )
}
var implementation$1, hasRequiredImplementation$1
function requireImplementation$1() {
  if (hasRequiredImplementation$1) return implementation$1
  hasRequiredImplementation$1 = 1
  var o = function(a) {
    return a !== a
  }
  return (
    (implementation$1 = function(s, $) {
      return s === 0 && $ === 0
        ? 1 / s === 1 / $
        : !!(s === $ || (o(s) && o($)))
    }),
    implementation$1
  )
}
var polyfill$1, hasRequiredPolyfill$1
function requirePolyfill$1() {
  if (hasRequiredPolyfill$1) return polyfill$1
  hasRequiredPolyfill$1 = 1
  var o = requireImplementation$1()
  return (
    (polyfill$1 = function() {
      return typeof Object.is == 'function' ? Object.is : o
    }),
    polyfill$1
  )
}
var shim$1, hasRequiredShim$1
function requireShim$1() {
  if (hasRequiredShim$1) return shim$1
  hasRequiredShim$1 = 1
  var o = requirePolyfill$1(),
    a = requireDefineProperties()
  return (
    (shim$1 = function() {
      var $ = o()
      return (
        a(
          Object,
          { is: $ },
          {
            is: function() {
              return Object.is !== $
            },
          }
        ),
        $
      )
    }),
    shim$1
  )
}
var objectIs, hasRequiredObjectIs
function requireObjectIs() {
  if (hasRequiredObjectIs) return objectIs
  hasRequiredObjectIs = 1
  var o = requireDefineProperties(),
    a = requireCallBind(),
    s = requireImplementation$1(),
    $ = requirePolyfill$1(),
    j = requireShim$1(),
    _e = a($(), Object)
  return (
    o(_e, { getPolyfill: $, implementation: s, shim: j }),
    (objectIs = _e),
    objectIs
  )
}
var implementation, hasRequiredImplementation
function requireImplementation() {
  return (
    hasRequiredImplementation ||
      ((hasRequiredImplementation = 1),
      (implementation = function(a) {
        return a !== a
      })),
    implementation
  )
}
var polyfill, hasRequiredPolyfill
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill
  hasRequiredPolyfill = 1
  var o = requireImplementation()
  return (
    (polyfill = function() {
      return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN('a')
        ? Number.isNaN
        : o
    }),
    polyfill
  )
}
var shim, hasRequiredShim
function requireShim() {
  if (hasRequiredShim) return shim
  hasRequiredShim = 1
  var o = requireDefineProperties(),
    a = requirePolyfill()
  return (
    (shim = function() {
      var $ = a()
      return (
        o(
          Number,
          { isNaN: $ },
          {
            isNaN: function() {
              return Number.isNaN !== $
            },
          }
        ),
        $
      )
    }),
    shim
  )
}
var isNan, hasRequiredIsNan
function requireIsNan() {
  if (hasRequiredIsNan) return isNan
  hasRequiredIsNan = 1
  var o = requireCallBind(),
    a = requireDefineProperties(),
    s = requireImplementation(),
    $ = requirePolyfill(),
    j = requireShim(),
    _e = o($(), Number)
  return (
    a(_e, { getPolyfill: $, implementation: s, shim: j }), (isNan = _e), isNan
  )
}
var comparisons, hasRequiredComparisons
function requireComparisons() {
  if (hasRequiredComparisons) return comparisons
  hasRequiredComparisons = 1
  function o(nr, fr) {
    return $(nr) || s(nr, fr) || a()
  }
  function a() {
    throw new TypeError('Invalid attempt to destructure non-iterable instance')
  }
  function s(nr, fr) {
    var gr = [],
      br = !0,
      Sr = !1,
      zt = void 0
    try {
      for (
        var bt = nr[Symbol.iterator](), Rt;
        !(br = (Rt = bt.next()).done) &&
        (gr.push(Rt.value), !(fr && gr.length === fr));
        br = !0
      );
    } catch (qt) {
      ;(Sr = !0), (zt = qt)
    } finally {
      try {
        !br && bt.return != null && bt.return()
      } finally {
        if (Sr) throw zt
      }
    }
    return gr
  }
  function $(nr) {
    if (Array.isArray(nr)) return nr
  }
  function j(nr) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (j = function(gr) {
            return typeof gr
          })
        : (j = function(gr) {
            return gr &&
              typeof Symbol == 'function' &&
              gr.constructor === Symbol &&
              gr !== Symbol.prototype
              ? 'symbol'
              : typeof gr
          }),
      j(nr)
    )
  }
  var _e = /a/g.flags !== void 0,
    et = function(fr) {
      var gr = []
      return (
        fr.forEach(function(br) {
          return gr.push(br)
        }),
        gr
      )
    },
    tt = function(fr) {
      var gr = []
      return (
        fr.forEach(function(br, Sr) {
          return gr.push([Sr, br])
        }),
        gr
      )
    },
    rt = Object.is ? Object.is : requireObjectIs(),
    nt = Object.getOwnPropertySymbols
      ? Object.getOwnPropertySymbols
      : function() {
          return []
        },
    it = Number.isNaN ? Number.isNaN : requireIsNan()
  function ot(nr) {
    return nr.call.bind(nr)
  }
  var at = ot(Object.prototype.hasOwnProperty),
    st = ot(Object.prototype.propertyIsEnumerable),
    ut = ot(Object.prototype.toString),
    ct = util$u.types,
    dt = ct.isAnyArrayBuffer,
    ft = ct.isArrayBufferView,
    mt = ct.isDate,
    vt = ct.isMap,
    yt = ct.isRegExp,
    pt = ct.isSet,
    ht = ct.isNativeError,
    At = ct.isBoxedPrimitive,
    wt = ct.isNumberObject,
    Ct = ct.isStringObject,
    Dt = ct.isBooleanObject,
    jt = ct.isBigIntObject,
    Et = ct.isSymbolObject,
    St = ct.isFloat32Array,
    Bt = ct.isFloat64Array
  function Mt(nr) {
    if (nr.length === 0 || nr.length > 10) return !0
    for (var fr = 0; fr < nr.length; fr++) {
      var gr = nr.charCodeAt(fr)
      if (gr < 48 || gr > 57) return !0
    }
    return nr.length === 10 && nr >= Math.pow(2, 32)
  }
  function Ut(nr) {
    return Object.keys(nr)
      .filter(Mt)
      .concat(nt(nr).filter(Object.prototype.propertyIsEnumerable.bind(nr)))
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */ function Wt(nr, fr) {
    if (nr === fr) return 0
    for (
      var gr = nr.length, br = fr.length, Sr = 0, zt = Math.min(gr, br);
      Sr < zt;
      ++Sr
    )
      if (nr[Sr] !== fr[Sr]) {
        ;(gr = nr[Sr]), (br = fr[Sr])
        break
      }
    return gr < br ? -1 : br < gr ? 1 : 0
  }
  var Tt = !0,
    kt = !1,
    Ot = 0,
    Nt = 1,
    $t = 2,
    Pt = 3
  function Ft(nr, fr) {
    return _e
      ? nr.source === fr.source && nr.flags === fr.flags
      : RegExp.prototype.toString.call(nr) ===
          RegExp.prototype.toString.call(fr)
  }
  function Vt(nr, fr) {
    if (nr.byteLength !== fr.byteLength) return !1
    for (var gr = 0; gr < nr.byteLength; gr++) if (nr[gr] !== fr[gr]) return !1
    return !0
  }
  function Xt(nr, fr) {
    return nr.byteLength !== fr.byteLength
      ? !1
      : Wt(
          new Uint8Array(nr.buffer, nr.byteOffset, nr.byteLength),
          new Uint8Array(fr.buffer, fr.byteOffset, fr.byteLength)
        ) === 0
  }
  function Yt(nr, fr) {
    return (
      nr.byteLength === fr.byteLength &&
      Wt(new Uint8Array(nr), new Uint8Array(fr)) === 0
    )
  }
  function xt(nr, fr) {
    return wt(nr)
      ? wt(fr) &&
          rt(
            Number.prototype.valueOf.call(nr),
            Number.prototype.valueOf.call(fr)
          )
      : Ct(nr)
      ? Ct(fr) &&
        String.prototype.valueOf.call(nr) === String.prototype.valueOf.call(fr)
      : Dt(nr)
      ? Dt(fr) &&
        Boolean.prototype.valueOf.call(nr) ===
          Boolean.prototype.valueOf.call(fr)
      : jt(nr)
      ? jt(fr) &&
        BigInt.prototype.valueOf.call(nr) === BigInt.prototype.valueOf.call(fr)
      : Et(fr) &&
        Symbol.prototype.valueOf.call(nr) === Symbol.prototype.valueOf.call(fr)
  }
  function It(nr, fr, gr, br) {
    if (nr === fr) return nr !== 0 ? !0 : gr ? rt(nr, fr) : !0
    if (gr) {
      if (j(nr) !== 'object') return typeof nr == 'number' && it(nr) && it(fr)
      if (
        j(fr) !== 'object' ||
        nr === null ||
        fr === null ||
        Object.getPrototypeOf(nr) !== Object.getPrototypeOf(fr)
      )
        return !1
    } else {
      if (nr === null || j(nr) !== 'object')
        return fr === null || j(fr) !== 'object' ? nr == fr : !1
      if (fr === null || j(fr) !== 'object') return !1
    }
    var Sr = ut(nr),
      zt = ut(fr)
    if (Sr !== zt) return !1
    if (Array.isArray(nr)) {
      if (nr.length !== fr.length) return !1
      var bt = Ut(nr),
        Rt = Ut(fr)
      return bt.length !== Rt.length ? !1 : Qt(nr, fr, gr, br, Nt, bt)
    }
    if (
      Sr === '[object Object]' &&
      ((!vt(nr) && vt(fr)) || (!pt(nr) && pt(fr)))
    )
      return !1
    if (mt(nr)) {
      if (
        !mt(fr) ||
        Date.prototype.getTime.call(nr) !== Date.prototype.getTime.call(fr)
      )
        return !1
    } else if (yt(nr)) {
      if (!yt(fr) || !Ft(nr, fr)) return !1
    } else if (ht(nr) || nr instanceof Error) {
      if (nr.message !== fr.message || nr.name !== fr.name) return !1
    } else if (ft(nr)) {
      if (!gr && (St(nr) || Bt(nr))) {
        if (!Vt(nr, fr)) return !1
      } else if (!Xt(nr, fr)) return !1
      var qt = Ut(nr),
        rr = Ut(fr)
      return qt.length !== rr.length ? !1 : Qt(nr, fr, gr, br, Ot, qt)
    } else {
      if (pt(nr))
        return !pt(fr) || nr.size !== fr.size ? !1 : Qt(nr, fr, gr, br, $t)
      if (vt(nr))
        return !vt(fr) || nr.size !== fr.size ? !1 : Qt(nr, fr, gr, br, Pt)
      if (dt(nr)) {
        if (!Yt(nr, fr)) return !1
      } else if (At(nr) && !xt(nr, fr)) return !1
    }
    return Qt(nr, fr, gr, br, Ot)
  }
  function Kt(nr, fr) {
    return fr.filter(function(gr) {
      return st(nr, gr)
    })
  }
  function Qt(nr, fr, gr, br, Sr, zt) {
    if (arguments.length === 5) {
      zt = Object.keys(nr)
      var bt = Object.keys(fr)
      if (zt.length !== bt.length) return !1
    }
    for (var Rt = 0; Rt < zt.length; Rt++) if (!at(fr, zt[Rt])) return !1
    if (gr && arguments.length === 5) {
      var qt = nt(nr)
      if (qt.length !== 0) {
        var rr = 0
        for (Rt = 0; Rt < qt.length; Rt++) {
          var ar = qt[Rt]
          if (st(nr, ar)) {
            if (!st(fr, ar)) return !1
            zt.push(ar), rr++
          } else if (st(fr, ar)) return !1
        }
        var ir = nt(fr)
        if (qt.length !== ir.length && Kt(fr, ir).length !== rr) return !1
      } else {
        var Tr = nt(fr)
        if (Tr.length !== 0 && Kt(fr, Tr).length !== 0) return !1
      }
    }
    if (
      zt.length === 0 &&
      (Sr === Ot || (Sr === Nt && nr.length === 0) || nr.size === 0)
    )
      return !0
    if (br === void 0) br = { val1: new Map(), val2: new Map(), position: 0 }
    else {
      var vr = br.val1.get(nr)
      if (vr !== void 0) {
        var Ar = br.val2.get(fr)
        if (Ar !== void 0) return vr === Ar
      }
      br.position++
    }
    br.val1.set(nr, br.position), br.val2.set(fr, br.position)
    var Nr = ur(nr, fr, gr, zt, br, Sr)
    return br.val1.delete(nr), br.val2.delete(fr), Nr
  }
  function Ht(nr, fr, gr, br) {
    for (var Sr = et(nr), zt = 0; zt < Sr.length; zt++) {
      var bt = Sr[zt]
      if (It(fr, bt, gr, br)) return nr.delete(bt), !0
    }
    return !1
  }
  function Lt(nr) {
    switch (j(nr)) {
      case 'undefined':
        return null
      case 'object':
        return
      case 'symbol':
        return !1
      case 'string':
        nr = +nr
      case 'number':
        if (it(nr)) return !1
    }
    return !0
  }
  function tr(nr, fr, gr) {
    var br = Lt(gr)
    return br ?? (fr.has(br) && !nr.has(br))
  }
  function lr(nr, fr, gr, br, Sr) {
    var zt = Lt(gr)
    if (zt != null) return zt
    var bt = fr.get(zt)
    return (bt === void 0 && !fr.has(zt)) || !It(br, bt, !1, Sr)
      ? !1
      : !nr.has(zt) && It(br, bt, !1, Sr)
  }
  function yr(nr, fr, gr, br) {
    for (var Sr = null, zt = et(nr), bt = 0; bt < zt.length; bt++) {
      var Rt = zt[bt]
      if (j(Rt) === 'object' && Rt !== null)
        Sr === null && (Sr = new Set()), Sr.add(Rt)
      else if (!fr.has(Rt)) {
        if (gr || !tr(nr, fr, Rt)) return !1
        Sr === null && (Sr = new Set()), Sr.add(Rt)
      }
    }
    if (Sr !== null) {
      for (var qt = et(fr), rr = 0; rr < qt.length; rr++) {
        var ar = qt[rr]
        if (j(ar) === 'object' && ar !== null) {
          if (!Ht(Sr, ar, gr, br)) return !1
        } else if (!gr && !nr.has(ar) && !Ht(Sr, ar, gr, br)) return !1
      }
      return Sr.size === 0
    }
    return !0
  }
  function mr(nr, fr, gr, br, Sr, zt) {
    for (var bt = et(nr), Rt = 0; Rt < bt.length; Rt++) {
      var qt = bt[Rt]
      if (It(gr, qt, Sr, zt) && It(br, fr.get(qt), Sr, zt))
        return nr.delete(qt), !0
    }
    return !1
  }
  function Er(nr, fr, gr, br) {
    for (var Sr = null, zt = tt(nr), bt = 0; bt < zt.length; bt++) {
      var Rt = o(zt[bt], 2),
        qt = Rt[0],
        rr = Rt[1]
      if (j(qt) === 'object' && qt !== null)
        Sr === null && (Sr = new Set()), Sr.add(qt)
      else {
        var ar = fr.get(qt)
        if ((ar === void 0 && !fr.has(qt)) || !It(rr, ar, gr, br)) {
          if (gr || !lr(nr, fr, qt, rr, br)) return !1
          Sr === null && (Sr = new Set()), Sr.add(qt)
        }
      }
    }
    if (Sr !== null) {
      for (var ir = tt(fr), Tr = 0; Tr < ir.length; Tr++) {
        var vr = o(ir[Tr], 2),
          qt = vr[0],
          Ar = vr[1]
        if (j(qt) === 'object' && qt !== null) {
          if (!mr(Sr, nr, qt, Ar, gr, br)) return !1
        } else if (
          !gr &&
          (!nr.has(qt) || !It(nr.get(qt), Ar, !1, br)) &&
          !mr(Sr, nr, qt, Ar, !1, br)
        )
          return !1
      }
      return Sr.size === 0
    }
    return !0
  }
  function ur(nr, fr, gr, br, Sr, zt) {
    var bt = 0
    if (zt === $t) {
      if (!yr(nr, fr, gr, Sr)) return !1
    } else if (zt === Pt) {
      if (!Er(nr, fr, gr, Sr)) return !1
    } else if (zt === Nt)
      for (; bt < nr.length; bt++)
        if (at(nr, bt)) {
          if (!at(fr, bt) || !It(nr[bt], fr[bt], gr, Sr)) return !1
        } else {
          if (at(fr, bt)) return !1
          for (var Rt = Object.keys(nr); bt < Rt.length; bt++) {
            var qt = Rt[bt]
            if (!at(fr, qt) || !It(nr[qt], fr[qt], gr, Sr)) return !1
          }
          return Rt.length === Object.keys(fr).length
        }
    for (bt = 0; bt < br.length; bt++) {
      var rr = br[bt]
      if (!It(nr[rr], fr[rr], gr, Sr)) return !1
    }
    return !0
  }
  function _r(nr, fr) {
    return It(nr, fr, kt)
  }
  function Rr(nr, fr) {
    return It(nr, fr, Tt)
  }
  return (comparisons = { isDeepEqual: _r, isDeepStrictEqual: Rr }), comparisons
}
var hasRequiredAssert
function requireAssert() {
  if (hasRequiredAssert) return assert.exports
  hasRequiredAssert = 1
  function o(Nt) {
    return (
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? (o = function(Pt) {
            return typeof Pt
          })
        : (o = function(Pt) {
            return Pt &&
              typeof Symbol == 'function' &&
              Pt.constructor === Symbol &&
              Pt !== Symbol.prototype
              ? 'symbol'
              : typeof Pt
          }),
      o(Nt)
    )
  }
  function a(Nt, $t) {
    if (!(Nt instanceof $t))
      throw new TypeError('Cannot call a class as a function')
  }
  var s = requireErrors(),
    $ = s.codes,
    j = $.ERR_AMBIGUOUS_ARGUMENT,
    _e = $.ERR_INVALID_ARG_TYPE,
    et = $.ERR_INVALID_ARG_VALUE,
    tt = $.ERR_INVALID_RETURN_VALUE,
    rt = $.ERR_MISSING_ARGS,
    nt = requireAssertion_error(),
    it = util$u,
    ot = it.inspect,
    at = util$u.types,
    st = at.isPromise,
    ut = at.isRegExp,
    ct = Object.assign ? Object.assign : requireEs6ObjectAssign().assign,
    dt = Object.is ? Object.is : requireObjectIs(),
    ft,
    mt
  function vt() {
    var Nt = requireComparisons()
    ;(ft = Nt.isDeepEqual), (mt = Nt.isDeepStrictEqual)
  }
  var yt = !1,
    pt = (assert.exports = Dt),
    ht = {}
  function At(Nt) {
    throw Nt.message instanceof Error ? Nt.message : new nt(Nt)
  }
  function wt(Nt, $t, Pt, Ft, Vt) {
    var Xt = arguments.length,
      Yt
    if (Xt === 0) Yt = 'Failed'
    else if (Xt === 1) (Pt = Nt), (Nt = void 0)
    else {
      if (yt === !1) {
        yt = !0
        var xt = process.emitWarning
          ? process.emitWarning
          : console.warn.bind(console)
        xt(
          'assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.',
          'DeprecationWarning',
          'DEP0094'
        )
      }
      Xt === 2 && (Ft = '!=')
    }
    if (Pt instanceof Error) throw Pt
    var It = {
      actual: Nt,
      expected: $t,
      operator: Ft === void 0 ? 'fail' : Ft,
      stackStartFn: Vt || wt,
    }
    Pt !== void 0 && (It.message = Pt)
    var Kt = new nt(It)
    throw (Yt && ((Kt.message = Yt), (Kt.generatedMessage = !0)), Kt)
  }
  ;(pt.fail = wt), (pt.AssertionError = nt)
  function Ct(Nt, $t, Pt, Ft) {
    if (!Pt) {
      var Vt = !1
      if ($t === 0)
        (Vt = !0), (Ft = 'No value argument passed to `assert.ok()`')
      else if (Ft instanceof Error) throw Ft
      var Xt = new nt({
        actual: Pt,
        expected: !0,
        message: Ft,
        operator: '==',
        stackStartFn: Nt,
      })
      throw ((Xt.generatedMessage = Vt), Xt)
    }
  }
  function Dt() {
    for (var Nt = arguments.length, $t = new Array(Nt), Pt = 0; Pt < Nt; Pt++)
      $t[Pt] = arguments[Pt]
    Ct.apply(void 0, [Dt, $t.length].concat($t))
  }
  ;(pt.ok = Dt),
    (pt.equal = function Nt($t, Pt, Ft) {
      if (arguments.length < 2) throw new rt('actual', 'expected')
      $t != Pt &&
        At({
          actual: $t,
          expected: Pt,
          message: Ft,
          operator: '==',
          stackStartFn: Nt,
        })
    }),
    (pt.notEqual = function Nt($t, Pt, Ft) {
      if (arguments.length < 2) throw new rt('actual', 'expected')
      $t == Pt &&
        At({
          actual: $t,
          expected: Pt,
          message: Ft,
          operator: '!=',
          stackStartFn: Nt,
        })
    }),
    (pt.deepEqual = function Nt($t, Pt, Ft) {
      if (arguments.length < 2) throw new rt('actual', 'expected')
      ft === void 0 && vt(),
        ft($t, Pt) ||
          At({
            actual: $t,
            expected: Pt,
            message: Ft,
            operator: 'deepEqual',
            stackStartFn: Nt,
          })
    }),
    (pt.notDeepEqual = function Nt($t, Pt, Ft) {
      if (arguments.length < 2) throw new rt('actual', 'expected')
      ft === void 0 && vt(),
        ft($t, Pt) &&
          At({
            actual: $t,
            expected: Pt,
            message: Ft,
            operator: 'notDeepEqual',
            stackStartFn: Nt,
          })
    }),
    (pt.deepStrictEqual = function Nt($t, Pt, Ft) {
      if (arguments.length < 2) throw new rt('actual', 'expected')
      ft === void 0 && vt(),
        mt($t, Pt) ||
          At({
            actual: $t,
            expected: Pt,
            message: Ft,
            operator: 'deepStrictEqual',
            stackStartFn: Nt,
          })
    }),
    (pt.notDeepStrictEqual = jt)
  function jt(Nt, $t, Pt) {
    if (arguments.length < 2) throw new rt('actual', 'expected')
    ft === void 0 && vt(),
      mt(Nt, $t) &&
        At({
          actual: Nt,
          expected: $t,
          message: Pt,
          operator: 'notDeepStrictEqual',
          stackStartFn: jt,
        })
  }
  ;(pt.strictEqual = function Nt($t, Pt, Ft) {
    if (arguments.length < 2) throw new rt('actual', 'expected')
    dt($t, Pt) ||
      At({
        actual: $t,
        expected: Pt,
        message: Ft,
        operator: 'strictEqual',
        stackStartFn: Nt,
      })
  }),
    (pt.notStrictEqual = function Nt($t, Pt, Ft) {
      if (arguments.length < 2) throw new rt('actual', 'expected')
      dt($t, Pt) &&
        At({
          actual: $t,
          expected: Pt,
          message: Ft,
          operator: 'notStrictEqual',
          stackStartFn: Nt,
        })
    })
  var Et = function Nt($t, Pt, Ft) {
    var Vt = this
    a(this, Nt),
      Pt.forEach(function(Xt) {
        Xt in $t &&
          (Ft !== void 0 &&
          typeof Ft[Xt] == 'string' &&
          ut($t[Xt]) &&
          $t[Xt].test(Ft[Xt])
            ? (Vt[Xt] = Ft[Xt])
            : (Vt[Xt] = $t[Xt]))
      })
  }
  function St(Nt, $t, Pt, Ft, Vt, Xt) {
    if (!(Pt in Nt) || !mt(Nt[Pt], $t[Pt])) {
      if (!Ft) {
        var Yt = new Et(Nt, Vt),
          xt = new Et($t, Vt, Nt),
          It = new nt({
            actual: Yt,
            expected: xt,
            operator: 'deepStrictEqual',
            stackStartFn: Xt,
          })
        throw ((It.actual = Nt),
        (It.expected = $t),
        (It.operator = Xt.name),
        It)
      }
      At({
        actual: Nt,
        expected: $t,
        message: Ft,
        operator: Xt.name,
        stackStartFn: Xt,
      })
    }
  }
  function Bt(Nt, $t, Pt, Ft) {
    if (typeof $t != 'function') {
      if (ut($t)) return $t.test(Nt)
      if (arguments.length === 2)
        throw new _e('expected', ['Function', 'RegExp'], $t)
      if (o(Nt) !== 'object' || Nt === null) {
        var Vt = new nt({
          actual: Nt,
          expected: $t,
          message: Pt,
          operator: 'deepStrictEqual',
          stackStartFn: Ft,
        })
        throw ((Vt.operator = Ft.name), Vt)
      }
      var Xt = Object.keys($t)
      if ($t instanceof Error) Xt.push('name', 'message')
      else if (Xt.length === 0)
        throw new et('error', $t, 'may not be an empty object')
      return (
        ft === void 0 && vt(),
        Xt.forEach(function(Yt) {
          ;(typeof Nt[Yt] == 'string' && ut($t[Yt]) && $t[Yt].test(Nt[Yt])) ||
            St(Nt, $t, Yt, Pt, Xt, Ft)
        }),
        !0
      )
    }
    return $t.prototype !== void 0 && Nt instanceof $t
      ? !0
      : Error.isPrototypeOf($t)
      ? !1
      : $t.call({}, Nt) === !0
  }
  function Mt(Nt) {
    if (typeof Nt != 'function') throw new _e('fn', 'Function', Nt)
    try {
      Nt()
    } catch ($t) {
      return $t
    }
    return ht
  }
  function Ut(Nt) {
    return (
      st(Nt) ||
      (Nt !== null &&
        o(Nt) === 'object' &&
        typeof Nt.then == 'function' &&
        typeof Nt.catch == 'function')
    )
  }
  function Wt(Nt) {
    return Promise.resolve().then(function() {
      var $t
      if (typeof Nt == 'function') {
        if ((($t = Nt()), !Ut($t)))
          throw new tt('instance of Promise', 'promiseFn', $t)
      } else if (Ut(Nt)) $t = Nt
      else throw new _e('promiseFn', ['Function', 'Promise'], Nt)
      return Promise.resolve()
        .then(function() {
          return $t
        })
        .then(function() {
          return ht
        })
        .catch(function(Pt) {
          return Pt
        })
    })
  }
  function Tt(Nt, $t, Pt, Ft) {
    if (typeof Pt == 'string') {
      if (arguments.length === 4)
        throw new _e('error', ['Object', 'Error', 'Function', 'RegExp'], Pt)
      if (o($t) === 'object' && $t !== null) {
        if ($t.message === Pt)
          throw new j(
            'error/message',
            'The error message "'.concat(
              $t.message,
              '" is identical to the message.'
            )
          )
      } else if ($t === Pt)
        throw new j(
          'error/message',
          'The error "'.concat($t, '" is identical to the message.')
        )
      ;(Ft = Pt), (Pt = void 0)
    } else if (Pt != null && o(Pt) !== 'object' && typeof Pt != 'function')
      throw new _e('error', ['Object', 'Error', 'Function', 'RegExp'], Pt)
    if ($t === ht) {
      var Vt = ''
      Pt && Pt.name && (Vt += ' ('.concat(Pt.name, ')')),
        (Vt += Ft ? ': '.concat(Ft) : '.')
      var Xt = Nt.name === 'rejects' ? 'rejection' : 'exception'
      At({
        actual: void 0,
        expected: Pt,
        operator: Nt.name,
        message: 'Missing expected '.concat(Xt).concat(Vt),
        stackStartFn: Nt,
      })
    }
    if (Pt && !Bt($t, Pt, Ft, Nt)) throw $t
  }
  function kt(Nt, $t, Pt, Ft) {
    if ($t !== ht) {
      if (
        (typeof Pt == 'string' && ((Ft = Pt), (Pt = void 0)), !Pt || Bt($t, Pt))
      ) {
        var Vt = Ft ? ': '.concat(Ft) : '.',
          Xt = Nt.name === 'doesNotReject' ? 'rejection' : 'exception'
        At({
          actual: $t,
          expected: Pt,
          operator: Nt.name,
          message:
            'Got unwanted '.concat(Xt).concat(
              Vt,
              `
`
            ) + 'Actual message: "'.concat($t && $t.message, '"'),
          stackStartFn: Nt,
        })
      }
      throw $t
    }
  }
  ;(pt.throws = function Nt($t) {
    for (
      var Pt = arguments.length, Ft = new Array(Pt > 1 ? Pt - 1 : 0), Vt = 1;
      Vt < Pt;
      Vt++
    )
      Ft[Vt - 1] = arguments[Vt]
    Tt.apply(void 0, [Nt, Mt($t)].concat(Ft))
  }),
    (pt.rejects = function Nt($t) {
      for (
        var Pt = arguments.length, Ft = new Array(Pt > 1 ? Pt - 1 : 0), Vt = 1;
        Vt < Pt;
        Vt++
      )
        Ft[Vt - 1] = arguments[Vt]
      return Wt($t).then(function(Xt) {
        return Tt.apply(void 0, [Nt, Xt].concat(Ft))
      })
    }),
    (pt.doesNotThrow = function Nt($t) {
      for (
        var Pt = arguments.length, Ft = new Array(Pt > 1 ? Pt - 1 : 0), Vt = 1;
        Vt < Pt;
        Vt++
      )
        Ft[Vt - 1] = arguments[Vt]
      kt.apply(void 0, [Nt, Mt($t)].concat(Ft))
    }),
    (pt.doesNotReject = function Nt($t) {
      for (
        var Pt = arguments.length, Ft = new Array(Pt > 1 ? Pt - 1 : 0), Vt = 1;
        Vt < Pt;
        Vt++
      )
        Ft[Vt - 1] = arguments[Vt]
      return Wt($t).then(function(Xt) {
        return kt.apply(void 0, [Nt, Xt].concat(Ft))
      })
    }),
    (pt.ifError = function Nt($t) {
      if ($t != null) {
        var Pt = 'ifError got unwanted exception: '
        o($t) === 'object' && typeof $t.message == 'string'
          ? $t.message.length === 0 && $t.constructor
            ? (Pt += $t.constructor.name)
            : (Pt += $t.message)
          : (Pt += ot($t))
        var Ft = new nt({
            actual: $t,
            expected: null,
            operator: 'ifError',
            message: Pt,
            stackStartFn: Nt,
          }),
          Vt = $t.stack
        if (typeof Vt == 'string') {
          var Xt = Vt.split(`
`)
          Xt.shift()
          for (
            var Yt = Ft.stack.split(`
`),
              xt = 0;
            xt < Xt.length;
            xt++
          ) {
            var It = Yt.indexOf(Xt[xt])
            if (It !== -1) {
              Yt = Yt.slice(0, It)
              break
            }
          }
          Ft.stack = ''
            .concat(
              Yt.join(`
`),
              `
`
            )
            .concat(
              Xt.join(`
`)
            )
        }
        throw Ft
      }
    })
  function Ot() {
    for (var Nt = arguments.length, $t = new Array(Nt), Pt = 0; Pt < Nt; Pt++)
      $t[Pt] = arguments[Pt]
    Ct.apply(void 0, [Ot, $t.length].concat($t))
  }
  return (
    (pt.strict = ct(Ot, pt, {
      equal: pt.strictEqual,
      deepEqual: pt.deepStrictEqual,
      notEqual: pt.notStrictEqual,
      notDeepEqual: pt.notDeepStrictEqual,
    })),
    (pt.strict.strict = pt.strict),
    assert.exports
  )
}
function ZStream() {
  ;(this.input = null),
    (this.next_in = 0),
    (this.avail_in = 0),
    (this.total_in = 0),
    (this.output = null),
    (this.next_out = 0),
    (this.avail_out = 0),
    (this.total_out = 0),
    (this.msg = ''),
    (this.state = null),
    (this.data_type = 2),
    (this.adler = 0)
}
var zstream = ZStream,
  deflate$1 = {},
  common = {}
;(function(o) {
  var a =
    typeof Uint8Array < 'u' &&
    typeof Uint16Array < 'u' &&
    typeof Int32Array < 'u'
  function s(_e, et) {
    return Object.prototype.hasOwnProperty.call(_e, et)
  }
  ;(o.assign = function(_e) {
    for (var et = Array.prototype.slice.call(arguments, 1); et.length; ) {
      var tt = et.shift()
      if (tt) {
        if (typeof tt != 'object')
          throw new TypeError(tt + 'must be non-object')
        for (var rt in tt) s(tt, rt) && (_e[rt] = tt[rt])
      }
    }
    return _e
  }),
    (o.shrinkBuf = function(_e, et) {
      return _e.length === et
        ? _e
        : _e.subarray
        ? _e.subarray(0, et)
        : ((_e.length = et), _e)
    })
  var $ = {
      arraySet: function(_e, et, tt, rt, nt) {
        if (et.subarray && _e.subarray) {
          _e.set(et.subarray(tt, tt + rt), nt)
          return
        }
        for (var it = 0; it < rt; it++) _e[nt + it] = et[tt + it]
      },
      flattenChunks: function(_e) {
        var et, tt, rt, nt, it, ot
        for (rt = 0, et = 0, tt = _e.length; et < tt; et++) rt += _e[et].length
        for (
          ot = new Uint8Array(rt), nt = 0, et = 0, tt = _e.length;
          et < tt;
          et++
        )
          (it = _e[et]), ot.set(it, nt), (nt += it.length)
        return ot
      },
    },
    j = {
      arraySet: function(_e, et, tt, rt, nt) {
        for (var it = 0; it < rt; it++) _e[nt + it] = et[tt + it]
      },
      flattenChunks: function(_e) {
        return [].concat.apply([], _e)
      },
    }
  ;(o.setTyped = function(_e) {
    _e
      ? ((o.Buf8 = Uint8Array),
        (o.Buf16 = Uint16Array),
        (o.Buf32 = Int32Array),
        o.assign(o, $))
      : ((o.Buf8 = Array), (o.Buf16 = Array), (o.Buf32 = Array), o.assign(o, j))
  }),
    o.setTyped(a)
})(common)
var trees$1 = {},
  utils$3 = common,
  Z_FIXED$1 = 4,
  Z_BINARY = 0,
  Z_TEXT = 1,
  Z_UNKNOWN$1 = 2
function zero$1(o) {
  for (var a = o.length; --a >= 0; ) o[a] = 0
}
var STORED_BLOCK = 0,
  STATIC_TREES = 1,
  DYN_TREES = 2,
  MIN_MATCH$1 = 3,
  MAX_MATCH$1 = 258,
  LENGTH_CODES$1 = 29,
  LITERALS$1 = 256,
  L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1,
  D_CODES$1 = 30,
  BL_CODES$1 = 19,
  HEAP_SIZE$1 = 2 * L_CODES$1 + 1,
  MAX_BITS$1 = 15,
  Buf_size = 16,
  MAX_BL_BITS = 7,
  END_BLOCK = 256,
  REP_3_6 = 16,
  REPZ_3_10 = 17,
  REPZ_11_138 = 18,
  extra_lbits = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
  ],
  extra_dbits = [
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
  ],
  extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
  bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
  DIST_CODE_LEN = 512,
  static_ltree = new Array((L_CODES$1 + 2) * 2)
zero$1(static_ltree)
var static_dtree = new Array(D_CODES$1 * 2)
zero$1(static_dtree)
var _dist_code = new Array(DIST_CODE_LEN)
zero$1(_dist_code)
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1)
zero$1(_length_code)
var base_length = new Array(LENGTH_CODES$1)
zero$1(base_length)
var base_dist = new Array(D_CODES$1)
zero$1(base_dist)
function StaticTreeDesc(o, a, s, $, j) {
  ;(this.static_tree = o),
    (this.extra_bits = a),
    (this.extra_base = s),
    (this.elems = $),
    (this.max_length = j),
    (this.has_stree = o && o.length)
}
var static_l_desc, static_d_desc, static_bl_desc
function TreeDesc(o, a) {
  ;(this.dyn_tree = o), (this.max_code = 0), (this.stat_desc = a)
}
function d_code(o) {
  return o < 256 ? _dist_code[o] : _dist_code[256 + (o >>> 7)]
}
function put_short(o, a) {
  ;(o.pending_buf[o.pending++] = a & 255),
    (o.pending_buf[o.pending++] = (a >>> 8) & 255)
}
function send_bits(o, a, s) {
  o.bi_valid > Buf_size - s
    ? ((o.bi_buf |= (a << o.bi_valid) & 65535),
      put_short(o, o.bi_buf),
      (o.bi_buf = a >> (Buf_size - o.bi_valid)),
      (o.bi_valid += s - Buf_size))
    : ((o.bi_buf |= (a << o.bi_valid) & 65535), (o.bi_valid += s))
}
function send_code(o, a, s) {
  send_bits(o, s[a * 2], s[a * 2 + 1])
}
function bi_reverse(o, a) {
  var s = 0
  do (s |= o & 1), (o >>>= 1), (s <<= 1)
  while (--a > 0)
  return s >>> 1
}
function bi_flush(o) {
  o.bi_valid === 16
    ? (put_short(o, o.bi_buf), (o.bi_buf = 0), (o.bi_valid = 0))
    : o.bi_valid >= 8 &&
      ((o.pending_buf[o.pending++] = o.bi_buf & 255),
      (o.bi_buf >>= 8),
      (o.bi_valid -= 8))
}
function gen_bitlen(o, a) {
  var s = a.dyn_tree,
    $ = a.max_code,
    j = a.stat_desc.static_tree,
    _e = a.stat_desc.has_stree,
    et = a.stat_desc.extra_bits,
    tt = a.stat_desc.extra_base,
    rt = a.stat_desc.max_length,
    nt,
    it,
    ot,
    at,
    st,
    ut,
    ct = 0
  for (at = 0; at <= MAX_BITS$1; at++) o.bl_count[at] = 0
  for (
    s[o.heap[o.heap_max] * 2 + 1] = 0, nt = o.heap_max + 1;
    nt < HEAP_SIZE$1;
    nt++
  )
    (it = o.heap[nt]),
      (at = s[s[it * 2 + 1] * 2 + 1] + 1),
      at > rt && ((at = rt), ct++),
      (s[it * 2 + 1] = at),
      !(it > $) &&
        (o.bl_count[at]++,
        (st = 0),
        it >= tt && (st = et[it - tt]),
        (ut = s[it * 2]),
        (o.opt_len += ut * (at + st)),
        _e && (o.static_len += ut * (j[it * 2 + 1] + st)))
  if (ct !== 0) {
    do {
      for (at = rt - 1; o.bl_count[at] === 0; ) at--
      o.bl_count[at]--, (o.bl_count[at + 1] += 2), o.bl_count[rt]--, (ct -= 2)
    } while (ct > 0)
    for (at = rt; at !== 0; at--)
      for (it = o.bl_count[at]; it !== 0; )
        (ot = o.heap[--nt]),
          !(ot > $) &&
            (s[ot * 2 + 1] !== at &&
              ((o.opt_len += (at - s[ot * 2 + 1]) * s[ot * 2]),
              (s[ot * 2 + 1] = at)),
            it--)
  }
}
function gen_codes(o, a, s) {
  var $ = new Array(MAX_BITS$1 + 1),
    j = 0,
    _e,
    et
  for (_e = 1; _e <= MAX_BITS$1; _e++) $[_e] = j = (j + s[_e - 1]) << 1
  for (et = 0; et <= a; et++) {
    var tt = o[et * 2 + 1]
    tt !== 0 && (o[et * 2] = bi_reverse($[tt]++, tt))
  }
}
function tr_static_init() {
  var o,
    a,
    s,
    $,
    j,
    _e = new Array(MAX_BITS$1 + 1)
  for (s = 0, $ = 0; $ < LENGTH_CODES$1 - 1; $++)
    for (base_length[$] = s, o = 0; o < 1 << extra_lbits[$]; o++)
      _length_code[s++] = $
  for (_length_code[s - 1] = $, j = 0, $ = 0; $ < 16; $++)
    for (base_dist[$] = j, o = 0; o < 1 << extra_dbits[$]; o++)
      _dist_code[j++] = $
  for (j >>= 7; $ < D_CODES$1; $++)
    for (base_dist[$] = j << 7, o = 0; o < 1 << (extra_dbits[$] - 7); o++)
      _dist_code[256 + j++] = $
  for (a = 0; a <= MAX_BITS$1; a++) _e[a] = 0
  for (o = 0; o <= 143; ) (static_ltree[o * 2 + 1] = 8), o++, _e[8]++
  for (; o <= 255; ) (static_ltree[o * 2 + 1] = 9), o++, _e[9]++
  for (; o <= 279; ) (static_ltree[o * 2 + 1] = 7), o++, _e[7]++
  for (; o <= 287; ) (static_ltree[o * 2 + 1] = 8), o++, _e[8]++
  for (gen_codes(static_ltree, L_CODES$1 + 1, _e), o = 0; o < D_CODES$1; o++)
    (static_dtree[o * 2 + 1] = 5), (static_dtree[o * 2] = bi_reverse(o, 5))
  ;(static_l_desc = new StaticTreeDesc(
    static_ltree,
    extra_lbits,
    LITERALS$1 + 1,
    L_CODES$1,
    MAX_BITS$1
  )),
    (static_d_desc = new StaticTreeDesc(
      static_dtree,
      extra_dbits,
      0,
      D_CODES$1,
      MAX_BITS$1
    )),
    (static_bl_desc = new StaticTreeDesc(
      new Array(0),
      extra_blbits,
      0,
      BL_CODES$1,
      MAX_BL_BITS
    ))
}
function init_block(o) {
  var a
  for (a = 0; a < L_CODES$1; a++) o.dyn_ltree[a * 2] = 0
  for (a = 0; a < D_CODES$1; a++) o.dyn_dtree[a * 2] = 0
  for (a = 0; a < BL_CODES$1; a++) o.bl_tree[a * 2] = 0
  ;(o.dyn_ltree[END_BLOCK * 2] = 1),
    (o.opt_len = o.static_len = 0),
    (o.last_lit = o.matches = 0)
}
function bi_windup(o) {
  o.bi_valid > 8
    ? put_short(o, o.bi_buf)
    : o.bi_valid > 0 && (o.pending_buf[o.pending++] = o.bi_buf),
    (o.bi_buf = 0),
    (o.bi_valid = 0)
}
function copy_block(o, a, s, $) {
  bi_windup(o),
    put_short(o, s),
    put_short(o, ~s),
    utils$3.arraySet(o.pending_buf, o.window, a, s, o.pending),
    (o.pending += s)
}
function smaller(o, a, s, $) {
  var j = a * 2,
    _e = s * 2
  return o[j] < o[_e] || (o[j] === o[_e] && $[a] <= $[s])
}
function pqdownheap(o, a, s) {
  for (
    var $ = o.heap[s], j = s << 1;
    j <= o.heap_len &&
    (j < o.heap_len && smaller(a, o.heap[j + 1], o.heap[j], o.depth) && j++,
    !smaller(a, $, o.heap[j], o.depth));

  )
    (o.heap[s] = o.heap[j]), (s = j), (j <<= 1)
  o.heap[s] = $
}
function compress_block(o, a, s) {
  var $,
    j,
    _e = 0,
    et,
    tt
  if (o.last_lit !== 0)
    do
      ($ =
        (o.pending_buf[o.d_buf + _e * 2] << 8) |
        o.pending_buf[o.d_buf + _e * 2 + 1]),
        (j = o.pending_buf[o.l_buf + _e]),
        _e++,
        $ === 0
          ? send_code(o, j, a)
          : ((et = _length_code[j]),
            send_code(o, et + LITERALS$1 + 1, a),
            (tt = extra_lbits[et]),
            tt !== 0 && ((j -= base_length[et]), send_bits(o, j, tt)),
            $--,
            (et = d_code($)),
            send_code(o, et, s),
            (tt = extra_dbits[et]),
            tt !== 0 && (($ -= base_dist[et]), send_bits(o, $, tt)))
    while (_e < o.last_lit)
  send_code(o, END_BLOCK, a)
}
function build_tree(o, a) {
  var s = a.dyn_tree,
    $ = a.stat_desc.static_tree,
    j = a.stat_desc.has_stree,
    _e = a.stat_desc.elems,
    et,
    tt,
    rt = -1,
    nt
  for (o.heap_len = 0, o.heap_max = HEAP_SIZE$1, et = 0; et < _e; et++)
    s[et * 2] !== 0
      ? ((o.heap[++o.heap_len] = rt = et), (o.depth[et] = 0))
      : (s[et * 2 + 1] = 0)
  for (; o.heap_len < 2; )
    (nt = o.heap[++o.heap_len] = rt < 2 ? ++rt : 0),
      (s[nt * 2] = 1),
      (o.depth[nt] = 0),
      o.opt_len--,
      j && (o.static_len -= $[nt * 2 + 1])
  for (a.max_code = rt, et = o.heap_len >> 1; et >= 1; et--)
    pqdownheap(o, s, et)
  nt = _e
  do
    (et = o.heap[1]),
      (o.heap[1] = o.heap[o.heap_len--]),
      pqdownheap(o, s, 1),
      (tt = o.heap[1]),
      (o.heap[--o.heap_max] = et),
      (o.heap[--o.heap_max] = tt),
      (s[nt * 2] = s[et * 2] + s[tt * 2]),
      (o.depth[nt] =
        (o.depth[et] >= o.depth[tt] ? o.depth[et] : o.depth[tt]) + 1),
      (s[et * 2 + 1] = s[tt * 2 + 1] = nt),
      (o.heap[1] = nt++),
      pqdownheap(o, s, 1)
  while (o.heap_len >= 2)
  ;(o.heap[--o.heap_max] = o.heap[1]),
    gen_bitlen(o, a),
    gen_codes(s, rt, o.bl_count)
}
function scan_tree(o, a, s) {
  var $,
    j = -1,
    _e,
    et = a[0 * 2 + 1],
    tt = 0,
    rt = 7,
    nt = 4
  for (
    et === 0 && ((rt = 138), (nt = 3)), a[(s + 1) * 2 + 1] = 65535, $ = 0;
    $ <= s;
    $++
  )
    (_e = et),
      (et = a[($ + 1) * 2 + 1]),
      !(++tt < rt && _e === et) &&
        (tt < nt
          ? (o.bl_tree[_e * 2] += tt)
          : _e !== 0
          ? (_e !== j && o.bl_tree[_e * 2]++, o.bl_tree[REP_3_6 * 2]++)
          : tt <= 10
          ? o.bl_tree[REPZ_3_10 * 2]++
          : o.bl_tree[REPZ_11_138 * 2]++,
        (tt = 0),
        (j = _e),
        et === 0
          ? ((rt = 138), (nt = 3))
          : _e === et
          ? ((rt = 6), (nt = 3))
          : ((rt = 7), (nt = 4)))
}
function send_tree(o, a, s) {
  var $,
    j = -1,
    _e,
    et = a[0 * 2 + 1],
    tt = 0,
    rt = 7,
    nt = 4
  for (et === 0 && ((rt = 138), (nt = 3)), $ = 0; $ <= s; $++)
    if (((_e = et), (et = a[($ + 1) * 2 + 1]), !(++tt < rt && _e === et))) {
      if (tt < nt)
        do send_code(o, _e, o.bl_tree)
        while (--tt !== 0)
      else
        _e !== 0
          ? (_e !== j && (send_code(o, _e, o.bl_tree), tt--),
            send_code(o, REP_3_6, o.bl_tree),
            send_bits(o, tt - 3, 2))
          : tt <= 10
          ? (send_code(o, REPZ_3_10, o.bl_tree), send_bits(o, tt - 3, 3))
          : (send_code(o, REPZ_11_138, o.bl_tree), send_bits(o, tt - 11, 7))
      ;(tt = 0),
        (j = _e),
        et === 0
          ? ((rt = 138), (nt = 3))
          : _e === et
          ? ((rt = 6), (nt = 3))
          : ((rt = 7), (nt = 4))
    }
}
function build_bl_tree(o) {
  var a
  for (
    scan_tree(o, o.dyn_ltree, o.l_desc.max_code),
      scan_tree(o, o.dyn_dtree, o.d_desc.max_code),
      build_tree(o, o.bl_desc),
      a = BL_CODES$1 - 1;
    a >= 3 && o.bl_tree[bl_order[a] * 2 + 1] === 0;
    a--
  );
  return (o.opt_len += 3 * (a + 1) + 5 + 5 + 4), a
}
function send_all_trees(o, a, s, $) {
  var j
  for (
    send_bits(o, a - 257, 5),
      send_bits(o, s - 1, 5),
      send_bits(o, $ - 4, 4),
      j = 0;
    j < $;
    j++
  )
    send_bits(o, o.bl_tree[bl_order[j] * 2 + 1], 3)
  send_tree(o, o.dyn_ltree, a - 1), send_tree(o, o.dyn_dtree, s - 1)
}
function detect_data_type(o) {
  var a = 4093624447,
    s
  for (s = 0; s <= 31; s++, a >>>= 1)
    if (a & 1 && o.dyn_ltree[s * 2] !== 0) return Z_BINARY
  if (
    o.dyn_ltree[9 * 2] !== 0 ||
    o.dyn_ltree[10 * 2] !== 0 ||
    o.dyn_ltree[13 * 2] !== 0
  )
    return Z_TEXT
  for (s = 32; s < LITERALS$1; s++) if (o.dyn_ltree[s * 2] !== 0) return Z_TEXT
  return Z_BINARY
}
var static_init_done = !1
function _tr_init(o) {
  static_init_done || (tr_static_init(), (static_init_done = !0)),
    (o.l_desc = new TreeDesc(o.dyn_ltree, static_l_desc)),
    (o.d_desc = new TreeDesc(o.dyn_dtree, static_d_desc)),
    (o.bl_desc = new TreeDesc(o.bl_tree, static_bl_desc)),
    (o.bi_buf = 0),
    (o.bi_valid = 0),
    init_block(o)
}
function _tr_stored_block(o, a, s, $) {
  send_bits(o, (STORED_BLOCK << 1) + ($ ? 1 : 0), 3), copy_block(o, a, s)
}
function _tr_align(o) {
  send_bits(o, STATIC_TREES << 1, 3),
    send_code(o, END_BLOCK, static_ltree),
    bi_flush(o)
}
function _tr_flush_block(o, a, s, $) {
  var j,
    _e,
    et = 0
  o.level > 0
    ? (o.strm.data_type === Z_UNKNOWN$1 &&
        (o.strm.data_type = detect_data_type(o)),
      build_tree(o, o.l_desc),
      build_tree(o, o.d_desc),
      (et = build_bl_tree(o)),
      (j = (o.opt_len + 3 + 7) >>> 3),
      (_e = (o.static_len + 3 + 7) >>> 3),
      _e <= j && (j = _e))
    : (j = _e = s + 5),
    s + 4 <= j && a !== -1
      ? _tr_stored_block(o, a, s, $)
      : o.strategy === Z_FIXED$1 || _e === j
      ? (send_bits(o, (STATIC_TREES << 1) + ($ ? 1 : 0), 3),
        compress_block(o, static_ltree, static_dtree))
      : (send_bits(o, (DYN_TREES << 1) + ($ ? 1 : 0), 3),
        send_all_trees(o, o.l_desc.max_code + 1, o.d_desc.max_code + 1, et + 1),
        compress_block(o, o.dyn_ltree, o.dyn_dtree)),
    init_block(o),
    $ && bi_windup(o)
}
function _tr_tally(o, a, s) {
  return (
    (o.pending_buf[o.d_buf + o.last_lit * 2] = (a >>> 8) & 255),
    (o.pending_buf[o.d_buf + o.last_lit * 2 + 1] = a & 255),
    (o.pending_buf[o.l_buf + o.last_lit] = s & 255),
    o.last_lit++,
    a === 0
      ? o.dyn_ltree[s * 2]++
      : (o.matches++,
        a--,
        o.dyn_ltree[(_length_code[s] + LITERALS$1 + 1) * 2]++,
        o.dyn_dtree[d_code(a) * 2]++),
    o.last_lit === o.lit_bufsize - 1
  )
}
trees$1._tr_init = _tr_init
trees$1._tr_stored_block = _tr_stored_block
trees$1._tr_flush_block = _tr_flush_block
trees$1._tr_tally = _tr_tally
trees$1._tr_align = _tr_align
function adler32$2(o, a, s, $) {
  for (
    var j = (o & 65535) | 0, _e = ((o >>> 16) & 65535) | 0, et = 0;
    s !== 0;

  ) {
    ;(et = s > 2e3 ? 2e3 : s), (s -= et)
    do (j = (j + a[$++]) | 0), (_e = (_e + j) | 0)
    while (--et)
    ;(j %= 65521), (_e %= 65521)
  }
  return j | (_e << 16) | 0
}
var adler32_1 = adler32$2
function makeTable() {
  for (var o, a = [], s = 0; s < 256; s++) {
    o = s
    for (var $ = 0; $ < 8; $++) o = o & 1 ? 3988292384 ^ (o >>> 1) : o >>> 1
    a[s] = o
  }
  return a
}
var crcTable$1 = makeTable()
function crc32$2(o, a, s, $) {
  var j = crcTable$1,
    _e = $ + s
  o ^= -1
  for (var et = $; et < _e; et++) o = (o >>> 8) ^ j[(o ^ a[et]) & 255]
  return o ^ -1
}
var crc32_1 = crc32$2,
  messages$1 = {
    2: 'need dictionary',
    1: 'stream end',
    0: '',
    '-1': 'file error',
    '-2': 'stream error',
    '-3': 'data error',
    '-4': 'insufficient memory',
    '-5': 'buffer error',
    '-6': 'incompatible version',
  },
  utils$2 = common,
  trees = trees$1,
  adler32$1 = adler32_1,
  crc32$1 = crc32_1,
  msg = messages$1,
  Z_NO_FLUSH = 0,
  Z_PARTIAL_FLUSH = 1,
  Z_FULL_FLUSH = 3,
  Z_FINISH$1 = 4,
  Z_BLOCK$1 = 5,
  Z_OK$1 = 0,
  Z_STREAM_END$1 = 1,
  Z_STREAM_ERROR$1 = -2,
  Z_DATA_ERROR$1 = -3,
  Z_BUF_ERROR$1 = -5,
  Z_DEFAULT_COMPRESSION = -1,
  Z_FILTERED = 1,
  Z_HUFFMAN_ONLY = 2,
  Z_RLE = 3,
  Z_FIXED = 4,
  Z_DEFAULT_STRATEGY = 0,
  Z_UNKNOWN = 2,
  Z_DEFLATED$1 = 8,
  MAX_MEM_LEVEL = 9,
  MAX_WBITS$1 = 15,
  DEF_MEM_LEVEL = 8,
  LENGTH_CODES = 29,
  LITERALS = 256,
  L_CODES = LITERALS + 1 + LENGTH_CODES,
  D_CODES = 30,
  BL_CODES = 19,
  HEAP_SIZE = 2 * L_CODES + 1,
  MAX_BITS = 15,
  MIN_MATCH = 3,
  MAX_MATCH = 258,
  MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,
  PRESET_DICT = 32,
  INIT_STATE = 42,
  EXTRA_STATE = 69,
  NAME_STATE = 73,
  COMMENT_STATE = 91,
  HCRC_STATE = 103,
  BUSY_STATE = 113,
  FINISH_STATE = 666,
  BS_NEED_MORE = 1,
  BS_BLOCK_DONE = 2,
  BS_FINISH_STARTED = 3,
  BS_FINISH_DONE = 4,
  OS_CODE = 3
function err(o, a) {
  return (o.msg = msg[a]), a
}
function rank(o) {
  return (o << 1) - (o > 4 ? 9 : 0)
}
function zero(o) {
  for (var a = o.length; --a >= 0; ) o[a] = 0
}
function flush_pending(o) {
  var a = o.state,
    s = a.pending
  s > o.avail_out && (s = o.avail_out),
    s !== 0 &&
      (utils$2.arraySet(o.output, a.pending_buf, a.pending_out, s, o.next_out),
      (o.next_out += s),
      (a.pending_out += s),
      (o.total_out += s),
      (o.avail_out -= s),
      (a.pending -= s),
      a.pending === 0 && (a.pending_out = 0))
}
function flush_block_only(o, a) {
  trees._tr_flush_block(
    o,
    o.block_start >= 0 ? o.block_start : -1,
    o.strstart - o.block_start,
    a
  ),
    (o.block_start = o.strstart),
    flush_pending(o.strm)
}
function put_byte(o, a) {
  o.pending_buf[o.pending++] = a
}
function putShortMSB(o, a) {
  ;(o.pending_buf[o.pending++] = (a >>> 8) & 255),
    (o.pending_buf[o.pending++] = a & 255)
}
function read_buf(o, a, s, $) {
  var j = o.avail_in
  return (
    j > $ && (j = $),
    j === 0
      ? 0
      : ((o.avail_in -= j),
        utils$2.arraySet(a, o.input, o.next_in, j, s),
        o.state.wrap === 1
          ? (o.adler = adler32$1(o.adler, a, j, s))
          : o.state.wrap === 2 && (o.adler = crc32$1(o.adler, a, j, s)),
        (o.next_in += j),
        (o.total_in += j),
        j)
  )
}
function longest_match(o, a) {
  var s = o.max_chain_length,
    $ = o.strstart,
    j,
    _e,
    et = o.prev_length,
    tt = o.nice_match,
    rt =
      o.strstart > o.w_size - MIN_LOOKAHEAD
        ? o.strstart - (o.w_size - MIN_LOOKAHEAD)
        : 0,
    nt = o.window,
    it = o.w_mask,
    ot = o.prev,
    at = o.strstart + MAX_MATCH,
    st = nt[$ + et - 1],
    ut = nt[$ + et]
  o.prev_length >= o.good_match && (s >>= 2),
    tt > o.lookahead && (tt = o.lookahead)
  do
    if (
      ((j = a),
      !(
        nt[j + et] !== ut ||
        nt[j + et - 1] !== st ||
        nt[j] !== nt[$] ||
        nt[++j] !== nt[$ + 1]
      ))
    ) {
      ;($ += 2), j++
      do;
      while (
        nt[++$] === nt[++j] &&
        nt[++$] === nt[++j] &&
        nt[++$] === nt[++j] &&
        nt[++$] === nt[++j] &&
        nt[++$] === nt[++j] &&
        nt[++$] === nt[++j] &&
        nt[++$] === nt[++j] &&
        nt[++$] === nt[++j] &&
        $ < at
      )
      if (((_e = MAX_MATCH - (at - $)), ($ = at - MAX_MATCH), _e > et)) {
        if (((o.match_start = a), (et = _e), _e >= tt)) break
        ;(st = nt[$ + et - 1]), (ut = nt[$ + et])
      }
    }
  while ((a = ot[a & it]) > rt && --s !== 0)
  return et <= o.lookahead ? et : o.lookahead
}
function fill_window(o) {
  var a = o.w_size,
    s,
    $,
    j,
    _e,
    et
  do {
    if (
      ((_e = o.window_size - o.lookahead - o.strstart),
      o.strstart >= a + (a - MIN_LOOKAHEAD))
    ) {
      utils$2.arraySet(o.window, o.window, a, a, 0),
        (o.match_start -= a),
        (o.strstart -= a),
        (o.block_start -= a),
        ($ = o.hash_size),
        (s = $)
      do (j = o.head[--s]), (o.head[s] = j >= a ? j - a : 0)
      while (--$)
      ;($ = a), (s = $)
      do (j = o.prev[--s]), (o.prev[s] = j >= a ? j - a : 0)
      while (--$)
      _e += a
    }
    if (o.strm.avail_in === 0) break
    if (
      (($ = read_buf(o.strm, o.window, o.strstart + o.lookahead, _e)),
      (o.lookahead += $),
      o.lookahead + o.insert >= MIN_MATCH)
    )
      for (
        et = o.strstart - o.insert,
          o.ins_h = o.window[et],
          o.ins_h =
            ((o.ins_h << o.hash_shift) ^ o.window[et + 1]) & o.hash_mask;
        o.insert &&
        ((o.ins_h =
          ((o.ins_h << o.hash_shift) ^ o.window[et + MIN_MATCH - 1]) &
          o.hash_mask),
        (o.prev[et & o.w_mask] = o.head[o.ins_h]),
        (o.head[o.ins_h] = et),
        et++,
        o.insert--,
        !(o.lookahead + o.insert < MIN_MATCH));

      );
  } while (o.lookahead < MIN_LOOKAHEAD && o.strm.avail_in !== 0)
}
function deflate_stored(o, a) {
  var s = 65535
  for (s > o.pending_buf_size - 5 && (s = o.pending_buf_size - 5); ; ) {
    if (o.lookahead <= 1) {
      if ((fill_window(o), o.lookahead === 0 && a === Z_NO_FLUSH))
        return BS_NEED_MORE
      if (o.lookahead === 0) break
    }
    ;(o.strstart += o.lookahead), (o.lookahead = 0)
    var $ = o.block_start + s
    if (
      ((o.strstart === 0 || o.strstart >= $) &&
        ((o.lookahead = o.strstart - $),
        (o.strstart = $),
        flush_block_only(o, !1),
        o.strm.avail_out === 0)) ||
      (o.strstart - o.block_start >= o.w_size - MIN_LOOKAHEAD &&
        (flush_block_only(o, !1), o.strm.avail_out === 0))
    )
      return BS_NEED_MORE
  }
  return (
    (o.insert = 0),
    a === Z_FINISH$1
      ? (flush_block_only(o, !0),
        o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE)
      : (o.strstart > o.block_start &&
          (flush_block_only(o, !1), o.strm.avail_out === 0),
        BS_NEED_MORE)
  )
}
function deflate_fast(o, a) {
  for (var s, $; ; ) {
    if (o.lookahead < MIN_LOOKAHEAD) {
      if ((fill_window(o), o.lookahead < MIN_LOOKAHEAD && a === Z_NO_FLUSH))
        return BS_NEED_MORE
      if (o.lookahead === 0) break
    }
    if (
      ((s = 0),
      o.lookahead >= MIN_MATCH &&
        ((o.ins_h =
          ((o.ins_h << o.hash_shift) ^ o.window[o.strstart + MIN_MATCH - 1]) &
          o.hash_mask),
        (s = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h]),
        (o.head[o.ins_h] = o.strstart)),
      s !== 0 &&
        o.strstart - s <= o.w_size - MIN_LOOKAHEAD &&
        (o.match_length = longest_match(o, s)),
      o.match_length >= MIN_MATCH)
    )
      if (
        (($ = trees._tr_tally(
          o,
          o.strstart - o.match_start,
          o.match_length - MIN_MATCH
        )),
        (o.lookahead -= o.match_length),
        o.match_length <= o.max_lazy_match && o.lookahead >= MIN_MATCH)
      ) {
        o.match_length--
        do
          o.strstart++,
            (o.ins_h =
              ((o.ins_h << o.hash_shift) ^
                o.window[o.strstart + MIN_MATCH - 1]) &
              o.hash_mask),
            (s = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h]),
            (o.head[o.ins_h] = o.strstart)
        while (--o.match_length !== 0)
        o.strstart++
      } else
        (o.strstart += o.match_length),
          (o.match_length = 0),
          (o.ins_h = o.window[o.strstart]),
          (o.ins_h =
            ((o.ins_h << o.hash_shift) ^ o.window[o.strstart + 1]) &
            o.hash_mask)
    else
      ($ = trees._tr_tally(o, 0, o.window[o.strstart])),
        o.lookahead--,
        o.strstart++
    if ($ && (flush_block_only(o, !1), o.strm.avail_out === 0))
      return BS_NEED_MORE
  }
  return (
    (o.insert = o.strstart < MIN_MATCH - 1 ? o.strstart : MIN_MATCH - 1),
    a === Z_FINISH$1
      ? (flush_block_only(o, !0),
        o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE)
      : o.last_lit && (flush_block_only(o, !1), o.strm.avail_out === 0)
      ? BS_NEED_MORE
      : BS_BLOCK_DONE
  )
}
function deflate_slow(o, a) {
  for (var s, $, j; ; ) {
    if (o.lookahead < MIN_LOOKAHEAD) {
      if ((fill_window(o), o.lookahead < MIN_LOOKAHEAD && a === Z_NO_FLUSH))
        return BS_NEED_MORE
      if (o.lookahead === 0) break
    }
    if (
      ((s = 0),
      o.lookahead >= MIN_MATCH &&
        ((o.ins_h =
          ((o.ins_h << o.hash_shift) ^ o.window[o.strstart + MIN_MATCH - 1]) &
          o.hash_mask),
        (s = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h]),
        (o.head[o.ins_h] = o.strstart)),
      (o.prev_length = o.match_length),
      (o.prev_match = o.match_start),
      (o.match_length = MIN_MATCH - 1),
      s !== 0 &&
        o.prev_length < o.max_lazy_match &&
        o.strstart - s <= o.w_size - MIN_LOOKAHEAD &&
        ((o.match_length = longest_match(o, s)),
        o.match_length <= 5 &&
          (o.strategy === Z_FILTERED ||
            (o.match_length === MIN_MATCH &&
              o.strstart - o.match_start > 4096)) &&
          (o.match_length = MIN_MATCH - 1)),
      o.prev_length >= MIN_MATCH && o.match_length <= o.prev_length)
    ) {
      ;(j = o.strstart + o.lookahead - MIN_MATCH),
        ($ = trees._tr_tally(
          o,
          o.strstart - 1 - o.prev_match,
          o.prev_length - MIN_MATCH
        )),
        (o.lookahead -= o.prev_length - 1),
        (o.prev_length -= 2)
      do
        ++o.strstart <= j &&
          ((o.ins_h =
            ((o.ins_h << o.hash_shift) ^ o.window[o.strstart + MIN_MATCH - 1]) &
            o.hash_mask),
          (s = o.prev[o.strstart & o.w_mask] = o.head[o.ins_h]),
          (o.head[o.ins_h] = o.strstart))
      while (--o.prev_length !== 0)
      if (
        ((o.match_available = 0),
        (o.match_length = MIN_MATCH - 1),
        o.strstart++,
        $ && (flush_block_only(o, !1), o.strm.avail_out === 0))
      )
        return BS_NEED_MORE
    } else if (o.match_available) {
      if (
        (($ = trees._tr_tally(o, 0, o.window[o.strstart - 1])),
        $ && flush_block_only(o, !1),
        o.strstart++,
        o.lookahead--,
        o.strm.avail_out === 0)
      )
        return BS_NEED_MORE
    } else (o.match_available = 1), o.strstart++, o.lookahead--
  }
  return (
    o.match_available &&
      (($ = trees._tr_tally(o, 0, o.window[o.strstart - 1])),
      (o.match_available = 0)),
    (o.insert = o.strstart < MIN_MATCH - 1 ? o.strstart : MIN_MATCH - 1),
    a === Z_FINISH$1
      ? (flush_block_only(o, !0),
        o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE)
      : o.last_lit && (flush_block_only(o, !1), o.strm.avail_out === 0)
      ? BS_NEED_MORE
      : BS_BLOCK_DONE
  )
}
function deflate_rle(o, a) {
  for (var s, $, j, _e, et = o.window; ; ) {
    if (o.lookahead <= MAX_MATCH) {
      if ((fill_window(o), o.lookahead <= MAX_MATCH && a === Z_NO_FLUSH))
        return BS_NEED_MORE
      if (o.lookahead === 0) break
    }
    if (
      ((o.match_length = 0),
      o.lookahead >= MIN_MATCH &&
        o.strstart > 0 &&
        ((j = o.strstart - 1),
        ($ = et[j]),
        $ === et[++j] && $ === et[++j] && $ === et[++j]))
    ) {
      _e = o.strstart + MAX_MATCH
      do;
      while (
        $ === et[++j] &&
        $ === et[++j] &&
        $ === et[++j] &&
        $ === et[++j] &&
        $ === et[++j] &&
        $ === et[++j] &&
        $ === et[++j] &&
        $ === et[++j] &&
        j < _e
      )
      ;(o.match_length = MAX_MATCH - (_e - j)),
        o.match_length > o.lookahead && (o.match_length = o.lookahead)
    }
    if (
      (o.match_length >= MIN_MATCH
        ? ((s = trees._tr_tally(o, 1, o.match_length - MIN_MATCH)),
          (o.lookahead -= o.match_length),
          (o.strstart += o.match_length),
          (o.match_length = 0))
        : ((s = trees._tr_tally(o, 0, o.window[o.strstart])),
          o.lookahead--,
          o.strstart++),
      s && (flush_block_only(o, !1), o.strm.avail_out === 0))
    )
      return BS_NEED_MORE
  }
  return (
    (o.insert = 0),
    a === Z_FINISH$1
      ? (flush_block_only(o, !0),
        o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE)
      : o.last_lit && (flush_block_only(o, !1), o.strm.avail_out === 0)
      ? BS_NEED_MORE
      : BS_BLOCK_DONE
  )
}
function deflate_huff(o, a) {
  for (var s; ; ) {
    if (o.lookahead === 0 && (fill_window(o), o.lookahead === 0)) {
      if (a === Z_NO_FLUSH) return BS_NEED_MORE
      break
    }
    if (
      ((o.match_length = 0),
      (s = trees._tr_tally(o, 0, o.window[o.strstart])),
      o.lookahead--,
      o.strstart++,
      s && (flush_block_only(o, !1), o.strm.avail_out === 0))
    )
      return BS_NEED_MORE
  }
  return (
    (o.insert = 0),
    a === Z_FINISH$1
      ? (flush_block_only(o, !0),
        o.strm.avail_out === 0 ? BS_FINISH_STARTED : BS_FINISH_DONE)
      : o.last_lit && (flush_block_only(o, !1), o.strm.avail_out === 0)
      ? BS_NEED_MORE
      : BS_BLOCK_DONE
  )
}
function Config(o, a, s, $, j) {
  ;(this.good_length = o),
    (this.max_lazy = a),
    (this.nice_length = s),
    (this.max_chain = $),
    (this.func = j)
}
var configuration_table
configuration_table = [
  new Config(0, 0, 0, 0, deflate_stored),
  new Config(4, 4, 8, 4, deflate_fast),
  new Config(4, 5, 16, 8, deflate_fast),
  new Config(4, 6, 32, 32, deflate_fast),
  new Config(4, 4, 16, 16, deflate_slow),
  new Config(8, 16, 32, 32, deflate_slow),
  new Config(8, 16, 128, 128, deflate_slow),
  new Config(8, 32, 128, 256, deflate_slow),
  new Config(32, 128, 258, 1024, deflate_slow),
  new Config(32, 258, 258, 4096, deflate_slow),
]
function lm_init(o) {
  ;(o.window_size = 2 * o.w_size),
    zero(o.head),
    (o.max_lazy_match = configuration_table[o.level].max_lazy),
    (o.good_match = configuration_table[o.level].good_length),
    (o.nice_match = configuration_table[o.level].nice_length),
    (o.max_chain_length = configuration_table[o.level].max_chain),
    (o.strstart = 0),
    (o.block_start = 0),
    (o.lookahead = 0),
    (o.insert = 0),
    (o.match_length = o.prev_length = MIN_MATCH - 1),
    (o.match_available = 0),
    (o.ins_h = 0)
}
function DeflateState() {
  ;(this.strm = null),
    (this.status = 0),
    (this.pending_buf = null),
    (this.pending_buf_size = 0),
    (this.pending_out = 0),
    (this.pending = 0),
    (this.wrap = 0),
    (this.gzhead = null),
    (this.gzindex = 0),
    (this.method = Z_DEFLATED$1),
    (this.last_flush = -1),
    (this.w_size = 0),
    (this.w_bits = 0),
    (this.w_mask = 0),
    (this.window = null),
    (this.window_size = 0),
    (this.prev = null),
    (this.head = null),
    (this.ins_h = 0),
    (this.hash_size = 0),
    (this.hash_bits = 0),
    (this.hash_mask = 0),
    (this.hash_shift = 0),
    (this.block_start = 0),
    (this.match_length = 0),
    (this.prev_match = 0),
    (this.match_available = 0),
    (this.strstart = 0),
    (this.match_start = 0),
    (this.lookahead = 0),
    (this.prev_length = 0),
    (this.max_chain_length = 0),
    (this.max_lazy_match = 0),
    (this.level = 0),
    (this.strategy = 0),
    (this.good_match = 0),
    (this.nice_match = 0),
    (this.dyn_ltree = new utils$2.Buf16(HEAP_SIZE * 2)),
    (this.dyn_dtree = new utils$2.Buf16((2 * D_CODES + 1) * 2)),
    (this.bl_tree = new utils$2.Buf16((2 * BL_CODES + 1) * 2)),
    zero(this.dyn_ltree),
    zero(this.dyn_dtree),
    zero(this.bl_tree),
    (this.l_desc = null),
    (this.d_desc = null),
    (this.bl_desc = null),
    (this.bl_count = new utils$2.Buf16(MAX_BITS + 1)),
    (this.heap = new utils$2.Buf16(2 * L_CODES + 1)),
    zero(this.heap),
    (this.heap_len = 0),
    (this.heap_max = 0),
    (this.depth = new utils$2.Buf16(2 * L_CODES + 1)),
    zero(this.depth),
    (this.l_buf = 0),
    (this.lit_bufsize = 0),
    (this.last_lit = 0),
    (this.d_buf = 0),
    (this.opt_len = 0),
    (this.static_len = 0),
    (this.matches = 0),
    (this.insert = 0),
    (this.bi_buf = 0),
    (this.bi_valid = 0)
}
function deflateResetKeep(o) {
  var a
  return !o || !o.state
    ? err(o, Z_STREAM_ERROR$1)
    : ((o.total_in = o.total_out = 0),
      (o.data_type = Z_UNKNOWN),
      (a = o.state),
      (a.pending = 0),
      (a.pending_out = 0),
      a.wrap < 0 && (a.wrap = -a.wrap),
      (a.status = a.wrap ? INIT_STATE : BUSY_STATE),
      (o.adler = a.wrap === 2 ? 0 : 1),
      (a.last_flush = Z_NO_FLUSH),
      trees._tr_init(a),
      Z_OK$1)
}
function deflateReset(o) {
  var a = deflateResetKeep(o)
  return a === Z_OK$1 && lm_init(o.state), a
}
function deflateSetHeader(o, a) {
  return !o || !o.state || o.state.wrap !== 2
    ? Z_STREAM_ERROR$1
    : ((o.state.gzhead = a), Z_OK$1)
}
function deflateInit2(o, a, s, $, j, _e) {
  if (!o) return Z_STREAM_ERROR$1
  var et = 1
  if (
    (a === Z_DEFAULT_COMPRESSION && (a = 6),
    $ < 0 ? ((et = 0), ($ = -$)) : $ > 15 && ((et = 2), ($ -= 16)),
    j < 1 ||
      j > MAX_MEM_LEVEL ||
      s !== Z_DEFLATED$1 ||
      $ < 8 ||
      $ > 15 ||
      a < 0 ||
      a > 9 ||
      _e < 0 ||
      _e > Z_FIXED)
  )
    return err(o, Z_STREAM_ERROR$1)
  $ === 8 && ($ = 9)
  var tt = new DeflateState()
  return (
    (o.state = tt),
    (tt.strm = o),
    (tt.wrap = et),
    (tt.gzhead = null),
    (tt.w_bits = $),
    (tt.w_size = 1 << tt.w_bits),
    (tt.w_mask = tt.w_size - 1),
    (tt.hash_bits = j + 7),
    (tt.hash_size = 1 << tt.hash_bits),
    (tt.hash_mask = tt.hash_size - 1),
    (tt.hash_shift = ~~((tt.hash_bits + MIN_MATCH - 1) / MIN_MATCH)),
    (tt.window = new utils$2.Buf8(tt.w_size * 2)),
    (tt.head = new utils$2.Buf16(tt.hash_size)),
    (tt.prev = new utils$2.Buf16(tt.w_size)),
    (tt.lit_bufsize = 1 << (j + 6)),
    (tt.pending_buf_size = tt.lit_bufsize * 4),
    (tt.pending_buf = new utils$2.Buf8(tt.pending_buf_size)),
    (tt.d_buf = 1 * tt.lit_bufsize),
    (tt.l_buf = 3 * tt.lit_bufsize),
    (tt.level = a),
    (tt.strategy = _e),
    (tt.method = s),
    deflateReset(o)
  )
}
function deflateInit(o, a) {
  return deflateInit2(
    o,
    a,
    Z_DEFLATED$1,
    MAX_WBITS$1,
    DEF_MEM_LEVEL,
    Z_DEFAULT_STRATEGY
  )
}
function deflate(o, a) {
  var s, $, j, _e
  if (!o || !o.state || a > Z_BLOCK$1 || a < 0)
    return o ? err(o, Z_STREAM_ERROR$1) : Z_STREAM_ERROR$1
  if (
    (($ = o.state),
    !o.output ||
      (!o.input && o.avail_in !== 0) ||
      ($.status === FINISH_STATE && a !== Z_FINISH$1))
  )
    return err(o, o.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$1)
  if (
    (($.strm = o),
    (s = $.last_flush),
    ($.last_flush = a),
    $.status === INIT_STATE)
  )
    if ($.wrap === 2)
      (o.adler = 0),
        put_byte($, 31),
        put_byte($, 139),
        put_byte($, 8),
        $.gzhead
          ? (put_byte(
              $,
              ($.gzhead.text ? 1 : 0) +
                ($.gzhead.hcrc ? 2 : 0) +
                ($.gzhead.extra ? 4 : 0) +
                ($.gzhead.name ? 8 : 0) +
                ($.gzhead.comment ? 16 : 0)
            ),
            put_byte($, $.gzhead.time & 255),
            put_byte($, ($.gzhead.time >> 8) & 255),
            put_byte($, ($.gzhead.time >> 16) & 255),
            put_byte($, ($.gzhead.time >> 24) & 255),
            put_byte(
              $,
              $.level === 9
                ? 2
                : $.strategy >= Z_HUFFMAN_ONLY || $.level < 2
                ? 4
                : 0
            ),
            put_byte($, $.gzhead.os & 255),
            $.gzhead.extra &&
              $.gzhead.extra.length &&
              (put_byte($, $.gzhead.extra.length & 255),
              put_byte($, ($.gzhead.extra.length >> 8) & 255)),
            $.gzhead.hcrc &&
              (o.adler = crc32$1(o.adler, $.pending_buf, $.pending, 0)),
            ($.gzindex = 0),
            ($.status = EXTRA_STATE))
          : (put_byte($, 0),
            put_byte($, 0),
            put_byte($, 0),
            put_byte($, 0),
            put_byte($, 0),
            put_byte(
              $,
              $.level === 9
                ? 2
                : $.strategy >= Z_HUFFMAN_ONLY || $.level < 2
                ? 4
                : 0
            ),
            put_byte($, OS_CODE),
            ($.status = BUSY_STATE))
    else {
      var et = (Z_DEFLATED$1 + (($.w_bits - 8) << 4)) << 8,
        tt = -1
      $.strategy >= Z_HUFFMAN_ONLY || $.level < 2
        ? (tt = 0)
        : $.level < 6
        ? (tt = 1)
        : $.level === 6
        ? (tt = 2)
        : (tt = 3),
        (et |= tt << 6),
        $.strstart !== 0 && (et |= PRESET_DICT),
        (et += 31 - (et % 31)),
        ($.status = BUSY_STATE),
        putShortMSB($, et),
        $.strstart !== 0 &&
          (putShortMSB($, o.adler >>> 16), putShortMSB($, o.adler & 65535)),
        (o.adler = 1)
    }
  if ($.status === EXTRA_STATE)
    if ($.gzhead.extra) {
      for (
        j = $.pending;
        $.gzindex < ($.gzhead.extra.length & 65535) &&
        !(
          $.pending === $.pending_buf_size &&
          ($.gzhead.hcrc &&
            $.pending > j &&
            (o.adler = crc32$1(o.adler, $.pending_buf, $.pending - j, j)),
          flush_pending(o),
          (j = $.pending),
          $.pending === $.pending_buf_size)
        );

      )
        put_byte($, $.gzhead.extra[$.gzindex] & 255), $.gzindex++
      $.gzhead.hcrc &&
        $.pending > j &&
        (o.adler = crc32$1(o.adler, $.pending_buf, $.pending - j, j)),
        $.gzindex === $.gzhead.extra.length &&
          (($.gzindex = 0), ($.status = NAME_STATE))
    } else $.status = NAME_STATE
  if ($.status === NAME_STATE)
    if ($.gzhead.name) {
      j = $.pending
      do {
        if (
          $.pending === $.pending_buf_size &&
          ($.gzhead.hcrc &&
            $.pending > j &&
            (o.adler = crc32$1(o.adler, $.pending_buf, $.pending - j, j)),
          flush_pending(o),
          (j = $.pending),
          $.pending === $.pending_buf_size)
        ) {
          _e = 1
          break
        }
        $.gzindex < $.gzhead.name.length
          ? (_e = $.gzhead.name.charCodeAt($.gzindex++) & 255)
          : (_e = 0),
          put_byte($, _e)
      } while (_e !== 0)
      $.gzhead.hcrc &&
        $.pending > j &&
        (o.adler = crc32$1(o.adler, $.pending_buf, $.pending - j, j)),
        _e === 0 && (($.gzindex = 0), ($.status = COMMENT_STATE))
    } else $.status = COMMENT_STATE
  if ($.status === COMMENT_STATE)
    if ($.gzhead.comment) {
      j = $.pending
      do {
        if (
          $.pending === $.pending_buf_size &&
          ($.gzhead.hcrc &&
            $.pending > j &&
            (o.adler = crc32$1(o.adler, $.pending_buf, $.pending - j, j)),
          flush_pending(o),
          (j = $.pending),
          $.pending === $.pending_buf_size)
        ) {
          _e = 1
          break
        }
        $.gzindex < $.gzhead.comment.length
          ? (_e = $.gzhead.comment.charCodeAt($.gzindex++) & 255)
          : (_e = 0),
          put_byte($, _e)
      } while (_e !== 0)
      $.gzhead.hcrc &&
        $.pending > j &&
        (o.adler = crc32$1(o.adler, $.pending_buf, $.pending - j, j)),
        _e === 0 && ($.status = HCRC_STATE)
    } else $.status = HCRC_STATE
  if (
    ($.status === HCRC_STATE &&
      ($.gzhead.hcrc
        ? ($.pending + 2 > $.pending_buf_size && flush_pending(o),
          $.pending + 2 <= $.pending_buf_size &&
            (put_byte($, o.adler & 255),
            put_byte($, (o.adler >> 8) & 255),
            (o.adler = 0),
            ($.status = BUSY_STATE)))
        : ($.status = BUSY_STATE)),
    $.pending !== 0)
  ) {
    if ((flush_pending(o), o.avail_out === 0))
      return ($.last_flush = -1), Z_OK$1
  } else if (o.avail_in === 0 && rank(a) <= rank(s) && a !== Z_FINISH$1)
    return err(o, Z_BUF_ERROR$1)
  if ($.status === FINISH_STATE && o.avail_in !== 0)
    return err(o, Z_BUF_ERROR$1)
  if (
    o.avail_in !== 0 ||
    $.lookahead !== 0 ||
    (a !== Z_NO_FLUSH && $.status !== FINISH_STATE)
  ) {
    var rt =
      $.strategy === Z_HUFFMAN_ONLY
        ? deflate_huff($, a)
        : $.strategy === Z_RLE
        ? deflate_rle($, a)
        : configuration_table[$.level].func($, a)
    if (
      ((rt === BS_FINISH_STARTED || rt === BS_FINISH_DONE) &&
        ($.status = FINISH_STATE),
      rt === BS_NEED_MORE || rt === BS_FINISH_STARTED)
    )
      return o.avail_out === 0 && ($.last_flush = -1), Z_OK$1
    if (
      rt === BS_BLOCK_DONE &&
      (a === Z_PARTIAL_FLUSH
        ? trees._tr_align($)
        : a !== Z_BLOCK$1 &&
          (trees._tr_stored_block($, 0, 0, !1),
          a === Z_FULL_FLUSH &&
            (zero($.head),
            $.lookahead === 0 &&
              (($.strstart = 0), ($.block_start = 0), ($.insert = 0)))),
      flush_pending(o),
      o.avail_out === 0)
    )
      return ($.last_flush = -1), Z_OK$1
  }
  return a !== Z_FINISH$1
    ? Z_OK$1
    : $.wrap <= 0
    ? Z_STREAM_END$1
    : ($.wrap === 2
        ? (put_byte($, o.adler & 255),
          put_byte($, (o.adler >> 8) & 255),
          put_byte($, (o.adler >> 16) & 255),
          put_byte($, (o.adler >> 24) & 255),
          put_byte($, o.total_in & 255),
          put_byte($, (o.total_in >> 8) & 255),
          put_byte($, (o.total_in >> 16) & 255),
          put_byte($, (o.total_in >> 24) & 255))
        : (putShortMSB($, o.adler >>> 16), putShortMSB($, o.adler & 65535)),
      flush_pending(o),
      $.wrap > 0 && ($.wrap = -$.wrap),
      $.pending !== 0 ? Z_OK$1 : Z_STREAM_END$1)
}
function deflateEnd(o) {
  var a
  return !o || !o.state
    ? Z_STREAM_ERROR$1
    : ((a = o.state.status),
      a !== INIT_STATE &&
      a !== EXTRA_STATE &&
      a !== NAME_STATE &&
      a !== COMMENT_STATE &&
      a !== HCRC_STATE &&
      a !== BUSY_STATE &&
      a !== FINISH_STATE
        ? err(o, Z_STREAM_ERROR$1)
        : ((o.state = null),
          a === BUSY_STATE ? err(o, Z_DATA_ERROR$1) : Z_OK$1))
}
function deflateSetDictionary(o, a) {
  var s = a.length,
    $,
    j,
    _e,
    et,
    tt,
    rt,
    nt,
    it
  if (
    !o ||
    !o.state ||
    (($ = o.state),
    (et = $.wrap),
    et === 2 || (et === 1 && $.status !== INIT_STATE) || $.lookahead)
  )
    return Z_STREAM_ERROR$1
  for (
    et === 1 && (o.adler = adler32$1(o.adler, a, s, 0)),
      $.wrap = 0,
      s >= $.w_size &&
        (et === 0 &&
          (zero($.head), ($.strstart = 0), ($.block_start = 0), ($.insert = 0)),
        (it = new utils$2.Buf8($.w_size)),
        utils$2.arraySet(it, a, s - $.w_size, $.w_size, 0),
        (a = it),
        (s = $.w_size)),
      tt = o.avail_in,
      rt = o.next_in,
      nt = o.input,
      o.avail_in = s,
      o.next_in = 0,
      o.input = a,
      fill_window($);
    $.lookahead >= MIN_MATCH;

  ) {
    ;(j = $.strstart), (_e = $.lookahead - (MIN_MATCH - 1))
    do
      ($.ins_h =
        (($.ins_h << $.hash_shift) ^ $.window[j + MIN_MATCH - 1]) &
        $.hash_mask),
        ($.prev[j & $.w_mask] = $.head[$.ins_h]),
        ($.head[$.ins_h] = j),
        j++
    while (--_e)
    ;($.strstart = j), ($.lookahead = MIN_MATCH - 1), fill_window($)
  }
  return (
    ($.strstart += $.lookahead),
    ($.block_start = $.strstart),
    ($.insert = $.lookahead),
    ($.lookahead = 0),
    ($.match_length = $.prev_length = MIN_MATCH - 1),
    ($.match_available = 0),
    (o.next_in = rt),
    (o.input = nt),
    (o.avail_in = tt),
    ($.wrap = et),
    Z_OK$1
  )
}
deflate$1.deflateInit = deflateInit
deflate$1.deflateInit2 = deflateInit2
deflate$1.deflateReset = deflateReset
deflate$1.deflateResetKeep = deflateResetKeep
deflate$1.deflateSetHeader = deflateSetHeader
deflate$1.deflate = deflate
deflate$1.deflateEnd = deflateEnd
deflate$1.deflateSetDictionary = deflateSetDictionary
deflate$1.deflateInfo = 'pako deflate (from Nodeca project)'
var inflate$1 = {},
  BAD$1 = 30,
  TYPE$1 = 12,
  inffast = function o(a, s) {
    var $,
      j,
      _e,
      et,
      tt,
      rt,
      nt,
      it,
      ot,
      at,
      st,
      ut,
      ct,
      dt,
      ft,
      mt,
      vt,
      yt,
      pt,
      ht,
      At,
      wt,
      Ct,
      Dt,
      jt
    ;($ = a.state),
      (j = a.next_in),
      (Dt = a.input),
      (_e = j + (a.avail_in - 5)),
      (et = a.next_out),
      (jt = a.output),
      (tt = et - (s - a.avail_out)),
      (rt = et + (a.avail_out - 257)),
      (nt = $.dmax),
      (it = $.wsize),
      (ot = $.whave),
      (at = $.wnext),
      (st = $.window),
      (ut = $.hold),
      (ct = $.bits),
      (dt = $.lencode),
      (ft = $.distcode),
      (mt = (1 << $.lenbits) - 1),
      (vt = (1 << $.distbits) - 1)
    e: do {
      ct < 15 &&
        ((ut += Dt[j++] << ct), (ct += 8), (ut += Dt[j++] << ct), (ct += 8)),
        (yt = dt[ut & mt])
      t: for (;;) {
        if (
          ((pt = yt >>> 24),
          (ut >>>= pt),
          (ct -= pt),
          (pt = (yt >>> 16) & 255),
          pt === 0)
        )
          jt[et++] = yt & 65535
        else if (pt & 16) {
          ;(ht = yt & 65535),
            (pt &= 15),
            pt &&
              (ct < pt && ((ut += Dt[j++] << ct), (ct += 8)),
              (ht += ut & ((1 << pt) - 1)),
              (ut >>>= pt),
              (ct -= pt)),
            ct < 15 &&
              ((ut += Dt[j++] << ct),
              (ct += 8),
              (ut += Dt[j++] << ct),
              (ct += 8)),
            (yt = ft[ut & vt])
          r: for (;;) {
            if (
              ((pt = yt >>> 24),
              (ut >>>= pt),
              (ct -= pt),
              (pt = (yt >>> 16) & 255),
              pt & 16)
            ) {
              if (
                ((At = yt & 65535),
                (pt &= 15),
                ct < pt &&
                  ((ut += Dt[j++] << ct),
                  (ct += 8),
                  ct < pt && ((ut += Dt[j++] << ct), (ct += 8))),
                (At += ut & ((1 << pt) - 1)),
                At > nt)
              ) {
                ;(a.msg = 'invalid distance too far back'), ($.mode = BAD$1)
                break e
              }
              if (((ut >>>= pt), (ct -= pt), (pt = et - tt), At > pt)) {
                if (((pt = At - pt), pt > ot && $.sane)) {
                  ;(a.msg = 'invalid distance too far back'), ($.mode = BAD$1)
                  break e
                }
                if (((wt = 0), (Ct = st), at === 0)) {
                  if (((wt += it - pt), pt < ht)) {
                    ht -= pt
                    do jt[et++] = st[wt++]
                    while (--pt)
                    ;(wt = et - At), (Ct = jt)
                  }
                } else if (at < pt) {
                  if (((wt += it + at - pt), (pt -= at), pt < ht)) {
                    ht -= pt
                    do jt[et++] = st[wt++]
                    while (--pt)
                    if (((wt = 0), at < ht)) {
                      ;(pt = at), (ht -= pt)
                      do jt[et++] = st[wt++]
                      while (--pt)
                      ;(wt = et - At), (Ct = jt)
                    }
                  }
                } else if (((wt += at - pt), pt < ht)) {
                  ht -= pt
                  do jt[et++] = st[wt++]
                  while (--pt)
                  ;(wt = et - At), (Ct = jt)
                }
                for (; ht > 2; )
                  (jt[et++] = Ct[wt++]),
                    (jt[et++] = Ct[wt++]),
                    (jt[et++] = Ct[wt++]),
                    (ht -= 3)
                ht && ((jt[et++] = Ct[wt++]), ht > 1 && (jt[et++] = Ct[wt++]))
              } else {
                wt = et - At
                do
                  (jt[et++] = jt[wt++]),
                    (jt[et++] = jt[wt++]),
                    (jt[et++] = jt[wt++]),
                    (ht -= 3)
                while (ht > 2)
                ht && ((jt[et++] = jt[wt++]), ht > 1 && (jt[et++] = jt[wt++]))
              }
            } else if (pt & 64) {
              ;(a.msg = 'invalid distance code'), ($.mode = BAD$1)
              break e
            } else {
              yt = ft[(yt & 65535) + (ut & ((1 << pt) - 1))]
              continue r
            }
            break
          }
        } else if (pt & 64)
          if (pt & 32) {
            $.mode = TYPE$1
            break e
          } else {
            ;(a.msg = 'invalid literal/length code'), ($.mode = BAD$1)
            break e
          }
        else {
          yt = dt[(yt & 65535) + (ut & ((1 << pt) - 1))]
          continue t
        }
        break
      }
    } while (j < _e && et < rt)
    ;(ht = ct >> 3),
      (j -= ht),
      (ct -= ht << 3),
      (ut &= (1 << ct) - 1),
      (a.next_in = j),
      (a.next_out = et),
      (a.avail_in = j < _e ? 5 + (_e - j) : 5 - (j - _e)),
      (a.avail_out = et < rt ? 257 + (rt - et) : 257 - (et - rt)),
      ($.hold = ut),
      ($.bits = ct)
  },
  utils$1 = common,
  MAXBITS = 15,
  ENOUGH_LENS$1 = 852,
  ENOUGH_DISTS$1 = 592,
  CODES$1 = 0,
  LENS$1 = 1,
  DISTS$1 = 2,
  lbase = [
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0,
  ],
  lext = [
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78,
  ],
  dbase = [
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0,
  ],
  dext = [
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64,
  ],
  inftrees = function o(a, s, $, j, _e, et, tt, rt) {
    var nt = rt.bits,
      it = 0,
      ot = 0,
      at = 0,
      st = 0,
      ut = 0,
      ct = 0,
      dt = 0,
      ft = 0,
      mt = 0,
      vt = 0,
      yt,
      pt,
      ht,
      At,
      wt,
      Ct = null,
      Dt = 0,
      jt,
      Et = new utils$1.Buf16(MAXBITS + 1),
      St = new utils$1.Buf16(MAXBITS + 1),
      Bt = null,
      Mt = 0,
      Ut,
      Wt,
      Tt
    for (it = 0; it <= MAXBITS; it++) Et[it] = 0
    for (ot = 0; ot < j; ot++) Et[s[$ + ot]]++
    for (ut = nt, st = MAXBITS; st >= 1 && Et[st] === 0; st--);
    if ((ut > st && (ut = st), st === 0))
      return (
        (_e[et++] = (1 << 24) | (64 << 16) | 0),
        (_e[et++] = (1 << 24) | (64 << 16) | 0),
        (rt.bits = 1),
        0
      )
    for (at = 1; at < st && Et[at] === 0; at++);
    for (ut < at && (ut = at), ft = 1, it = 1; it <= MAXBITS; it++)
      if (((ft <<= 1), (ft -= Et[it]), ft < 0)) return -1
    if (ft > 0 && (a === CODES$1 || st !== 1)) return -1
    for (St[1] = 0, it = 1; it < MAXBITS; it++) St[it + 1] = St[it] + Et[it]
    for (ot = 0; ot < j; ot++) s[$ + ot] !== 0 && (tt[St[s[$ + ot]]++] = ot)
    if (
      (a === CODES$1
        ? ((Ct = Bt = tt), (jt = 19))
        : a === LENS$1
        ? ((Ct = lbase), (Dt -= 257), (Bt = lext), (Mt -= 257), (jt = 256))
        : ((Ct = dbase), (Bt = dext), (jt = -1)),
      (vt = 0),
      (ot = 0),
      (it = at),
      (wt = et),
      (ct = ut),
      (dt = 0),
      (ht = -1),
      (mt = 1 << ut),
      (At = mt - 1),
      (a === LENS$1 && mt > ENOUGH_LENS$1) ||
        (a === DISTS$1 && mt > ENOUGH_DISTS$1))
    )
      return 1
    for (;;) {
      ;(Ut = it - dt),
        tt[ot] < jt
          ? ((Wt = 0), (Tt = tt[ot]))
          : tt[ot] > jt
          ? ((Wt = Bt[Mt + tt[ot]]), (Tt = Ct[Dt + tt[ot]]))
          : ((Wt = 96), (Tt = 0)),
        (yt = 1 << (it - dt)),
        (pt = 1 << ct),
        (at = pt)
      do
        (pt -= yt),
          (_e[wt + (vt >> dt) + pt] = (Ut << 24) | (Wt << 16) | Tt | 0)
      while (pt !== 0)
      for (yt = 1 << (it - 1); vt & yt; ) yt >>= 1
      if (
        (yt !== 0 ? ((vt &= yt - 1), (vt += yt)) : (vt = 0),
        ot++,
        --Et[it] === 0)
      ) {
        if (it === st) break
        it = s[$ + tt[ot]]
      }
      if (it > ut && (vt & At) !== ht) {
        for (
          dt === 0 && (dt = ut), wt += at, ct = it - dt, ft = 1 << ct;
          ct + dt < st && ((ft -= Et[ct + dt]), !(ft <= 0));

        )
          ct++, (ft <<= 1)
        if (
          ((mt += 1 << ct),
          (a === LENS$1 && mt > ENOUGH_LENS$1) ||
            (a === DISTS$1 && mt > ENOUGH_DISTS$1))
        )
          return 1
        ;(ht = vt & At), (_e[ht] = (ut << 24) | (ct << 16) | (wt - et) | 0)
      }
    }
    return (
      vt !== 0 && (_e[wt + vt] = ((it - dt) << 24) | (64 << 16) | 0),
      (rt.bits = ut),
      0
    )
  },
  utils = common,
  adler32 = adler32_1,
  crc32 = crc32_1,
  inflate_fast = inffast,
  inflate_table = inftrees,
  CODES = 0,
  LENS = 1,
  DISTS = 2,
  Z_FINISH = 4,
  Z_BLOCK = 5,
  Z_TREES = 6,
  Z_OK = 0,
  Z_STREAM_END = 1,
  Z_NEED_DICT = 2,
  Z_STREAM_ERROR = -2,
  Z_DATA_ERROR = -3,
  Z_MEM_ERROR = -4,
  Z_BUF_ERROR = -5,
  Z_DEFLATED = 8,
  HEAD = 1,
  FLAGS = 2,
  TIME = 3,
  OS = 4,
  EXLEN = 5,
  EXTRA = 6,
  NAME = 7,
  COMMENT = 8,
  HCRC = 9,
  DICTID = 10,
  DICT = 11,
  TYPE = 12,
  TYPEDO = 13,
  STORED = 14,
  COPY_ = 15,
  COPY$1 = 16,
  TABLE = 17,
  LENLENS = 18,
  CODELENS = 19,
  LEN_ = 20,
  LEN = 21,
  LENEXT = 22,
  DIST = 23,
  DISTEXT = 24,
  MATCH = 25,
  LIT = 26,
  CHECK = 27,
  LENGTH = 28,
  DONE = 29,
  BAD = 30,
  MEM = 31,
  SYNC = 32,
  ENOUGH_LENS = 852,
  ENOUGH_DISTS = 592,
  MAX_WBITS = 15,
  DEF_WBITS = MAX_WBITS
function zswap32(o) {
  return (
    ((o >>> 24) & 255) +
    ((o >>> 8) & 65280) +
    ((o & 65280) << 8) +
    ((o & 255) << 24)
  )
}
function InflateState() {
  ;(this.mode = 0),
    (this.last = !1),
    (this.wrap = 0),
    (this.havedict = !1),
    (this.flags = 0),
    (this.dmax = 0),
    (this.check = 0),
    (this.total = 0),
    (this.head = null),
    (this.wbits = 0),
    (this.wsize = 0),
    (this.whave = 0),
    (this.wnext = 0),
    (this.window = null),
    (this.hold = 0),
    (this.bits = 0),
    (this.length = 0),
    (this.offset = 0),
    (this.extra = 0),
    (this.lencode = null),
    (this.distcode = null),
    (this.lenbits = 0),
    (this.distbits = 0),
    (this.ncode = 0),
    (this.nlen = 0),
    (this.ndist = 0),
    (this.have = 0),
    (this.next = null),
    (this.lens = new utils.Buf16(320)),
    (this.work = new utils.Buf16(288)),
    (this.lendyn = null),
    (this.distdyn = null),
    (this.sane = 0),
    (this.back = 0),
    (this.was = 0)
}
function inflateResetKeep(o) {
  var a
  return !o || !o.state
    ? Z_STREAM_ERROR
    : ((a = o.state),
      (o.total_in = o.total_out = a.total = 0),
      (o.msg = ''),
      a.wrap && (o.adler = a.wrap & 1),
      (a.mode = HEAD),
      (a.last = 0),
      (a.havedict = 0),
      (a.dmax = 32768),
      (a.head = null),
      (a.hold = 0),
      (a.bits = 0),
      (a.lencode = a.lendyn = new utils.Buf32(ENOUGH_LENS)),
      (a.distcode = a.distdyn = new utils.Buf32(ENOUGH_DISTS)),
      (a.sane = 1),
      (a.back = -1),
      Z_OK)
}
function inflateReset(o) {
  var a
  return !o || !o.state
    ? Z_STREAM_ERROR
    : ((a = o.state),
      (a.wsize = 0),
      (a.whave = 0),
      (a.wnext = 0),
      inflateResetKeep(o))
}
function inflateReset2(o, a) {
  var s, $
  return !o ||
    !o.state ||
    (($ = o.state),
    a < 0 ? ((s = 0), (a = -a)) : ((s = (a >> 4) + 1), a < 48 && (a &= 15)),
    a && (a < 8 || a > 15))
    ? Z_STREAM_ERROR
    : ($.window !== null && $.wbits !== a && ($.window = null),
      ($.wrap = s),
      ($.wbits = a),
      inflateReset(o))
}
function inflateInit2(o, a) {
  var s, $
  return o
    ? (($ = new InflateState()),
      (o.state = $),
      ($.window = null),
      (s = inflateReset2(o, a)),
      s !== Z_OK && (o.state = null),
      s)
    : Z_STREAM_ERROR
}
function inflateInit(o) {
  return inflateInit2(o, DEF_WBITS)
}
var virgin = !0,
  lenfix,
  distfix
function fixedtables(o) {
  if (virgin) {
    var a
    for (
      lenfix = new utils.Buf32(512), distfix = new utils.Buf32(32), a = 0;
      a < 144;

    )
      o.lens[a++] = 8
    for (; a < 256; ) o.lens[a++] = 9
    for (; a < 280; ) o.lens[a++] = 7
    for (; a < 288; ) o.lens[a++] = 8
    for (
      inflate_table(LENS, o.lens, 0, 288, lenfix, 0, o.work, { bits: 9 }),
        a = 0;
      a < 32;

    )
      o.lens[a++] = 5
    inflate_table(DISTS, o.lens, 0, 32, distfix, 0, o.work, { bits: 5 }),
      (virgin = !1)
  }
  ;(o.lencode = lenfix),
    (o.lenbits = 9),
    (o.distcode = distfix),
    (o.distbits = 5)
}
function updatewindow(o, a, s, $) {
  var j,
    _e = o.state
  return (
    _e.window === null &&
      ((_e.wsize = 1 << _e.wbits),
      (_e.wnext = 0),
      (_e.whave = 0),
      (_e.window = new utils.Buf8(_e.wsize))),
    $ >= _e.wsize
      ? (utils.arraySet(_e.window, a, s - _e.wsize, _e.wsize, 0),
        (_e.wnext = 0),
        (_e.whave = _e.wsize))
      : ((j = _e.wsize - _e.wnext),
        j > $ && (j = $),
        utils.arraySet(_e.window, a, s - $, j, _e.wnext),
        ($ -= j),
        $
          ? (utils.arraySet(_e.window, a, s - $, $, 0),
            (_e.wnext = $),
            (_e.whave = _e.wsize))
          : ((_e.wnext += j),
            _e.wnext === _e.wsize && (_e.wnext = 0),
            _e.whave < _e.wsize && (_e.whave += j))),
    0
  )
}
function inflate(o, a) {
  var s,
    $,
    j,
    _e,
    et,
    tt,
    rt,
    nt,
    it,
    ot,
    at,
    st,
    ut,
    ct,
    dt = 0,
    ft,
    mt,
    vt,
    yt,
    pt,
    ht,
    At,
    wt,
    Ct = new utils.Buf8(4),
    Dt,
    jt,
    Et = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  if (!o || !o.state || !o.output || (!o.input && o.avail_in !== 0))
    return Z_STREAM_ERROR
  ;(s = o.state),
    s.mode === TYPE && (s.mode = TYPEDO),
    (et = o.next_out),
    (j = o.output),
    (rt = o.avail_out),
    (_e = o.next_in),
    ($ = o.input),
    (tt = o.avail_in),
    (nt = s.hold),
    (it = s.bits),
    (ot = tt),
    (at = rt),
    (wt = Z_OK)
  e: for (;;)
    switch (s.mode) {
      case HEAD:
        if (s.wrap === 0) {
          s.mode = TYPEDO
          break
        }
        for (; it < 16; ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        if (s.wrap & 2 && nt === 35615) {
          ;(s.check = 0),
            (Ct[0] = nt & 255),
            (Ct[1] = (nt >>> 8) & 255),
            (s.check = crc32(s.check, Ct, 2, 0)),
            (nt = 0),
            (it = 0),
            (s.mode = FLAGS)
          break
        }
        if (
          ((s.flags = 0),
          s.head && (s.head.done = !1),
          !(s.wrap & 1) || (((nt & 255) << 8) + (nt >> 8)) % 31)
        ) {
          ;(o.msg = 'incorrect header check'), (s.mode = BAD)
          break
        }
        if ((nt & 15) !== Z_DEFLATED) {
          ;(o.msg = 'unknown compression method'), (s.mode = BAD)
          break
        }
        if (((nt >>>= 4), (it -= 4), (At = (nt & 15) + 8), s.wbits === 0))
          s.wbits = At
        else if (At > s.wbits) {
          ;(o.msg = 'invalid window size'), (s.mode = BAD)
          break
        }
        ;(s.dmax = 1 << At),
          (o.adler = s.check = 1),
          (s.mode = nt & 512 ? DICTID : TYPE),
          (nt = 0),
          (it = 0)
        break
      case FLAGS:
        for (; it < 16; ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        if (((s.flags = nt), (s.flags & 255) !== Z_DEFLATED)) {
          ;(o.msg = 'unknown compression method'), (s.mode = BAD)
          break
        }
        if (s.flags & 57344) {
          ;(o.msg = 'unknown header flags set'), (s.mode = BAD)
          break
        }
        s.head && (s.head.text = (nt >> 8) & 1),
          s.flags & 512 &&
            ((Ct[0] = nt & 255),
            (Ct[1] = (nt >>> 8) & 255),
            (s.check = crc32(s.check, Ct, 2, 0))),
          (nt = 0),
          (it = 0),
          (s.mode = TIME)
      case TIME:
        for (; it < 32; ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        s.head && (s.head.time = nt),
          s.flags & 512 &&
            ((Ct[0] = nt & 255),
            (Ct[1] = (nt >>> 8) & 255),
            (Ct[2] = (nt >>> 16) & 255),
            (Ct[3] = (nt >>> 24) & 255),
            (s.check = crc32(s.check, Ct, 4, 0))),
          (nt = 0),
          (it = 0),
          (s.mode = OS)
      case OS:
        for (; it < 16; ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        s.head && ((s.head.xflags = nt & 255), (s.head.os = nt >> 8)),
          s.flags & 512 &&
            ((Ct[0] = nt & 255),
            (Ct[1] = (nt >>> 8) & 255),
            (s.check = crc32(s.check, Ct, 2, 0))),
          (nt = 0),
          (it = 0),
          (s.mode = EXLEN)
      case EXLEN:
        if (s.flags & 1024) {
          for (; it < 16; ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          ;(s.length = nt),
            s.head && (s.head.extra_len = nt),
            s.flags & 512 &&
              ((Ct[0] = nt & 255),
              (Ct[1] = (nt >>> 8) & 255),
              (s.check = crc32(s.check, Ct, 2, 0))),
            (nt = 0),
            (it = 0)
        } else s.head && (s.head.extra = null)
        s.mode = EXTRA
      case EXTRA:
        if (
          s.flags & 1024 &&
          ((st = s.length),
          st > tt && (st = tt),
          st &&
            (s.head &&
              ((At = s.head.extra_len - s.length),
              s.head.extra || (s.head.extra = new Array(s.head.extra_len)),
              utils.arraySet(s.head.extra, $, _e, st, At)),
            s.flags & 512 && (s.check = crc32(s.check, $, st, _e)),
            (tt -= st),
            (_e += st),
            (s.length -= st)),
          s.length)
        )
          break e
        ;(s.length = 0), (s.mode = NAME)
      case NAME:
        if (s.flags & 2048) {
          if (tt === 0) break e
          st = 0
          do
            (At = $[_e + st++]),
              s.head &&
                At &&
                s.length < 65536 &&
                (s.head.name += String.fromCharCode(At))
          while (At && st < tt)
          if (
            (s.flags & 512 && (s.check = crc32(s.check, $, st, _e)),
            (tt -= st),
            (_e += st),
            At)
          )
            break e
        } else s.head && (s.head.name = null)
        ;(s.length = 0), (s.mode = COMMENT)
      case COMMENT:
        if (s.flags & 4096) {
          if (tt === 0) break e
          st = 0
          do
            (At = $[_e + st++]),
              s.head &&
                At &&
                s.length < 65536 &&
                (s.head.comment += String.fromCharCode(At))
          while (At && st < tt)
          if (
            (s.flags & 512 && (s.check = crc32(s.check, $, st, _e)),
            (tt -= st),
            (_e += st),
            At)
          )
            break e
        } else s.head && (s.head.comment = null)
        s.mode = HCRC
      case HCRC:
        if (s.flags & 512) {
          for (; it < 16; ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          if (nt !== (s.check & 65535)) {
            ;(o.msg = 'header crc mismatch'), (s.mode = BAD)
            break
          }
          ;(nt = 0), (it = 0)
        }
        s.head && ((s.head.hcrc = (s.flags >> 9) & 1), (s.head.done = !0)),
          (o.adler = s.check = 0),
          (s.mode = TYPE)
        break
      case DICTID:
        for (; it < 32; ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        ;(o.adler = s.check = zswap32(nt)), (nt = 0), (it = 0), (s.mode = DICT)
      case DICT:
        if (s.havedict === 0)
          return (
            (o.next_out = et),
            (o.avail_out = rt),
            (o.next_in = _e),
            (o.avail_in = tt),
            (s.hold = nt),
            (s.bits = it),
            Z_NEED_DICT
          )
        ;(o.adler = s.check = 1), (s.mode = TYPE)
      case TYPE:
        if (a === Z_BLOCK || a === Z_TREES) break e
      case TYPEDO:
        if (s.last) {
          ;(nt >>>= it & 7), (it -= it & 7), (s.mode = CHECK)
          break
        }
        for (; it < 3; ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        switch (((s.last = nt & 1), (nt >>>= 1), (it -= 1), nt & 3)) {
          case 0:
            s.mode = STORED
            break
          case 1:
            if ((fixedtables(s), (s.mode = LEN_), a === Z_TREES)) {
              ;(nt >>>= 2), (it -= 2)
              break e
            }
            break
          case 2:
            s.mode = TABLE
            break
          case 3:
            ;(o.msg = 'invalid block type'), (s.mode = BAD)
        }
        ;(nt >>>= 2), (it -= 2)
        break
      case STORED:
        for (nt >>>= it & 7, it -= it & 7; it < 32; ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        if ((nt & 65535) !== ((nt >>> 16) ^ 65535)) {
          ;(o.msg = 'invalid stored block lengths'), (s.mode = BAD)
          break
        }
        if (
          ((s.length = nt & 65535),
          (nt = 0),
          (it = 0),
          (s.mode = COPY_),
          a === Z_TREES)
        )
          break e
      case COPY_:
        s.mode = COPY$1
      case COPY$1:
        if (((st = s.length), st)) {
          if ((st > tt && (st = tt), st > rt && (st = rt), st === 0)) break e
          utils.arraySet(j, $, _e, st, et),
            (tt -= st),
            (_e += st),
            (rt -= st),
            (et += st),
            (s.length -= st)
          break
        }
        s.mode = TYPE
        break
      case TABLE:
        for (; it < 14; ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        if (
          ((s.nlen = (nt & 31) + 257),
          (nt >>>= 5),
          (it -= 5),
          (s.ndist = (nt & 31) + 1),
          (nt >>>= 5),
          (it -= 5),
          (s.ncode = (nt & 15) + 4),
          (nt >>>= 4),
          (it -= 4),
          s.nlen > 286 || s.ndist > 30)
        ) {
          ;(o.msg = 'too many length or distance symbols'), (s.mode = BAD)
          break
        }
        ;(s.have = 0), (s.mode = LENLENS)
      case LENLENS:
        for (; s.have < s.ncode; ) {
          for (; it < 3; ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          ;(s.lens[Et[s.have++]] = nt & 7), (nt >>>= 3), (it -= 3)
        }
        for (; s.have < 19; ) s.lens[Et[s.have++]] = 0
        if (
          ((s.lencode = s.lendyn),
          (s.lenbits = 7),
          (Dt = { bits: s.lenbits }),
          (wt = inflate_table(CODES, s.lens, 0, 19, s.lencode, 0, s.work, Dt)),
          (s.lenbits = Dt.bits),
          wt)
        ) {
          ;(o.msg = 'invalid code lengths set'), (s.mode = BAD)
          break
        }
        ;(s.have = 0), (s.mode = CODELENS)
      case CODELENS:
        for (; s.have < s.nlen + s.ndist; ) {
          for (
            ;
            (dt = s.lencode[nt & ((1 << s.lenbits) - 1)]),
              (ft = dt >>> 24),
              (mt = (dt >>> 16) & 255),
              (vt = dt & 65535),
              !(ft <= it);

          ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          if (vt < 16) (nt >>>= ft), (it -= ft), (s.lens[s.have++] = vt)
          else {
            if (vt === 16) {
              for (jt = ft + 2; it < jt; ) {
                if (tt === 0) break e
                tt--, (nt += $[_e++] << it), (it += 8)
              }
              if (((nt >>>= ft), (it -= ft), s.have === 0)) {
                ;(o.msg = 'invalid bit length repeat'), (s.mode = BAD)
                break
              }
              ;(At = s.lens[s.have - 1]),
                (st = 3 + (nt & 3)),
                (nt >>>= 2),
                (it -= 2)
            } else if (vt === 17) {
              for (jt = ft + 3; it < jt; ) {
                if (tt === 0) break e
                tt--, (nt += $[_e++] << it), (it += 8)
              }
              ;(nt >>>= ft),
                (it -= ft),
                (At = 0),
                (st = 3 + (nt & 7)),
                (nt >>>= 3),
                (it -= 3)
            } else {
              for (jt = ft + 7; it < jt; ) {
                if (tt === 0) break e
                tt--, (nt += $[_e++] << it), (it += 8)
              }
              ;(nt >>>= ft),
                (it -= ft),
                (At = 0),
                (st = 11 + (nt & 127)),
                (nt >>>= 7),
                (it -= 7)
            }
            if (s.have + st > s.nlen + s.ndist) {
              ;(o.msg = 'invalid bit length repeat'), (s.mode = BAD)
              break
            }
            for (; st--; ) s.lens[s.have++] = At
          }
        }
        if (s.mode === BAD) break
        if (s.lens[256] === 0) {
          ;(o.msg = 'invalid code -- missing end-of-block'), (s.mode = BAD)
          break
        }
        if (
          ((s.lenbits = 9),
          (Dt = { bits: s.lenbits }),
          (wt = inflate_table(
            LENS,
            s.lens,
            0,
            s.nlen,
            s.lencode,
            0,
            s.work,
            Dt
          )),
          (s.lenbits = Dt.bits),
          wt)
        ) {
          ;(o.msg = 'invalid literal/lengths set'), (s.mode = BAD)
          break
        }
        if (
          ((s.distbits = 6),
          (s.distcode = s.distdyn),
          (Dt = { bits: s.distbits }),
          (wt = inflate_table(
            DISTS,
            s.lens,
            s.nlen,
            s.ndist,
            s.distcode,
            0,
            s.work,
            Dt
          )),
          (s.distbits = Dt.bits),
          wt)
        ) {
          ;(o.msg = 'invalid distances set'), (s.mode = BAD)
          break
        }
        if (((s.mode = LEN_), a === Z_TREES)) break e
      case LEN_:
        s.mode = LEN
      case LEN:
        if (tt >= 6 && rt >= 258) {
          ;(o.next_out = et),
            (o.avail_out = rt),
            (o.next_in = _e),
            (o.avail_in = tt),
            (s.hold = nt),
            (s.bits = it),
            inflate_fast(o, at),
            (et = o.next_out),
            (j = o.output),
            (rt = o.avail_out),
            (_e = o.next_in),
            ($ = o.input),
            (tt = o.avail_in),
            (nt = s.hold),
            (it = s.bits),
            s.mode === TYPE && (s.back = -1)
          break
        }
        for (
          s.back = 0;
          (dt = s.lencode[nt & ((1 << s.lenbits) - 1)]),
            (ft = dt >>> 24),
            (mt = (dt >>> 16) & 255),
            (vt = dt & 65535),
            !(ft <= it);

        ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        if (mt && !(mt & 240)) {
          for (
            yt = ft, pt = mt, ht = vt;
            (dt = s.lencode[ht + ((nt & ((1 << (yt + pt)) - 1)) >> yt)]),
              (ft = dt >>> 24),
              (mt = (dt >>> 16) & 255),
              (vt = dt & 65535),
              !(yt + ft <= it);

          ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          ;(nt >>>= yt), (it -= yt), (s.back += yt)
        }
        if (
          ((nt >>>= ft), (it -= ft), (s.back += ft), (s.length = vt), mt === 0)
        ) {
          s.mode = LIT
          break
        }
        if (mt & 32) {
          ;(s.back = -1), (s.mode = TYPE)
          break
        }
        if (mt & 64) {
          ;(o.msg = 'invalid literal/length code'), (s.mode = BAD)
          break
        }
        ;(s.extra = mt & 15), (s.mode = LENEXT)
      case LENEXT:
        if (s.extra) {
          for (jt = s.extra; it < jt; ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          ;(s.length += nt & ((1 << s.extra) - 1)),
            (nt >>>= s.extra),
            (it -= s.extra),
            (s.back += s.extra)
        }
        ;(s.was = s.length), (s.mode = DIST)
      case DIST:
        for (
          ;
          (dt = s.distcode[nt & ((1 << s.distbits) - 1)]),
            (ft = dt >>> 24),
            (mt = (dt >>> 16) & 255),
            (vt = dt & 65535),
            !(ft <= it);

        ) {
          if (tt === 0) break e
          tt--, (nt += $[_e++] << it), (it += 8)
        }
        if (!(mt & 240)) {
          for (
            yt = ft, pt = mt, ht = vt;
            (dt = s.distcode[ht + ((nt & ((1 << (yt + pt)) - 1)) >> yt)]),
              (ft = dt >>> 24),
              (mt = (dt >>> 16) & 255),
              (vt = dt & 65535),
              !(yt + ft <= it);

          ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          ;(nt >>>= yt), (it -= yt), (s.back += yt)
        }
        if (((nt >>>= ft), (it -= ft), (s.back += ft), mt & 64)) {
          ;(o.msg = 'invalid distance code'), (s.mode = BAD)
          break
        }
        ;(s.offset = vt), (s.extra = mt & 15), (s.mode = DISTEXT)
      case DISTEXT:
        if (s.extra) {
          for (jt = s.extra; it < jt; ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          ;(s.offset += nt & ((1 << s.extra) - 1)),
            (nt >>>= s.extra),
            (it -= s.extra),
            (s.back += s.extra)
        }
        if (s.offset > s.dmax) {
          ;(o.msg = 'invalid distance too far back'), (s.mode = BAD)
          break
        }
        s.mode = MATCH
      case MATCH:
        if (rt === 0) break e
        if (((st = at - rt), s.offset > st)) {
          if (((st = s.offset - st), st > s.whave && s.sane)) {
            ;(o.msg = 'invalid distance too far back'), (s.mode = BAD)
            break
          }
          st > s.wnext
            ? ((st -= s.wnext), (ut = s.wsize - st))
            : (ut = s.wnext - st),
            st > s.length && (st = s.length),
            (ct = s.window)
        } else (ct = j), (ut = et - s.offset), (st = s.length)
        st > rt && (st = rt), (rt -= st), (s.length -= st)
        do j[et++] = ct[ut++]
        while (--st)
        s.length === 0 && (s.mode = LEN)
        break
      case LIT:
        if (rt === 0) break e
        ;(j[et++] = s.length), rt--, (s.mode = LEN)
        break
      case CHECK:
        if (s.wrap) {
          for (; it < 32; ) {
            if (tt === 0) break e
            tt--, (nt |= $[_e++] << it), (it += 8)
          }
          if (
            ((at -= rt),
            (o.total_out += at),
            (s.total += at),
            at &&
              (o.adler = s.check = s.flags
                ? crc32(s.check, j, at, et - at)
                : adler32(s.check, j, at, et - at)),
            (at = rt),
            (s.flags ? nt : zswap32(nt)) !== s.check)
          ) {
            ;(o.msg = 'incorrect data check'), (s.mode = BAD)
            break
          }
          ;(nt = 0), (it = 0)
        }
        s.mode = LENGTH
      case LENGTH:
        if (s.wrap && s.flags) {
          for (; it < 32; ) {
            if (tt === 0) break e
            tt--, (nt += $[_e++] << it), (it += 8)
          }
          if (nt !== (s.total & 4294967295)) {
            ;(o.msg = 'incorrect length check'), (s.mode = BAD)
            break
          }
          ;(nt = 0), (it = 0)
        }
        s.mode = DONE
      case DONE:
        wt = Z_STREAM_END
        break e
      case BAD:
        wt = Z_DATA_ERROR
        break e
      case MEM:
        return Z_MEM_ERROR
      case SYNC:
      default:
        return Z_STREAM_ERROR
    }
  return (
    (o.next_out = et),
    (o.avail_out = rt),
    (o.next_in = _e),
    (o.avail_in = tt),
    (s.hold = nt),
    (s.bits = it),
    (s.wsize ||
      (at !== o.avail_out &&
        s.mode < BAD &&
        (s.mode < CHECK || a !== Z_FINISH))) &&
      updatewindow(o, o.output, o.next_out, at - o.avail_out),
    (ot -= o.avail_in),
    (at -= o.avail_out),
    (o.total_in += ot),
    (o.total_out += at),
    (s.total += at),
    s.wrap &&
      at &&
      (o.adler = s.check = s.flags
        ? crc32(s.check, j, at, o.next_out - at)
        : adler32(s.check, j, at, o.next_out - at)),
    (o.data_type =
      s.bits +
      (s.last ? 64 : 0) +
      (s.mode === TYPE ? 128 : 0) +
      (s.mode === LEN_ || s.mode === COPY_ ? 256 : 0)),
    ((ot === 0 && at === 0) || a === Z_FINISH) &&
      wt === Z_OK &&
      (wt = Z_BUF_ERROR),
    wt
  )
}
function inflateEnd(o) {
  if (!o || !o.state) return Z_STREAM_ERROR
  var a = o.state
  return a.window && (a.window = null), (o.state = null), Z_OK
}
function inflateGetHeader(o, a) {
  var s
  return !o || !o.state || ((s = o.state), !(s.wrap & 2))
    ? Z_STREAM_ERROR
    : ((s.head = a), (a.done = !1), Z_OK)
}
function inflateSetDictionary(o, a) {
  var s = a.length,
    $,
    j,
    _e
  return !o || !o.state || (($ = o.state), $.wrap !== 0 && $.mode !== DICT)
    ? Z_STREAM_ERROR
    : $.mode === DICT && ((j = 1), (j = adler32(j, a, s, 0)), j !== $.check)
    ? Z_DATA_ERROR
    : ((_e = updatewindow(o, a, s, s)),
      _e ? (($.mode = MEM), Z_MEM_ERROR) : (($.havedict = 1), Z_OK))
}
inflate$1.inflateReset = inflateReset
inflate$1.inflateReset2 = inflateReset2
inflate$1.inflateResetKeep = inflateResetKeep
inflate$1.inflateInit = inflateInit
inflate$1.inflateInit2 = inflateInit2
inflate$1.inflate = inflate
inflate$1.inflateEnd = inflateEnd
inflate$1.inflateGetHeader = inflateGetHeader
inflate$1.inflateSetDictionary = inflateSetDictionary
inflate$1.inflateInfo = 'pako inflate (from Nodeca project)'
var constants$6 = {
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_BUF_ERROR: -5,
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  Z_BINARY: 0,
  Z_TEXT: 1,
  Z_UNKNOWN: 2,
  Z_DEFLATED: 8,
}
;(function(o) {
  var a = requireAssert(),
    s = zstream,
    $ = deflate$1,
    j = inflate$1,
    _e = constants$6
  for (var et in _e) o[et] = _e[et]
  ;(o.NONE = 0),
    (o.DEFLATE = 1),
    (o.INFLATE = 2),
    (o.GZIP = 3),
    (o.GUNZIP = 4),
    (o.DEFLATERAW = 5),
    (o.INFLATERAW = 6),
    (o.UNZIP = 7)
  var tt = 31,
    rt = 139
  function nt(it) {
    if (typeof it != 'number' || it < o.DEFLATE || it > o.UNZIP)
      throw new TypeError('Bad argument')
    ;(this.dictionary = null),
      (this.err = 0),
      (this.flush = 0),
      (this.init_done = !1),
      (this.level = 0),
      (this.memLevel = 0),
      (this.mode = it),
      (this.strategy = 0),
      (this.windowBits = 0),
      (this.write_in_progress = !1),
      (this.pending_close = !1),
      (this.gzip_id_bytes_read = 0)
  }
  ;(nt.prototype.close = function() {
    if (this.write_in_progress) {
      this.pending_close = !0
      return
    }
    ;(this.pending_close = !1),
      a(this.init_done, 'close before init'),
      a(this.mode <= o.UNZIP),
      this.mode === o.DEFLATE ||
      this.mode === o.GZIP ||
      this.mode === o.DEFLATERAW
        ? $.deflateEnd(this.strm)
        : (this.mode === o.INFLATE ||
            this.mode === o.GUNZIP ||
            this.mode === o.INFLATERAW ||
            this.mode === o.UNZIP) &&
          j.inflateEnd(this.strm),
      (this.mode = o.NONE),
      (this.dictionary = null)
  }),
    (nt.prototype.write = function(it, ot, at, st, ut, ct, dt) {
      return this._write(!0, it, ot, at, st, ut, ct, dt)
    }),
    (nt.prototype.writeSync = function(it, ot, at, st, ut, ct, dt) {
      return this._write(!1, it, ot, at, st, ut, ct, dt)
    }),
    (nt.prototype._write = function(it, ot, at, st, ut, ct, dt, ft) {
      if (
        (a.equal(arguments.length, 8),
        a(this.init_done, 'write before init'),
        a(this.mode !== o.NONE, 'already finalized'),
        a.equal(!1, this.write_in_progress, 'write already in progress'),
        a.equal(!1, this.pending_close, 'close is pending'),
        (this.write_in_progress = !0),
        a.equal(!1, ot === void 0, 'must provide flush value'),
        (this.write_in_progress = !0),
        ot !== o.Z_NO_FLUSH &&
          ot !== o.Z_PARTIAL_FLUSH &&
          ot !== o.Z_SYNC_FLUSH &&
          ot !== o.Z_FULL_FLUSH &&
          ot !== o.Z_FINISH &&
          ot !== o.Z_BLOCK)
      )
        throw new Error('Invalid flush value')
      if (
        (at == null && ((at = Buffer.alloc(0)), (ut = 0), (st = 0)),
        (this.strm.avail_in = ut),
        (this.strm.input = at),
        (this.strm.next_in = st),
        (this.strm.avail_out = ft),
        (this.strm.output = ct),
        (this.strm.next_out = dt),
        (this.flush = ot),
        !it)
      )
        return this._process(), this._checkError() ? this._afterSync() : void 0
      var mt = this
      return (
        process.nextTick(function() {
          mt._process(), mt._after()
        }),
        this
      )
    }),
    (nt.prototype._afterSync = function() {
      var it = this.strm.avail_out,
        ot = this.strm.avail_in
      return (this.write_in_progress = !1), [ot, it]
    }),
    (nt.prototype._process = function() {
      var it = null
      switch (this.mode) {
        case o.DEFLATE:
        case o.GZIP:
        case o.DEFLATERAW:
          this.err = $.deflate(this.strm, this.flush)
          break
        case o.UNZIP:
          switch (
            (this.strm.avail_in > 0 && (it = this.strm.next_in),
            this.gzip_id_bytes_read)
          ) {
            case 0:
              if (it === null) break
              if (this.strm.input[it] === tt) {
                if (
                  ((this.gzip_id_bytes_read = 1),
                  it++,
                  this.strm.avail_in === 1)
                )
                  break
              } else {
                this.mode = o.INFLATE
                break
              }
            case 1:
              if (it === null) break
              this.strm.input[it] === rt
                ? ((this.gzip_id_bytes_read = 2), (this.mode = o.GUNZIP))
                : (this.mode = o.INFLATE)
              break
            default:
              throw new Error('invalid number of gzip magic number bytes read')
          }
        case o.INFLATE:
        case o.GUNZIP:
        case o.INFLATERAW:
          for (
            this.err = j.inflate(this.strm, this.flush),
              this.err === o.Z_NEED_DICT &&
                this.dictionary &&
                ((this.err = j.inflateSetDictionary(
                  this.strm,
                  this.dictionary
                )),
                this.err === o.Z_OK
                  ? (this.err = j.inflate(this.strm, this.flush))
                  : this.err === o.Z_DATA_ERROR && (this.err = o.Z_NEED_DICT));
            this.strm.avail_in > 0 &&
            this.mode === o.GUNZIP &&
            this.err === o.Z_STREAM_END &&
            this.strm.next_in[0] !== 0;

          )
            this.reset(), (this.err = j.inflate(this.strm, this.flush))
          break
        default:
          throw new Error('Unknown mode ' + this.mode)
      }
    }),
    (nt.prototype._checkError = function() {
      switch (this.err) {
        case o.Z_OK:
        case o.Z_BUF_ERROR:
          if (this.strm.avail_out !== 0 && this.flush === o.Z_FINISH)
            return this._error('unexpected end of file'), !1
          break
        case o.Z_STREAM_END:
          break
        case o.Z_NEED_DICT:
          return (
            this.dictionary == null
              ? this._error('Missing dictionary')
              : this._error('Bad dictionary'),
            !1
          )
        default:
          return this._error('Zlib error'), !1
      }
      return !0
    }),
    (nt.prototype._after = function() {
      if (this._checkError()) {
        var it = this.strm.avail_out,
          ot = this.strm.avail_in
        ;(this.write_in_progress = !1),
          this.callback(ot, it),
          this.pending_close && this.close()
      }
    }),
    (nt.prototype._error = function(it) {
      this.strm.msg && (it = this.strm.msg),
        this.onerror(it, this.err),
        (this.write_in_progress = !1),
        this.pending_close && this.close()
    }),
    (nt.prototype.init = function(it, ot, at, st, ut) {
      a(
        arguments.length === 4 || arguments.length === 5,
        'init(windowBits, level, memLevel, strategy, [dictionary])'
      ),
        a(it >= 8 && it <= 15, 'invalid windowBits'),
        a(ot >= -1 && ot <= 9, 'invalid compression level'),
        a(at >= 1 && at <= 9, 'invalid memlevel'),
        a(
          st === o.Z_FILTERED ||
            st === o.Z_HUFFMAN_ONLY ||
            st === o.Z_RLE ||
            st === o.Z_FIXED ||
            st === o.Z_DEFAULT_STRATEGY,
          'invalid strategy'
        ),
        this._init(ot, it, at, st, ut),
        this._setDictionary()
    }),
    (nt.prototype.params = function() {
      throw new Error('deflateParams Not supported')
    }),
    (nt.prototype.reset = function() {
      this._reset(), this._setDictionary()
    }),
    (nt.prototype._init = function(it, ot, at, st, ut) {
      switch (
        ((this.level = it),
        (this.windowBits = ot),
        (this.memLevel = at),
        (this.strategy = st),
        (this.flush = o.Z_NO_FLUSH),
        (this.err = o.Z_OK),
        (this.mode === o.GZIP || this.mode === o.GUNZIP) &&
          (this.windowBits += 16),
        this.mode === o.UNZIP && (this.windowBits += 32),
        (this.mode === o.DEFLATERAW || this.mode === o.INFLATERAW) &&
          (this.windowBits = -1 * this.windowBits),
        (this.strm = new s()),
        this.mode)
      ) {
        case o.DEFLATE:
        case o.GZIP:
        case o.DEFLATERAW:
          this.err = $.deflateInit2(
            this.strm,
            this.level,
            o.Z_DEFLATED,
            this.windowBits,
            this.memLevel,
            this.strategy
          )
          break
        case o.INFLATE:
        case o.GUNZIP:
        case o.INFLATERAW:
        case o.UNZIP:
          this.err = j.inflateInit2(this.strm, this.windowBits)
          break
        default:
          throw new Error('Unknown mode ' + this.mode)
      }
      this.err !== o.Z_OK && this._error('Init error'),
        (this.dictionary = ut),
        (this.write_in_progress = !1),
        (this.init_done = !0)
    }),
    (nt.prototype._setDictionary = function() {
      if (this.dictionary != null) {
        switch (((this.err = o.Z_OK), this.mode)) {
          case o.DEFLATE:
          case o.DEFLATERAW:
            this.err = $.deflateSetDictionary(this.strm, this.dictionary)
            break
        }
        this.err !== o.Z_OK && this._error('Failed to set dictionary')
      }
    }),
    (nt.prototype._reset = function() {
      switch (((this.err = o.Z_OK), this.mode)) {
        case o.DEFLATE:
        case o.DEFLATERAW:
        case o.GZIP:
          this.err = $.deflateReset(this.strm)
          break
        case o.INFLATE:
        case o.INFLATERAW:
        case o.GUNZIP:
          this.err = j.inflateReset(this.strm)
          break
      }
      this.err !== o.Z_OK && this._error('Failed to reset stream')
    }),
    (o.Zlib = nt)
})(binding)
;(function(o) {
  var a = buffer$1.Buffer,
    s = stream$1.Transform,
    $ = binding,
    j = util$u,
    _e = requireAssert().ok,
    et = buffer$1.kMaxLength,
    tt =
      'Cannot create final Buffer. It would be larger than 0x' +
      et.toString(16) +
      ' bytes'
  ;($.Z_MIN_WINDOWBITS = 8),
    ($.Z_MAX_WINDOWBITS = 15),
    ($.Z_DEFAULT_WINDOWBITS = 15),
    ($.Z_MIN_CHUNK = 64),
    ($.Z_MAX_CHUNK = 1 / 0),
    ($.Z_DEFAULT_CHUNK = 16 * 1024),
    ($.Z_MIN_MEMLEVEL = 1),
    ($.Z_MAX_MEMLEVEL = 9),
    ($.Z_DEFAULT_MEMLEVEL = 8),
    ($.Z_MIN_LEVEL = -1),
    ($.Z_MAX_LEVEL = 9),
    ($.Z_DEFAULT_LEVEL = $.Z_DEFAULT_COMPRESSION)
  for (var rt = Object.keys($), nt = 0; nt < rt.length; nt++) {
    var it = rt[nt]
    it.match(/^Z/) &&
      Object.defineProperty(o, it, {
        enumerable: !0,
        value: $[it],
        writable: !1,
      })
  }
  for (
    var ot = {
        Z_OK: $.Z_OK,
        Z_STREAM_END: $.Z_STREAM_END,
        Z_NEED_DICT: $.Z_NEED_DICT,
        Z_ERRNO: $.Z_ERRNO,
        Z_STREAM_ERROR: $.Z_STREAM_ERROR,
        Z_DATA_ERROR: $.Z_DATA_ERROR,
        Z_MEM_ERROR: $.Z_MEM_ERROR,
        Z_BUF_ERROR: $.Z_BUF_ERROR,
        Z_VERSION_ERROR: $.Z_VERSION_ERROR,
      },
      at = Object.keys(ot),
      st = 0;
    st < at.length;
    st++
  ) {
    var ut = at[st]
    ot[ot[ut]] = ut
  }
  Object.defineProperty(o, 'codes', {
    enumerable: !0,
    value: Object.freeze(ot),
    writable: !1,
  }),
    (o.Deflate = ft),
    (o.Inflate = mt),
    (o.Gzip = vt),
    (o.Gunzip = yt),
    (o.DeflateRaw = pt),
    (o.InflateRaw = ht),
    (o.Unzip = At),
    (o.createDeflate = function(Et) {
      return new ft(Et)
    }),
    (o.createInflate = function(Et) {
      return new mt(Et)
    }),
    (o.createDeflateRaw = function(Et) {
      return new pt(Et)
    }),
    (o.createInflateRaw = function(Et) {
      return new ht(Et)
    }),
    (o.createGzip = function(Et) {
      return new vt(Et)
    }),
    (o.createGunzip = function(Et) {
      return new yt(Et)
    }),
    (o.createUnzip = function(Et) {
      return new At(Et)
    }),
    (o.deflate = function(Et, St, Bt) {
      return (
        typeof St == 'function' && ((Bt = St), (St = {})),
        ct(new ft(St), Et, Bt)
      )
    }),
    (o.deflateSync = function(Et, St) {
      return dt(new ft(St), Et)
    }),
    (o.gzip = function(Et, St, Bt) {
      return (
        typeof St == 'function' && ((Bt = St), (St = {})),
        ct(new vt(St), Et, Bt)
      )
    }),
    (o.gzipSync = function(Et, St) {
      return dt(new vt(St), Et)
    }),
    (o.deflateRaw = function(Et, St, Bt) {
      return (
        typeof St == 'function' && ((Bt = St), (St = {})),
        ct(new pt(St), Et, Bt)
      )
    }),
    (o.deflateRawSync = function(Et, St) {
      return dt(new pt(St), Et)
    }),
    (o.unzip = function(Et, St, Bt) {
      return (
        typeof St == 'function' && ((Bt = St), (St = {})),
        ct(new At(St), Et, Bt)
      )
    }),
    (o.unzipSync = function(Et, St) {
      return dt(new At(St), Et)
    }),
    (o.inflate = function(Et, St, Bt) {
      return (
        typeof St == 'function' && ((Bt = St), (St = {})),
        ct(new mt(St), Et, Bt)
      )
    }),
    (o.inflateSync = function(Et, St) {
      return dt(new mt(St), Et)
    }),
    (o.gunzip = function(Et, St, Bt) {
      return (
        typeof St == 'function' && ((Bt = St), (St = {})),
        ct(new yt(St), Et, Bt)
      )
    }),
    (o.gunzipSync = function(Et, St) {
      return dt(new yt(St), Et)
    }),
    (o.inflateRaw = function(Et, St, Bt) {
      return (
        typeof St == 'function' && ((Bt = St), (St = {})),
        ct(new ht(St), Et, Bt)
      )
    }),
    (o.inflateRawSync = function(Et, St) {
      return dt(new ht(St), Et)
    })
  function ct(Et, St, Bt) {
    var Mt = [],
      Ut = 0
    Et.on('error', Tt), Et.on('end', kt), Et.end(St), Wt()
    function Wt() {
      for (var Ot; (Ot = Et.read()) !== null; ) Mt.push(Ot), (Ut += Ot.length)
      Et.once('readable', Wt)
    }
    function Tt(Ot) {
      Et.removeListener('end', kt), Et.removeListener('readable', Wt), Bt(Ot)
    }
    function kt() {
      var Ot,
        Nt = null
      Ut >= et ? (Nt = new RangeError(tt)) : (Ot = a.concat(Mt, Ut)),
        (Mt = []),
        Et.close(),
        Bt(Nt, Ot)
    }
  }
  function dt(Et, St) {
    if ((typeof St == 'string' && (St = a.from(St)), !a.isBuffer(St)))
      throw new TypeError('Not a string or buffer')
    var Bt = Et._finishFlushFlag
    return Et._processChunk(St, Bt)
  }
  function ft(Et) {
    if (!(this instanceof ft)) return new ft(Et)
    Ct.call(this, Et, $.DEFLATE)
  }
  function mt(Et) {
    if (!(this instanceof mt)) return new mt(Et)
    Ct.call(this, Et, $.INFLATE)
  }
  function vt(Et) {
    if (!(this instanceof vt)) return new vt(Et)
    Ct.call(this, Et, $.GZIP)
  }
  function yt(Et) {
    if (!(this instanceof yt)) return new yt(Et)
    Ct.call(this, Et, $.GUNZIP)
  }
  function pt(Et) {
    if (!(this instanceof pt)) return new pt(Et)
    Ct.call(this, Et, $.DEFLATERAW)
  }
  function ht(Et) {
    if (!(this instanceof ht)) return new ht(Et)
    Ct.call(this, Et, $.INFLATERAW)
  }
  function At(Et) {
    if (!(this instanceof At)) return new At(Et)
    Ct.call(this, Et, $.UNZIP)
  }
  function wt(Et) {
    return (
      Et === $.Z_NO_FLUSH ||
      Et === $.Z_PARTIAL_FLUSH ||
      Et === $.Z_SYNC_FLUSH ||
      Et === $.Z_FULL_FLUSH ||
      Et === $.Z_FINISH ||
      Et === $.Z_BLOCK
    )
  }
  function Ct(Et, St) {
    var Bt = this
    if (
      ((this._opts = Et = Et || {}),
      (this._chunkSize = Et.chunkSize || o.Z_DEFAULT_CHUNK),
      s.call(this, Et),
      Et.flush && !wt(Et.flush))
    )
      throw new Error('Invalid flush flag: ' + Et.flush)
    if (Et.finishFlush && !wt(Et.finishFlush))
      throw new Error('Invalid flush flag: ' + Et.finishFlush)
    if (
      ((this._flushFlag = Et.flush || $.Z_NO_FLUSH),
      (this._finishFlushFlag =
        typeof Et.finishFlush < 'u' ? Et.finishFlush : $.Z_FINISH),
      Et.chunkSize &&
        (Et.chunkSize < o.Z_MIN_CHUNK || Et.chunkSize > o.Z_MAX_CHUNK))
    )
      throw new Error('Invalid chunk size: ' + Et.chunkSize)
    if (
      Et.windowBits &&
      (Et.windowBits < o.Z_MIN_WINDOWBITS || Et.windowBits > o.Z_MAX_WINDOWBITS)
    )
      throw new Error('Invalid windowBits: ' + Et.windowBits)
    if (Et.level && (Et.level < o.Z_MIN_LEVEL || Et.level > o.Z_MAX_LEVEL))
      throw new Error('Invalid compression level: ' + Et.level)
    if (
      Et.memLevel &&
      (Et.memLevel < o.Z_MIN_MEMLEVEL || Et.memLevel > o.Z_MAX_MEMLEVEL)
    )
      throw new Error('Invalid memLevel: ' + Et.memLevel)
    if (
      Et.strategy &&
      Et.strategy != o.Z_FILTERED &&
      Et.strategy != o.Z_HUFFMAN_ONLY &&
      Et.strategy != o.Z_RLE &&
      Et.strategy != o.Z_FIXED &&
      Et.strategy != o.Z_DEFAULT_STRATEGY
    )
      throw new Error('Invalid strategy: ' + Et.strategy)
    if (Et.dictionary && !a.isBuffer(Et.dictionary))
      throw new Error('Invalid dictionary: it should be a Buffer instance')
    this._handle = new $.Zlib(St)
    var Mt = this
    ;(this._hadError = !1),
      (this._handle.onerror = function(Tt, kt) {
        Dt(Mt), (Mt._hadError = !0)
        var Ot = new Error(Tt)
        ;(Ot.errno = kt), (Ot.code = o.codes[kt]), Mt.emit('error', Ot)
      })
    var Ut = o.Z_DEFAULT_COMPRESSION
    typeof Et.level == 'number' && (Ut = Et.level)
    var Wt = o.Z_DEFAULT_STRATEGY
    typeof Et.strategy == 'number' && (Wt = Et.strategy),
      this._handle.init(
        Et.windowBits || o.Z_DEFAULT_WINDOWBITS,
        Ut,
        Et.memLevel || o.Z_DEFAULT_MEMLEVEL,
        Wt,
        Et.dictionary
      ),
      (this._buffer = a.allocUnsafe(this._chunkSize)),
      (this._offset = 0),
      (this._level = Ut),
      (this._strategy = Wt),
      this.once('end', this.close),
      Object.defineProperty(this, '_closed', {
        get: function() {
          return !Bt._handle
        },
        configurable: !0,
        enumerable: !0,
      })
  }
  j.inherits(Ct, s),
    (Ct.prototype.params = function(Et, St, Bt) {
      if (Et < o.Z_MIN_LEVEL || Et > o.Z_MAX_LEVEL)
        throw new RangeError('Invalid compression level: ' + Et)
      if (
        St != o.Z_FILTERED &&
        St != o.Z_HUFFMAN_ONLY &&
        St != o.Z_RLE &&
        St != o.Z_FIXED &&
        St != o.Z_DEFAULT_STRATEGY
      )
        throw new TypeError('Invalid strategy: ' + St)
      if (this._level !== Et || this._strategy !== St) {
        var Mt = this
        this.flush($.Z_SYNC_FLUSH, function() {
          _e(Mt._handle, 'zlib binding closed'),
            Mt._handle.params(Et, St),
            Mt._hadError || ((Mt._level = Et), (Mt._strategy = St), Bt && Bt())
        })
      } else process.nextTick(Bt)
    }),
    (Ct.prototype.reset = function() {
      return _e(this._handle, 'zlib binding closed'), this._handle.reset()
    }),
    (Ct.prototype._flush = function(Et) {
      this._transform(a.alloc(0), '', Et)
    }),
    (Ct.prototype.flush = function(Et, St) {
      var Bt = this,
        Mt = this._writableState
      ;(typeof Et == 'function' || (Et === void 0 && !St)) &&
        ((St = Et), (Et = $.Z_FULL_FLUSH)),
        Mt.ended
          ? St && process.nextTick(St)
          : Mt.ending
          ? St && this.once('end', St)
          : Mt.needDrain
          ? St &&
            this.once('drain', function() {
              return Bt.flush(Et, St)
            })
          : ((this._flushFlag = Et), this.write(a.alloc(0), '', St))
    }),
    (Ct.prototype.close = function(Et) {
      Dt(this, Et), process.nextTick(jt, this)
    })
  function Dt(Et, St) {
    St && process.nextTick(St),
      Et._handle && (Et._handle.close(), (Et._handle = null))
  }
  function jt(Et) {
    Et.emit('close')
  }
  ;(Ct.prototype._transform = function(Et, St, Bt) {
    var Mt,
      Ut = this._writableState,
      Wt = Ut.ending || Ut.ended,
      Tt = Wt && (!Et || Ut.length === Et.length)
    if (Et !== null && !a.isBuffer(Et)) return Bt(new Error('invalid input'))
    if (!this._handle) return Bt(new Error('zlib binding closed'))
    Tt
      ? (Mt = this._finishFlushFlag)
      : ((Mt = this._flushFlag),
        Et.length >= Ut.length &&
          (this._flushFlag = this._opts.flush || $.Z_NO_FLUSH)),
      this._processChunk(Et, Mt, Bt)
  }),
    (Ct.prototype._processChunk = function(Et, St, Bt) {
      var Mt = Et && Et.length,
        Ut = this._chunkSize - this._offset,
        Wt = 0,
        Tt = this,
        kt = typeof Bt == 'function'
      if (!kt) {
        var Ot = [],
          Nt = 0,
          $t
        this.on('error', function(Yt) {
          $t = Yt
        }),
          _e(this._handle, 'zlib binding closed')
        do
          var Pt = this._handle.writeSync(
            St,
            Et,
            Wt,
            Mt,
            this._buffer,
            this._offset,
            Ut
          )
        while (!this._hadError && Xt(Pt[0], Pt[1]))
        if (this._hadError) throw $t
        if (Nt >= et) throw (Dt(this), new RangeError(tt))
        var Ft = a.concat(Ot, Nt)
        return Dt(this), Ft
      }
      _e(this._handle, 'zlib binding closed')
      var Vt = this._handle.write(
        St,
        Et,
        Wt,
        Mt,
        this._buffer,
        this._offset,
        Ut
      )
      ;(Vt.buffer = Et), (Vt.callback = Xt)
      function Xt(Yt, xt) {
        if (
          (this && ((this.buffer = null), (this.callback = null)),
          !Tt._hadError)
        ) {
          var It = Ut - xt
          if ((_e(It >= 0, 'have should not go down'), It > 0)) {
            var Kt = Tt._buffer.slice(Tt._offset, Tt._offset + It)
            ;(Tt._offset += It),
              kt ? Tt.push(Kt) : (Ot.push(Kt), (Nt += Kt.length))
          }
          if (
            ((xt === 0 || Tt._offset >= Tt._chunkSize) &&
              ((Ut = Tt._chunkSize),
              (Tt._offset = 0),
              (Tt._buffer = a.allocUnsafe(Tt._chunkSize))),
            xt === 0)
          ) {
            if (((Wt += Mt - Yt), (Mt = Yt), !kt)) return !0
            var Qt = Tt._handle.write(
              St,
              Et,
              Wt,
              Mt,
              Tt._buffer,
              Tt._offset,
              Tt._chunkSize
            )
            ;(Qt.callback = Xt), (Qt.buffer = Et)
            return
          }
          if (!kt) return !1
          Bt()
        }
      }
    }),
    j.inherits(ft, Ct),
    j.inherits(mt, Ct),
    j.inherits(vt, Ct),
    j.inherits(yt, Ct),
    j.inherits(pt, Ct),
    j.inherits(ht, Ct),
    j.inherits(At, Ct)
})(lib$2)
var chunkstream = { exports: {} }
let util$5 = util$u,
  Stream$2 = stream$1,
  ChunkStream$2 = (chunkstream.exports = function() {
    Stream$2.call(this),
      (this._buffers = []),
      (this._buffered = 0),
      (this._reads = []),
      (this._paused = !1),
      (this._encoding = 'utf8'),
      (this.writable = !0)
  })
util$5.inherits(ChunkStream$2, Stream$2)
ChunkStream$2.prototype.read = function(o, a) {
  this._reads.push({ length: Math.abs(o), allowLess: o < 0, func: a }),
    process.nextTick(
      function() {
        this._process(),
          this._paused &&
            this._reads &&
            this._reads.length > 0 &&
            ((this._paused = !1), this.emit('drain'))
      }.bind(this)
    )
}
ChunkStream$2.prototype.write = function(o, a) {
  if (!this.writable)
    return this.emit('error', new Error('Stream not writable')), !1
  let s
  return (
    Buffer.isBuffer(o) ? (s = o) : (s = Buffer.from(o, a || this._encoding)),
    this._buffers.push(s),
    (this._buffered += s.length),
    this._process(),
    this._reads && this._reads.length === 0 && (this._paused = !0),
    this.writable && !this._paused
  )
}
ChunkStream$2.prototype.end = function(o, a) {
  o && this.write(o, a),
    (this.writable = !1),
    this._buffers &&
      (this._buffers.length === 0
        ? this._end()
        : (this._buffers.push(null), this._process()))
}
ChunkStream$2.prototype.destroySoon = ChunkStream$2.prototype.end
ChunkStream$2.prototype._end = function() {
  this._reads.length > 0 &&
    this.emit('error', new Error('Unexpected end of input')),
    this.destroy()
}
ChunkStream$2.prototype.destroy = function() {
  this._buffers &&
    ((this.writable = !1),
    (this._reads = null),
    (this._buffers = null),
    this.emit('close'))
}
ChunkStream$2.prototype._processReadAllowingLess = function(o) {
  this._reads.shift()
  let a = this._buffers[0]
  a.length > o.length
    ? ((this._buffered -= o.length),
      (this._buffers[0] = a.slice(o.length)),
      o.func.call(this, a.slice(0, o.length)))
    : ((this._buffered -= a.length),
      this._buffers.shift(),
      o.func.call(this, a))
}
ChunkStream$2.prototype._processRead = function(o) {
  this._reads.shift()
  let a = 0,
    s = 0,
    $ = Buffer.alloc(o.length)
  for (; a < o.length; ) {
    let j = this._buffers[s++],
      _e = Math.min(j.length, o.length - a)
    j.copy($, a, 0, _e),
      (a += _e),
      _e !== j.length && (this._buffers[--s] = j.slice(_e))
  }
  s > 0 && this._buffers.splice(0, s),
    (this._buffered -= o.length),
    o.func.call(this, $)
}
ChunkStream$2.prototype._process = function() {
  try {
    for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
      let o = this._reads[0]
      if (o.allowLess) this._processReadAllowingLess(o)
      else if (this._buffered >= o.length) this._processRead(o)
      else break
    }
    this._buffers && !this.writable && this._end()
  } catch (o) {
    this.emit('error', o)
  }
}
var chunkstreamExports = chunkstream.exports,
  filterParseAsync = { exports: {} },
  filterParse = { exports: {} },
  interlace = {}
let imagePasses = [
  { x: [0], y: [0] },
  { x: [4], y: [0] },
  { x: [0, 4], y: [4] },
  { x: [2, 6], y: [0, 4] },
  { x: [0, 2, 4, 6], y: [2, 6] },
  { x: [1, 3, 5, 7], y: [0, 2, 4, 6] },
  { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] },
]
interlace.getImagePasses = function(o, a) {
  let s = [],
    $ = o % 8,
    j = a % 8,
    _e = (o - $) / 8,
    et = (a - j) / 8
  for (let tt = 0; tt < imagePasses.length; tt++) {
    let rt = imagePasses[tt],
      nt = _e * rt.x.length,
      it = et * rt.y.length
    for (let ot = 0; ot < rt.x.length && rt.x[ot] < $; ot++) nt++
    for (let ot = 0; ot < rt.y.length && rt.y[ot] < j; ot++) it++
    nt > 0 && it > 0 && s.push({ width: nt, height: it, index: tt })
  }
  return s
}
interlace.getInterlaceIterator = function(o) {
  return function(a, s, $) {
    let j = a % imagePasses[$].x.length,
      _e = ((a - j) / imagePasses[$].x.length) * 8 + imagePasses[$].x[j],
      et = s % imagePasses[$].y.length,
      tt = ((s - et) / imagePasses[$].y.length) * 8 + imagePasses[$].y[et]
    return _e * 4 + tt * o * 4
  }
}
var paethPredictor$2 = function o(a, s, $) {
  let j = a + s - $,
    _e = Math.abs(j - a),
    et = Math.abs(j - s),
    tt = Math.abs(j - $)
  return _e <= et && _e <= tt ? a : et <= tt ? s : $
}
let interlaceUtils$1 = interlace,
  paethPredictor$1 = paethPredictor$2
function getByteWidth(o, a, s) {
  let $ = o * a
  return s !== 8 && ($ = Math.ceil($ / (8 / s))), $
}
let Filter$2 = (filterParse.exports = function(o, a) {
  let s = o.width,
    $ = o.height,
    j = o.interlace,
    _e = o.bpp,
    et = o.depth
  if (
    ((this.read = a.read),
    (this.write = a.write),
    (this.complete = a.complete),
    (this._imageIndex = 0),
    (this._images = []),
    j)
  ) {
    let tt = interlaceUtils$1.getImagePasses(s, $)
    for (let rt = 0; rt < tt.length; rt++)
      this._images.push({
        byteWidth: getByteWidth(tt[rt].width, _e, et),
        height: tt[rt].height,
        lineIndex: 0,
      })
  } else
    this._images.push({
      byteWidth: getByteWidth(s, _e, et),
      height: $,
      lineIndex: 0,
    })
  et === 8
    ? (this._xComparison = _e)
    : et === 16
    ? (this._xComparison = _e * 2)
    : (this._xComparison = 1)
})
Filter$2.prototype.start = function() {
  this.read(
    this._images[this._imageIndex].byteWidth + 1,
    this._reverseFilterLine.bind(this)
  )
}
Filter$2.prototype._unFilterType1 = function(o, a, s) {
  let $ = this._xComparison,
    j = $ - 1
  for (let _e = 0; _e < s; _e++) {
    let et = o[1 + _e],
      tt = _e > j ? a[_e - $] : 0
    a[_e] = et + tt
  }
}
Filter$2.prototype._unFilterType2 = function(o, a, s) {
  let $ = this._lastLine
  for (let j = 0; j < s; j++) {
    let _e = o[1 + j],
      et = $ ? $[j] : 0
    a[j] = _e + et
  }
}
Filter$2.prototype._unFilterType3 = function(o, a, s) {
  let $ = this._xComparison,
    j = $ - 1,
    _e = this._lastLine
  for (let et = 0; et < s; et++) {
    let tt = o[1 + et],
      rt = _e ? _e[et] : 0,
      nt = et > j ? a[et - $] : 0,
      it = Math.floor((nt + rt) / 2)
    a[et] = tt + it
  }
}
Filter$2.prototype._unFilterType4 = function(o, a, s) {
  let $ = this._xComparison,
    j = $ - 1,
    _e = this._lastLine
  for (let et = 0; et < s; et++) {
    let tt = o[1 + et],
      rt = _e ? _e[et] : 0,
      nt = et > j ? a[et - $] : 0,
      it = et > j && _e ? _e[et - $] : 0,
      ot = paethPredictor$1(nt, rt, it)
    a[et] = tt + ot
  }
}
Filter$2.prototype._reverseFilterLine = function(o) {
  let a = o[0],
    s,
    $ = this._images[this._imageIndex],
    j = $.byteWidth
  if (a === 0) s = o.slice(1, j + 1)
  else
    switch (((s = Buffer.alloc(j)), a)) {
      case 1:
        this._unFilterType1(o, s, j)
        break
      case 2:
        this._unFilterType2(o, s, j)
        break
      case 3:
        this._unFilterType3(o, s, j)
        break
      case 4:
        this._unFilterType4(o, s, j)
        break
      default:
        throw new Error('Unrecognised filter type - ' + a)
    }
  this.write(s),
    $.lineIndex++,
    $.lineIndex >= $.height
      ? ((this._lastLine = null),
        this._imageIndex++,
        ($ = this._images[this._imageIndex]))
      : (this._lastLine = s),
    $
      ? this.read($.byteWidth + 1, this._reverseFilterLine.bind(this))
      : ((this._lastLine = null), this.complete())
}
var filterParseExports = filterParse.exports
let util$4 = util$u,
  ChunkStream$1 = chunkstreamExports,
  Filter$1 = filterParseExports,
  FilterAsync$1 = (filterParseAsync.exports = function(o) {
    ChunkStream$1.call(this)
    let a = [],
      s = this
    ;(this._filter = new Filter$1(o, {
      read: this.read.bind(this),
      write: function($) {
        a.push($)
      },
      complete: function() {
        s.emit('complete', Buffer.concat(a))
      },
    })),
      this._filter.start()
  })
util$4.inherits(FilterAsync$1, ChunkStream$1)
var filterParseAsyncExports = filterParseAsync.exports,
  parser$1 = { exports: {} },
  constants$5 = {
    PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
    TYPE_IHDR: 1229472850,
    TYPE_IEND: 1229278788,
    TYPE_IDAT: 1229209940,
    TYPE_PLTE: 1347179589,
    TYPE_tRNS: 1951551059,
    TYPE_gAMA: 1732332865,
    COLORTYPE_GRAYSCALE: 0,
    COLORTYPE_PALETTE: 1,
    COLORTYPE_COLOR: 2,
    COLORTYPE_ALPHA: 4,
    COLORTYPE_PALETTE_COLOR: 3,
    COLORTYPE_COLOR_ALPHA: 6,
    COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 },
    GAMMA_DIVISION: 1e5,
  },
  crc = { exports: {} }
let crcTable = []
;(function() {
  for (let o = 0; o < 256; o++) {
    let a = o
    for (let s = 0; s < 8; s++)
      a & 1 ? (a = 3988292384 ^ (a >>> 1)) : (a = a >>> 1)
    crcTable[o] = a
  }
})()
let CrcCalculator$1 = (crc.exports = function() {
  this._crc = -1
})
CrcCalculator$1.prototype.write = function(o) {
  for (let a = 0; a < o.length; a++)
    this._crc = crcTable[(this._crc ^ o[a]) & 255] ^ (this._crc >>> 8)
  return !0
}
CrcCalculator$1.prototype.crc32 = function() {
  return this._crc ^ -1
}
CrcCalculator$1.crc32 = function(o) {
  let a = -1
  for (let s = 0; s < o.length; s++) a = crcTable[(a ^ o[s]) & 255] ^ (a >>> 8)
  return a ^ -1
}
var crcExports = crc.exports
let constants$4 = constants$5,
  CrcCalculator = crcExports,
  Parser$5 = (parser$1.exports = function(o, a) {
    ;(this._options = o),
      (o.checkCRC = o.checkCRC !== !1),
      (this._hasIHDR = !1),
      (this._hasIEND = !1),
      (this._emittedHeadersFinished = !1),
      (this._palette = []),
      (this._colorType = 0),
      (this._chunks = {}),
      (this._chunks[constants$4.TYPE_IHDR] = this._handleIHDR.bind(this)),
      (this._chunks[constants$4.TYPE_IEND] = this._handleIEND.bind(this)),
      (this._chunks[constants$4.TYPE_IDAT] = this._handleIDAT.bind(this)),
      (this._chunks[constants$4.TYPE_PLTE] = this._handlePLTE.bind(this)),
      (this._chunks[constants$4.TYPE_tRNS] = this._handleTRNS.bind(this)),
      (this._chunks[constants$4.TYPE_gAMA] = this._handleGAMA.bind(this)),
      (this.read = a.read),
      (this.error = a.error),
      (this.metadata = a.metadata),
      (this.gamma = a.gamma),
      (this.transColor = a.transColor),
      (this.palette = a.palette),
      (this.parsed = a.parsed),
      (this.inflateData = a.inflateData),
      (this.finished = a.finished),
      (this.simpleTransparency = a.simpleTransparency),
      (this.headersFinished = a.headersFinished || function() {})
  })
Parser$5.prototype.start = function() {
  this.read(constants$4.PNG_SIGNATURE.length, this._parseSignature.bind(this))
}
Parser$5.prototype._parseSignature = function(o) {
  let a = constants$4.PNG_SIGNATURE
  for (let s = 0; s < a.length; s++)
    if (o[s] !== a[s]) {
      this.error(new Error('Invalid file signature'))
      return
    }
  this.read(8, this._parseChunkBegin.bind(this))
}
Parser$5.prototype._parseChunkBegin = function(o) {
  let a = o.readUInt32BE(0),
    s = o.readUInt32BE(4),
    $ = ''
  for (let _e = 4; _e < 8; _e++) $ += String.fromCharCode(o[_e])
  let j = !!(o[4] & 32)
  if (!this._hasIHDR && s !== constants$4.TYPE_IHDR) {
    this.error(new Error('Expected IHDR on beggining'))
    return
  }
  if (
    ((this._crc = new CrcCalculator()),
    this._crc.write(Buffer.from($)),
    this._chunks[s])
  )
    return this._chunks[s](a)
  if (!j) {
    this.error(new Error('Unsupported critical chunk type ' + $))
    return
  }
  this.read(a + 4, this._skipChunk.bind(this))
}
Parser$5.prototype._skipChunk = function() {
  this.read(8, this._parseChunkBegin.bind(this))
}
Parser$5.prototype._handleChunkEnd = function() {
  this.read(4, this._parseChunkEnd.bind(this))
}
Parser$5.prototype._parseChunkEnd = function(o) {
  let a = o.readInt32BE(0),
    s = this._crc.crc32()
  if (this._options.checkCRC && s !== a) {
    this.error(new Error('Crc error - ' + a + ' - ' + s))
    return
  }
  this._hasIEND || this.read(8, this._parseChunkBegin.bind(this))
}
Parser$5.prototype._handleIHDR = function(o) {
  this.read(o, this._parseIHDR.bind(this))
}
Parser$5.prototype._parseIHDR = function(o) {
  this._crc.write(o)
  let a = o.readUInt32BE(0),
    s = o.readUInt32BE(4),
    $ = o[8],
    j = o[9],
    _e = o[10],
    et = o[11],
    tt = o[12]
  if ($ !== 8 && $ !== 4 && $ !== 2 && $ !== 1 && $ !== 16) {
    this.error(new Error('Unsupported bit depth ' + $))
    return
  }
  if (!(j in constants$4.COLORTYPE_TO_BPP_MAP)) {
    this.error(new Error('Unsupported color type'))
    return
  }
  if (_e !== 0) {
    this.error(new Error('Unsupported compression method'))
    return
  }
  if (et !== 0) {
    this.error(new Error('Unsupported filter method'))
    return
  }
  if (tt !== 0 && tt !== 1) {
    this.error(new Error('Unsupported interlace method'))
    return
  }
  this._colorType = j
  let rt = constants$4.COLORTYPE_TO_BPP_MAP[this._colorType]
  ;(this._hasIHDR = !0),
    this.metadata({
      width: a,
      height: s,
      depth: $,
      interlace: !!tt,
      palette: !!(j & constants$4.COLORTYPE_PALETTE),
      color: !!(j & constants$4.COLORTYPE_COLOR),
      alpha: !!(j & constants$4.COLORTYPE_ALPHA),
      bpp: rt,
      colorType: j,
    }),
    this._handleChunkEnd()
}
Parser$5.prototype._handlePLTE = function(o) {
  this.read(o, this._parsePLTE.bind(this))
}
Parser$5.prototype._parsePLTE = function(o) {
  this._crc.write(o)
  let a = Math.floor(o.length / 3)
  for (let s = 0; s < a; s++)
    this._palette.push([o[s * 3], o[s * 3 + 1], o[s * 3 + 2], 255])
  this.palette(this._palette), this._handleChunkEnd()
}
Parser$5.prototype._handleTRNS = function(o) {
  this.simpleTransparency(), this.read(o, this._parseTRNS.bind(this))
}
Parser$5.prototype._parseTRNS = function(o) {
  if (
    (this._crc.write(o),
    this._colorType === constants$4.COLORTYPE_PALETTE_COLOR)
  ) {
    if (this._palette.length === 0) {
      this.error(new Error('Transparency chunk must be after palette'))
      return
    }
    if (o.length > this._palette.length) {
      this.error(new Error('More transparent colors than palette size'))
      return
    }
    for (let a = 0; a < o.length; a++) this._palette[a][3] = o[a]
    this.palette(this._palette)
  }
  this._colorType === constants$4.COLORTYPE_GRAYSCALE &&
    this.transColor([o.readUInt16BE(0)]),
    this._colorType === constants$4.COLORTYPE_COLOR &&
      this.transColor([
        o.readUInt16BE(0),
        o.readUInt16BE(2),
        o.readUInt16BE(4),
      ]),
    this._handleChunkEnd()
}
Parser$5.prototype._handleGAMA = function(o) {
  this.read(o, this._parseGAMA.bind(this))
}
Parser$5.prototype._parseGAMA = function(o) {
  this._crc.write(o),
    this.gamma(o.readUInt32BE(0) / constants$4.GAMMA_DIVISION),
    this._handleChunkEnd()
}
Parser$5.prototype._handleIDAT = function(o) {
  this._emittedHeadersFinished ||
    ((this._emittedHeadersFinished = !0), this.headersFinished()),
    this.read(-o, this._parseIDAT.bind(this, o))
}
Parser$5.prototype._parseIDAT = function(o, a) {
  if (
    (this._crc.write(a),
    this._colorType === constants$4.COLORTYPE_PALETTE_COLOR &&
      this._palette.length === 0)
  )
    throw new Error('Expected palette not found')
  this.inflateData(a)
  let s = o - a.length
  s > 0 ? this._handleIDAT(s) : this._handleChunkEnd()
}
Parser$5.prototype._handleIEND = function(o) {
  this.read(o, this._parseIEND.bind(this))
}
Parser$5.prototype._parseIEND = function(o) {
  this._crc.write(o),
    (this._hasIEND = !0),
    this._handleChunkEnd(),
    this.finished && this.finished()
}
var parserExports = parser$1.exports,
  bitmapper$2 = {}
let interlaceUtils = interlace,
  pixelBppMapper = [
    function() {},
    function(o, a, s, $) {
      if ($ === a.length) throw new Error('Ran out of data')
      let j = a[$]
      ;(o[s] = j), (o[s + 1] = j), (o[s + 2] = j), (o[s + 3] = 255)
    },
    function(o, a, s, $) {
      if ($ + 1 >= a.length) throw new Error('Ran out of data')
      let j = a[$]
      ;(o[s] = j), (o[s + 1] = j), (o[s + 2] = j), (o[s + 3] = a[$ + 1])
    },
    function(o, a, s, $) {
      if ($ + 2 >= a.length) throw new Error('Ran out of data')
      ;(o[s] = a[$]),
        (o[s + 1] = a[$ + 1]),
        (o[s + 2] = a[$ + 2]),
        (o[s + 3] = 255)
    },
    function(o, a, s, $) {
      if ($ + 3 >= a.length) throw new Error('Ran out of data')
      ;(o[s] = a[$]),
        (o[s + 1] = a[$ + 1]),
        (o[s + 2] = a[$ + 2]),
        (o[s + 3] = a[$ + 3])
    },
  ],
  pixelBppCustomMapper = [
    function() {},
    function(o, a, s, $) {
      let j = a[0]
      ;(o[s] = j), (o[s + 1] = j), (o[s + 2] = j), (o[s + 3] = $)
    },
    function(o, a, s) {
      let $ = a[0]
      ;(o[s] = $), (o[s + 1] = $), (o[s + 2] = $), (o[s + 3] = a[1])
    },
    function(o, a, s, $) {
      ;(o[s] = a[0]), (o[s + 1] = a[1]), (o[s + 2] = a[2]), (o[s + 3] = $)
    },
    function(o, a, s) {
      ;(o[s] = a[0]), (o[s + 1] = a[1]), (o[s + 2] = a[2]), (o[s + 3] = a[3])
    },
  ]
function bitRetriever(o, a) {
  let s = [],
    $ = 0
  function j() {
    if ($ === o.length) throw new Error('Ran out of data')
    let _e = o[$]
    $++
    let et, tt, rt, nt, it, ot, at, st
    switch (a) {
      default:
        throw new Error('unrecognised depth')
      case 16:
        ;(at = o[$]), $++, s.push((_e << 8) + at)
        break
      case 4:
        ;(at = _e & 15), (st = _e >> 4), s.push(st, at)
        break
      case 2:
        ;(it = _e & 3),
          (ot = (_e >> 2) & 3),
          (at = (_e >> 4) & 3),
          (st = (_e >> 6) & 3),
          s.push(st, at, ot, it)
        break
      case 1:
        ;(et = _e & 1),
          (tt = (_e >> 1) & 1),
          (rt = (_e >> 2) & 1),
          (nt = (_e >> 3) & 1),
          (it = (_e >> 4) & 1),
          (ot = (_e >> 5) & 1),
          (at = (_e >> 6) & 1),
          (st = (_e >> 7) & 1),
          s.push(st, at, ot, it, nt, rt, tt, et)
        break
    }
  }
  return {
    get: function(_e) {
      for (; s.length < _e; ) j()
      let et = s.slice(0, _e)
      return (s = s.slice(_e)), et
    },
    resetAfterLine: function() {
      s.length = 0
    },
    end: function() {
      if ($ !== o.length) throw new Error('extra data found')
    },
  }
}
function mapImage8Bit(o, a, s, $, j, _e) {
  let et = o.width,
    tt = o.height,
    rt = o.index
  for (let nt = 0; nt < tt; nt++)
    for (let it = 0; it < et; it++) {
      let ot = s(it, nt, rt)
      pixelBppMapper[$](a, j, ot, _e), (_e += $)
    }
  return _e
}
function mapImageCustomBit(o, a, s, $, j, _e) {
  let et = o.width,
    tt = o.height,
    rt = o.index
  for (let nt = 0; nt < tt; nt++) {
    for (let it = 0; it < et; it++) {
      let ot = j.get($),
        at = s(it, nt, rt)
      pixelBppCustomMapper[$](a, ot, at, _e)
    }
    j.resetAfterLine()
  }
}
bitmapper$2.dataToBitMap = function(o, a) {
  let s = a.width,
    $ = a.height,
    j = a.depth,
    _e = a.bpp,
    et = a.interlace,
    tt
  j !== 8 && (tt = bitRetriever(o, j))
  let rt
  j <= 8 ? (rt = Buffer.alloc(s * $ * 4)) : (rt = new Uint16Array(s * $ * 4))
  let nt = Math.pow(2, j) - 1,
    it = 0,
    ot,
    at
  if (et)
    (ot = interlaceUtils.getImagePasses(s, $)),
      (at = interlaceUtils.getInterlaceIterator(s, $))
  else {
    let st = 0
    ;(at = function() {
      let ut = st
      return (st += 4), ut
    }),
      (ot = [{ width: s, height: $ }])
  }
  for (let st = 0; st < ot.length; st++)
    j === 8
      ? (it = mapImage8Bit(ot[st], rt, at, _e, o, it))
      : mapImageCustomBit(ot[st], rt, at, _e, tt, nt)
  if (j === 8) {
    if (it !== o.length) throw new Error('extra data found')
  } else tt.end()
  return rt
}
function dePalette(o, a, s, $, j) {
  let _e = 0
  for (let et = 0; et < $; et++)
    for (let tt = 0; tt < s; tt++) {
      let rt = j[o[_e]]
      if (!rt) throw new Error('index ' + o[_e] + ' not in palette')
      for (let nt = 0; nt < 4; nt++) a[_e + nt] = rt[nt]
      _e += 4
    }
}
function replaceTransparentColor(o, a, s, $, j) {
  let _e = 0
  for (let et = 0; et < $; et++)
    for (let tt = 0; tt < s; tt++) {
      let rt = !1
      if (
        (j.length === 1
          ? j[0] === o[_e] && (rt = !0)
          : j[0] === o[_e] &&
            j[1] === o[_e + 1] &&
            j[2] === o[_e + 2] &&
            (rt = !0),
        rt)
      )
        for (let nt = 0; nt < 4; nt++) a[_e + nt] = 0
      _e += 4
    }
}
function scaleDepth(o, a, s, $, j) {
  let _e = 255,
    et = Math.pow(2, j) - 1,
    tt = 0
  for (let rt = 0; rt < $; rt++)
    for (let nt = 0; nt < s; nt++) {
      for (let it = 0; it < 4; it++)
        a[tt + it] = Math.floor((o[tt + it] * _e) / et + 0.5)
      tt += 4
    }
}
var formatNormaliser$2 = function(o, a, s = !1) {
  let $ = a.depth,
    j = a.width,
    _e = a.height,
    et = a.colorType,
    tt = a.transColor,
    rt = a.palette,
    nt = o
  return (
    et === 3
      ? dePalette(o, nt, j, _e, rt)
      : (tt && replaceTransparentColor(o, nt, j, _e, tt),
        $ !== 8 &&
          !s &&
          ($ === 16 && (nt = Buffer.alloc(j * _e * 4)),
          scaleDepth(o, nt, j, _e, $))),
    nt
  )
}
let util$3 = util$u,
  zlib$3 = lib$2,
  ChunkStream = chunkstreamExports,
  FilterAsync = filterParseAsyncExports,
  Parser$4 = parserExports,
  bitmapper$1 = bitmapper$2,
  formatNormaliser$1 = formatNormaliser$2,
  ParserAsync = (parserAsync.exports = function(o) {
    ChunkStream.call(this),
      (this._parser = new Parser$4(o, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, 'gamma'),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this),
      })),
      (this._options = o),
      (this.writable = !0),
      this._parser.start()
  })
util$3.inherits(ParserAsync, ChunkStream)
ParserAsync.prototype._handleError = function(o) {
  this.emit('error', o),
    (this.writable = !1),
    this.destroy(),
    this._inflate && this._inflate.destroy && this._inflate.destroy(),
    this._filter &&
      (this._filter.destroy(), this._filter.on('error', function() {})),
    (this.errord = !0)
}
ParserAsync.prototype._inflateData = function(o) {
  if (!this._inflate)
    if (this._bitmapInfo.interlace)
      (this._inflate = zlib$3.createInflate()),
        this._inflate.on('error', this.emit.bind(this, 'error')),
        this._filter.on('complete', this._complete.bind(this)),
        this._inflate.pipe(this._filter)
    else {
      let s =
          (((this._bitmapInfo.width *
            this._bitmapInfo.bpp *
            this._bitmapInfo.depth +
            7) >>
            3) +
            1) *
          this._bitmapInfo.height,
        $ = Math.max(s, zlib$3.Z_MIN_CHUNK)
      this._inflate = zlib$3.createInflate({ chunkSize: $ })
      let j = s,
        _e = this.emit.bind(this, 'error')
      this._inflate.on('error', function(tt) {
        j && _e(tt)
      }),
        this._filter.on('complete', this._complete.bind(this))
      let et = this._filter.write.bind(this._filter)
      this._inflate.on('data', function(tt) {
        j && (tt.length > j && (tt = tt.slice(0, j)), (j -= tt.length), et(tt))
      }),
        this._inflate.on('end', this._filter.end.bind(this._filter))
    }
  this._inflate.write(o)
}
ParserAsync.prototype._handleMetaData = function(o) {
  ;(this._metaData = o),
    (this._bitmapInfo = Object.create(o)),
    (this._filter = new FilterAsync(this._bitmapInfo))
}
ParserAsync.prototype._handleTransColor = function(o) {
  this._bitmapInfo.transColor = o
}
ParserAsync.prototype._handlePalette = function(o) {
  this._bitmapInfo.palette = o
}
ParserAsync.prototype._simpleTransparency = function() {
  this._metaData.alpha = !0
}
ParserAsync.prototype._headersFinished = function() {
  this.emit('metadata', this._metaData)
}
ParserAsync.prototype._finished = function() {
  this.errord ||
    (this._inflate
      ? this._inflate.end()
      : this.emit('error', 'No Inflate block'))
}
ParserAsync.prototype._complete = function(o) {
  if (this.errord) return
  let a
  try {
    let s = bitmapper$1.dataToBitMap(o, this._bitmapInfo)
    ;(a = formatNormaliser$1(s, this._bitmapInfo, this._options.skipRescale)),
      (s = null)
  } catch (s) {
    this._handleError(s)
    return
  }
  this.emit('parsed', a)
}
var parserAsyncExports = parserAsync.exports,
  packerAsync = { exports: {} },
  packer = { exports: {} }
let constants$3 = constants$5
var bitpacker = function(o, a, s, $) {
  let j =
    [constants$3.COLORTYPE_COLOR_ALPHA, constants$3.COLORTYPE_ALPHA].indexOf(
      $.colorType
    ) !== -1
  if ($.colorType === $.inputColorType) {
    let ut = (function() {
      let ct = new ArrayBuffer(2)
      return (
        new DataView(ct).setInt16(0, 256, !0), new Int16Array(ct)[0] !== 256
      )
    })()
    if ($.bitDepth === 8 || ($.bitDepth === 16 && ut)) return o
  }
  let _e = $.bitDepth !== 16 ? o : new Uint16Array(o.buffer),
    et = 255,
    tt = constants$3.COLORTYPE_TO_BPP_MAP[$.inputColorType]
  tt === 4 && !$.inputHasAlpha && (tt = 3)
  let rt = constants$3.COLORTYPE_TO_BPP_MAP[$.colorType]
  $.bitDepth === 16 && ((et = 65535), (rt *= 2))
  let nt = Buffer.alloc(a * s * rt),
    it = 0,
    ot = 0,
    at = $.bgColor || {}
  at.red === void 0 && (at.red = et),
    at.green === void 0 && (at.green = et),
    at.blue === void 0 && (at.blue = et)
  function st() {
    let ut,
      ct,
      dt,
      ft = et
    switch ($.inputColorType) {
      case constants$3.COLORTYPE_COLOR_ALPHA:
        ;(ft = _e[it + 3]), (ut = _e[it]), (ct = _e[it + 1]), (dt = _e[it + 2])
        break
      case constants$3.COLORTYPE_COLOR:
        ;(ut = _e[it]), (ct = _e[it + 1]), (dt = _e[it + 2])
        break
      case constants$3.COLORTYPE_ALPHA:
        ;(ft = _e[it + 1]), (ut = _e[it]), (ct = ut), (dt = ut)
        break
      case constants$3.COLORTYPE_GRAYSCALE:
        ;(ut = _e[it]), (ct = ut), (dt = ut)
        break
      default:
        throw new Error(
          'input color type:' +
            $.inputColorType +
            ' is not supported at present'
        )
    }
    return (
      $.inputHasAlpha &&
        (j ||
          ((ft /= et),
          (ut = Math.min(
            Math.max(Math.round((1 - ft) * at.red + ft * ut), 0),
            et
          )),
          (ct = Math.min(
            Math.max(Math.round((1 - ft) * at.green + ft * ct), 0),
            et
          )),
          (dt = Math.min(
            Math.max(Math.round((1 - ft) * at.blue + ft * dt), 0),
            et
          )))),
      { red: ut, green: ct, blue: dt, alpha: ft }
    )
  }
  for (let ut = 0; ut < s; ut++)
    for (let ct = 0; ct < a; ct++) {
      let dt = st()
      switch ($.colorType) {
        case constants$3.COLORTYPE_COLOR_ALPHA:
        case constants$3.COLORTYPE_COLOR:
          $.bitDepth === 8
            ? ((nt[ot] = dt.red),
              (nt[ot + 1] = dt.green),
              (nt[ot + 2] = dt.blue),
              j && (nt[ot + 3] = dt.alpha))
            : (nt.writeUInt16BE(dt.red, ot),
              nt.writeUInt16BE(dt.green, ot + 2),
              nt.writeUInt16BE(dt.blue, ot + 4),
              j && nt.writeUInt16BE(dt.alpha, ot + 6))
          break
        case constants$3.COLORTYPE_ALPHA:
        case constants$3.COLORTYPE_GRAYSCALE: {
          let ft = (dt.red + dt.green + dt.blue) / 3
          $.bitDepth === 8
            ? ((nt[ot] = ft), j && (nt[ot + 1] = dt.alpha))
            : (nt.writeUInt16BE(ft, ot),
              j && nt.writeUInt16BE(dt.alpha, ot + 2))
          break
        }
        default:
          throw new Error('unrecognised color Type ' + $.colorType)
      }
      ;(it += tt), (ot += rt)
    }
  return nt
}
let paethPredictor = paethPredictor$2
function filterNone(o, a, s, $, j) {
  for (let _e = 0; _e < s; _e++) $[j + _e] = o[a + _e]
}
function filterSumNone(o, a, s) {
  let $ = 0,
    j = a + s
  for (let _e = a; _e < j; _e++) $ += Math.abs(o[_e])
  return $
}
function filterSub(o, a, s, $, j, _e) {
  for (let et = 0; et < s; et++) {
    let tt = et >= _e ? o[a + et - _e] : 0,
      rt = o[a + et] - tt
    $[j + et] = rt
  }
}
function filterSumSub(o, a, s, $) {
  let j = 0
  for (let _e = 0; _e < s; _e++) {
    let et = _e >= $ ? o[a + _e - $] : 0,
      tt = o[a + _e] - et
    j += Math.abs(tt)
  }
  return j
}
function filterUp(o, a, s, $, j) {
  for (let _e = 0; _e < s; _e++) {
    let et = a > 0 ? o[a + _e - s] : 0,
      tt = o[a + _e] - et
    $[j + _e] = tt
  }
}
function filterSumUp(o, a, s) {
  let $ = 0,
    j = a + s
  for (let _e = a; _e < j; _e++) {
    let et = a > 0 ? o[_e - s] : 0,
      tt = o[_e] - et
    $ += Math.abs(tt)
  }
  return $
}
function filterAvg(o, a, s, $, j, _e) {
  for (let et = 0; et < s; et++) {
    let tt = et >= _e ? o[a + et - _e] : 0,
      rt = a > 0 ? o[a + et - s] : 0,
      nt = o[a + et] - ((tt + rt) >> 1)
    $[j + et] = nt
  }
}
function filterSumAvg(o, a, s, $) {
  let j = 0
  for (let _e = 0; _e < s; _e++) {
    let et = _e >= $ ? o[a + _e - $] : 0,
      tt = a > 0 ? o[a + _e - s] : 0,
      rt = o[a + _e] - ((et + tt) >> 1)
    j += Math.abs(rt)
  }
  return j
}
function filterPaeth(o, a, s, $, j, _e) {
  for (let et = 0; et < s; et++) {
    let tt = et >= _e ? o[a + et - _e] : 0,
      rt = a > 0 ? o[a + et - s] : 0,
      nt = a > 0 && et >= _e ? o[a + et - (s + _e)] : 0,
      it = o[a + et] - paethPredictor(tt, rt, nt)
    $[j + et] = it
  }
}
function filterSumPaeth(o, a, s, $) {
  let j = 0
  for (let _e = 0; _e < s; _e++) {
    let et = _e >= $ ? o[a + _e - $] : 0,
      tt = a > 0 ? o[a + _e - s] : 0,
      rt = a > 0 && _e >= $ ? o[a + _e - (s + $)] : 0,
      nt = o[a + _e] - paethPredictor(et, tt, rt)
    j += Math.abs(nt)
  }
  return j
}
let filters = {
    0: filterNone,
    1: filterSub,
    2: filterUp,
    3: filterAvg,
    4: filterPaeth,
  },
  filterSums = {
    0: filterSumNone,
    1: filterSumSub,
    2: filterSumUp,
    3: filterSumAvg,
    4: filterSumPaeth,
  }
var filterPack = function(o, a, s, $, j) {
  let _e
  if (!('filterType' in $) || $.filterType === -1) _e = [0, 1, 2, 3, 4]
  else if (typeof $.filterType == 'number') _e = [$.filterType]
  else throw new Error('unrecognised filter types')
  $.bitDepth === 16 && (j *= 2)
  let et = a * j,
    tt = 0,
    rt = 0,
    nt = Buffer.alloc((et + 1) * s),
    it = _e[0]
  for (let ot = 0; ot < s; ot++) {
    if (_e.length > 1) {
      let at = 1 / 0
      for (let st = 0; st < _e.length; st++) {
        let ut = filterSums[_e[st]](o, rt, et, j)
        ut < at && ((it = _e[st]), (at = ut))
      }
    }
    ;(nt[tt] = it),
      tt++,
      filters[it](o, rt, et, nt, tt, j),
      (tt += et),
      (rt += et)
  }
  return nt
}
let constants$2 = constants$5,
  CrcStream = crcExports,
  bitPacker = bitpacker,
  filter = filterPack,
  zlib$2 = lib$2,
  Packer$3 = (packer.exports = function(o) {
    if (
      ((this._options = o),
      (o.deflateChunkSize = o.deflateChunkSize || 32 * 1024),
      (o.deflateLevel = o.deflateLevel != null ? o.deflateLevel : 9),
      (o.deflateStrategy = o.deflateStrategy != null ? o.deflateStrategy : 3),
      (o.inputHasAlpha = o.inputHasAlpha != null ? o.inputHasAlpha : !0),
      (o.deflateFactory = o.deflateFactory || zlib$2.createDeflate),
      (o.bitDepth = o.bitDepth || 8),
      (o.colorType =
        typeof o.colorType == 'number'
          ? o.colorType
          : constants$2.COLORTYPE_COLOR_ALPHA),
      (o.inputColorType =
        typeof o.inputColorType == 'number'
          ? o.inputColorType
          : constants$2.COLORTYPE_COLOR_ALPHA),
      [
        constants$2.COLORTYPE_GRAYSCALE,
        constants$2.COLORTYPE_COLOR,
        constants$2.COLORTYPE_COLOR_ALPHA,
        constants$2.COLORTYPE_ALPHA,
      ].indexOf(o.colorType) === -1)
    )
      throw new Error(
        'option color type:' + o.colorType + ' is not supported at present'
      )
    if (
      [
        constants$2.COLORTYPE_GRAYSCALE,
        constants$2.COLORTYPE_COLOR,
        constants$2.COLORTYPE_COLOR_ALPHA,
        constants$2.COLORTYPE_ALPHA,
      ].indexOf(o.inputColorType) === -1
    )
      throw new Error(
        'option input color type:' +
          o.inputColorType +
          ' is not supported at present'
      )
    if (o.bitDepth !== 8 && o.bitDepth !== 16)
      throw new Error(
        'option bit depth:' + o.bitDepth + ' is not supported at present'
      )
  })
Packer$3.prototype.getDeflateOptions = function() {
  return {
    chunkSize: this._options.deflateChunkSize,
    level: this._options.deflateLevel,
    strategy: this._options.deflateStrategy,
  }
}
Packer$3.prototype.createDeflate = function() {
  return this._options.deflateFactory(this.getDeflateOptions())
}
Packer$3.prototype.filterData = function(o, a, s) {
  let $ = bitPacker(o, a, s, this._options),
    j = constants$2.COLORTYPE_TO_BPP_MAP[this._options.colorType]
  return filter($, a, s, this._options, j)
}
Packer$3.prototype._packChunk = function(o, a) {
  let s = a ? a.length : 0,
    $ = Buffer.alloc(s + 12)
  return (
    $.writeUInt32BE(s, 0),
    $.writeUInt32BE(o, 4),
    a && a.copy($, 8),
    $.writeInt32BE(CrcStream.crc32($.slice(4, $.length - 4)), $.length - 4),
    $
  )
}
Packer$3.prototype.packGAMA = function(o) {
  let a = Buffer.alloc(4)
  return (
    a.writeUInt32BE(Math.floor(o * constants$2.GAMMA_DIVISION), 0),
    this._packChunk(constants$2.TYPE_gAMA, a)
  )
}
Packer$3.prototype.packIHDR = function(o, a) {
  let s = Buffer.alloc(13)
  return (
    s.writeUInt32BE(o, 0),
    s.writeUInt32BE(a, 4),
    (s[8] = this._options.bitDepth),
    (s[9] = this._options.colorType),
    (s[10] = 0),
    (s[11] = 0),
    (s[12] = 0),
    this._packChunk(constants$2.TYPE_IHDR, s)
  )
}
Packer$3.prototype.packIDAT = function(o) {
  return this._packChunk(constants$2.TYPE_IDAT, o)
}
Packer$3.prototype.packIEND = function() {
  return this._packChunk(constants$2.TYPE_IEND, null)
}
var packerExports = packer.exports
let util$2 = util$u,
  Stream$1 = stream$1,
  constants$1 = constants$5,
  Packer$2 = packerExports,
  PackerAsync = (packerAsync.exports = function(o) {
    Stream$1.call(this)
    let a = o || {}
    ;(this._packer = new Packer$2(a)),
      (this._deflate = this._packer.createDeflate()),
      (this.readable = !0)
  })
util$2.inherits(PackerAsync, Stream$1)
PackerAsync.prototype.pack = function(o, a, s, $) {
  this.emit('data', Buffer.from(constants$1.PNG_SIGNATURE)),
    this.emit('data', this._packer.packIHDR(a, s)),
    $ && this.emit('data', this._packer.packGAMA($))
  let j = this._packer.filterData(o, a, s)
  this._deflate.on('error', this.emit.bind(this, 'error')),
    this._deflate.on(
      'data',
      function(_e) {
        this.emit('data', this._packer.packIDAT(_e))
      }.bind(this)
    ),
    this._deflate.on(
      'end',
      function() {
        this.emit('data', this._packer.packIEND()), this.emit('end')
      }.bind(this)
    ),
    this._deflate.end(j)
}
var packerAsyncExports = packerAsync.exports,
  pngSync = {},
  syncInflate = { exports: {} }
;(function(o, a) {
  let s = requireAssert().ok,
    $ = lib$2,
    j = util$u,
    _e = buffer$1.kMaxLength
  function et(ot) {
    if (!(this instanceof et)) return new et(ot)
    ot && ot.chunkSize < $.Z_MIN_CHUNK && (ot.chunkSize = $.Z_MIN_CHUNK),
      $.Inflate.call(this, ot),
      (this._offset = this._offset === void 0 ? this._outOffset : this._offset),
      (this._buffer = this._buffer || this._outBuffer),
      ot && ot.maxLength != null && (this._maxLength = ot.maxLength)
  }
  function tt(ot) {
    return new et(ot)
  }
  function rt(ot, at) {
    ot._handle && (ot._handle.close(), (ot._handle = null))
  }
  ;(et.prototype._processChunk = function(ot, at, st) {
    if (typeof st == 'function')
      return $.Inflate._processChunk.call(this, ot, at, st)
    let ut = this,
      ct = ot && ot.length,
      dt = this._chunkSize - this._offset,
      ft = this._maxLength,
      mt = 0,
      vt = [],
      yt = 0,
      pt
    this.on('error', function(Ct) {
      pt = Ct
    })
    function ht(Ct, Dt) {
      if (ut._hadError) return
      let jt = dt - Dt
      if ((s(jt >= 0, 'have should not go down'), jt > 0)) {
        let Et = ut._buffer.slice(ut._offset, ut._offset + jt)
        if (
          ((ut._offset += jt),
          Et.length > ft && (Et = Et.slice(0, ft)),
          vt.push(Et),
          (yt += Et.length),
          (ft -= Et.length),
          ft === 0)
        )
          return !1
      }
      return (
        (Dt === 0 || ut._offset >= ut._chunkSize) &&
          ((dt = ut._chunkSize),
          (ut._offset = 0),
          (ut._buffer = Buffer.allocUnsafe(ut._chunkSize))),
        Dt === 0 ? ((mt += ct - Ct), (ct = Ct), !0) : !1
      )
    }
    s(this._handle, 'zlib binding closed')
    let At
    do
      (At = this._handle.writeSync(
        at,
        ot,
        mt,
        ct,
        this._buffer,
        this._offset,
        dt
      )),
        (At = At || this._writeState)
    while (!this._hadError && ht(At[0], At[1]))
    if (this._hadError) throw pt
    if (yt >= _e)
      throw (rt(this),
      new RangeError(
        'Cannot create final Buffer. It would be larger than 0x' +
          _e.toString(16) +
          ' bytes'
      ))
    let wt = Buffer.concat(vt, yt)
    return rt(this), wt
  }),
    j.inherits(et, $.Inflate)
  function nt(ot, at) {
    if (
      (typeof at == 'string' && (at = Buffer.from(at)), !(at instanceof Buffer))
    )
      throw new TypeError('Not a string or buffer')
    let st = ot._finishFlushFlag
    return st == null && (st = $.Z_FINISH), ot._processChunk(at, st)
  }
  function it(ot, at) {
    return nt(new et(at), ot)
  }
  ;(o.exports = a = it),
    (a.Inflate = et),
    (a.createInflate = tt),
    (a.inflateSync = it)
})(syncInflate, syncInflate.exports)
var syncInflateExports = syncInflate.exports,
  syncReader = { exports: {} }
let SyncReader$2 = (syncReader.exports = function(o) {
  ;(this._buffer = o), (this._reads = [])
})
SyncReader$2.prototype.read = function(o, a) {
  this._reads.push({ length: Math.abs(o), allowLess: o < 0, func: a })
}
SyncReader$2.prototype.process = function() {
  for (; this._reads.length > 0 && this._buffer.length; ) {
    let o = this._reads[0]
    if (
      this._buffer.length &&
      (this._buffer.length >= o.length || o.allowLess)
    ) {
      this._reads.shift()
      let a = this._buffer
      ;(this._buffer = a.slice(o.length)),
        o.func.call(this, a.slice(0, o.length))
    } else break
  }
  if (this._reads.length > 0)
    throw new Error('There are some read requests waitng on finished stream')
  if (this._buffer.length > 0)
    throw new Error('unrecognised content at end of stream')
}
var syncReaderExports = syncReader.exports,
  filterParseSync = {}
let SyncReader$1 = syncReaderExports,
  Filter = filterParseExports
filterParseSync.process = function(o, a) {
  let s = [],
    $ = new SyncReader$1(o)
  return (
    new Filter(a, {
      read: $.read.bind($),
      write: function(_e) {
        s.push(_e)
      },
      complete: function() {},
    }).start(),
    $.process(),
    Buffer.concat(s)
  )
}
let hasSyncZlib$1 = !0,
  zlib$1 = lib$2,
  inflateSync = syncInflateExports
zlib$1.deflateSync || (hasSyncZlib$1 = !1)
let SyncReader = syncReaderExports,
  FilterSync = filterParseSync,
  Parser$3 = parserExports,
  bitmapper = bitmapper$2,
  formatNormaliser = formatNormaliser$2
var parserSync = function(o, a) {
  if (!hasSyncZlib$1)
    throw new Error(
      'To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0'
    )
  let s
  function $(yt) {
    s = yt
  }
  let j
  function _e(yt) {
    j = yt
  }
  function et(yt) {
    j.transColor = yt
  }
  function tt(yt) {
    j.palette = yt
  }
  function rt() {
    j.alpha = !0
  }
  let nt
  function it(yt) {
    nt = yt
  }
  let ot = []
  function at(yt) {
    ot.push(yt)
  }
  let st = new SyncReader(o)
  if (
    (new Parser$3(a, {
      read: st.read.bind(st),
      error: $,
      metadata: _e,
      gamma: it,
      palette: tt,
      transColor: et,
      inflateData: at,
      simpleTransparency: rt,
    }).start(),
    st.process(),
    s)
  )
    throw s
  let ct = Buffer.concat(ot)
  ot.length = 0
  let dt
  if (j.interlace) dt = zlib$1.inflateSync(ct)
  else {
    let pt = (((j.width * j.bpp * j.depth + 7) >> 3) + 1) * j.height
    dt = inflateSync(ct, { chunkSize: pt, maxLength: pt })
  }
  if (((ct = null), !dt || !dt.length))
    throw new Error('bad png - invalid inflate data response')
  let ft = FilterSync.process(dt, j)
  ct = null
  let mt = bitmapper.dataToBitMap(ft, j)
  ft = null
  let vt = formatNormaliser(mt, j, a.skipRescale)
  return (j.data = vt), (j.gamma = nt || 0), j
}
let hasSyncZlib = !0,
  zlib = lib$2
zlib.deflateSync || (hasSyncZlib = !1)
let constants = constants$5,
  Packer$1 = packerExports
var packerSync = function(o, a) {
  if (!hasSyncZlib)
    throw new Error(
      'To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0'
    )
  let s = a || {},
    $ = new Packer$1(s),
    j = []
  j.push(Buffer.from(constants.PNG_SIGNATURE)),
    j.push($.packIHDR(o.width, o.height)),
    o.gamma && j.push($.packGAMA(o.gamma))
  let _e = $.filterData(o.data, o.width, o.height),
    et = zlib.deflateSync(_e, $.getDeflateOptions())
  if (((_e = null), !et || !et.length))
    throw new Error('bad png - invalid compressed data response')
  return j.push($.packIDAT(et)), j.push($.packIEND()), Buffer.concat(j)
}
let parse$4 = parserSync,
  pack = packerSync
pngSync.read = function(o, a) {
  return parse$4(o, a || {})
}
pngSync.write = function(o, a) {
  return pack(o, a)
}
var PNG_1
let util$1 = util$u,
  Stream = stream$1,
  Parser$2 = parserAsyncExports,
  Packer = packerAsyncExports,
  PNGSync = pngSync,
  PNG = (PNG_1 = function(o) {
    Stream.call(this),
      (o = o || {}),
      (this.width = o.width | 0),
      (this.height = o.height | 0),
      (this.data =
        this.width > 0 && this.height > 0
          ? Buffer.alloc(4 * this.width * this.height)
          : null),
      o.fill && this.data && this.data.fill(0),
      (this.gamma = 0),
      (this.readable = this.writable = !0),
      (this._parser = new Parser$2(o)),
      this._parser.on('error', this.emit.bind(this, 'error')),
      this._parser.on('close', this._handleClose.bind(this)),
      this._parser.on('metadata', this._metadata.bind(this)),
      this._parser.on('gamma', this._gamma.bind(this)),
      this._parser.on(
        'parsed',
        function(a) {
          ;(this.data = a), this.emit('parsed', a)
        }.bind(this)
      ),
      (this._packer = new Packer(o)),
      this._packer.on('data', this.emit.bind(this, 'data')),
      this._packer.on('end', this.emit.bind(this, 'end')),
      this._parser.on('close', this._handleClose.bind(this)),
      this._packer.on('error', this.emit.bind(this, 'error'))
  })
util$1.inherits(PNG, Stream)
PNG.sync = PNGSync
PNG.prototype.pack = function() {
  return !this.data || !this.data.length
    ? (this.emit('error', 'No data provided'), this)
    : (process.nextTick(
        function() {
          this._packer.pack(this.data, this.width, this.height, this.gamma)
        }.bind(this)
      ),
      this)
}
PNG.prototype.parse = function(o, a) {
  if (a) {
    let s, $
    ;(s = function(j) {
      this.removeListener('error', $), (this.data = j), a(null, this)
    }.bind(this)),
      ($ = function(j) {
        this.removeListener('parsed', s), a(j, null)
      }.bind(this)),
      this.once('parsed', s),
      this.once('error', $)
  }
  return this.end(o), this
}
PNG.prototype.write = function(o) {
  return this._parser.write(o), !0
}
PNG.prototype.end = function(o) {
  this._parser.end(o)
}
PNG.prototype._metadata = function(o) {
  ;(this.width = o.width), (this.height = o.height), this.emit('metadata', o)
}
PNG.prototype._gamma = function(o) {
  this.gamma = o
}
PNG.prototype._handleClose = function() {
  !this._parser.writable && !this._packer.readable && this.emit('close')
}
PNG.bitblt = function(o, a, s, $, j, _e, et, tt) {
  if (
    ((s |= 0),
    ($ |= 0),
    (j |= 0),
    (_e |= 0),
    (et |= 0),
    (tt |= 0),
    s > o.width || $ > o.height || s + j > o.width || $ + _e > o.height)
  )
    throw new Error('bitblt reading outside image')
  if (et > a.width || tt > a.height || et + j > a.width || tt + _e > a.height)
    throw new Error('bitblt writing outside image')
  for (let rt = 0; rt < _e; rt++)
    o.data.copy(
      a.data,
      ((tt + rt) * a.width + et) << 2,
      (($ + rt) * o.width + s) << 2,
      (($ + rt) * o.width + s + j) << 2
    )
}
PNG.prototype.bitblt = function(o, a, s, $, j, _e, et) {
  return PNG.bitblt(this, o, a, s, $, j, _e, et), this
}
PNG.adjustGamma = function(o) {
  if (o.gamma) {
    for (let a = 0; a < o.height; a++)
      for (let s = 0; s < o.width; s++) {
        let $ = (o.width * a + s) << 2
        for (let j = 0; j < 3; j++) {
          let _e = o.data[$ + j] / 255
          ;(_e = Math.pow(_e, 1 / 2.2 / o.gamma)),
            (o.data[$ + j] = Math.round(_e * 255))
        }
      }
    o.gamma = 0
  }
}
PNG.prototype.adjustGamma = function() {
  PNG.adjustGamma(this)
}
const MIME_TYPE = 'image/png',
  PNG_FILTER_AUTO = -1,
  PNG_FILTER_NONE = 0,
  PNG_FILTER_SUB = 1,
  PNG_FILTER_UP = 2,
  PNG_FILTER_AVERAGE = 3,
  PNG_FILTER_PATH = 4,
  jimpPng = () => ({
    mime: { [MIME_TYPE]: ['png'] },
    constants: {
      MIME_PNG: MIME_TYPE,
      PNG_FILTER_AUTO,
      PNG_FILTER_NONE,
      PNG_FILTER_SUB,
      PNG_FILTER_UP,
      PNG_FILTER_AVERAGE,
      PNG_FILTER_PATH,
    },
    hasAlpha: { [MIME_TYPE]: !0 },
    decoders: { [MIME_TYPE]: PNG_1.sync.read },
    encoders: {
      [MIME_TYPE](o) {
        const a = new PNG_1({ width: o.bitmap.width, height: o.bitmap.height })
        return (
          (a.data = o.bitmap.data),
          PNG_1.sync.write(a, {
            deflateLevel: o._deflateLevel,
            deflateStrategy: o._deflateStrategy,
            filterType: o._filterType,
            colorType:
              typeof o._colorType == 'number' ? o._colorType : o._rgba ? 6 : 2,
            inputHasAlpha: o._rgba,
          })
        )
      },
    },
    class: {
      _deflateLevel: 9,
      _deflateStrategy: 3,
      _filterType: PNG_FILTER_AUTO,
      _colorType: null,
      deflateLevel(o, a) {
        return typeof o != 'number'
          ? throwError.call(this, 'l must be a number', a)
          : o < 0 || o > 9
          ? throwError.call(this, 'l must be a number 0 - 9', a)
          : ((this._deflateLevel = Math.round(o)),
            isNodePattern(a) && a.call(this, null, this),
            this)
      },
      deflateStrategy(o, a) {
        return typeof o != 'number'
          ? throwError.call(this, 's must be a number', a)
          : o < 0 || o > 3
          ? throwError.call(this, 's must be a number 0 - 3', a)
          : ((this._deflateStrategy = Math.round(o)),
            isNodePattern(a) && a.call(this, null, this),
            this)
      },
      filterType(o, a) {
        return typeof o != 'number'
          ? throwError.call(this, 'n must be a number', a)
          : o < -1 || o > 4
          ? throwError.call(this, 'n must be -1 (auto) or a number 0 - 4', a)
          : ((this._filterType = Math.round(o)),
            isNodePattern(a) && a.call(this, null, this),
            this)
      },
      colorType(o, a) {
        return typeof o != 'number'
          ? throwError.call(this, 's must be a number', a)
          : o !== 0 && o !== 2 && o !== 4 && o !== 6
          ? throwError.call(this, 's must be a number 0, 2, 4, 6.', a)
          : ((this._colorType = Math.round(o)),
            isNodePattern(a) && a.call(this, null, this),
            this)
      },
    },
  })
var lodash_sortby = { exports: {} }
lodash_sortby.exports
;(function(o, a) {
  var s = {},
    $ = 200,
    j = 'Expected a function',
    _e = '__lodash_hash_undefined__',
    et = 1,
    tt = 2,
    rt = 1 / 0,
    nt = 9007199254740991,
    it = '[object Arguments]',
    ot = '[object Array]',
    at = '[object Boolean]',
    st = '[object Date]',
    ut = '[object Error]',
    ct = '[object Function]',
    dt = '[object GeneratorFunction]',
    ft = '[object Map]',
    mt = '[object Number]',
    vt = '[object Object]',
    yt = '[object Promise]',
    pt = '[object RegExp]',
    ht = '[object Set]',
    At = '[object String]',
    wt = '[object Symbol]',
    Ct = '[object WeakMap]',
    Dt = '[object ArrayBuffer]',
    jt = '[object DataView]',
    Et = '[object Float32Array]',
    St = '[object Float64Array]',
    Bt = '[object Int8Array]',
    Mt = '[object Int16Array]',
    Ut = '[object Int32Array]',
    Wt = '[object Uint8Array]',
    Tt = '[object Uint8ClampedArray]',
    kt = '[object Uint16Array]',
    Ot = '[object Uint32Array]',
    Nt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    $t = /^\w*$/,
    Pt = /^\./,
    Ft = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
    Vt = /[\\^$.*+?()[\]{}|]/g,
    Xt = /\\(\\)?/g,
    Yt = /^\[object .+?Constructor\]$/,
    xt = /^(?:0|[1-9]\d*)$/,
    It = {}
  ;(It[Et] = It[St] = It[Bt] = It[Mt] = It[Ut] = It[Wt] = It[Tt] = It[kt] = It[
    Ot
  ] = !0),
    (It[it] = It[ot] = It[Dt] = It[at] = It[jt] = It[st] = It[ut] = It[ct] = It[
      ft
    ] = It[mt] = It[vt] = It[pt] = It[ht] = It[At] = It[Ct] = !1)
  var Kt = typeof s == 'object' && s && s.Object === Object && s,
    Qt = typeof self == 'object' && self && self.Object === Object && self,
    Ht = Kt || Qt || Function('return this')(),
    Lt = a && !a.nodeType && a,
    tr = Lt && !0 && o && !o.nodeType && o,
    lr = tr && tr.exports === Lt,
    yr = lr && Kt.process,
    mr = (function() {
      try {
        return yr && yr.binding('util')
      } catch {}
    })(),
    Er = mr && mr.isTypedArray
  function ur(Gt, Jt, pr) {
    switch (pr.length) {
      case 0:
        return Gt.call(Jt)
      case 1:
        return Gt.call(Jt, pr[0])
      case 2:
        return Gt.call(Jt, pr[0], pr[1])
      case 3:
        return Gt.call(Jt, pr[0], pr[1], pr[2])
    }
    return Gt.apply(Jt, pr)
  }
  function _r(Gt, Jt) {
    for (var pr = -1, wr = Gt ? Gt.length : 0, Mr = Array(wr); ++pr < wr; )
      Mr[pr] = Jt(Gt[pr], pr, Gt)
    return Mr
  }
  function Rr(Gt, Jt) {
    for (var pr = -1, wr = Jt.length, Mr = Gt.length; ++pr < wr; )
      Gt[Mr + pr] = Jt[pr]
    return Gt
  }
  function nr(Gt, Jt) {
    for (var pr = -1, wr = Gt ? Gt.length : 0; ++pr < wr; )
      if (Jt(Gt[pr], pr, Gt)) return !0
    return !1
  }
  function fr(Gt) {
    return function(Jt) {
      return Jt == null ? void 0 : Jt[Gt]
    }
  }
  function gr(Gt, Jt) {
    var pr = Gt.length
    for (Gt.sort(Jt); pr--; ) Gt[pr] = Gt[pr].value
    return Gt
  }
  function br(Gt, Jt) {
    for (var pr = -1, wr = Array(Gt); ++pr < Gt; ) wr[pr] = Jt(pr)
    return wr
  }
  function Sr(Gt) {
    return function(Jt) {
      return Gt(Jt)
    }
  }
  function zt(Gt, Jt) {
    return Gt == null ? void 0 : Gt[Jt]
  }
  function bt(Gt) {
    var Jt = !1
    if (Gt != null && typeof Gt.toString != 'function')
      try {
        Jt = !!(Gt + '')
      } catch {}
    return Jt
  }
  function Rt(Gt) {
    var Jt = -1,
      pr = Array(Gt.size)
    return (
      Gt.forEach(function(wr, Mr) {
        pr[++Jt] = [Mr, wr]
      }),
      pr
    )
  }
  function qt(Gt, Jt) {
    return function(pr) {
      return Gt(Jt(pr))
    }
  }
  function rr(Gt) {
    var Jt = -1,
      pr = Array(Gt.size)
    return (
      Gt.forEach(function(wr) {
        pr[++Jt] = wr
      }),
      pr
    )
  }
  var ar = Array.prototype,
    ir = Function.prototype,
    Tr = Object.prototype,
    vr = Ht['__core-js_shared__'],
    Ar = (function() {
      var Gt = /[^.]+$/.exec((vr && vr.keys && vr.keys.IE_PROTO) || '')
      return Gt ? 'Symbol(src)_1.' + Gt : ''
    })(),
    Nr = ir.toString,
    Or = Tr.hasOwnProperty,
    Fr = Tr.toString,
    Qr = RegExp(
      '^' +
        Nr.call(Or)
          .replace(Vt, '\\$&')
          .replace(
            /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
            '$1.*?'
          ) +
        '$'
    ),
    qr = Ht.Symbol,
    tn = Ht.Uint8Array,
    en = Tr.propertyIsEnumerable,
    ln = ar.splice,
    yn = qr ? qr.isConcatSpreadable : void 0,
    Bn = qt(Object.keys, Object),
    xn = Math.max,
    vn = Hn(Ht, 'DataView'),
    on = Hn(Ht, 'Map'),
    Cn = Hn(Ht, 'Promise'),
    dn = Hn(Ht, 'Set'),
    An = Hn(Ht, 'WeakMap'),
    Jr = Hn(Object, 'create'),
    En = Fn(vn),
    Pn = Fn(on),
    pn = Fn(Cn),
    Tn = Fn(dn),
    _n = Fn(An),
    hn = qr ? qr.prototype : void 0,
    wn = hn ? hn.valueOf : void 0,
    Kr = hn ? hn.toString : void 0
  function Vr(Gt) {
    var Jt = -1,
      pr = Gt ? Gt.length : 0
    for (this.clear(); ++Jt < pr; ) {
      var wr = Gt[Jt]
      this.set(wr[0], wr[1])
    }
  }
  function In() {
    this.__data__ = Jr ? Jr(null) : {}
  }
  function Sn(Gt) {
    return this.has(Gt) && delete this.__data__[Gt]
  }
  function an(Gt) {
    var Jt = this.__data__
    if (Jr) {
      var pr = Jt[Gt]
      return pr === _e ? void 0 : pr
    }
    return Or.call(Jt, Gt) ? Jt[Gt] : void 0
  }
  function jr(Gt) {
    var Jt = this.__data__
    return Jr ? Jt[Gt] !== void 0 : Or.call(Jt, Gt)
  }
  function rn(Gt, Jt) {
    var pr = this.__data__
    return (pr[Gt] = Jr && Jt === void 0 ? _e : Jt), this
  }
  ;(Vr.prototype.clear = In),
    (Vr.prototype.delete = Sn),
    (Vr.prototype.get = an),
    (Vr.prototype.has = jr),
    (Vr.prototype.set = rn)
  function bn(Gt) {
    var Jt = -1,
      pr = Gt ? Gt.length : 0
    for (this.clear(); ++Jt < pr; ) {
      var wr = Gt[Jt]
      this.set(wr[0], wr[1])
    }
  }
  function ao() {
    this.__data__ = []
  }
  function so(Gt) {
    var Jt = this.__data__,
      pr = Cr(Jt, Gt)
    if (pr < 0) return !1
    var wr = Jt.length - 1
    return pr == wr ? Jt.pop() : ln.call(Jt, pr, 1), !0
  }
  function Xn(Gt) {
    var Jt = this.__data__,
      pr = Cr(Jt, Gt)
    return pr < 0 ? void 0 : Jt[pr][1]
  }
  function Ln(Gt) {
    return Cr(this.__data__, Gt) > -1
  }
  function Zn(Gt, Jt) {
    var pr = this.__data__,
      wr = Cr(pr, Gt)
    return wr < 0 ? pr.push([Gt, Jt]) : (pr[wr][1] = Jt), this
  }
  ;(bn.prototype.clear = ao),
    (bn.prototype.delete = so),
    (bn.prototype.get = Xn),
    (bn.prototype.has = Ln),
    (bn.prototype.set = Zn)
  function nn(Gt) {
    var Jt = -1,
      pr = Gt ? Gt.length : 0
    for (this.clear(); ++Jt < pr; ) {
      var wr = Gt[Jt]
      this.set(wr[0], wr[1])
    }
  }
  function lo() {
    this.__data__ = { hash: new Vr(), map: new (on || bn)(), string: new Vr() }
  }
  function Wn(Gt) {
    return _i(this, Gt).delete(Gt)
  }
  function Gn(Gt) {
    return _i(this, Gt).get(Gt)
  }
  function uo(Gt) {
    return _i(this, Gt).has(Gt)
  }
  function co(Gt, Jt) {
    return _i(this, Gt).set(Gt, Jt), this
  }
  ;(nn.prototype.clear = lo),
    (nn.prototype.delete = Wn),
    (nn.prototype.get = Gn),
    (nn.prototype.has = uo),
    (nn.prototype.set = co)
  function On(Gt) {
    var Jt = -1,
      pr = Gt ? Gt.length : 0
    for (this.__data__ = new nn(); ++Jt < pr; ) this.add(Gt[Jt])
  }
  function fo(Gt) {
    return this.__data__.set(Gt, _e), this
  }
  function po(Gt) {
    return this.__data__.has(Gt)
  }
  ;(On.prototype.add = On.prototype.push = fo), (On.prototype.has = po)
  function Zt(Gt) {
    this.__data__ = new bn(Gt)
  }
  function or() {
    this.__data__ = new bn()
  }
  function er(Gt) {
    return this.__data__.delete(Gt)
  }
  function dr(Gt) {
    return this.__data__.get(Gt)
  }
  function hr(Gt) {
    return this.__data__.has(Gt)
  }
  function cr(Gt, Jt) {
    var pr = this.__data__
    if (pr instanceof bn) {
      var wr = pr.__data__
      if (!on || wr.length < $ - 1) return wr.push([Gt, Jt]), this
      pr = this.__data__ = new nn(wr)
    }
    return pr.set(Gt, Jt), this
  }
  ;(Zt.prototype.clear = or),
    (Zt.prototype.delete = er),
    (Zt.prototype.get = dr),
    (Zt.prototype.has = hr),
    (Zt.prototype.set = cr)
  function xr(Gt, Jt) {
    var pr = Nn(Gt) || Eo(Gt) ? br(Gt.length, String) : [],
      wr = pr.length,
      Mr = !!wr
    for (var kr in Gt)
      Or.call(Gt, kr) && !(Mr && (kr == 'length' || yo(kr, wr))) && pr.push(kr)
    return pr
  }
  function Cr(Gt, Jt) {
    for (var pr = Gt.length; pr--; ) if (Ao(Gt[pr][0], Jt)) return pr
    return -1
  }
  var Ir = zo(Dr)
  function $r(Gt, Jt, pr, wr, Mr) {
    var kr = -1,
      Br = Gt.length
    for (pr || (pr = Qo), Mr || (Mr = []); ++kr < Br; ) {
      var Gr = Gt[kr]
      pr(Gr) ? Rr(Mr, Gr) : (Mr[Mr.length] = Gr)
    }
    return Mr
  }
  var Pr = Go()
  function Dr(Gt, Jt) {
    return Gt && Pr(Gt, Jt, no)
  }
  function Lr(Gt, Jt) {
    Jt = eo(Jt, Gt) ? [Jt] : So(Jt)
    for (var pr = 0, wr = Jt.length; Gt != null && pr < wr; )
      Gt = Gt[to(Jt[pr++])]
    return pr && pr == wr ? Gt : void 0
  }
  function Hr(Gt) {
    return Fr.call(Gt)
  }
  function zr(Gt, Jt) {
    return Gt != null && Jt in Object(Gt)
  }
  function Xr(Gt, Jt, pr, wr, Mr) {
    return Gt === Jt
      ? !0
      : Gt == null || Jt == null || (!Yn(Gt) && !ro(Jt))
      ? Gt !== Gt && Jt !== Jt
      : Zr(Gt, Jt, Xr, pr, wr, Mr)
  }
  function Zr(Gt, Jt, pr, wr, Mr, kr) {
    var Br = Nn(Gt),
      Gr = Nn(Jt),
      Ur = ot,
      Yr = ot
    Br || ((Ur = kn(Gt)), (Ur = Ur == it ? vt : Ur)),
      Gr || ((Yr = kn(Jt)), (Yr = Yr == it ? vt : Yr))
    var cn = Ur == vt && !bt(Gt),
      fn = Yr == vt && !bt(Jt),
      sn = Ur == Yr
    if (sn && !cn)
      return (
        kr || (kr = new Zt()),
        Br || es(Gt)
          ? Ro(Gt, Jt, pr, wr, Mr, kr)
          : qo(Gt, Jt, Ur, pr, wr, Mr, kr)
      )
    if (!(Mr & tt)) {
      var mn = cn && Or.call(Gt, '__wrapped__'),
        gn = fn && Or.call(Jt, '__wrapped__')
      if (mn || gn) {
        var Mn = mn ? Gt.value() : Gt,
          $n = gn ? Jt.value() : Jt
        return kr || (kr = new Zt()), pr(Mn, $n, wr, Mr, kr)
      }
    }
    return sn ? (kr || (kr = new Zt()), Vo(Gt, Jt, pr, wr, Mr, kr)) : !1
  }
  function un(Gt, Jt, pr, wr) {
    var Mr = pr.length,
      kr = Mr
    if (Gt == null) return !kr
    for (Gt = Object(Gt); Mr--; ) {
      var Br = pr[Mr]
      if (Br[2] ? Br[1] !== Gt[Br[0]] : !(Br[0] in Gt)) return !1
    }
    for (; ++Mr < kr; ) {
      Br = pr[Mr]
      var Gr = Br[0],
        Ur = Gt[Gr],
        Yr = Br[1]
      if (Br[2]) {
        if (Ur === void 0 && !(Gr in Gt)) return !1
      } else {
        var cn = new Zt(),
          fn
        if (!(fn === void 0 ? Xr(Yr, Ur, wr, et | tt, cn) : fn)) return !1
      }
    }
    return !0
  }
  function jn(Gt) {
    if (!Yn(Gt) || Zo(Gt)) return !1
    var Jt = $o(Gt) || bt(Gt) ? Qr : Yt
    return Jt.test(Fn(Gt))
  }
  function qn(Gt) {
    return ro(Gt) && bo(Gt.length) && !!It[Fr.call(Gt)]
  }
  function ho(Gt) {
    return typeof Gt == 'function'
      ? Gt
      : Gt == null
      ? Po
      : typeof Gt == 'object'
      ? Nn(Gt)
        ? go(Gt[0], Gt[1])
        : mo(Gt)
      : os(Gt)
  }
  function Vn(Gt) {
    if (!Jo(Gt)) return Bn(Gt)
    var Jt = []
    for (var pr in Object(Gt))
      Or.call(Gt, pr) && pr != 'constructor' && Jt.push(pr)
    return Jt
  }
  function wo(Gt, Jt) {
    var pr = -1,
      wr = Kn(Gt) ? Array(Gt.length) : []
    return (
      Ir(Gt, function(Mr, kr, Br) {
        wr[++pr] = Jt(Mr, kr, Br)
      }),
      wr
    )
  }
  function mo(Gt) {
    var Jt = Ko(Gt)
    return Jt.length == 1 && Jt[0][2]
      ? Io(Jt[0][0], Jt[0][1])
      : function(pr) {
          return pr === Gt || un(pr, Gt, Jt)
        }
  }
  function go(Gt, Jt) {
    return eo(Gt) && To(Jt)
      ? Io(to(Gt), Jt)
      : function(pr) {
          var wr = rs(pr, Gt)
          return wr === void 0 && wr === Jt
            ? ns(pr, Gt)
            : Xr(Jt, wr, void 0, et | tt)
        }
  }
  function Jn(Gt, Jt, pr) {
    var wr = -1
    Jt = _r(Jt.length ? Jt : [Po], Sr(ho))
    var Mr = wo(Gt, function(kr, Br, Gr) {
      var Ur = _r(Jt, function(Yr) {
        return Yr(kr)
      })
      return { criteria: Ur, index: ++wr, value: kr }
    })
    return gr(Mr, function(kr, Br) {
      return Ho(kr, Br, pr)
    })
  }
  function jo(Gt) {
    return function(Jt) {
      return Lr(Jt, Gt)
    }
  }
  function Fo(Gt, Jt) {
    return (
      (Jt = xn(Jt === void 0 ? Gt.length - 1 : Jt, 0)),
      function() {
        for (
          var pr = arguments,
            wr = -1,
            Mr = xn(pr.length - Jt, 0),
            kr = Array(Mr);
          ++wr < Mr;

        )
          kr[wr] = pr[Jt + wr]
        wr = -1
        for (var Br = Array(Jt + 1); ++wr < Jt; ) Br[wr] = pr[wr]
        return (Br[Jt] = kr), ur(Gt, this, Br)
      }
    )
  }
  function Uo(Gt) {
    if (typeof Gt == 'string') return Gt
    if (Qn(Gt)) return Kr ? Kr.call(Gt) : ''
    var Jt = Gt + ''
    return Jt == '0' && 1 / Gt == -rt ? '-0' : Jt
  }
  function So(Gt) {
    return Nn(Gt) ? Gt : ga(Gt)
  }
  function Wo(Gt, Jt) {
    if (Gt !== Jt) {
      var pr = Gt !== void 0,
        wr = Gt === null,
        Mr = Gt === Gt,
        kr = Qn(Gt),
        Br = Jt !== void 0,
        Gr = Jt === null,
        Ur = Jt === Jt,
        Yr = Qn(Jt)
      if (
        (!Gr && !Yr && !kr && Gt > Jt) ||
        (kr && Br && Ur && !Gr && !Yr) ||
        (wr && Br && Ur) ||
        (!pr && Ur) ||
        !Mr
      )
        return 1
      if (
        (!wr && !kr && !Yr && Gt < Jt) ||
        (Yr && pr && Mr && !wr && !kr) ||
        (Gr && pr && Mr) ||
        (!Br && Mr) ||
        !Ur
      )
        return -1
    }
    return 0
  }
  function Ho(Gt, Jt, pr) {
    for (
      var wr = -1,
        Mr = Gt.criteria,
        kr = Jt.criteria,
        Br = Mr.length,
        Gr = pr.length;
      ++wr < Br;

    ) {
      var Ur = Wo(Mr[wr], kr[wr])
      if (Ur) {
        if (wr >= Gr) return Ur
        var Yr = pr[wr]
        return Ur * (Yr == 'desc' ? -1 : 1)
      }
    }
    return Gt.index - Jt.index
  }
  function zo(Gt, Jt) {
    return function(pr, wr) {
      if (pr == null) return pr
      if (!Kn(pr)) return Gt(pr, wr)
      for (
        var Mr = pr.length, kr = -1, Br = Object(pr);
        ++kr < Mr && wr(Br[kr], kr, Br) !== !1;

      );
      return pr
    }
  }
  function Go(Gt) {
    return function(Jt, pr, wr) {
      for (var Mr = -1, kr = Object(Jt), Br = wr(Jt), Gr = Br.length; Gr--; ) {
        var Ur = Br[++Mr]
        if (pr(kr[Ur], Ur, kr) === !1) break
      }
      return Jt
    }
  }
  function Ro(Gt, Jt, pr, wr, Mr, kr) {
    var Br = Mr & tt,
      Gr = Gt.length,
      Ur = Jt.length
    if (Gr != Ur && !(Br && Ur > Gr)) return !1
    var Yr = kr.get(Gt)
    if (Yr && kr.get(Jt)) return Yr == Jt
    var cn = -1,
      fn = !0,
      sn = Mr & et ? new On() : void 0
    for (kr.set(Gt, Jt), kr.set(Jt, Gt); ++cn < Gr; ) {
      var mn = Gt[cn],
        gn = Jt[cn]
      if (wr)
        var Mn = Br ? wr(gn, mn, cn, Jt, Gt, kr) : wr(mn, gn, cn, Gt, Jt, kr)
      if (Mn !== void 0) {
        if (Mn) continue
        fn = !1
        break
      }
      if (sn) {
        if (
          !nr(Jt, function($n, Un) {
            if (!sn.has(Un) && (mn === $n || pr(mn, $n, wr, Mr, kr)))
              return sn.add(Un)
          })
        ) {
          fn = !1
          break
        }
      } else if (!(mn === gn || pr(mn, gn, wr, Mr, kr))) {
        fn = !1
        break
      }
    }
    return kr.delete(Gt), kr.delete(Jt), fn
  }
  function qo(Gt, Jt, pr, wr, Mr, kr, Br) {
    switch (pr) {
      case jt:
        if (Gt.byteLength != Jt.byteLength || Gt.byteOffset != Jt.byteOffset)
          return !1
        ;(Gt = Gt.buffer), (Jt = Jt.buffer)
      case Dt:
        return !(Gt.byteLength != Jt.byteLength || !wr(new tn(Gt), new tn(Jt)))
      case at:
      case st:
      case mt:
        return Ao(+Gt, +Jt)
      case ut:
        return Gt.name == Jt.name && Gt.message == Jt.message
      case pt:
      case At:
        return Gt == Jt + ''
      case ft:
        var Gr = Rt
      case ht:
        var Ur = kr & tt
        if ((Gr || (Gr = rr), Gt.size != Jt.size && !Ur)) return !1
        var Yr = Br.get(Gt)
        if (Yr) return Yr == Jt
        ;(kr |= et), Br.set(Gt, Jt)
        var cn = Ro(Gr(Gt), Gr(Jt), wr, Mr, kr, Br)
        return Br.delete(Gt), cn
      case wt:
        if (wn) return wn.call(Gt) == wn.call(Jt)
    }
    return !1
  }
  function Vo(Gt, Jt, pr, wr, Mr, kr) {
    var Br = Mr & tt,
      Gr = no(Gt),
      Ur = Gr.length,
      Yr = no(Jt),
      cn = Yr.length
    if (Ur != cn && !Br) return !1
    for (var fn = Ur; fn--; ) {
      var sn = Gr[fn]
      if (!(Br ? sn in Jt : Or.call(Jt, sn))) return !1
    }
    var mn = kr.get(Gt)
    if (mn && kr.get(Jt)) return mn == Jt
    var gn = !0
    kr.set(Gt, Jt), kr.set(Jt, Gt)
    for (var Mn = Br; ++fn < Ur; ) {
      sn = Gr[fn]
      var $n = Gt[sn],
        Un = Jt[sn]
      if (wr)
        var Oo = Br ? wr(Un, $n, sn, Jt, Gt, kr) : wr($n, Un, sn, Gt, Jt, kr)
      if (!(Oo === void 0 ? $n === Un || pr($n, Un, wr, Mr, kr) : Oo)) {
        gn = !1
        break
      }
      Mn || (Mn = sn == 'constructor')
    }
    if (gn && !Mn) {
      var io = Gt.constructor,
        oo = Jt.constructor
      io != oo &&
        'constructor' in Gt &&
        'constructor' in Jt &&
        !(
          typeof io == 'function' &&
          io instanceof io &&
          typeof oo == 'function' &&
          oo instanceof oo
        ) &&
        (gn = !1)
    }
    return kr.delete(Gt), kr.delete(Jt), gn
  }
  function _i(Gt, Jt) {
    var pr = Gt.__data__
    return Xo(Jt) ? pr[typeof Jt == 'string' ? 'string' : 'hash'] : pr.map
  }
  function Ko(Gt) {
    for (var Jt = no(Gt), pr = Jt.length; pr--; ) {
      var wr = Jt[pr],
        Mr = Gt[wr]
      Jt[pr] = [wr, Mr, To(Mr)]
    }
    return Jt
  }
  function Hn(Gt, Jt) {
    var pr = zt(Gt, Jt)
    return jn(pr) ? pr : void 0
  }
  var kn = Hr
  ;((vn && kn(new vn(new ArrayBuffer(1))) != jt) ||
    (on && kn(new on()) != ft) ||
    (Cn && kn(Cn.resolve()) != yt) ||
    (dn && kn(new dn()) != ht) ||
    (An && kn(new An()) != Ct)) &&
    (kn = function(Gt) {
      var Jt = Fr.call(Gt),
        pr = Jt == vt ? Gt.constructor : void 0,
        wr = pr ? Fn(pr) : void 0
      if (wr)
        switch (wr) {
          case En:
            return jt
          case Pn:
            return ft
          case pn:
            return yt
          case Tn:
            return ht
          case _n:
            return Ct
        }
      return Jt
    })
  function Yo(Gt, Jt, pr) {
    Jt = eo(Jt, Gt) ? [Jt] : So(Jt)
    for (var wr, Mr = -1, Br = Jt.length; ++Mr < Br; ) {
      var kr = to(Jt[Mr])
      if (!(wr = Gt != null && pr(Gt, kr))) break
      Gt = Gt[kr]
    }
    if (wr) return wr
    var Br = Gt ? Gt.length : 0
    return !!Br && bo(Br) && yo(kr, Br) && (Nn(Gt) || Eo(Gt))
  }
  function Qo(Gt) {
    return Nn(Gt) || Eo(Gt) || !!(yn && Gt && Gt[yn])
  }
  function yo(Gt, Jt) {
    return (
      (Jt = Jt ?? nt),
      !!Jt &&
        (typeof Gt == 'number' || xt.test(Gt)) &&
        Gt > -1 &&
        Gt % 1 == 0 &&
        Gt < Jt
    )
  }
  function Co(Gt, Jt, pr) {
    if (!Yn(pr)) return !1
    var wr = typeof Jt
    return (wr == 'number'
    ? Kn(pr) && yo(Jt, pr.length)
    : wr == 'string' && Jt in pr)
      ? Ao(pr[Jt], Gt)
      : !1
  }
  function eo(Gt, Jt) {
    if (Nn(Gt)) return !1
    var pr = typeof Gt
    return pr == 'number' ||
      pr == 'symbol' ||
      pr == 'boolean' ||
      Gt == null ||
      Qn(Gt)
      ? !0
      : $t.test(Gt) || !Nt.test(Gt) || (Jt != null && Gt in Object(Jt))
  }
  function Xo(Gt) {
    var Jt = typeof Gt
    return Jt == 'string' || Jt == 'number' || Jt == 'symbol' || Jt == 'boolean'
      ? Gt !== '__proto__'
      : Gt === null
  }
  function Zo(Gt) {
    return !!Ar && Ar in Gt
  }
  function Jo(Gt) {
    var Jt = Gt && Gt.constructor,
      pr = (typeof Jt == 'function' && Jt.prototype) || Tr
    return Gt === pr
  }
  function To(Gt) {
    return Gt === Gt && !Yn(Gt)
  }
  function Io(Gt, Jt) {
    return function(pr) {
      return pr == null
        ? !1
        : pr[Gt] === Jt && (Jt !== void 0 || Gt in Object(pr))
    }
  }
  var ga = vo(function(Gt) {
    Gt = ts(Gt)
    var Jt = []
    return (
      Pt.test(Gt) && Jt.push(''),
      Gt.replace(Ft, function(pr, wr, Mr, kr) {
        Jt.push(Mr ? kr.replace(Xt, '$1') : wr || pr)
      }),
      Jt
    )
  })
  function to(Gt) {
    if (typeof Gt == 'string' || Qn(Gt)) return Gt
    var Jt = Gt + ''
    return Jt == '0' && 1 / Gt == -rt ? '-0' : Jt
  }
  function Fn(Gt) {
    if (Gt != null) {
      try {
        return Nr.call(Gt)
      } catch {}
      try {
        return Gt + ''
      } catch {}
    }
    return ''
  }
  var va = Fo(function(Gt, Jt) {
    if (Gt == null) return []
    var pr = Jt.length
    return (
      pr > 1 && Co(Gt, Jt[0], Jt[1])
        ? (Jt = [])
        : pr > 2 && Co(Jt[0], Jt[1], Jt[2]) && (Jt = [Jt[0]]),
      Jn(Gt, $r(Jt), [])
    )
  })
  function vo(Gt, Jt) {
    if (typeof Gt != 'function' || (Jt && typeof Jt != 'function'))
      throw new TypeError(j)
    var pr = function() {
      var wr = arguments,
        Mr = Jt ? Jt.apply(this, wr) : wr[0],
        kr = pr.cache
      if (kr.has(Mr)) return kr.get(Mr)
      var Br = Gt.apply(this, wr)
      return (pr.cache = kr.set(Mr, Br)), Br
    }
    return (pr.cache = new (vo.Cache || nn)()), pr
  }
  vo.Cache = nn
  function Ao(Gt, Jt) {
    return Gt === Jt || (Gt !== Gt && Jt !== Jt)
  }
  function Eo(Gt) {
    return (
      _a(Gt) &&
      Or.call(Gt, 'callee') &&
      (!en.call(Gt, 'callee') || Fr.call(Gt) == it)
    )
  }
  var Nn = Array.isArray
  function Kn(Gt) {
    return Gt != null && bo(Gt.length) && !$o(Gt)
  }
  function _a(Gt) {
    return ro(Gt) && Kn(Gt)
  }
  function $o(Gt) {
    var Jt = Yn(Gt) ? Fr.call(Gt) : ''
    return Jt == ct || Jt == dt
  }
  function bo(Gt) {
    return typeof Gt == 'number' && Gt > -1 && Gt % 1 == 0 && Gt <= nt
  }
  function Yn(Gt) {
    var Jt = typeof Gt
    return !!Gt && (Jt == 'object' || Jt == 'function')
  }
  function ro(Gt) {
    return !!Gt && typeof Gt == 'object'
  }
  function Qn(Gt) {
    return typeof Gt == 'symbol' || (ro(Gt) && Fr.call(Gt) == wt)
  }
  var es = Er ? Sr(Er) : qn
  function ts(Gt) {
    return Gt == null ? '' : Uo(Gt)
  }
  function rs(Gt, Jt, pr) {
    var wr = Gt == null ? void 0 : Lr(Gt, Jt)
    return wr === void 0 ? pr : wr
  }
  function ns(Gt, Jt) {
    return Gt != null && Yo(Gt, Jt, zr)
  }
  function no(Gt) {
    return Kn(Gt) ? xr(Gt) : Vn(Gt)
  }
  function Po(Gt) {
    return Gt
  }
  function os(Gt) {
    return eo(Gt) ? fr(to(Gt)) : jo(Gt)
  }
  o.exports = va
})(lodash_sortby, lodash_sortby.exports)
var lodash_sortbyExports = lodash_sortby.exports
const sortBy = getDefaultExportFromCjs(lodash_sortbyExports)
var animalNames = [
    'Aardvark',
    'Albatross',
    'Alligator',
    'Alpaca',
    'Angelfish',
    'Anglerfish',
    'Ant',
    'Anteater',
    'Antelope',
    'Antlion',
    'Ape',
    'Armadillo',
    'Asp',
    'Baboon',
    'Badger',
    'Bandicoot',
    'Barnacle',
    'Barracuda',
    'Basilisk',
    'Bass',
    'Bat',
    'Bear',
    'Beaver',
    'Bee',
    'Beetle',
    'Bird',
    'Bison',
    'Blackbird',
    'Boar',
    'Bobcat',
    'Bonobo',
    'Bug',
    'Butterfly',
    'Buzzard',
    'Camel',
    'Capybara',
    'Cardinal',
    'Caribou',
    'Cat',
    'Caterpillar',
    'Catfish',
    'Cattle',
    'Chameleon',
    'Cheetah',
    'Chickadee',
    'Chicken',
    'Chimpanzee',
    'Chinchilla',
    'Chipmunk',
    'Clam',
    'Clownfish',
    'Cobra',
    'Condor',
    'Coral',
    'Cougar',
    'Coyote',
    'Crab',
    'Crane',
    'Crawdad',
    'Crayfish',
    'Cricket',
    'Crocodile',
    'Crow',
    'Cuckoo',
    'Deer',
    'Dingo',
    'Dinosaur',
    'Dog',
    'Dolphin',
    'Donkey',
    'Dove',
    'Dragon',
    'Dragonfly',
    'Duck',
    'Eagle',
    'Earthworm',
    'Echidna',
    'Egret',
    'Elephant',
    'Elk',
    'Emu',
    'Ermine',
    'Falcon',
    'Ferret',
    'Finch',
    'Firefly',
    'Fish',
    'Flamingo',
    'Fowl',
    'Fox',
    'Frog',
    'Gazelle',
    'Gecko',
    'Gerbil',
    'Gibbon',
    'Giraffe',
    'Goat',
    'Goldfish',
    'Goose',
    'Gopher',
    'Gorilla',
    'Grasshopper',
    'Grouse',
    'Gull',
    'Guppy',
    'Hamster',
    'Hare',
    'Harrier',
    'Hawk',
    'Hedgehog',
    'Heron',
    'Hippopotamus',
    'Horse',
    'Hummingbird',
    'Hyena',
    'Iguana',
    'Impala',
    'Jackal',
    'Jaguar',
    'Jay',
    'Jellyfish',
    'Kangaroo',
    'Kingfisher',
    'Kiwi',
    'Koala',
    'Koi',
    'Ladybug',
    'Lark',
    'Lemming',
    'Lemur',
    'Leopard',
    'Lion',
    'Llama',
    'Lobster',
    'Loon',
    'Lynx',
    'Macaw',
    'Mackerel',
    'Mammal',
    'Manatee',
    'Mandrill',
    'Marlin',
    'Marmoset',
    'Marmot',
    'Marsupial',
    'Mastodon',
    'Meerkat',
    'Mink',
    'Minnow',
    'Mockingbird',
    'Mole',
    'Mongoose',
    'Monkey',
    'Moose',
    'Mosquito',
    'Mouse',
    'Mule',
    'Muskox',
    'Narwhal',
    'Ocelot',
    'Octopus',
    'Opossum',
    'Orangutan',
    'Orca',
    'Ostrich',
    'Otter',
    'Owl',
    'Ox',
    'Panda',
    'Panther',
    'Parakeet',
    'Parrot',
    'Partridge',
    'Peacock',
    'Pelican',
    'Penguin',
    'Pig',
    'Pigeon',
    'Platypus',
    'Pony',
    'Porcupine',
    'Porpoise',
    'Puffin',
    'Puma',
    'Python',
    'Quail',
    'Quokka',
    'Rabbit',
    'Raccoon',
    'Raven',
    'Reindeer',
    'Rhinoceros',
    'Roadrunner',
    'Rooster',
    'Salamander',
    'Salmon',
    'Seahorse',
    'Shark',
    'Sheep',
    'Shrew',
    'Sloth',
    'Snail',
    'Sparrow',
    'Squid',
    'Squirrel',
    'Starfish',
    'Stingray',
    'Stoat',
    'Stork',
    'Sturgeon',
    'Swan',
    'Swift',
    'Swordfish',
    'Tapir',
    'Tarsier',
    'Tern',
    'Tiger',
    'Tortoise',
    'Toucan',
    'Turkey',
    'Turtle',
    'Tyrannosaurus',
    'Vole',
    'Wallaby',
    'Walrus',
    'Warbler',
    'Whale',
    'Wildcat',
    'Wolf',
    'Wolverine',
    'Wombat',
    'Woodpecker',
    'Wren',
    'Yak',
    'Zebra',
  ],
  adjectives = [
    'Adorable',
    'Adventurous',
    'Agreeable',
    'Alert',
    'Amused',
    'Attractive',
    'Average',
    'Beautiful',
    'Blushing',
    'Brainy',
    'Brave',
    'Bright',
    'Busy',
    'Calm',
    'Careful',
    'Cautious',
    'Charming',
    'Cheerful',
    'Clever',
    'Cloudy',
    'Colorful',
    'Comfortable',
    'Concerned',
    'Cooperative',
    'Courageous',
    'Crazy',
    'Curious',
    'Cute',
    'Delightful',
    'Determined',
    'Distinct',
    'Dizzy',
    'Elated',
    'Elegant',
    'Enchanting',
    'Encouraging',
    'Energetic',
    'Enthusiastic',
    'Excited',
    'Exuberant',
    'Famous',
    'Fancy',
    'Fantastic',
    'Fierce',
    'Fine',
    'Friendly',
    'Funny',
    'Gentle',
    'Gifted',
    'Glamorous',
    'Gleaming',
    'Glorious',
    'Gorgeous',
    'Graceful',
    'Handsome',
    'Happy',
    'Healthy',
    'Helpful',
    'Hilarious',
    'Important',
    'Inquisitive',
    'Jolly',
    'Joyous',
    'Kind',
    'Light',
    'Lively',
    'Lovely',
    'Lucky',
    'Magnificent',
    'Mysterious',
    'Nice',
    'Nutty',
    'Outrageous',
    'Outstanding',
    'Perfect',
    'Pleasant',
    'Poised',
    'Powerful',
    'Precious',
    'Proud',
    'Puzzled',
    'Quaint',
    'Relieved',
    'Shiny',
    'Silly',
    'Sleepy',
    'Smiling',
    'Sparkling',
    'Splendid',
    'Stormy',
    'Strange',
    'Successful',
    'Tame',
    'Thankful',
    'Thoughtful',
    'Tough',
    'Victorious',
    'Vivacious',
    'Wandering',
    'Wide-eyed',
    'Wild',
    'Witty',
    'Zany',
  ],
  convertStringToInteger$1 = function o(a) {
    return a.split('').reduce(function(s, $, j) {
      return s + $.charCodeAt(0) * j
    }, 0)
  },
  funAnimalName = function o(a, s) {
    var $ = {},
      j = $.adjectives,
      _e = j === void 0 ? adjectives : j,
      et = $.animalNames,
      tt = et === void 0 ? animalNames : et,
      rt = convertStringToInteger$1(a),
      nt = _e[rt % _e.length],
      it = convertStringToInteger$1(nt),
      ot = tt[(rt + it) % tt.length]
    return nt + ' ' + ot
  }
const enumify = o => o.reduce((a, s) => ({ [s]: s, ...a }), {}),
  cropType = enumify([
    'ASPARAGUS',
    'CARROT',
    'CORN',
    'GARLIC',
    'GRAPE',
    'JALAPENO',
    'OLIVE',
    'ONION',
    'PEA',
    'POTATO',
    'PUMPKIN',
    'SOYBEAN',
    'SPINACH',
    'SUNFLOWER',
    'STRAWBERRY',
    'SWEET_POTATO',
    'TOMATO',
    'WATERMELON',
    'WHEAT',
    'WEED',
  ]),
  recipeType = enumify([
    'FERMENTATION',
    'FORGE',
    'KITCHEN',
    'RECYCLING',
    'WINE',
  ]),
  fieldMode = enumify([
    'CLEANUP',
    'FERTILIZE',
    'HARVEST',
    'MINE',
    'OBSERVE',
    'PLANT',
    'SET_SPRINKLER',
    'SET_SCARECROW',
    'WATER',
    'USE_WATER_CREDIT',
    'BUY_MANURE_MANAGER',
  ]),
  stageFocusType = enumify([
    'NONE',
    'HOME',
    'FIELD',
    'FOREST',
    'SHOP',
    'COW_PEN',
    'INVENTORY',
    'WORKSHOP',
    'CELLAR',
  ]),
  cropLifeStage = enumify(['SEED', 'GROWING', 'GROWN']),
  itemType = enumify([
    'COW_FEED',
    'CRAFTED_ITEM',
    'CROP',
    'FERTILIZER',
    'FUEL',
    'HUGGING_MACHINE',
    'MILK',
    'ORE',
    'SCARECROW',
    'SPRINKLER',
    'STONE',
    'TOOL_UPGRADE',
    'WEED',
    'WATER_CREDIT',
    'MANURE_MANAGER',
  ]),
  fertilizerType = enumify(['NONE', 'STANDARD', 'RAINBOW']),
  genders = enumify(['FEMALE', 'MALE']),
  cowColors = enumify([
    'BLUE',
    'BROWN',
    'GREEN',
    'ORANGE',
    'PURPLE',
    'RAINBOW',
    'WHITE',
    'YELLOW',
  ]),
  { RAINBOW, ...standardCowColors } = cowColors,
  dialogView = enumify([
    'NONE',
    'ACCOUNTING',
    'ACHIEVEMENTS',
    'FARMERS_LOG',
    'KEYBINDINGS',
    'ONLINE_PEERS',
    'PRICE_EVENTS',
    'SETTINGS',
    'STATS',
  ]),
  toolType = enumify(['SCYTHE', 'SHOVEL', 'HOE', 'WATERING_CAN']),
  toolLevel = enumify([
    'UNAVAILABLE',
    'DEFAULT',
    'BRONZE',
    'IRON',
    'SILVER',
    'GOLD',
  ]),
  cowTradeRejectionReason = enumify(['REQUESTED_COW_UNAVAILABLE']),
  cropFamily = { GRAPE: 'GRAPE' },
  grapeVariety = {
    CHARDONNAY: 'CHARDONNAY',
    SAUVIGNON_BLANC: 'SAUVIGNON_BLANC',
    CABERNET_SAUVIGNON: 'CABERNET_SAUVIGNON',
    TEMPRANILLO: 'TEMPRANILLO',
    NEBBIOLO: 'NEBBIOLO',
  },
  { freeze: freeze$9 } = Object,
  MEMOIZE_CACHE_CLEAR_THRESHOLD = 10,
  BREAKPOINTS = { XS: 0, SM: 600, MD: 960, LG: 1280, XL: 1920 },
  STANDARD_LOAN_AMOUNT = 1e4,
  LOAN_GARNISHMENT_RATE = 0.05,
  LOAN_INTEREST_RATE = 0.02,
  FERTILIZER_BONUS = 0.5,
  INITIAL_STORAGE_LIMIT = 200,
  INFINITE_STORAGE_LIMIT = -1,
  STORAGE_EXPANSION_AMOUNT = 100,
  STORAGE_EXPANSION_BASE_PRICE = 500,
  STORAGE_EXPANSION_SCALE_PREMIUM = 50,
  INITIAL_FIELD_WIDTH = 6,
  INITIAL_FIELD_HEIGHT = 10,
  PURCHASEABLE_FIELD_SIZES = freeze$9(
    new Map([
      [1, { columns: 8, rows: 12, price: 1e3 }],
      [2, { columns: 10, rows: 16, price: 5e3 }],
      [3, { columns: 12, rows: 18, price: 2e4 }],
    ])
  ),
  INITIAL_FOREST_WIDTH = 4,
  INITIAL_FOREST_HEIGHT = 1,
  PURCHASABLE_FOREST_SIZES = freeze$9(
    new Map([
      [1, { columns: 4, rows: 2, price: 1e5 }],
      [2, { columns: 4, rows: 3, price: 2e5 }],
      [3, { columns: 4, rows: 4, price: 3e5 }],
    ])
  ),
  LARGEST_PURCHASABLE_FIELD_SIZE = PURCHASEABLE_FIELD_SIZES.get(
    PURCHASEABLE_FIELD_SIZES.size
  ),
  PURCHASEABLE_COMBINES = freeze$9(
    new Map([[1, { type: 'Basic', price: 25e4 }]])
  ),
  PURCHASEABLE_COMPOSTERS = freeze$9(
    new Map([[1, { type: 'Basic', price: 1e3 }]])
  ),
  PURCHASEABLE_SMELTERS = freeze$9(
    new Map([[1, { type: 'Basic', price: 25e4 }]])
  ),
  PURCHASEABLE_COW_PENS = freeze$9(
    new Map([
      [1, { cows: 10, price: 1500 }],
      [2, { cows: 20, price: 1e4 }],
      [3, { cows: 30, price: 5e4 }],
    ])
  ),
  PURCHASEABLE_CELLARS = freeze$9(
    new Map([
      [1, { space: 10, price: 25e4 }],
      [2, { space: 20, price: 75e4 }],
      [3, { space: 30, price: 2e6 }],
    ])
  ),
  CROW_CHANCE = 0.4,
  MAX_CROWS = 5,
  PRECIPITATION_CHANCE = 0.1,
  STORM_CHANCE = 0.5,
  SCARECROW_ITEM_ID = 'scarecrow',
  SPRINKLER_ITEM_ID = 'sprinkler',
  INITIAL_SPRINKLER_RANGE = 1,
  COW_STARTING_WEIGHT_BASE = 1800,
  COW_STARTING_WEIGHT_VARIANCE = 200,
  MAX_ANIMAL_NAME_LENGTH = 30,
  MALE_COW_WEIGHT_MULTIPLIER = 1.1,
  COW_HUG_BENEFIT = 0.05,
  MAX_DAILY_COW_HUG_BENEFITS = 3,
  COW_WEIGHT_MULTIPLIER_FEED_BENEFIT = 0.1,
  COW_WEIGHT_MULTIPLIER_MINIMUM = 0.5,
  COW_WEIGHT_MULTIPLIER_MAXIMUM = 1.5,
  COW_MILK_RATE_SLOWEST = 7,
  COW_MILK_RATE_FASTEST = 2,
  COW_FERTILIZER_PRODUCTION_RATE_SLOWEST = 7,
  COW_FERTILIZER_PRODUCTION_RATE_FASTEST = 1,
  COW_FEED_ITEM_ID = 'cow-feed',
  ADJUSTED_COW_FEED_ITEM_ID = 'adjusted-cow-feed',
  HUGGING_MACHINE_ITEM_ID = 'hugging-machine',
  WATER_CREDIT_ID = 'water-credit',
  MANURE_MANAGER_ID = 'manure-manager',
  COW_MAXIMUM_VALUE_MATURITY_AGE = 100,
  COW_MINIMUM_VALUE_MULTIPLIER = 0,
  COW_MAXIMUM_VALUE_MULTIPLIER = 1,
  COW_GESTATION_PERIOD_DAYS = 3,
  COW_MINIMUM_HAPPINESS_TO_BREED = 0.8,
  NOTIFICATION_DURATION = 6e3,
  NOTIFICATION_LOG_SIZE = 14,
  PRICE_EVENT_CHANCE = 0.2,
  PRICE_EVENT_STANDARD_DURATION_DECREASE = 1,
  STAGE_TITLE_MAP = {
    [stageFocusType.HOME]: 'Home',
    [stageFocusType.FIELD]: 'Field',
    [stageFocusType.FOREST]: 'Forest',
    [stageFocusType.SHOP]: 'Shop',
    [stageFocusType.COW_PEN]: 'Cows',
    [stageFocusType.WORKSHOP]: 'Workshop',
    [stageFocusType.CELLAR]: 'Cellar',
  },
  DAILY_FINANCIAL_HISTORY_RECORD_LENGTH = 7,
  RECIPE_INGREDIENT_VALUE_MULTIPLIER = 1.25,
  I_AM_RICH_BONUSES = [0.05, 0.1, 0.25],
  PERSISTED_STATE_KEYS = [
    'allowCustomPeerCowNames',
    'cellarInventory',
    'completedAchievements',
    'cowBreedingPen',
    'cowColorsPurchased',
    'cowForSale',
    'cowInventory',
    'cowsSold',
    'cowsTraded',
    'cropsHarvested',
    'dayCount',
    'experience',
    'farmName',
    'field',
    'forest',
    'historicalDailyLosses',
    'historicalDailyRevenue',
    'historicalValueAdjustments',
    'hoveredPlotRangeSize',
    'id',
    'inventory',
    'inventoryLimit',
    'isCombineEnabled',
    'itemsSold',
    'cellarItemsSold',
    'learnedRecipes',
    'loanBalance',
    'loansTakenOut',
    'money',
    'newDayNotifications',
    'notificationLog',
    'priceCrashes',
    'priceSurges',
    'profitabilityStreak',
    'purchasedCombine',
    'purchasedComposter',
    'purchasedCowPen',
    'purchasedCellar',
    'purchasedField',
    'purchasedForest',
    'purchasedSmelter',
    'record7dayProfitAverage',
    'recordProfitabilityStreak',
    'recordSingleDayProfit',
    'revenue',
    'showHomeScreen',
    'showNotifications',
    'todaysLosses',
    'todaysPurchases',
    'todaysRevenue',
    'todaysStartingInventory',
    'toolLevels',
    'useAlternateEndDayButtonPosition',
    'valueAdjustments',
    'version',
  ],
  PEER_METADATA_STATE_KEYS = [
    'cowsSold',
    'cropsHarvested',
    'dayCount',
    'experience',
    'id',
    'money',
    'pendingPeerMessages',
    'version',
  ],
  DEFAULT_ROOM = 'global',
  MAX_PENDING_PEER_MESSAGES = 5,
  MAX_LATEST_PEER_MESSAGES = 30,
  LEFT = 'left',
  RIGHT = 'right',
  TOOLBELT_FIELD_MODES = new Set([
    fieldMode.CLEANUP,
    fieldMode.HARVEST,
    fieldMode.WATER,
    fieldMode.MINE,
  ]),
  RESOURCE_SPAWN_CHANCE = 0.3,
  ORE_SPAWN_CHANCE = 0.25,
  COAL_SPAWN_CHANCE = 0.15,
  STONE_SPAWN_CHANCE = 0.4,
  SALT_ROCK_SPAWN_CHANCE = 0.3,
  BRONZE_SPAWN_CHANCE = 0.4,
  GOLD_SPAWN_CHANCE = 0.07,
  IRON_SPAWN_CHANCE = 0.33,
  SILVER_SPAWN_CHANCE = 0.2,
  HOE_LEVEL_TO_SEED_RECLAIM_RATE = {
    [toolLevel.DEFAULT]: 0,
    [toolLevel.BRONZE]: 0.25,
    [toolLevel.IRON]: 0.5,
    [toolLevel.SILVER]: 0.75,
    [toolLevel.GOLD]: 1,
  },
  COW_COLORS_HEX_MAP = {
    [cowColors.BLUE]: '#8ff0f9',
    [cowColors.BROWN]: '#b45f28',
    [cowColors.GREEN]: '#65f295',
    [cowColors.ORANGE]: '#ff7031',
    [cowColors.PURPLE]: '#d884f2',
    [cowColors.WHITE]: '#ffffff',
    [cowColors.YELLOW]: '#fff931',
  },
  COW_TRADE_TIMEOUT = 1e4,
  WEEDS_SPAWN_CHANCE = 0.15,
  KEG_INTEREST_RATE = 0.02,
  KEG_SPOILAGE_RATE_MULTIPLIER = 0.001,
  WINE_INTEREST_RATE = 0.015,
  WINE_GROWTH_TIMELINE_CAP = 100,
  EXPERIENCE_VALUES = {
    CELLAR_ACQUIRED: 10,
    CELLAR_EXPANDED: 5,
    COMPOSTER_ACQUIRED: 10,
    COW_BRED: 1,
    COW_PEN_ACQUIRED: 10,
    COW_PEN_EXPANDED: 5,
    COW_TRADED: 1,
    FERMENTATION_RECIPE_MADE: 1,
    FIELD_EXPANDED: 5,
    FOREST_EXPANDED: 10,
    FORGE_RECIPE_MADE: 3,
    ITEM_SOLD: 1,
    KEG_SOLD: 2,
    KITCHEN_RECIPE_MADE: 2,
    LOAN_PAID_OFF: 25,
    NEW_YEAR: 5,
    RAINBOW_COW_BRED: 2,
    RECYCLING_RECIPE_MADE: 1,
    SMELTER_ACQUIRED: 10,
  },
  STANDARD_VIEW_LIST = [stageFocusType.SHOP],
  Z_INDEX = { END_DAY_BUTTON: 1100 },
  HEARTBEAT_INTERVAL_PERIOD = 10 * 1e3,
  GRAPES_REQUIRED_FOR_WINE = 50,
  YEAST_REQUIREMENT_FOR_WINE_MULTIPLIER = 5
var src = { exports: {} }
function memoize$1(o, a) {
  var s = a && a.cache ? a.cache : cacheDefault,
    $ = a && a.serializer ? a.serializer : serializerDefault,
    j = a && a.strategy ? a.strategy : strategyDefault
  return j(o, { cache: s, serializer: $ })
}
function isPrimitive(o) {
  return o == null || typeof o == 'number' || typeof o == 'boolean'
}
function monadic(o, a, s, $) {
  var j = isPrimitive($) ? $ : s($),
    _e = a.get(j)
  return typeof _e > 'u' && ((_e = o.call(this, $)), a.set(j, _e)), _e
}
function variadic(o, a, s) {
  var $ = Array.prototype.slice.call(arguments, 3),
    j = s($),
    _e = a.get(j)
  return typeof _e > 'u' && ((_e = o.apply(this, $)), a.set(j, _e)), _e
}
function assemble(o, a, s, $, j) {
  return s.bind(a, o, $, j)
}
function strategyDefault(o, a) {
  var s = o.length === 1 ? monadic : variadic
  return assemble(o, this, s, a.cache.create(), a.serializer)
}
function strategyVariadic(o, a) {
  var s = variadic
  return assemble(o, this, s, a.cache.create(), a.serializer)
}
function strategyMonadic(o, a) {
  var s = monadic
  return assemble(o, this, s, a.cache.create(), a.serializer)
}
function serializerDefault() {
  return JSON.stringify(arguments)
}
function ObjectWithoutPrototypeCache() {
  this.cache = Object.create(null)
}
ObjectWithoutPrototypeCache.prototype.has = function(o) {
  return o in this.cache
}
ObjectWithoutPrototypeCache.prototype.get = function(o) {
  return this.cache[o]
}
ObjectWithoutPrototypeCache.prototype.set = function(o, a) {
  this.cache[o] = a
}
var cacheDefault = {
  create: function o() {
    return new ObjectWithoutPrototypeCache()
  },
}
src.exports = memoize$1
src.exports.strategies = {
  variadic: strategyVariadic,
  monadic: strategyMonadic,
}
var srcExports = src.exports
const fastMemoize = getDefaultExportFromCjs(srcExports)
class MemoizeCache {
  constructor({ cacheSize: a = MEMOIZE_CACHE_CLEAR_THRESHOLD } = {}) {
    Wr(this, 'cache', {})
    this.cacheSize = a
  }
  has(a) {
    return a in this.cache
  }
  get(a) {
    return this.cache[a]
  }
  set(a, s) {
    Object.keys(this.cache).length > this.cacheSize && (this.cache = {}),
      (this.cache[a] = s)
  }
}
const memoize = (o, a) =>
    fastMemoize(o, { cache: { create: () => new MemoizeCache(a) }, ...a }),
  getCropLifecycleDuration = memoize(({ cropTimeline: o }) =>
    o.reduce((a, s) => a + s, 0)
  ),
  { freeze: freeze$8 } = Object,
  crop = ({
    cropTimeline: o,
    growsInto: a,
    tier: s = 1,
    isSeed: $ = !!a,
    cropLifecycleDuration: j = getCropLifecycleDuration({ cropTimeline: o }),
    ..._e
  }) =>
    freeze$8({
      cropTimeline: o,
      doesPriceFluctuate: !0,
      tier: s,
      type: itemType.CROP,
      value: 10 + j * s * ($ ? 1 : 3),
      ...($ && {
        enablesFieldMode: fieldMode.PLANT,
        growsInto: a,
        isPlantableCrop: !0,
      }),
      ..._e,
    }),
  fromSeed = (
    { cropTimeline: o, cropType: a, growsInto: s, tier: $ },
    { variantIdx: j = 0, canBeFermented: _e = !1 } = {}
  ) => {
    const et = Array.isArray(s) ? s : [s]
    return {
      cropTimeline: o,
      cropType: a,
      doesPriceFluctuate: !0,
      id: et[j],
      tier: $,
      type: itemType.CROP,
      ...(_e && {
        daysToFerment: getCropLifecycleDuration({ cropTimeline: o }) * $,
      }),
    }
  },
  cropVariety = ({ imageId: o, cropFamily: a, variety: s, ...$ }) => ({
    imageId: o,
    cropFamily: a,
    variety: s,
    ...crop({ ...$ }),
  }),
  asparagusSeed$1 = crop({
    cropType: cropType.ASPARAGUS,
    cropTimeline: [4, 2, 2, 1],
    growsInto: 'asparagus',
    id: 'asparagus-seed',
    name: 'Asparagus Seed',
    tier: 4,
  }),
  asparagus$1 = crop({
    ...fromSeed(asparagusSeed$1, { canBeFermented: !0 }),
    name: 'Asparagus',
  }),
  carrotSeed$1 = crop({
    cropType: cropType.CARROT,
    cropTimeline: [2, 1, 1, 1],
    growsInto: 'carrot',
    id: 'carrot-seed',
    name: 'Carrot Seed',
    tier: 1,
  }),
  carrot$1 = crop({
    ...fromSeed(carrotSeed$1, { canBeFermented: !0 }),
    name: 'Carrot',
  }),
  cornSeed$1 = crop({
    cropType: cropType.CORN,
    cropTimeline: [3, 1, 1, 1, 2, 2],
    growsInto: 'corn',
    id: 'corn-seed',
    name: 'Corn Kernels',
    tier: 2,
  }),
  corn$1 = crop({
    ...fromSeed(cornSeed$1, { canBeFermented: !0 }),
    name: 'Corn',
  }),
  isGrape = o => 'cropFamily' in o && o.cropFamily === cropFamily.GRAPE,
  grape = o => {
    const a = { ...cropVariety({ ...o, cropFamily: cropFamily.GRAPE }) }
    if (!isGrape(a)) throw new Error('Invalid cropVariety props')
    return a
  },
  grapeSeed$1 = crop({
    cropType: cropType.GRAPE,
    cropTimeline: [3, 4],
    growsInto: [
      'grape-chardonnay',
      'grape-sauvignon-blanc',
      'grape-cabernet-sauvignon',
      'grape-tempranillo',
      'grape-nebbiolo',
    ],
    id: 'grape-seed',
    name: 'Grape Seed',
    tier: 7,
  }),
  grapeVarietyNameMap = {
    [grapeVariety.CHARDONNAY]: 'Chardonnay',
    [grapeVariety.SAUVIGNON_BLANC]: 'Sauvignon Blanc',
    [grapeVariety.CABERNET_SAUVIGNON]: 'Cabernet Sauvignon',
    [grapeVariety.TEMPRANILLO]: 'Tempranillo',
    [grapeVariety.NEBBIOLO]: 'Nebbiolo',
  },
  wineVarietyValueMap = {
    [grapeVariety.CHARDONNAY]: 1,
    [grapeVariety.SAUVIGNON_BLANC]: 8,
    [grapeVariety.CABERNET_SAUVIGNON]: 3,
    [grapeVariety.TEMPRANILLO]: 5,
    [grapeVariety.NEBBIOLO]: 10,
  }
var ko
const grapeChardonnay = grape({
  ...fromSeed(grapeSeed$1, {
    variantIdx:
      (ko = grapeSeed$1.growsInto) == null
        ? void 0
        : ko.indexOf('grape-chardonnay'),
  }),
  name: 'Chardonnay Grape',
  imageId: 'grape-green',
  variety: grapeVariety.CHARDONNAY,
  wineId: 'wine-chardonnay',
})
var No
const grapeSauvignonBlanc = grape({
  ...fromSeed(grapeSeed$1, {
    variantIdx:
      (No = grapeSeed$1.growsInto) == null
        ? void 0
        : No.indexOf('grape-sauvignon-blanc'),
  }),
  name: 'Sauvignon Blanc Grape',
  imageId: 'grape-green',
  variety: grapeVariety.SAUVIGNON_BLANC,
  wineId: 'wine-sauvignon-blanc',
})
var Mo
const grapeCabernetSauvignon = grape({
  ...fromSeed(grapeSeed$1, {
    variantIdx:
      (Mo = grapeSeed$1.growsInto) == null
        ? void 0
        : Mo.indexOf('grape-cabernet-sauvignon'),
  }),
  name: 'Cabernet Sauvignon Grape',
  imageId: 'grape-purple',
  variety: grapeVariety.CABERNET_SAUVIGNON,
  wineId: 'wine-cabernet-sauvignon',
})
var Do
const grapeTempranillo = grape({
  ...fromSeed(grapeSeed$1, {
    variantIdx:
      (Do = grapeSeed$1.growsInto) == null
        ? void 0
        : Do.indexOf('grape-tempranillo'),
  }),
  name: 'Tempranillo Grape',
  imageId: 'grape-purple',
  variety: grapeVariety.TEMPRANILLO,
  wineId: 'wine-tempranillo',
})
var Bo
const grapeNebbiolo = grape({
    ...fromSeed(grapeSeed$1, {
      variantIdx:
        (Bo = grapeSeed$1.growsInto) == null
          ? void 0
          : Bo.indexOf('grape-nebbiolo'),
    }),
    name: 'Nebbiolo Grape',
    imageId: 'grape-purple',
    variety: grapeVariety.NEBBIOLO,
    wineId: 'wine-nebbiolo',
  }),
  grapeVarietyToGrapeItemMap = {
    [grapeVariety.CHARDONNAY]: grapeChardonnay,
    [grapeVariety.SAUVIGNON_BLANC]: grapeSauvignonBlanc,
    [grapeVariety.CABERNET_SAUVIGNON]: grapeCabernetSauvignon,
    [grapeVariety.TEMPRANILLO]: grapeTempranillo,
    [grapeVariety.NEBBIOLO]: grapeNebbiolo,
  },
  garlicSeed$1 = crop({
    cropType: cropType.GARLIC,
    cropTimeline: [2, 1, 1, 1],
    growsInto: 'garlic',
    id: 'garlic-seed',
    name: 'Garlic Bulb',
    tier: 5,
  }),
  garlic$1 = crop({
    ...fromSeed(garlicSeed$1, { canBeFermented: !0 }),
    name: 'Garlic',
  }),
  jalapenoSeed$1 = crop({
    cropType: cropType.JALAPENO,
    cropTimeline: [2, 1, 1, 1],
    growsInto: 'jalapeno',
    id: 'jalapeno-seed',
    name: 'Jalapeo Seed',
    tier: 4,
  }),
  jalapeno$1 = crop({
    ...fromSeed(jalapenoSeed$1, { canBeFermented: !0 }),
    name: 'Jalapeo',
  }),
  oliveSeed$1 = crop({
    cropType: cropType.OLIVE,
    cropTimeline: [3, 6],
    growsInto: 'olive',
    id: 'olive-seed',
    name: 'Olive Seed',
    tier: 6,
  }),
  olive$1 = crop({
    ...fromSeed(oliveSeed$1, { canBeFermented: !0 }),
    name: 'Olive',
  }),
  onionSeed$1 = crop({
    cropType: cropType.ONION,
    cropTimeline: [3, 1, 2, 1],
    growsInto: 'onion',
    id: 'onion-seed',
    name: 'Onion Seeds',
    tier: 2,
  }),
  onion$1 = crop({
    ...fromSeed(onionSeed$1, { canBeFermented: !0 }),
    name: 'Onion',
  }),
  peaSeed$1 = crop({
    cropType: cropType.PEA,
    cropTimeline: [2, 3],
    growsInto: 'pea',
    id: 'pea-seed',
    name: 'Pea Seed',
    tier: 5,
  }),
  pea$1 = crop({ ...fromSeed(peaSeed$1, { canBeFermented: !0 }), name: 'Pea' }),
  potatoSeed$1 = crop({
    cropType: cropType.POTATO,
    cropTimeline: [2, 1, 1, 1],
    growsInto: 'potato',
    id: 'potato-seed',
    name: 'Potato Seeds',
    tier: 2,
  }),
  potato$1 = crop({
    ...fromSeed(potatoSeed$1, { canBeFermented: !0 }),
    name: 'Potato',
  }),
  pumpkinSeed$1 = crop({
    cropType: cropType.PUMPKIN,
    cropTimeline: [3, 1, 1, 1, 1, 1],
    growsInto: 'pumpkin',
    id: 'pumpkin-seed',
    name: 'Pumpkin Seed',
    tier: 1,
  }),
  pumpkin$1 = crop({
    ...fromSeed(pumpkinSeed$1, { canBeFermented: !0 }),
    name: 'Pumpkin',
  }),
  soybeanSeed$1 = crop({
    cropType: cropType.SOYBEAN,
    cropTimeline: [2, 2],
    growsInto: 'soybean',
    id: 'soybean-seed',
    name: 'Soybean Seeds',
    tier: 3,
  }),
  soybean$1 = crop({
    ...fromSeed(soybeanSeed$1, { canBeFermented: !0 }),
    name: 'Soybean',
  }),
  spinachSeed$1 = crop({
    cropType: cropType.SPINACH,
    cropTimeline: [2, 4],
    growsInto: 'spinach',
    id: 'spinach-seed',
    name: 'Spinach Seed',
    tier: 1,
  }),
  spinach$1 = crop({
    ...fromSeed(spinachSeed$1, { canBeFermented: !0 }),
    name: 'Spinach',
  }),
  sunflowerSeed$1 = crop({
    cropType: cropType.SUNFLOWER,
    cropTimeline: [1, 1, 1, 1, 1, 1],
    growsInto: 'sunflower',
    id: 'sunflower-seed',
    name: 'Sunflower Seed',
    tier: 6,
  }),
  sunflower$1 = crop({
    ...fromSeed(sunflowerSeed$1, { canBeFermented: !0 }),
    name: 'Sunflower',
  }),
  strawberrySeed$1 = crop({
    cropType: cropType.STRAWBERRY,
    cropTimeline: [6, 2],
    growsInto: 'strawberry',
    id: 'strawberry-seed',
    name: 'Strawberry Seed',
    tier: 5,
  }),
  strawberry$1 = crop({ ...fromSeed(strawberrySeed$1), name: 'Strawberry' }),
  sweetPotatoSeed$1 = crop({
    cropType: cropType.SWEET_POTATO,
    cropTimeline: [2, 1, 1, 2, 2],
    growsInto: 'sweet-potato',
    id: 'sweet-potato-seed',
    name: 'Sweet Potato Slip',
    tier: 6,
  }),
  sweetPotato$1 = crop({
    ...fromSeed(sweetPotatoSeed$1, { canBeFermented: !0 }),
    name: 'Sweet Potato',
  }),
  tomatoSeed$1 = crop({
    cropType: cropType.TOMATO,
    cropTimeline: [2, 1, 1, 1, 2, 2, 2],
    growsInto: 'tomato',
    id: 'tomato-seed',
    name: 'Tomato Seeds',
    tier: 3,
  }),
  tomato$1 = crop({
    ...fromSeed(tomatoSeed$1, { canBeFermented: !0 }),
    name: 'Tomato',
  }),
  watermelonSeed$1 = crop({
    cropType: cropType.WATERMELON,
    cropTimeline: [2, 10],
    growsInto: 'watermelon',
    id: 'watermelon-seed',
    name: 'Watermelon Seed',
    tier: 4,
  }),
  watermelon$1 = crop({ ...fromSeed(watermelonSeed$1), name: 'Watermelon' }),
  wheatSeed$1 = crop({
    cropType: cropType.WHEAT,
    cropTimeline: [1, 1],
    growsInto: 'wheat',
    id: 'wheat-seed',
    name: 'Wheat Seeds',
    tier: 3,
  }),
  wheat$1 = crop({ ...fromSeed(wheatSeed$1), name: 'Wheat' }),
  { freeze: freeze$7 } = Object,
  bronzeOre$1 = freeze$7({
    description: 'A piece of bronze ore.',
    doesPriceFluctuate: !0,
    id: 'bronze-ore',
    name: 'Bronze Ore',
    type: itemType.ORE,
    value: 25,
    spawnChance: BRONZE_SPAWN_CHANCE,
  }),
  { freeze: freeze$6 } = Object,
  coal$2 = freeze$6({
    description: 'A piece of coal.',
    doesPriceFluctuate: !1,
    id: 'coal',
    name: 'Coal',
    type: itemType.FUEL,
    spawnChance: COAL_SPAWN_CHANCE,
    value: 2,
  }),
  { freeze: freeze$5 } = Object,
  goldOre$1 = freeze$5({
    description: 'A piece of gold ore.',
    doesPriceFluctuate: !0,
    id: 'gold-ore',
    name: 'Gold Ore',
    type: itemType.ORE,
    value: 500,
    spawnChance: GOLD_SPAWN_CHANCE,
  }),
  { freeze: freeze$4 } = Object,
  ironOre$1 = freeze$4({
    description: 'A piece of iron ore.',
    doesPriceFluctuate: !0,
    id: 'iron-ore',
    name: 'Iron Ore',
    type: itemType.ORE,
    value: 40,
    spawnChance: IRON_SPAWN_CHANCE,
  }),
  { freeze: freeze$3 } = Object,
  silverOre$1 = freeze$3({
    description: 'A piece of silver ore.',
    doesPriceFluctuate: !0,
    id: 'silver-ore',
    name: 'Silver Ore',
    type: itemType.ORE,
    value: 100,
    spawnChance: SILVER_SPAWN_CHANCE,
  }),
  { freeze: freeze$2 } = Object,
  stone$1 = freeze$2({
    description: 'A piece of rock.',
    doesPriceFluctuate: !1,
    id: 'stone',
    name: 'Stone',
    spawnChance: STONE_SPAWN_CHANCE,
    type: itemType.STONE,
    value: 10,
  }),
  { freeze: freeze$1 } = Object,
  saltRock$1 = freeze$1({
    description: 'A large chunk of salt.',
    doesPriceFluctuate: !0,
    id: 'salt-rock',
    name: 'Salt Rock',
    spawnChance: SALT_ROCK_SPAWN_CHANCE,
    type: itemType.STONE,
    value: 10,
  }),
  { freeze } = Object,
  {
    COW_FEED,
    ADJUSTED_COW_FEED,
    FERTILIZER,
    HUGGING_MACHINE,
    MILK,
    SCARECROW,
    SPRINKLER,
    WEED: WEED$1,
    WATER_CREDIT,
    MANURE_MANAGER,
  } = itemType,
  weed = freeze({
    id: 'weed',
    name: 'Weed',
    value: 0.1,
    doesPriceFluctuate: !1,
    type: WEED$1,
  }),
  rainbowFertilizer$1 = freeze({
    description:
      'Helps crops grow a little faster and automatically replants them upon harvesting. Consumes seeds upon replanting and disappears if none are available. Also works for Scarecrows.',
    enablesFieldMode: fieldMode.FERTILIZE,
    id: 'rainbow-fertilizer',
    name: 'Rainbow Fertilizer',
    type: FERTILIZER,
    value: 15,
  }),
  sprinkler$1 = freeze({
    description: 'Automatically waters adjacent plants every day.',
    enablesFieldMode: fieldMode.SET_SPRINKLER,
    hoveredPlotRangeSize: INITIAL_SPRINKLER_RANGE,
    id: 'sprinkler',
    isReplantable: !0,
    name: 'Sprinkler',
    type: SPRINKLER,
    value: 120,
  }),
  scarecrow$1 = freeze({
    description:
      'Prevents crows from eating your crops. One scarecrow covers an entire field, but they are afraid of storms.',
    enablesFieldMode: fieldMode.SET_SCARECROW,
    hoveredPlotRangeSize: Number.MAX_SAFE_INTEGER,
    id: 'scarecrow',
    isReplantable: !0,
    name: 'Scarecrow',
    type: SCARECROW,
    value: 160,
  }),
  watercredit$1 = freeze({
    id: WATER_CREDIT_ID,
    description:
      'Credit for waste water, each cow consume one unit of water credit per day (if you adopt sustainable farming practice, it will consume less!)',
    enablesFieldMode: fieldMode.USE_WATER_CREDIT,
    name: 'Water Credit',
    type: WATER_CREDIT,
    value: 10,
  }),
  manureManager$1 = freeze({
    id: MANURE_MANAGER_ID,
    description:
      'A machine that sustainably processes manure waste. Purchasing a Manure Manager earns you one unit of water credit per cow every day!',
    enablesFieldMode: fieldMode.BUY_MANURE_MANAGER,
    name: 'Manure Manager',
    type: MANURE_MANAGER,
    value: 1e3,
  }),
  cowFeed$1 = freeze({
    id: COW_FEED_ITEM_ID,
    description:
      'Each cow automatically consumes one unit of Cow Feed per day. Fed cows gain and maintain weight.',
    name: 'Cow Feed',
    type: COW_FEED,
    value: 5,
  }),
  adjustedcowFeed$1 = freeze({
    id: ADJUSTED_COW_FEED_ITEM_ID,
    description:
      'Adjusted cow feed that allow cows to produce less nitrogen. Each cow automatically consumes one unit of Adjusted Cow Feed per day. Using one unit of adjusted cow feed can earn you one unit of water credit. Fed cows gain and maintain weight.',
    name: 'Adjusted Cow Feed',
    type: ADJUSTED_COW_FEED,
    value: 7,
  }),
  huggingMachine$1 = freeze({
    id: HUGGING_MACHINE_ITEM_ID,
    description: 'Automatically hugs one cow three times every day.',
    name: 'Hugging Machine',
    type: HUGGING_MACHINE,
    value: 500,
  }),
  milk1$1 = freeze({
    id: 'milk-1',
    name: 'Grade C Milk',
    type: MILK,
    value: 40,
  }),
  milk2$1 = freeze({
    id: 'milk-2',
    name: 'Grade B Milk',
    type: MILK,
    value: 80,
  }),
  milk3$1 = freeze({
    id: 'milk-3',
    name: 'Grade A Milk',
    type: MILK,
    value: 120,
  }),
  rainbowMilk1$1 = freeze({
    id: 'rainbow-milk-1',
    name: 'Grade C Rainbow Milk',
    type: MILK,
    value: 60,
  }),
  rainbowMilk2$1 = freeze({
    id: 'rainbow-milk-2',
    name: 'Grade B Rainbow Milk',
    type: MILK,
    value: 120,
  }),
  rainbowMilk3$1 = freeze({
    id: 'rainbow-milk-3',
    name: 'Grade A Rainbow Milk',
    type: MILK,
    value: 180,
  }),
  chocolateMilk$1 = freeze({
    id: 'chocolate-milk',
    name: 'Chocolate Milk',
    type: MILK,
    value: 80,
  }),
  items$1 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        adjustedcowFeed: adjustedcowFeed$1,
        asparagus: asparagus$1,
        asparagusSeed: asparagusSeed$1,
        bronzeOre: bronzeOre$1,
        carrot: carrot$1,
        carrotSeed: carrotSeed$1,
        chocolateMilk: chocolateMilk$1,
        coal: coal$2,
        corn: corn$1,
        cornSeed: cornSeed$1,
        cowFeed: cowFeed$1,
        garlic: garlic$1,
        garlicSeed: garlicSeed$1,
        goldOre: goldOre$1,
        grapeCabernetSauvignon,
        grapeChardonnay,
        grapeNebbiolo,
        grapeSauvignonBlanc,
        grapeSeed: grapeSeed$1,
        grapeTempranillo,
        huggingMachine: huggingMachine$1,
        ironOre: ironOre$1,
        jalapeno: jalapeno$1,
        jalapenoSeed: jalapenoSeed$1,
        manureManager: manureManager$1,
        milk1: milk1$1,
        milk2: milk2$1,
        milk3: milk3$1,
        olive: olive$1,
        oliveSeed: oliveSeed$1,
        onion: onion$1,
        onionSeed: onionSeed$1,
        pea: pea$1,
        peaSeed: peaSeed$1,
        potato: potato$1,
        potatoSeed: potatoSeed$1,
        pumpkin: pumpkin$1,
        pumpkinSeed: pumpkinSeed$1,
        rainbowFertilizer: rainbowFertilizer$1,
        rainbowMilk1: rainbowMilk1$1,
        rainbowMilk2: rainbowMilk2$1,
        rainbowMilk3: rainbowMilk3$1,
        saltRock: saltRock$1,
        scarecrow: scarecrow$1,
        silverOre: silverOre$1,
        soybean: soybean$1,
        soybeanSeed: soybeanSeed$1,
        spinach: spinach$1,
        spinachSeed: spinachSeed$1,
        sprinkler: sprinkler$1,
        stone: stone$1,
        strawberry: strawberry$1,
        strawberrySeed: strawberrySeed$1,
        sunflower: sunflower$1,
        sunflowerSeed: sunflowerSeed$1,
        sweetPotato: sweetPotato$1,
        sweetPotatoSeed: sweetPotatoSeed$1,
        tomato: tomato$1,
        tomatoSeed: tomatoSeed$1,
        watercredit: watercredit$1,
        watermelon: watermelon$1,
        watermelonSeed: watermelonSeed$1,
        weed,
        wheat: wheat$1,
        wheatSeed: wheatSeed$1,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  inventory$1 = [
    adjustedcowFeed$1,
    cowFeed$1,
    huggingMachine$1,
    watercredit$1,
    manureManager$1,
  ],
  getYeastRequiredForWine = o =>
    wineVarietyValueMap[o] * YEAST_REQUIREMENT_FOR_WINE_MULTIPLIER,
  baseItemsMap = {
    ...Object.keys(items$1).reduce((o, a) => {
      const s = items$1[a]
      return (o[s.id] = s), o
    }, {}),
  },
  itemsMap$1 = { ...baseItemsMap },
  itemify = o => {
    const a = Object.freeze({
      type: itemType.CRAFTED_ITEM,
      value: Object.keys(o.ingredients).reduce(
        (s, $) =>
          s +
          RECIPE_INGREDIENT_VALUE_MULTIPLIER *
            itemsMap$1[$].value *
            o.ingredients[$],
        0
      ),
      ...o,
    })
    return (itemsMap$1[o.id] = a), a
  },
  salt$1 = itemify({
    id: 'salt',
    name: 'Salt',
    ingredients: { [saltRock$1.id]: 1 },
    condition: o => o.itemsSold[saltRock$1.id] >= 30,
    description: 'Useful for seasoning food and fermentation.',
    recipeType: recipeType.KITCHEN,
  }),
  flour$1 = itemify({
    id: 'flour',
    name: 'Flour',
    ingredients: { [wheat$1.id]: 10 },
    condition: o => o.itemsSold[wheat$1.id] >= 20,
    recipeType: recipeType.KITCHEN,
  }),
  yeast$1 = itemify({
    id: 'yeast',
    name: 'Yeast',
    ingredients: { [flour$1.id]: 5 },
    condition: o => o.itemsSold[flour$1.id] >= 25,
    recipeType: recipeType.KITCHEN,
  }),
  getWineRecipeFromGrape = o => ({
    ...itemify({
      id: o.wineId,
      name: `${grapeVarietyNameMap[o.variety]} Wine`,
      type: itemType.CRAFTED_ITEM,
      ingredients: {
        [o.id]: GRAPES_REQUIRED_FOR_WINE,
        [yeast$1.id]: getYeastRequiredForWine(o.variety),
      },
      recipeType: recipeType.WINE,
      condition: () => !1,
    }),
    variety: o.variety,
  }),
  bread$1 = itemify({
    id: 'bread',
    name: 'Bread',
    ingredients: { [flour$1.id]: 10, [yeast$1.id]: 5 },
    condition: o =>
      o.itemsSold[flour$1.id] >= 30 && o.itemsSold[yeast$1.id] >= 15,
    recipeType: recipeType.KITCHEN,
  }),
  butter$1 = itemify({
    id: 'butter',
    name: 'Butter',
    ingredients: { [milk3$1.id]: 5 },
    condition: o => o.itemsSold[milk3$1.id] >= 30,
    recipeType: recipeType.KITCHEN,
  }),
  sunButter$1 = itemify({
    id: 'sun-butter',
    name: 'Sun Butter',
    ingredients: { [sunflower$1.id]: 25 },
    condition: o => o.itemsSold[sunflower$1.id] >= 200,
    recipeType: recipeType.KITCHEN,
  }),
  oliveOil$1 = itemify({
    id: 'olive-oil',
    name: 'Olive Oil',
    ingredients: { [olive$1.id]: 250 },
    condition: o => o.itemsSold[olive$1.id] >= 500,
    recipeType: recipeType.KITCHEN,
  }),
  cheese$1 = itemify({
    id: 'cheese',
    name: 'Cheese',
    ingredients: { [milk3$1.id]: 8 },
    condition: o => (o.itemsSold[milk3$1.id] || 0) >= 20,
    recipeType: recipeType.KITCHEN,
  }),
  rainbowCheese$1 = itemify({
    id: 'rainbowCheese',
    name: 'Rainbow Cheese',
    ingredients: { [rainbowMilk3$1.id]: 10 },
    condition: o => (o.itemsSold[rainbowMilk3$1.id] || 0) >= 30,
    recipeType: recipeType.KITCHEN,
  }),
  chocolate$1 = itemify({
    id: 'chocolate',
    name: 'Chocolate',
    ingredients: { [chocolateMilk$1.id]: 10 },
    condition: o => (o.itemsSold[chocolateMilk$1.id] || 0) >= 25,
    recipeType: recipeType.KITCHEN,
  }),
  carrotSoup$1 = itemify({
    id: 'carrot-soup',
    name: 'Carrot Soup',
    ingredients: { [carrot$1.id]: 4 },
    condition: o => (o.itemsSold[carrot$1.id] || 0) >= 10,
    recipeType: recipeType.KITCHEN,
  }),
  jackolantern$1 = itemify({
    id: 'jackolantern',
    name: "Jack-o'-lantern",
    ingredients: { [pumpkin$1.id]: 1 },
    condition: o => (o.itemsSold[pumpkin$1.id] || 0) >= 50,
    recipeType: recipeType.KITCHEN,
  }),
  spaghetti$1 = itemify({
    id: 'spaghetti',
    name: 'Spaghetti',
    ingredients: { [wheat$1.id]: 10, [tomato$1.id]: 2 },
    condition: o =>
      o.itemsSold[wheat$1.id] >= 20 && o.itemsSold[tomato$1.id] >= 5,
    recipeType: recipeType.KITCHEN,
  }),
  frenchOnionSoup$1 = itemify({
    id: 'french-onion-soup',
    name: 'French Onion Soup',
    ingredients: { [onion$1.id]: 5, [cheese$1.id]: 2, [salt$1.id]: 2 },
    condition: o =>
      o.itemsSold[onion$1.id] >= 15 && o.itemsSold[cheese$1.id] >= 10,
    recipeType: recipeType.KITCHEN,
  }),
  burger$1 = itemify({
    id: 'burger',
    name: 'Burger',
    ingredients: {
      [bread$1.id]: 1,
      [cheese$1.id]: 1,
      [onion$1.id]: 1,
      [soybean$1.id]: 12,
      [spinach$1.id]: 1,
      [tomato$1.id]: 1,
    },
    condition: o =>
      o.itemsSold[bread$1.id] >= 5 &&
      o.itemsSold[cheese$1.id] >= 5 &&
      o.itemsSold[onion$1.id] >= 5 &&
      o.itemsSold[soybean$1.id] >= 25 &&
      o.itemsSold[spinach$1.id] >= 5 &&
      o.itemsSold[tomato$1.id] >= 5,
    recipeType: recipeType.KITCHEN,
  }),
  summerSalad$1 = itemify({
    id: 'summer-salad',
    name: 'Summer Salad',
    ingredients: { [spinach$1.id]: 6, [corn$1.id]: 1, [carrot$1.id]: 1 },
    condition: o =>
      o.itemsSold[spinach$1.id] >= 30 &&
      o.itemsSold[corn$1.id] > 5 &&
      o.itemsSold[carrot$1.id] > 5,
    recipeType: recipeType.KITCHEN,
  }),
  soyMilk$1 = itemify({
    id: 'soy-milk',
    name: 'Soy Milk',
    ingredients: { [soybean$1.id]: 20 },
    condition: o => o.itemsSold[soybean$1.id] >= 100,
    recipeType: recipeType.KITCHEN,
  }),
  chocolateSoyMilk$1 = itemify({
    id: 'chocolate-soy-milk',
    name: 'Chocolate Soy Milk',
    ingredients: { [soyMilk$1.id]: 1, [chocolate$1.id]: 1 },
    condition: o =>
      o.itemsSold[soyMilk$1.id] >= 5 && o.itemsSold[chocolate$1.id] >= 5,
    recipeType: recipeType.KITCHEN,
  }),
  tofu$1 = itemify({
    id: 'tofu',
    name: 'Tofu',
    ingredients: { [soyMilk$1.id]: 4 },
    condition: o => o.itemsSold[soyMilk$1.id] >= 20,
    recipeType: recipeType.KITCHEN,
  }),
  chicknPotPie$1 = itemify({
    id: 'chickn-pot-pie',
    name: "Chick'n Pot Pie",
    ingredients: {
      [tofu$1.id]: 6,
      [pea$1.id]: 10,
      [carrot$1.id]: 8,
      [wheat$1.id]: 12,
      [soyMilk$1.id]: 3,
    },
    condition: o =>
      o.itemsSold[tofu$1.id] >= 30 &&
      o.itemsSold[pea$1.id] >= 225 &&
      o.itemsSold[carrot$1.id] >= 300 &&
      o.itemsSold[wheat$1.id] >= 425 &&
      o.itemsSold[soyMilk$1.id] >= 15,
    recipeType: recipeType.KITCHEN,
  }),
  hotSauce$1 = itemify({
    id: 'hot-sauce',
    name: 'Hot Sauce',
    ingredients: { [jalapeno$1.id]: 10, [salt$1.id]: 1 },
    condition: o => o.itemsSold[jalapeno$1.id] >= 50,
    recipeType: recipeType.KITCHEN,
  }),
  salsa$1 = itemify({
    id: 'salsa',
    name: 'Salsa',
    ingredients: {
      [jalapeno$1.id]: 1,
      [onion$1.id]: 1,
      [tomato$1.id]: 1,
      [corn$1.id]: 1,
    },
    condition: o =>
      o.itemsSold[jalapeno$1.id] >= 5 &&
      o.itemsSold[onion$1.id] >= 5 &&
      o.itemsSold[tomato$1.id] >= 5 &&
      o.itemsSold[corn$1.id] >= 5,
    recipeType: recipeType.KITCHEN,
  }),
  spicyCheese$1 = itemify({
    id: 'spicy-cheese',
    name: 'Spicy Cheese',
    ingredients: { [jalapeno$1.id]: 4, [milk3$1.id]: 10 },
    condition: o =>
      o.itemsSold[jalapeno$1.id] >= 20 && o.itemsSold[milk3$1.id] >= 50,
    recipeType: recipeType.KITCHEN,
  }),
  vegetableOil$1 = itemify({
    id: 'vegetable-oil',
    name: 'Vegetable Oil',
    ingredients: { [soybean$1.id]: 350 },
    condition: o => o.itemsSold[soybean$1.id] >= 900,
    recipeType: recipeType.KITCHEN,
  }),
  friedTofu$1 = itemify({
    id: 'fried-tofu',
    name: 'Deep Fried Tofu',
    ingredients: { [tofu$1.id]: 1, [vegetableOil$1.id]: 2 },
    condition: o =>
      o.itemsSold[tofu$1.id] >= 50 && o.itemsSold[vegetableOil$1.id] >= 50,
    recipeType: recipeType.KITCHEN,
  }),
  spicyPickledGarlic$1 = itemify({
    id: 'spicy-pickled-garlic',
    name: 'Spicy Pickled Garlic',
    ingredients: { [jalapeno$1.id]: 2, [garlic$1.id]: 5 },
    condition: o =>
      o.itemsSold[jalapeno$1.id] >= 12 && o.itemsSold[garlic$1.id] >= 25,
    recipeType: recipeType.KITCHEN,
  }),
  garlicFries$1 = itemify({
    id: 'garlic-fries',
    name: 'Garlic Fries',
    ingredients: {
      [potato$1.id]: 5,
      [garlic$1.id]: 3,
      [vegetableOil$1.id]: 1,
      [salt$1.id]: 2,
    },
    condition: o =>
      o.itemsSold[potato$1.id] >= 50 && o.itemsSold[garlic$1.id] >= 30,
    recipeType: recipeType.KITCHEN,
  }),
  garlicBread$1 = itemify({
    id: 'garlic-bread',
    name: 'Garlic Bread',
    ingredients: { [bread$1.id]: 1, [garlic$1.id]: 5, [oliveOil$1.id]: 1 },
    condition: o =>
      o.itemsSold[bread$1.id] >= 30 &&
      o.itemsSold[oliveOil$1.id] >= 20 &&
      o.itemsSold[garlic$1.id] >= 50,
    recipeType: recipeType.KITCHEN,
  }),
  strawberryJam$1 = itemify({
    id: 'strawberry-jam',
    name: 'Strawberry Jam',
    ingredients: { [strawberry$1.id]: 10 },
    condition: o => o.itemsSold[strawberry$1.id] >= 60,
    recipeType: recipeType.KITCHEN,
  }),
  popcorn$1 = itemify({
    id: 'popcorn',
    name: 'Popcorn',
    ingredients: { [corn$1.id]: 2, [butter$1.id]: 1 },
    condition: o =>
      o.itemsSold[corn$1.id] >= 12 && o.itemsSold[butter$1.id] >= 6,
    recipeType: recipeType.KITCHEN,
  }),
  pumpkinPie$1 = itemify({
    id: 'pumpkin-pie',
    name: 'Pumpkin Pie',
    ingredients: { [pumpkin$1.id]: 4, [wheat$1.id]: 10, [butter$1.id]: 2 },
    condition: o =>
      o.itemsSold[pumpkin$1.id] >= 200 &&
      o.itemsSold[wheat$1.id] >= 250 &&
      o.itemsSold[butter$1.id] >= 75,
    recipeType: recipeType.KITCHEN,
  }),
  sweetPotatoPie$1 = itemify({
    id: 'sweet-potato-pie',
    name: 'Sweet Potato Pie',
    ingredients: { [sweetPotato$1.id]: 6, [wheat$1.id]: 10, [butter$1.id]: 2 },
    condition: o =>
      o.itemsSold[sweetPotato$1.id] >= 200 &&
      o.itemsSold[wheat$1.id] >= 250 &&
      o.itemsSold[butter$1.id] >= 75,
    recipeType: recipeType.KITCHEN,
  }),
  sweetPotatoFries$1 = itemify({
    id: 'sweet-potato-fries',
    name: 'Sweet Potato Fries',
    ingredients: {
      [sweetPotato$1.id]: 10,
      [vegetableOil$1.id]: 1,
      [salt$1.id]: 1,
    },
    condition: o => o.itemsSold[sweetPotato$1.id] >= 100,
    recipeType: recipeType.KITCHEN,
  }),
  onionRings$1 = itemify({
    id: 'onion-rings',
    name: 'Onion Rings',
    ingredients: {
      [onion$1.id]: 1,
      [vegetableOil$1.id]: 1,
      [wheat$1.id]: 5,
      [soyMilk$1.id]: 1,
      [salt$1.id]: 3,
    },
    condition: o =>
      o.itemsSold[onion$1.id] >= 50 &&
      o.itemsSold[vegetableOil$1.id] > 20 &&
      o.itemsSold[soyMilk$1.id] > 20 &&
      o.itemsSold[wheat$1.id] > 30,
    recipeType: recipeType.KITCHEN,
  }),
  bronzeIngot$2 = itemify({
    id: 'bronze-ingot',
    name: 'Bronze Ingot',
    ingredients: { [bronzeOre$1.id]: 5, [coal$2.id]: 5 },
    condition: o => o.purchasedSmelter > 0 && o.itemsSold[bronzeOre$1.id] >= 50,
    recipeType: recipeType.FORGE,
  }),
  ironIngot$2 = itemify({
    id: 'iron-ingot',
    name: 'Iron Ingot',
    ingredients: { [ironOre$1.id]: 5, [coal$2.id]: 12 },
    condition: o => o.purchasedSmelter > 0 && o.itemsSold[ironOre$1.id] >= 50,
    recipeType: recipeType.FORGE,
  }),
  silverIngot$2 = itemify({
    id: 'silver-ingot',
    name: 'Silver Ingot',
    ingredients: { [silverOre$1.id]: 5, [coal$2.id]: 8 },
    condition: o => o.purchasedSmelter > 0 && o.itemsSold[silverOre$1.id] >= 50,
    recipeType: recipeType.FORGE,
  }),
  goldIngot$2 = itemify({
    id: 'gold-ingot',
    name: 'Gold Ingot',
    ingredients: { [goldOre$1.id]: 5, [coal$2.id]: 10 },
    condition: o => o.purchasedSmelter > 0 && o.itemsSold[goldOre$1.id] >= 50,
    recipeType: recipeType.FORGE,
  }),
  compost$1 = itemify({
    id: 'compost',
    name: 'Compost',
    ingredients: { [weed.id]: 25 },
    condition: o => o.purchasedComposter > 0 && o.itemsSold[weed.id] >= 100,
    description: 'Can be used to make fertilizer.',
    recipeType: recipeType.RECYCLING,
    type: itemType.CRAFTED_ITEM,
  }),
  fertilizer$1 = itemify({
    id: 'fertilizer',
    name: 'Fertilizer',
    ingredients: { [compost$1.id]: 10 },
    condition: o => o.purchasedComposter > 0 && o.itemsSold[compost$1.id] >= 10,
    description: 'Helps crops grow and mature a little faster.',
    enablesFieldMode: fieldMode.FERTILIZE,
    recipeType: recipeType.RECYCLING,
    type: itemType.FERTILIZER,
    value: 25,
  }),
  wineChardonnay = getWineRecipeFromGrape({ ...grapeChardonnay }),
  wineSauvignonBlanc = getWineRecipeFromGrape({ ...grapeSauvignonBlanc }),
  wineCabernetSauvignon = getWineRecipeFromGrape({ ...grapeCabernetSauvignon }),
  wineTempranillo = getWineRecipeFromGrape({ ...grapeTempranillo }),
  wineNebbiolo = getWineRecipeFromGrape({ ...grapeNebbiolo }),
  recipes = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        bread: bread$1,
        bronzeIngot: bronzeIngot$2,
        burger: burger$1,
        butter: butter$1,
        carrotSoup: carrotSoup$1,
        cheese: cheese$1,
        chicknPotPie: chicknPotPie$1,
        chocolate: chocolate$1,
        chocolateSoyMilk: chocolateSoyMilk$1,
        compost: compost$1,
        fertilizer: fertilizer$1,
        flour: flour$1,
        frenchOnionSoup: frenchOnionSoup$1,
        friedTofu: friedTofu$1,
        garlicBread: garlicBread$1,
        garlicFries: garlicFries$1,
        goldIngot: goldIngot$2,
        hotSauce: hotSauce$1,
        ironIngot: ironIngot$2,
        jackolantern: jackolantern$1,
        oliveOil: oliveOil$1,
        onionRings: onionRings$1,
        popcorn: popcorn$1,
        pumpkinPie: pumpkinPie$1,
        rainbowCheese: rainbowCheese$1,
        salsa: salsa$1,
        salt: salt$1,
        silverIngot: silverIngot$2,
        soyMilk: soyMilk$1,
        spaghetti: spaghetti$1,
        spicyCheese: spicyCheese$1,
        spicyPickledGarlic: spicyPickledGarlic$1,
        strawberryJam: strawberryJam$1,
        summerSalad: summerSalad$1,
        sunButter: sunButter$1,
        sweetPotatoFries: sweetPotatoFries$1,
        sweetPotatoPie: sweetPotatoPie$1,
        tofu: tofu$1,
        vegetableOil: vegetableOil$1,
        wineCabernetSauvignon,
        wineChardonnay,
        wineNebbiolo,
        wineSauvignonBlanc,
        wineTempranillo,
        yeast: yeast$1,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  inventory = [watercredit$1, manureManager$1],
  itemIds$1 = new Set(inventory.map(o => o.id)),
  fruitNames = [
    'Akee',
    'Apple',
    'Apricot',
    'Avocado',
    'Aa',
    'Banana',
    'Bilberry',
    'Blackberry',
    'Blackcurrant',
    'Blueberry',
    'Boysenberry',
    'Cantaloupe',
    'Cherimoya',
    'Cherry',
    'Chico',
    'Clementine',
    'Cloudberry',
    'Coconut',
    'Crabapple',
    'Cranberry',
    'Cucumber',
    'Currant',
    'Damson',
    'Durian',
    'Elderberry',
    'Feijoa',
    'Fig',
    'Goji',
    'Gooseberry',
    'Grape',
    'Grapefruit',
    'Guava',
    'Honeyberry',
    'Honeydew',
    'Huckleberry',
    'Jabuticaba',
    'Jackfruit',
    'Jambul',
    'Jostaberry',
    'Jujube',
    'Juniper',
    'Kiwano',
    'Kiwi',
    'Kumquat',
    'Lemon',
    'Lime',
    'Longan',
    'Loquat',
    'Lychee',
    'Mandarine',
    'Mango',
    'Mangosteen',
    'Marion',
    'Melon',
    'Mulberry',
    'Nance',
    'Nectarine',
    'Olive',
    'Orange',
    'Papaya',
    'Peach',
    'Pear',
    'Persimmon',
    'Pineapple',
    'Pineberry',
    'Pitaya',
    'Plantain',
    'Plum',
    'Plumcot',
    'Pomegranate',
    'Pomelo',
    'Prune',
    'Pumpkin',
    'Quince',
    'Raisin',
    'Rambutan',
    'Raspberry',
    'Salak',
    'Salal',
    'Salmonberry',
    'Sapote',
    'Satsuma',
    'Soursop',
    'Strawberry',
    'Surinam',
    'Tamarillo',
    'Tamarind',
    'Tangerine',
    'Tomato',
    'Watermelon',
    'Yuzu',
    'Zucchini',
  ],
  coalNeededForIngots = (o, a = 1) => {
    switch (o) {
      case bronzeIngot$2.id:
        return a * 2
      case ironIngot$2.id:
        return Math.round(a * 3.5)
      case silverIngot$2.id:
        return Math.round(a * 2.5)
      case goldIngot$2.id:
        return a * 3
      default:
        return a
    }
  },
  {
    bronzeIngot: bronzeIngot$1,
    ironIngot: ironIngot$1,
    silverIngot: silverIngot$1,
    goldIngot: goldIngot$1,
  } = recipes,
  { coal: coal$1 } = items$1,
  upgrades = {
    [toolType.HOE]: {
      [toolLevel.DEFAULT]: {
        id: 'hoe-default',
        name: 'Basic Hoe',
        nextLevel: toolLevel.BRONZE,
      },
      [toolLevel.BRONZE]: {
        id: 'hoe-bronze',
        description: 'Gives 25% chance to retrieve seeds when digging up crops',
        name: 'Bronze Hoe',
        ingredients: {
          [bronzeIngot$1.id]: 8,
          [coal$1.id]: coalNeededForIngots(bronzeIngot$1.id, 8),
        },
        nextLevel: toolLevel.IRON,
      },
      [toolLevel.IRON]: {
        id: 'hoe-iron',
        description: 'Gives 50% chance to retrieve seeds when digging up crops',
        name: 'Iron Hoe',
        ingredients: {
          [ironIngot$1.id]: 8,
          [coal$1.id]: coalNeededForIngots(ironIngot$1.id, 8),
        },
        nextLevel: toolLevel.SILVER,
      },
      [toolLevel.SILVER]: {
        id: 'hoe-silver',
        description: 'Gives 75% chance to retrieve seeds when digging up crops',
        name: 'Silver Hoe',
        ingredients: {
          [silverIngot$1.id]: 8,
          [coal$1.id]: coalNeededForIngots(silverIngot$1.id, 8),
        },
        nextLevel: toolLevel.GOLD,
      },
      [toolLevel.GOLD]: {
        id: 'hoe-gold',
        description:
          'Gives 100% chance to retrieve seeds when digging up crops',
        name: 'Gold Hoe',
        ingredients: {
          [goldIngot$1.id]: 8,
          [coal$1.id]: coalNeededForIngots(goldIngot$1.id, 8),
        },
        isMaxLevel: !0,
      },
    },
    [toolType.SCYTHE]: {
      [toolLevel.DEFAULT]: {
        id: 'scythe-default',
        name: 'Basic Scythe',
        nextLevel: toolLevel.BRONZE,
      },
      [toolLevel.BRONZE]: {
        id: 'scythe-bronze',
        description: 'Increases crop yield by 1 when harvesting',
        name: 'Bronze Scythe',
        ingredients: {
          [bronzeIngot$1.id]: 10,
          [coal$1.id]: coalNeededForIngots(bronzeIngot$1.id, 10),
        },
        nextLevel: toolLevel.IRON,
      },
      [toolLevel.IRON]: {
        id: 'scythe-iron',
        description: 'Increases crop yield by 2 when harvesting',
        name: 'Iron Scythe',
        ingredients: {
          [ironIngot$1.id]: 10,
          [coal$1.id]: coalNeededForIngots(ironIngot$1.id, 10),
        },
        nextLevel: toolLevel.SILVER,
      },
      [toolLevel.SILVER]: {
        id: 'scythe-silver',
        description: 'Increases crop yield by 3 when harvesting',
        name: 'Silver Scythe',
        ingredients: {
          [silverIngot$1.id]: 10,
          [coal$1.id]: coalNeededForIngots(silverIngot$1.id, 10),
        },
        nextLevel: toolLevel.GOLD,
      },
      [toolLevel.GOLD]: {
        id: 'scythe-gold',
        description: 'Increases crop yield by 4 when harvesting',
        name: 'Gold Scythe',
        ingredients: {
          [goldIngot$1.id]: 10,
          [coal$1.id]: coalNeededForIngots(goldIngot$1.id, 10),
        },
        isMaxLevel: !0,
      },
    },
    [toolType.SHOVEL]: {
      [toolLevel.DEFAULT]: {
        id: 'shovel-default',
        name: 'Basic Shovel',
        nextLevel: toolLevel.BRONZE,
      },
      [toolLevel.BRONZE]: {
        id: 'shovel-bronze',
        description: 'Increases chance of finding ore',
        name: 'Bronze Shovel',
        ingredients: {
          [bronzeIngot$1.id]: 15,
          [coal$1.id]: coalNeededForIngots(bronzeIngot$1.id, 15),
        },
        nextLevel: toolLevel.IRON,
      },
      [toolLevel.IRON]: {
        id: 'shovel-iron',
        description: 'Increases chance of finding ore',
        name: 'Iron Shovel',
        ingredients: {
          [ironIngot$1.id]: 15,
          [coal$1.id]: coalNeededForIngots(ironIngot$1.id, 15),
        },
        nextLevel: toolLevel.SILVER,
      },
      [toolLevel.SILVER]: {
        id: 'shovel-silver',
        description: 'Increases chance of finding ore',
        name: 'Silver Shovel',
        ingredients: {
          [silverIngot$1.id]: 15,
          [coal$1.id]: coalNeededForIngots(silverIngot$1.id, 15),
        },
        nextLevel: toolLevel.GOLD,
      },
      [toolLevel.GOLD]: {
        id: 'shovel-gold',
        description: 'Increases chance of finding ore',
        name: 'Gold Shovel',
        ingredients: {
          [goldIngot$1.id]: 15,
          [coal$1.id]: coalNeededForIngots(goldIngot$1.id, 15),
        },
        isMaxLevel: !0,
      },
    },
  }
for (let o in upgrades)
  for (let a in upgrades[o])
    Object.assign(upgrades[o][a], {
      toolType: o,
      value: 0,
      doesPriceFluctuate: !1,
      type: itemType.TOOL_UPGRADE,
      level: a,
    })
const {
    ASPARAGUS,
    CARROT,
    CORN,
    GARLIC,
    GRAPE,
    JALAPENO,
    OLIVE,
    ONION,
    PEA,
    POTATO,
    PUMPKIN,
    SOYBEAN,
    SPINACH,
    SUNFLOWER,
    STRAWBERRY,
    SWEET_POTATO,
    TOMATO,
    WATERMELON,
    WHEAT,
    WEED,
  } = cropType,
  recipeCategories = {
    [recipeType.KITCHEN]: {},
    [recipeType.FORGE]: {},
    [recipeType.FERMENTATION]: {},
    [recipeType.RECYCLING]: {},
    [recipeType.WINE]: {},
  },
  recipesMap = {}
for (const o of Object.keys(recipes)) {
  const a = recipes[o]
  ;(recipeCategories[a.recipeType][a.id] = a), (recipesMap[a.id] = a)
}
const upgradesMap = {}
for (let o of Object.keys(upgrades))
  for (let a of Object.values(upgrades[o])) upgradesMap[a.id] = a
const itemsMap = { ...baseItemsMap, ...recipesMap, ...upgradesMap },
  fermentableItemsMap = Object.fromEntries(
    Object.entries(itemsMap).filter(([o]) => 'daysToFerment' in itemsMap[o])
  ),
  cropItemIdToSeedItemMap = Object.entries(baseItemsMap).reduce((o, [a, s]) => {
    const { growsInto: $ } = s
    if ($) {
      const j = Array.isArray($) ? $ : [$]
      for (const _e of j) o[_e] = baseItemsMap[a]
    }
    return o
  }, {})
ASPARAGUS + '',
  CARROT + '',
  CORN + '',
  GARLIC + '',
  GRAPE + '',
  grapeSeed$1.growsInto,
  JALAPENO + '',
  OLIVE + '',
  ONION + '',
  PEA + '',
  POTATO + '',
  PUMPKIN + '',
  SOYBEAN + '',
  SPINACH + '',
  STRAWBERRY + '',
  SUNFLOWER + '',
  SWEET_POTATO + '',
  TOMATO + '',
  WATERMELON + '',
  WHEAT + '',
  WEED + ''
const __vite_import_meta_env__ = {
    BASE_URL: '/',
    DEV: !1,
    MODE: 'production',
    PROD: !0,
    SSR: !1,
    VITE_API_ROOT: 'https://farmhand.vercel.app/',
    VITE_FARMHAND_PACKAGE_VERSION: '1.18.26',
    VITE_NAME: '@jeremyckahn/farmhand',
    VITE_TURN_CREDENTIAL: '',
    VITE_TURN_USERNAME: '',
  },
  endpoints = {
    getMarketData: 'https://farmhand.vercel.app/api/get-market-data',
    postDayResults: 'https://farmhand.vercel.app/api/post-day-results',
  },
  features = Object.keys(__vite_import_meta_env__ ?? {}).reduce((o, a) => {
    const s = a.match(/VITE_ENABLE_(.*)/)
    return s && (o[s[1]] = !0), o
  }, {})
var Lo
const searchParams = new URLSearchParams(
  (Lo = window$1.location) == null ? void 0 : Lo.search
)
for (const o of searchParams.keys()) {
  const a = o.match(/enable_(.*)/)
  a && (features[a[1]] = !0)
}
const rtcConfig = {
    iceServers: [
      { urls: 'stun:stun.relay.metered.ca:80' },
      { urls: 'turn:a.relay.metered.ca:80', username: '', credential: '' },
      {
        urls: 'turn:a.relay.metered.ca:80?transport=tcp',
        username: '',
        credential: '',
      },
      { urls: 'turn:a.relay.metered.ca:443', username: '', credential: '' },
      {
        urls: 'turn:a.relay.metered.ca:443?transport=tcp',
        username: '',
        credential: '',
      },
    ],
  },
  relayUrls =
    __vite_import_meta_env__ != null &&
    __vite_import_meta_env__.VITE_TRACKER_URL
      ? [
          __vite_import_meta_env__ == null
            ? void 0
            : __vite_import_meta_env__.VITE_TRACKER_URL,
        ]
      : void 0,
  levels = []
levels[1] = { unlocksShopItem: [carrotSeed$1.id, watercredit$1.id] }
levels[2] = { unlocksShopItem: spinachSeed$1.id }
levels[3] = { unlocksShopItem: fertilizer$1.id }
levels[4] = { unlocksShopItem: pumpkinSeed$1.id }
levels[5] = { unlocksShopItem: sprinkler$1.id }
levels[6] = { unlocksTool: toolType.SHOVEL }
levels[8] = { increasesSprinklerRange: !0 }
levels[10] = { unlocksShopItem: cornSeed$1.id }
levels[12] = { increasesSprinklerRange: !0 }
levels[14] = { unlocksShopItem: potatoSeed$1.id }
features.FOREST &&
  (levels[15] = { unlocksStageFocusType: stageFocusType.FOREST })
levels[16] = { unlocksShopItem: onionSeed$1.id }
levels[18] = { unlocksShopItem: soybeanSeed$1.id }
levels[20] = { unlocksShopItem: wheatSeed$1.id }
levels[22] = { unlocksShopItem: tomatoSeed$1.id }
levels[24] = { unlocksShopItem: asparagusSeed$1.id }
levels[26] = { unlocksShopItem: jalapenoSeed$1.id }
levels[28] = { unlocksShopItem: watermelonSeed$1.id }
levels[30] = { unlocksShopItem: peaSeed$1.id }
levels[32] = { unlocksShopItem: strawberrySeed$1.id }
levels[34] = { unlocksShopItem: garlicSeed$1.id }
levels[36] = { unlocksShopItem: sweetPotatoSeed$1.id }
levels[38] = { unlocksShopItem: oliveSeed$1.id }
levels[40] = { unlocksShopItem: sunflowerSeed$1.id }
levels[42] = { unlocksShopItem: grapeSeed$1.id }
for (let o = 0; o < levels.length; o++) levels[o] = { id: o, ...levels[o] }
Object.freeze(levels)
const unlockableItems = levels.reduce(
    (o, { id: a, unlocksShopItem: s }) => (s && (o[s] = a), o),
    {}
  ),
  itemUnlockLevels = Object.entries(unlockableItems).reduce(
    (o, [a, s]) => ((o[s] = a), o),
    {}
  ),
  wateredPlot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVRIia1WvY3GIAz15ToqRqCmZoAMwT4R+3iJ66lTMwIjXGX04tjJp9NZQgFsnv1sfkL0gdRaj0/sPhIN5oH/yekTmOh0/239hkpmbhYQMzcNoJ1Y64mIvrQSjVC8ecvuwsDyrI2IiEopxxiDxhgLRMZPQSwGaFRKWeOUEglYSukCiDaix0wsB+hkjEG994ZjCwhFbGQeM/CtGcQYKYSwxxjXeM5JvfeWc17zzNxCCPuc8+I8xkg55/08zx+XgSc6RcgImSGDzQIXQ/x64LIOwTEjm7drtBMB0c5Qb8mmq64jk37vvWkG2O+93w4jkVEDTdPKse5bzAXndpJF+QSimXrgi4G3573rwcu3u4twEqNGx1gPLLbeDO4uqrUemGthgKBSaLyLiGgVGLNxu001fbwuvPRYRdcZuZwDZm4S6dPVjKlBRxqcSJ0D/fUcWGDM3KRdgnt6/rwXTLcnHLIm316utzf5X/9C3oL6BQBimEemYBpmAAAAAElFTkSuQmCC',
  fertilizedPlot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVRYhe2QwREAIAjD2MVBnc65dAUOi+0J+fSZXM2aX1hz7GcS71KkkIhbKSSGGpEll4jQfyBbrh9RVy4R0Q/0AyUecEGVfx0Roq4cFQGFIvXGNFEOnwmdSclbLhUAAAAASUVORK5CYII=',
  rainbowFertilizedPlot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAkUlEQVRYhe3Quw2AMAxF0ezDFizDCjTMwLI0VKaBSFhyEht/pITXuDxXTulfL4NjBntkn+B1b5S6NmgjvsIijyBRJo6vToQQZ0WY4XB+iOgCb4kwx1kRVngpYlw8R1jjGxQ+EInXItRwyQdccCpCHed8wBXHESH4s1C8FiHGNSJccRwxHp4XitdiXFBqIWiPuwDmWChFXQDxHwAAAABJRU5ErkJggg==',
  shoveledPlot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXklEQVRYheWYPQ7CMAyFTRcGxMaRei/Ue3EXLoBYqg6dyhAZue6Lk1T5oeJJVURckk8vdtSE6MgaelqGnpaSc5xCAL7Y/eH+q9/hfjSGjiUBIZhxdu31HBrWlgW2CUgQBkBiKP2OhpVxHUNgXSzMa1q3z7d7R/eP8/rRcLIPrUKnOxAMEdHt4iYNtQgejc9zaKgvEAcsZ2KhLMiQoENSeyFQi5zSLnmBcjizx6lOEjJxTogYpzZAXH5cliVhUFVKU5o4ZDkFc6gGjC+XIFBzh2rnkJXY3rJvsVxEtP6EkLt0LYd4VXiVfs4hc6dulkM6qUs7ZAlujKUdCgIh1cghndAmUGko0yGUQ0TlHUr+HmrmEErqplWGluyvqswSPPZaB8TQJCkwyWWPxIPqFsVTl2sDJHOJH/k7NzwSPPTHXrn4zvUxdwIsfb4PXo8MPS2+q5ccSgay5LsbirlXOow+jbqqwQYBTPwAAAAASUVORK5CYII=',
  bread =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAmklEQVRIiWNgGAUDDRjJ1PefWPNIteA/AwMDw9Ic7JLRUzDNJdYCvAbjsIiRgYGBgYWaBt9+jimGywKKDcZlwX8GBgaGhmDcGlUliTMYmwX/YQYX1M/CqWFCYxphU5EAciT//3AJt8GkWNSwFmE2E0nOIQOMWkB/C5AjmIGBcE4m1WAUw6liAS6DKbaAkMG4JHGV88ToHQXkAQCMXCTuoxbh9AAAAABJRU5ErkJggg==',
  burger =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4ElEQVRIiWNgGAUEACOR6v6Tq5+Qgv8MDAwMkxJQBfml9Bk+PrvIkLeAsDm4JDAMhhlKqkXYLPiPz2BsFsEA1CIUM5mwKeSX0oez0Q2D8WFqkNViA+g+INv1aMEFNxerDwi5nhi1MIA1DvBZSgRAMZMFm4ozUFrlQT9OU/68qEfhi1h8wjAcqwAU/PdfA5FaaNJH0PDkJ58ZGBgYGDaG/Mcwk+QgenOCD86Guhod4LXg/6kWfMYTBmY1qObiTUXUADRPRXgzGjmApIxGDUCwsCMFYCvs8BbXZABiK7BRgAAAeO5Ta9GiRlQAAAAASUVORK5CYII=',
  butter =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABFklEQVRIS2NkoDFgpLH5DKMWEAzhgQmig0sY/iM7zT6G/LjC8AHIcDsHbxSvHzqwFc4n1TIUC7AZjh7IyJaB5AhZiGGBrp4+3ExBIRmCkUjIQrw+eP/uCdGWwdRevnQRxVdwC/Snff8/iY+TAT38YTbgsgwmDvMtyEfIwQa2AGT4hYirDIe2meC0ADms8PmMKhYg+wo9nvBaANII8gUM4AouQhbkffrOcDGLExw6KHEACiZkQMgyUFBh84Gd1xkGgxXaYEtQUhEoLkAWoFuE7jMQH+Q7ZAtgyRVkOAhgtQDmephFuCzDaiHUYGTDUYIIV45CtgyfhTCDQTQs/ImyAN1idAuR5ZENhokPTHFNsAAiQcHQ9wEAcVWNGQEhAZkAAAAASUVORK5CYIIA',
  carrotSoup =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyElEQVRIie2UsRXCMAxEzzz6PAaAESihyiJMwghMwiKpSMkIyQB5mUAUIOfiyCYQ6HylpPsnO34BsrKyXKInv2CFRQ+V834yXDcdDruNWXOXu8nlAFGomixgLIh7x2vr2SvevG46APBmhmiP61wLvcrUE4j0FVxResPttE1uGfb4iojl1jwkfTUYihJAawY8Ne6xdxTMM7GhT6XbA8M3+Jsmz3TpKXh7K2BRSAiPBXwVYsFTAcDrHb8Loqc961cRDUplzGBkxfUAEyhSiovwVIoAAAAASUVORK5CYII=',
  cheese =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA10lEQVRIie2VsRHCMAxFfzi6tCzAEFmIYyyOhVIyAAvQpjaNjSVZsmWThjt+qTjvKYpyAX490w6MUGN+IwgA8Lrx4unKuaOCIMGWpFegdl2THPcGy7QEw2CPoDpnmjgOt6DZtQSG56U4M53vhcAEe4AAgG0F5oWVkoCNww2UcEWS1pR9jW6g6JbW4ojymnZDJdyoHdrUOqAVXbCteaa1OM6Ua0pv0uZMQ6/Fs2k9Ed9vKZiXLFEAMgQI4PEB208gwaLGgblTK1ng6rANtAWDHfYkoPz9/YM3a79OWiGiHuMAAAAASUVORK5CYII=',
  chicknPotPie =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAACHklEQVRIS+1Vv08TYRh+3g8GimJigpOySSks+idggh20bC0DJNaEXoxbJTI50uhQicDoXaVltNdBXI1RBv8ErcRN4oKDCy1L7zXve72zP64hIekk79Cvd993z/M+z/d8d4QhFw0ZHxcEZzp8YdH/bNHX9XlmAogBZsYojYZ2tNACYGDYgyGCx4TEy4+Rgem6KaABSiJ1pctfITspv8e9eBIHj1fQyGfD+fGtCuqFN9oIEWGu+CnEDf/Un85zfLEbVBBEgQf/wcbuPsa39/D7aEzBJ2+c6th5zQwcbpQwu/lZsfVHOo+nJmCi3hxtn3S4lYYANPMPFDi2taddn6499K9fVQBtxqBeKKmSkGBm8TKIzcDYBQTNfBZj2xWYlu/myZMsQIS7s0m8u78KMGFyqol6wcFc8cAnkPq+foenUxNQQ9TLkT4ysUisWphJ4sujZRz/iiFWXMKlnTLYM8KjdbhRDjc9JLAsi9eu/oBGB0AiJYqkIU8TI8Te7SWMeO0cEOH4KIZr1xu6/tvzXRhZbwibf27CeW3/2wNZkMvlOJPJhF1PfXgBbu+KKDLGj6XXbilIjK+Y8HPhmTYh5boubLuHQCZERTqdVhsE4Dzlum9h26X+mHYSRAP7VgWHbxB5tVqF4zjRBAGJjKJEql+Nvx+9VavVVHVgTTA/8HtgWasssZVDJv53Wqb39MwYEHuqqhf4TILz+B/1zNC/aH8Brz3WGQIa2zUAAAAASUVORK5CYIIA',
  chocolate =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABBklEQVRIic2VoRKCQBCGf7VTSQbeQGbovoQ2GxSzL2CkkE0+gb6A0U7wDQwkKt050zF3cHu7cOOMWxjudr5vd+8YgD8PxSUsQ+Cf3YaVLALhAIDV/UWy5ggsOCeZKnDCfZIpAi+ckkgFIrhLIrlFqq5rMRwAzNvFdaCqPMH2eOsX0rJgBWYHPoGq8gQA0LQdAOBwfrAS6RmM4ACwjiOrm6FMeot6uI6m7bCOo9G7lqVlQX4Hw0MmKzfh+vm87MnKXYIR3JRQ0izLSLi5wVZuSvT66fr2woeblsQ1czMkcFeC84B1TKmcEliSULgv0TmuqXAu2RrXHLgkVJUnCoJ/b5Dkl/Dg+AKF7I1oIzfs7AAAAABJRU5ErkJggg==',
  garlicBread =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABDklEQVRIS2NkoDFgpLH5DKMWEAzhwRVEGyrk/mNzckDHI5wOJdoHIMP9Ax6Bzf/4SRBizxsIdeASLwMuS4iyAGb4X1lPVA+8YmD4cv0EXksIWoBuuLTQVYan77QRFkEt+f+BgeHgI0yf4LUAp8uR/UGuBcQYLrDqBcMHBwlwMJHsA2QLkIMFbGiYBOVBBLLAwekzA4+2Be7MhBTJZPkAZgGGq2FWUmyB3mcGHntMH4CD7IY2PImCXA8CJKUicBDpfQZrxGYJAxGuB+klmEzhlmii+gSWwXCFPSwUibYAW0zjCxqiLAApghVw9nKQ4EIH2MIdWQ3BogKmmJySlGAc4M4AxMsQ7QPijURVSXMLAIP+thkNIUCYAAAAAElFTkSuQmCC',
  garlicFries =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAB00lEQVRIS7WVMUsDQRCFN8FGTKdYCYqglQiCRQjGRiwsBMFWA6KC/oFYim3+gBbaRC0VwcJCLDQhpBAEsVIQBSvR7sRGEnkb3zK37uUu4bLN7e3Nvm/ezG6SUB0eiQ7rq8iA80JffT7/oePl3PUuk/4HwGYEUIwC6bltVb3Y0Xs5Rwzi5btdER+AwQiCmBTgGsQ4J6xnaEFd7U74kiLI6WBm8059vZz5MqYIAEmvoiqlS+Omq3dclY8WTfLSvRPALGXWFAUc2bIsLiDdY7+zySjV1NKJ+vm81y6kSCY7q7MnAHG11z2zJsvbFCBrbYsACiffD3ktbLtqWiIWki5QW+kAMNcaXNRSGXM4ApssAbLOaDIa7+oLyoYBNzL7wBLhQ2FkoL5yuqVPDDLDMzm4ofvCQSi+YRzkSir/9Obra+BNBgCb1q+PdRO7xwragQQSTHE8WwJMplLq1vN0dqvFrHaCAQiAaDKyxmBsywCWgyBTn78JhGVM2wBb2PWOJGIDpG8aPxXV6cYJwogFQGGKxgoY3l9W/aM5k/H7Y1E9rx2254B3QTYRa4BwhIkjLvQfDffBhtgNdtWeMaGAICfNGisTiAQgxHU07WNpx0QGRLkHrphfBDxYKKqYnIMAAAAASUVORK5CYIIA',
  flour =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAEHUlEQVRIS7WVa2xTZRjH/6f30+vapVrqVl0ZSGKy6EQgDkwIypiaMYIfiEVjYoiXzZJM/KRRNOGTQuKcRickLtuIkhg2vCBREwNz04wwwiLboHRu3Uq30Z6ul9Pb1mPet+uxtzXGhPfLOee9/H//53ne9z0M7nJj7rI+ygGEMvD/so7OKZwoip5o2wOUQjBAe+dPuexcDeHtl5+iY8dO/Uz18wZbm+uw3malEwpEREEKJo3AC2BZ8VIAoVA86LkJQRCgUcsQ5ZfBMAz9Nto2/gtrXYUBuOxaQE1VZZ773BSJAOKciLMqKeKJZaTTGb3LP3Rg8zNOUZwAK6o34PnGetpXSrwsgGEEUZxMVLMyLHFByFVa+s7HltH14VsI8bwInZr14/SFK3m1zdZAaGuug91mpbn/5QsnHm1qy3OejIehUOloHwF8130MBg2LpWgMo+MzyIqfaGtCe+d5EVJU5FHXHQxd99I0EVG5Ukvzn5smUovAeD9GxyZp/3NHTtEnMTkXSODsIO0v2qaZOlRbccvjxafnrlFIthHRwpYtOBG+HYyDVSpQ/2BVdgcWA/Y2bMQTD9sR4WNY8HMUUq4RQ1w0BZNejRqrGdO+AOYWw/j24njpCN5xbAUXjmFrbSUWE0oEOA6sQorbgQjs1VbEoiGwGj3MygT+dPmxzqSl326Pl45fnfTgkU3Va0fwek6KaKpm5rDedh+21degUhFAx5nr0Go00LBK8LEEGEYCsykDIKZuzPMYm1rEwJC7dASH92+hB9SkY3FglwX+pAnf/3oVLzbZUHHPBKZmGzB8xU3BjpbtFNr94zSWIlFqhNSudnUnlixy42N2bN5gxtO76mGvGkJwYRMCSRN9d882oK//Eox6HWQyKQ48ac1A5xowOPwXLDoJFiJpjNyYxze/TZSOwLl/C6QQ8EqLHRX3TqLrtAFqNYuDe33oHbDQ4u/e8RB6zl7CwX07KLizW0nrRu6wWzNe1N6fOUtrbtNttZXwhtJIplI45ODxeZ8erzpC6O234NnHDTCYM65/H3HjhX0+9A1YsJKKw6JlaAQTngBOnh8rAgg9b+7EpI+HscJInRBHjuaMcxJB3zkLXNNevOeU4GjHCo46pej62kgLnkzEoVCqxHWk6KtbXLyuhZ72nRh2+WE1aSGXybFOL8HuRi4DaPHh+EkF1KwSrznC+PgrNQ6/xOOzXh0MOg0tLtl1JIVaNUt3VRHgeOsecEFOjIDcS8T5R18qcORQkqaCRPbuGxK835GmkXzwSZpGGorw0GvVVDgcFzDPRXBhZIqmSbzsSIr+uOmnByZ7cMiTOBsc+xvb6x6gAG8gDqtJBc8dHhKJFCtpAaxCBj6RglopR4iPg48ncfHabB6AfJT7B5e9MtYYLPlP/j9CZdf8Az/h7SitknPUAAAAAElFTkSuQmCC',
  frenchOnionSoup =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3klEQVRIie2UPRKCMBBGvzh2Vlg43sDOgoOgDYU38BCUHMIbUNCgB6Gg8wYMBTlCbExY4iZk1DJfBfl5b5dkAGJiYoRnTv2DZQ8aaJMBp+thkXq/PQEA5wfPpQLVZNNLCJwTEZkAgJWG+zaEhClIGQsANfYdtvujmdXdLHXCfSLCEmu6eOw786xlxUYCAMpqQHHZzeBlNbB7aWZn4FqUtDlkWiNp89m4TGt2va4emM7AGw2iQBfczsc1dXURGlo9J/hJYsNdgq8kHNwnAN73eElErnbQr8Ip8iSEEePOC53iSqgjgs9oAAAAAElFTkSuQmCC',
  friedTofu =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA4ElEQVRIS2NkoDFgpLH5DIPDAj8Fhv/4fLrpAW6HEvQByPD+EhGs5u/a/wYsvv0sAwMuS/BaQMhwkMH+VtwMG499Jd0CQsECcjnIcBAg2wJcQQMytLDnzUi1ADnsiQkiUPjjAqCUhZKKkFMNKIwJWQAyGJsaUPJlY4ekLrgF6EmSGAtwGY6cfMEW4ErvIEtwAUKGw5IvI6npnVDhCMsbKBYQCmvkDEWs2lELsEYFtuIDHMnEhCssQxGrFlZ8E2UByLkgDcQ4BqYW5kWikinMNcQkafSKh2CNRijdE5KnuQUA0jXJFH9Pv6cAAAAASUVORK5CYIIA',
  jackolantern =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7UlEQVRIidVUMRKDIBA8mJS+wHfkL3mAM/bpU6a3d8YHJG9Jny6lL7CWNHAg3gFHJoVbiHC3e9yKABwdqoJjJHxpAXO/nHFye7yyGrpWvBQnMQNw5wAFDkg6iFFkL9WBIdY4sWxuXMCYK8EYSKFULhZROUIN1OC1yW8wL/597TtWKIyFnE0xO+Lu5wWgbfYCepxYcRcLua6L7Cl6Pz9VMSyezfgRSYukEFnkPA69XvtuN49zYrAdpEgU9DjJOohPTU6cjdlR2YrQNv5MO2I4UmsAtP/4sPjLnxxfYmwR1yEmpvPIuwi53MYq8w6OL4W0Y7hN+2EVAAAAAElFTkSuQmCC',
  hotSauce =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAnklEQVRIiWNgGGTgPxQTDRhJMfz/f4jZjIyMROtlIsU15ACSfECOXpJ8sNrfkWG1vyMpWmgfREPfAmIj+T962Idu3E+UfmIswDCcFEuIsoCAPF4zWIiwgOHf/3lYxZkYkwjqJSuSbeYRNpgiC2atM6edBdd8ZpKknqg4IMdgGCDaB1pb0rGyCQGikimBVDQE8gGBnIwXDJ7CjkL9tAMAL4QnWOXkSy4AAAAASUVORK5CYII=',
  rainbowCheese =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABzUlEQVRIid2VvS9DURjGf5UrqZCwCBZNByQdhBvpQmLqH2BisIjqYrGQSNNEIo1BGCQsPrraDGKyaNIOGi4xSFiERGi6kDQ08XEM7j3t6a3bogvPcs77nvM+z3ve8wV/Ha4qcAgnzt8ICIDZ5oTiXMgMKLw1PyXX2EJjyzZgCspVfVdAWOROKBSpVEAAwhdM4gsmlYHFzKVjYDkBAYjRw4RC3BnsqjAv0JzII6lxrsRYWRJzY0ui1CkSAJHUOIAiYKx/Tj/f6FcC3Jyy0t6h+EI39QCuwhUIgFR8CIBd0+l1xZj3byrB/vATZ1Hn2luwBMTBjD9PMLijTJp+yQGwVLtMX3gKgO5wZ0UiVomU2/iWDRFzN0v7QkQAiM+9K8FGdNvMUucVg7X2YTlmlUieoofVAA+rAd6yIVsWd8ZRyez08IhiXz2f2ObYjunxcUaxr417vK4YAINz9lOtocvWW9frLHB6/Sj7Y7m8kEdvlf1s+oRs2p7pV7Cl9LR3q9iF5AD6RPHjqSJ0Uy/rD0UXrcfTWDajNr2Phpb8ZufoKSBHEltwusklsVjrLnY5PvllBYJa1OxZ7ff+EJtA0+Q+TCquavx6gPlyVovs/+ADoliAUUBEL7MAAAAASUVORK5CYII=',
  salsa =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABQUlEQVRIie2ToU7DUBSGvzaIdZItRQ/sCAKDZWK2AbOXAMODkJBN42sgs3sCzAQZaoKKKZYMCRNLD4Ldw21v2y3o/urk9tzvO/e2hTp16uzMotGTRaMn/93vlT0YNbsSpSHBbMP36QEAY38JQJSGALSSmMeTSwBuvt4KWc7iqNkVGwIwGU7p355XTmrkeZGfhwcPC6I0pJXEum7gwWyjkwOs23MdIEpDojTUAZ0TmCvJx76isnVTt5KYVWfA2F/qSXxnpwUAdKOdyXCq8HV7rvWqM3A49n0J4ROvk2MADi/unGYzYb4G+Hy5B+Cs/w7La2VnBCKCd/QMoKIymQ1VMCAfV3jeHzv/FYnI7zsyorzMjoEaMJCBFwkyEm2yZJnGLVT7PHfosh/NkexKEbxKACBb0z7gUlaVICOqcuzBqFOeHxC+hOOYYjlcAAAAAElFTkSuQmCC',
  soyMilk =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAz0lEQVRIiWNgGJHAysrqP00Nf/H45n+aWAIzHIapagm64cRawkSs4etWzscQL6lsJqiXoAX4DO9pr6XMAkoNxwtgYR4TE4MS5jD+/3dr//9/t5b8iEaOVJihyIYr1zAQZQFRkdzTXgsPFnHuKwwqfcEMTE/4iXIoURbAALLht/rmMbz8qkNdCxgYGEgynCwLSDGcgYGBgYUUw0kxGAZI9sHwsiAoPJHh2LFjjDSxgBjD8Vpw7NgxxqDwRIoMJwqgl0mklj1EuQLZUKq5nFoAAB8UtnDnOmpmAAAAAElFTkSuQmCC',
  spicyCheese =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABZUlEQVRIid1UPWrDMBh9atrg3qCLSwYPhnbq2jVgaEyP0SP4ED6CzyEHCl27Zit4SCHEi2/gEFPUIZb49OOftF7aBwZL+vze+55kAX8dbAIO0cd58UtiUecR6jzC+90T6jyyBH/agWjJnLhevSrucwUEAPSRmyJjI9LiAIBNMsMmmVmF5tzlCOJOxw/p1+BcX0S9OVO0cbjAXB0M5mwSHneJVTNfpCcFF7HMUbY7hrBDQHWgxfH4sT69rLoJmRdAHLZqXMYFAMDnoV5H3Z/jsIwL+DxUQswLsF9yJSA7UMe0qTJ83j+jqTLLqemSOpVdiMPWcg+Qq2K/5NaiGYPVvhdoBlxQAj4P4fNQI6TvJnGXKbquCZgFZVxokbg+pobKuADzAswXKa5uXgDjLhJ0YyXx7VusEdCIZHzyvFMProEYOjnSeeuuk9CE+pOpQ7q5Qw7HQhx3iWiqTKC9OckzGSYn/B/4BhgmpsuPu4+VAAAAAElFTkSuQmCC',
  spicyPickledGarlic =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABEUlEQVRIS91VwQ3CMAxMxQZELMAGLIDon2cWYBBeDMIC6Y9/EQuwAQugsAEqMtJFrpuiJk0+9Gm1d2ffua5U4acqjK/+kEBr3c0dm3POT2YwouIEpN5a29Vn823kfWrV4lgPmlpeOvXa9/W1B6uMMb1i0GQQEDg9IQLOiPduD5dGQGCrzc4rBiDIsxCgC4AR4fN+9d1RPboDeMDHxNWjDj+SPJDz/+VLFMF2rb2PRMKBoVh6kY2Ajw4qSEQSgTRXJocnLIoAixYaR2g3klIkt3gs/+gyqgNu8phivs20F03TTN9kmSIOliVF5AEBYVtD+c8SU5oviHgXvD7LA77JUrH8h082GTch9rLJW0DfFz/6H7rf9hk80F8vAAAAAElFTkSuQmCC',
  sunButter =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA2UlEQVRIS2NkoDFgpLH5DCgWHF/F+p8aFlqG/YabC2eADDdxkqKG+Qxn9j1jgFkyzCwAhQ+lwQQKHhDACCKQYHWM1/8vZw5RFA88JnYMrUu2YUYyzIIIWwGKLFhx+MMAWjBrYtP/wJg0inywfskshrT8OuxBNHwt4PnhijXYvnDsxhAnKYhwGYxuKrJFRFtArOEwy2CWEGUBLsNrA/nA5jWv/4QzyMi2AGY4zGRsloB8QZYF6IbjsoSgBaCyaGgXFZQWeOgFHcg8rJU+KKjIKZCQi2mYfpq3KgAeqqgZelcVKAAAAABJRU5ErkJgggAA',
  chocolateSoyMilk =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyUlEQVRIiWNgGJHAysrqP00N/3Bl2X+aWAIzHIaJsYSRFMO3zcrBEPdKm8Jw7NgxnOYwUWJ4Tsc2gnoJWoDP8CkVXpRZQKnhDAwMDCyEDEc3DMZfM7ERKiKM1wKCQTSlwgse1siGt4vfJMYDxEUyzBJkw5me8FPPAhhANrycVYIhJL+euhYwMDCQZDhZFpBiOAMDnlSEDZBiMAyQ7IPhZQGhgo4iC4gxHK8Fx44dY/RKm0KR4XgtwGUJKYYzMBBZ4SDXXKQYThcAAIIOcW1FSq9sAAAAAElFTkSuQmCC',
  oliveOil =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA9ElEQVRIS2NkoDFgJNZ8dlmB/8hqfz7+QJReohSBDKa5BXpuIv9F+N6APfHmkwjDpV1viHIcUYrApvJz/ndy/Q5m7tvNycDw8TtReolShGw4LB6ItYSwBUguR08QxFhC0ALksEe3gJi4wGsBPsNhlhGyZGAteLCV7T+bnhjevPjr0isGBe9fOB2K1wd0taBjuhCKTyoy34H5VPEByHBdQ0mGt28hhoKAZsZlBtPHItSzQEqOHcUHVLUAZDJNgwhfMqJKHNDMgqGfk7EV0+jBdfSkAAO+6pNgaQqyRM+cG8XcSye/IvgEKh7CFhDbKsChjuYWAAAtPZoZgsyz7QAAAABJRU5ErkJgggAA',
  onionRings =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABMUlEQVRIS+2UsQ0CMRAE/RExISlUQAs0gIQQGWQUQQUQkxKSIYREA7RABcSUAVqktfZPd28nn+EI8fbO3d7aTep5NT3rpz+g6HCVRYtR+qjS7V1vbREA8ct5m573R2bsr6/f7xpQJ8AT104Isj4pOASUxCkKyHg4yIzDcZNW61PuzgV02QIlzzL8h0UrAUYnVQBuhkAE3y0nLaeqASreOyCaC4rQDrSolkWadx7QpFjvddDRPckAiKuoVjSdz1oDtFGN/Me+H0DFtSp70Oad1rAAN0Uqjo3IMFcXQMW9MzlFHoA30esMcCuuN9da3VgR7QIH7UMHADvj3k6ANwN6GrUeRdJqoVM3RaVH3su9N7cWgHS1wAPxXpQSxlmFb1HURSkAGvPwsStZxO9eAPiNhXwBw/0AOoT0r0UAAAAASUVORK5CYIIA',
  popcorn =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABgElEQVRIie2VP2vCQBjGn0taDSI4tKBLUYyD+Kdzp27uguAkfoAuLf0UdusH6NhJlCKOQqFbP4AWhxAFF4dKrUopmvPtUA2pNMk1trRDn+W4e3PP7/K8IQf867fFRB5qX++RXS1TGgl5OJob4zwR12k6uCXiujknrpMTXMicGxMirtO81ySiChFViBsTc50bE28Qq/l6tALmvSYZ47xZs4NIbiA+PYfEHgGpCv58DyyLoFkZu7HOe31wB0hV2/07TuY0K0MO3QC4AJZFLJ/SYMF9yKEjLPppyAcnkIPAom/vYQvIlEbQLo+hp1qIP/igpzTkch20Wv7V3I944wrq6Ry9hg+Zs5FzFJ+9QDsbJSISGgF468G2cuzBprovr+gmIgCA9DcdwIygpobJqpoaNiOCTTzCgE1zK8QN8OM9EAIkAwrqq+zXqiciSAYU171uTWaMMWpnoyhoww+QgjZE5zAGxhjg8Ff+UkTJgIKCNhQ6uSeAF4lcFiKf4HaXzp/WG0R0GZSwU81hAAAAAElFTkSuQmCC',
  pumpkinPie =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA6klEQVRIS2NkoDFgpLH5DKMWEAzh0SAa5EG0v1j4P0EnMjAwOPa+xRmXWCVgBitocBBjPsODGz/A6rBZhGIBqQaj247NIrgFIMPxufjTt38o5vFxMeH0HcgimG/AFpBqOMxkYiwhygKQgaT4AKQe5guUIAJJEBuxuMIHPR5QIrmqquq/68+ZcL3EWgYzFKRxN3s6Q1tbG9xcjGQKsqSkLBFsycVmC6KSqX7tCbC6nq75KIaDxLDmA2RLiLIBh+E4LQBJgCwB0TDf4LII5GoQQA4WZLUEi2uYRbgswGUwTD1BC4gNIlzqhr4FAOLAXRkvhyyAAAAAAElFTkSuQmCC',
  salt =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA3klEQVRIS2NkoDFgpLH5DANqwX8yfYfiaFw++K++6TjJ5t/0s4TpgZuLzQKyDQc5CmoJTgvIDRYGmI8JWlBz4S7JQdNioEyaBVcPKxFtibbtPQaqWLAuB2Jn0BRUu6liAczwR48eMcjJyaFYQrEFMMPRwwzmE4osABkOczXVLcDlcpBFyEFFsQ9gQYHsG+SIpsgCWLCADEdPPTA5qliAL1OQZQHRuQyqkOSMhmyB0R9lDPvOsaAWJ3SzAL2gA7kMvbj+T25hB/UmRvGPtT4gNQ6wOBRuxIDWyWR4BFMLAHg9rRn+GIpBAAAAAElFTkSuQmCC',
  summerSalad =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABeUlEQVRIie2VL2/CQByGn9IlBQdJde303ASmAr4BBsMHIJmZQZA0TSZmMCT7AJgZvsACogYxNz1bTQIOKppOHNdey7UlW4biNb1c797nvT+/Fm666a8yake8rpLK95N+pcddnfF82Kv0f+IUoAR03nmh8RnofY0OlAe8rhLVeLO/zLzbLoAUSKPKfP1l0G0LA9nW9alB5sNe7ty0Z7DZC4OPEMZ2E3sZAeAFBnGYPU0Hxp9NeDymc4pqFNPLgV5gYDrQmQnz7cAiDmF3bwHCHKDzHeEF+ZWoq2ig0XSRHY00tJcRpgP2ISIOYdsS/btnAS6TFmA6WWL7IFagmqogCfYCfTloAb6bpBNlOtMR2wECFIcivVTZKrQAmWbbstK9Vtv24bRdyyg1fhnpC14AJn1DFkq3Db2HBN9NssQDK22rSSXUd5PcLVJrQXtN5Y2QqTozI217gYHvJkwXBm+jIz6UXlG4QiVf+Vv0C1CZcT2gACpVzf/g3/UD5wa+Sc12t5MAAAAASUVORK5CYII=',
  sweetPotatoFries =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABFElEQVRIS+1UMQ7CMAxsRngHG+IlCJ4AY/ukZmyfAE9BbLyDjiAHXXQ1DkklujVTGsd357NTV8283Mz41UKQdXix6L8WXU6rlyAe+6HY2uKLAr7d7ILi++OWJNEiAoEc5lQxAUjgD3ItEQ6HKVVQxGajEpxJriyrwkigVaUALTAm1EKjRczOaiyVINGqtWXyHZus/UMyK84Bc9XoS6wAQV2uRZQbfggRklEPuA+llqXIJF+IAoFWbzXSAtLVWtMVLKrrOpDsh340ahpUA/yaPLx4J+Bt20as63kd9ofu+SUaMQ5Y9xBvmuYzRZok18SSuIB7710cU9gkyVxRCRgrxl7AR++AgZhsCgFAOaf4bzqFiO++AQm8tH22dLVsAAAAAElFTkSuQmCC',
  sweetPotatoPie =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA4UlEQVRIS2NkoDFgpLH5DKMWEAzh0SAa5EF03o39P0EnMjAwGO76iTMusUrADFbz5iLGfIZbW7+B1WGzCMUCUg1Gtx2bRXALQIYT62JC3gJZBPMN2AJqGg6zHGYJfSyA+QJEEwqmV1xcDGLfIJGKDaDHA0okV1VV/Q890wvXR8gy5OCAsVebFDO0tbXBzcVIpiBLstyNwepft0YRik+wvGj1MjA9bedZFMNBYljzAbIlRNmAw3CcFoAkQJaAaJhvcFkEcjUIIAcLslqCxTXMIlwW4DIYpp6gBcQGES51Q98CAC9yVxnnyn4gAAAAAElFTkSuQmCC',
  spaghetti =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABBElEQVRIie2VIRLCMBBFfxngGhimAtEz9BBgEKgqLkANBgUX4ADY3AfBYLgGFYuAbXfThDSFGQxfZf4k/2W3mynw16+VhDaYEsTrxT6839YwFDwvDrhcb0inExhsKBbkBJgSxMFS7BkcyT7jg7YApgRl+Vp56XRSV8EgALXHUBdk4CtNBnfxsnytvpcTwK2JCZbevDi0IK0K+gT7PECPKdFqrGHLotV/2Xf2sNvq0NO9zmYAnSvCbNTwbFhIr1AAgMhK1BSdq6Z9ySjuTcmzCizW5NsUK749EBjTb8juw8dVyNu7AB9B7HAfoBfEFf4OAOD5IkMgMdrOrC6zGCol+h/xl9IDcxCDNEfiwBwAAAAASUVORK5CYII=',
  strawberryJam =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAVRJREFUSIljYBgFBAAjLon+MGsY8z8h/YWrjuJUwIRLgschgpDhDAwMDP+h6vC7AB0sv/6a4ffJTQxrnv4nZAFDiDQjI6u5H0OkpihWeRZcGtc8/f8//vtJQuYzLHxq/j8ST1DjtCDRxYJx/h6CQcSQ6GLB+AOPPIbNy6+/ZuBhZ2OYvXz1//qMZELmMzTOmMuQGhnK+OXnL6zBhBHJpBjOwMDAUJ+RzDB7+er/POxsWOUxLCDFcHRLsMlhjQMtFyOSLGBgYGBgCMnGKowzH1ALYLWA49w5Bo5z54gygJBanMkUpplSQHQQZe83ZMjeb0gbC2AG9xYzMvwwIi0BEO2D3mJEniTFEqIsmOp4nuz4wBrJMBeiG4rNErhvcOQDvKmI1PDGBjCCqFhKkDEch2twgfCQbIZiKUGsRTbW0lTqxCGG3mfvCRbVyI56ZmGHs9KhKQAAu7Vof/9SQdkAAAAASUVORK5CYII=',
  tofu =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABLElEQVRIie1UuW3EMBAcmgTYgSAIduASHDhw6ALcgMu4Qq4MN+ACFCpQ4BIcUCYO14EACuvgjtLy0YmJHWnCITmzu7MgsGPHjj+HKLnUdy2VCj6/vAaamwZ919LDfYPRAVql55wfHXA+2cDkrkQcCEUmkvMdz5vBZgtYNeDio7twE0loBUgxBbwZLHyXRQZ8LLzKWFirRZzfAzBnlhjkxsJFOW8Gi6pukvOvj8NsEkyt71qq6gZmsCASECJcHs5VdTNXzrtR35/BmyQWrRA8jLdndICSEvbHgGd0Pi3iT+9H4Lqh2Qx4u0rK4IyH7LEmvmqg1bKKPFjP8QL4WGLx2ID4YymmJFhvptUlgy1xTtA1ebjHt1xTWWyJA5mQ4y3Ywi3x+KD4Q7uh8f/4BeeCk0AHVwhiAAAAAElFTkSuQmCC',
  vegetableOil =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAxElEQVRIS2NkoDFgpLH5DERbwL71y39kx/z05iFKL1GKQAbT3IKWatH/oT6/wJ5YvYWNoab1NVGOI0oRsuGwYCLWEoIWYDOcFEvwWoDPcGItGbWAYIoa2EgGReTQTkVeNvr/nz18gLc8lJJXYNh25CLOoMYpAQqa4JhDDMfPXIJbkBgTxjB/ySoGZPrGjRsMa5fY4Sw6iLIAm8Ewi4aGBbAwQvcJSNzSRI+8IAJppmkkw/IAMVUqvrqBYE4mxgJ8aoa+BQAVra8Zml1jUgAAAABJRU5ErkJgggAA',
  yeast =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABbklEQVRIS+2Uv0vDQBTHvwc6RAIhOJToZinURYiC+RdchG7FvbropH+HTrpId+mmuPRfiKABFwNSN00dJBSCGRRP7poLaS6/sHQQfVtyl8/nvXe5RzDjIDPm419Q2uG/1SKa6kel6qts4mCntw0aKQgBzPa18BUy8hbjbDcOG+huNpGVfufGxe3JY7IwiZcloNZRA4zoe+/otdbjzAXp5XWEpZrGL1H76g66sQD2YB9z2QQzLeDwwAvxQSmHPw/HsLwQknlCoBqKJEkK6NaZCX8QYOSFuGiZuZmnZexMdi4daIYCva6iv+/ElUwKTk3+rf8U4JNSdK1VqfdJOGvVck1Dx37AHCHQV1S+3D8oEQjI2yDAF7JFLLNd2+UNX6yPwSIqC5IiaSxSGVwqsPaa0NeU0vlStMG/D2Gfu5lnwF7SaSRpuPTPRpn9SJIFzxPwSkQbWEVFEbVDbKl0k9O89JSQrkFRAlWG3VSH/vsF3ysBgRmuWgXeAAAAAElFTkSuQmCC',
  wineGreen =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABLElEQVRIS2NkoDFgJNH8/1D1ROsjWiEDA8P/C9ujweYbeC4FUUTpJUoR1NX/z2+DWGDoNVQt2LIkD+wDn5hJtAkimseBR7oU2Ac7Zj6jug/+e6ZLo6To7TOfEmUJMakIw3CYTcRYMuAW4HQ9sb4g5AMUC/4zQEoKRqRMTCiYiLYAZHiQrhvYgnWXd8EtoYoFMMM9bZTBFmw/chduCcUWgNI+yOVetsoM/6FlKSMjA8O2wxBLCOUJgkE0a0oC2HBD41qG82dbGP7//89gYVPLcPJoM9iStJwFePMDURaAgoaRkZHB0LiGgY2DgeHkUYhFoKCiigU09QF6HIDCHwSoFgegMgg5icIyGCypUpyKEIUcrDqGWQHxCqUWgMxANxmlVCVUNxNKReiGkcwHAB32mBlT632HAAAAAElFTkSuQmCC',
  winePurple =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABWUlEQVRIS2NkoDFgJNH8/1D1ROsjWiEDA8P/bB5+sPlTv3wEUUTpJUoR1NXDwAIlCVmwZ+69eEybIIrSdwZbsOzi3qFnwX+Y62HJmlhfEJOKMAwnxZKBt0BAUPC/l6whw39YHgblMCZGBpDAskv7CEY2QR/w8PD8X7ZsGcN/mA2MjAyf/SIZ+DYtZ4iKimL48uULXjMIWsArKPh/+vvfDLybloFd/dk/mkF271qGx85BDJmCbAyf37+nzAJuHp7/2zeuZXjkHMQgu3cd2GDejcsYBHk4GDz9gxm+UsUHn/4zMPByMDB8+Ay25MOXHwwMjIwM0dQIIlApemjvToZH7uEMvOsWgVPo5+A4BgY2FoZMtr+UBxHIgkhdJ3DK+f8PkpTAqYjIIoNgJIMsQM/FQyuj0cUH9or6DNJ8IijV99NPbxgO3r9IeU6GVZc4GgcE45CgAhJbHRjKAc39ixlOVxPLAAAAAElFTkSuQmCC',
  asparagus =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAV9JREFUSInFVTuOgzAUHKJttlmlJF2UFIgr0EUpkNiaC3AGjsEZuAA1kVKg7SjpIkSRgg4phyBF8pCxn8GglTJVHL/PvBk/AXwCjmf3/5Wz4QKd7WlRk6kcSw703WA4X+sLmrKz5KQlORsxEAB+fm1T4iM8Djf2/5FEYRwNwY/DDWEcTUrleHYfxtFQnGsyNGjKzsqSFPe6AAAc3bMR8yxJR2eZlGIy4V4XSjIHZ3tClbdaUl8mBeD99bLZorn7XYBrfgFQoMpbvcnkAQBUeQvfDbDffcN3g1W7MWpA4MbUvRB6DLr7UQPZZLEAoJonI4wjRR52AuAljyjX3Iuaule2lFhSA5pIZEd+idNy7NkJmrKzOLk4iUx2RbsHU4U4AjrM7gHwkkknARE4ukCWpMq+sBPIO6G7FyfLktTMA5kZB5KIMCUV28DUZBMPVpm8BKtNfv/upbOC2c/hXIGP4wnebtncsEc6vwAAAABJRU5ErkJggg==',
  asparagusGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAJhJREFUSIljYBgFIxOoW0n8p5ZaJmwa1AUcibKEGLWM6BrcNb3g/J3XtzHcPPaCEUMXCWpZ0AV2Xt9GyOFkqR2hgJiEgJGKSDGcmNSGNYUQYzixqQ0jFRELXitdRXCu41ZHtgXntj4kVysqULeS+E9K0YEO8MYBLCIZGBgYbn7YjzOc8QGcQYQekTc/kGo0AQsYGEaLguECAF6gPZZVZb3GAAAAAElFTkSuQmCC',
  asparagusGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAQdJREFUSIljYBgF5AB1K4n/1FLLhE2DuoAjUZYQo5YRXYO7phecv/P6Noabx14wYugiQS2GD14rXSXkcJLUwy1Qt5L4H1qSBNdEjEUwNfjUYvhAWdOZ4dzWhwzntj5kCC1Jwhq+MMfA1J3b+pCgY8gCxCQEDB+QYjgxqQ1rCiHGcGJTGws5FjAwoEXsddzqyA4iYgFBC9StJP4TCmdcqY2gBfCIxBOZyprOeB2IMw7QI/LmB4R4aEkSw+qeeQwMDAwM57ZCaIoi+bXSVXhE3jz2grElqI0YbQwMDASCCLnIwBfOJFuAXC4xMBAOZ5ItQDf47vW9DKt75uEMZ3wApwb04CDH8OEBAFoqeOiVTrE/AAAAAElFTkSuQmCC',
  asparagusGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAUBJREFUSInFUz3KwkAQnYgHsIyVosVia5lGxELQwsoLeAaPkTPkAqks8oFFCpuU6WRJkSJdwMYbxMZdxv2b1U/wQSAhM/Pe/DyAX4BFYfet2J4pgQ2WXiQ+sYGasJ5t5PeZ/0FVtIGW9Uas1sFtcqWEvxUvCVgUdvvjQSb5EIkYV6zWwXS2ku/748E4XyyGgiSoijZI4wRqnmtENpRZQ4rROhCoeQ5pnBgXJ8SwwRLKrHGK6ZMyDcAXNB5uII0TSfwVAgBlsdxcXCN4BnX4W8zVVoCCtoOqaAPxSKcSbrUtWOsAQ3VqdTfHUddmvSIMPG/VA65rIwmwo9UxYOW7aGEdkZFAVYmLqYak4OxAFKbGcCou1n/W02NR2M23oxcyTIJH4jphL6OZLsXXF14ENc+hzJqPzOZ1pv+BU5HvnH+KB+Rns9NcWsNEAAAAAElFTkSuQmCC',
  asparagusSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVRIie1VwQ2AIAw8jJMYV2CRDuoirkBYRT9CxJS2Up9ewsNiubO9IvBDQWBih7LvIjjWZakPKWc3yT25OfwrkpkLEkUAwLbtUq6plBMXVA4Grq8t60HWYKQH9R2iWMX0SjniokZEIXlDoOGVGUbdYbazx+MmF2kE7qmWkqxlEEX0CKyNVEWwg1ZQJtoqghs6kcAKotgV0yMIKefmypCsKF0tXhepPXD/UAwifsg4AawtUVA+F49vAAAAAElFTkSuQmCC',
  carrot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3klEQVRIie2UMQ7DIAxFTVUJZcnIBTggU0+RKQfMBTJmQUx0aEDY2FSkdMvbwMn//o4VgJshrFOEdYr/N+m57xalKYaloqKd4o9uk4TzqnrmcqJW5+lOEH92m3BnmqZALJyU86+rDeFEK0E8Fp0Ps/PYyHklzrwwbnWADAAA5lfAJkSMQ9qiLL7tIV9Sw9OsuTmSO+p+2wNYU4zrk0QhAyEJl6Dq3hqNkiCS8JU1TcLWaJRANGGgBdQ9Fc0f+ft6Z8QEzMy7hLkX4rFo1PkvwokqgTV6iLBEhPL3cAMAb8x5cUBYehurAAAAAElFTkSuQmCC',
  carrotGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFFJREFUSIljYBgFo2AUjAIagYmc/2lnINUMn8j5H6vB6GLo6si2BBdNADDhlc3/zkiyQ8gCyK5G9xUBg4lzIbIlyIAIH+JSQElKId7Ro2B4AAAM7CorC4ZVKwAAAABJRU5ErkJggg==',
  carrotGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAG1JREFUSIljYBgFo2AUkAcmcv6nnYFUM3wi53+sBqOLoasj2xJcNAHAhFc2/zsjyQ4hCyC7Gt1XBAwmzoXIliADInxIvAXolhAZfMRagC8Y8JpBjAX/P3Wz45TkK/2J1xxcEpRkJtKCfRQMfQAAPQYyLlPDfzcAAAAASUVORK5CYII=',
  carrotGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHNJREFUSIljYBgFo2CYgomc/2lnINUMn8j5H6vB6GLo6si2BBdNADDhlc3/zkiyQ8gCyK5G9xUBg4lzIbIlyIAIHxJvAbolRAYfsRbgCwa8ZhBjwf9P3ew4JflKf+I1h5AFeA0nxhJcFlCSW0mL11Ew9AEAw2E2LwiWHwcAAAAASUVORK5CYII=',
  carrotSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAp0lEQVRIie2U3Q2AMAiErXEZGcShHeQcpz4YkipQ8CdqjN8bacvBlbZpfj4HEWUiyhx3VycfenCUASRVgCsAkGrrtT2MENCqsNf1PaaAPLyPRWjdvXkH40Rq+2WSMpEVC7ZTcAtnRN0x9S7doz1S1W0CEetci7TR4+QR60Jfhef7IqSLCIuiEwMgjRO5xVVesj8xln2mQEmtbSlis7Io2vZpHvkuXssMLP56RC4nRRUAAAAASUVORK5CYII=',
  garlic =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABB0lEQVRIS82VvQ3CQAyFnRUoGIGWgoYSMQUVJQswBwtQUjEFoqShoGUEClYAOZLRi3P+OaRISRUS8z4/2+c0NPDVDKxP4wIsF5PP7f6uSiodzOLn4542uwPVQMYH4KGocZFyIOXBictC0oDL9UGv54mms23LWa/mqV6EAM6exflCQBbiAlC8BMhATIDUXUoi2WsX/NvrRxFgiUuTayA9gBYvlUYDJKbkpAPIiFsuLMgPgLMudbcaGz1HJy2gVjxygae9A8DMvSw9gC6V6yAqhU5I4nsO/imTNUl6GfamiAN470eNts4C/x+/F+ZBExBuUDzVerNqYXkf7iIUsu69L1y4TTMAL+YLkFzsGSkFyYQAAAAASUVORK5CYIIA',
  garlicGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAADtJREFUSIljYBgFo2AUjIJRMNxA6nS1/6TqYSLFcB19LZItIdoCcsEIsyBWZxrJFjASoQZfpBKjf4gDABs7CRP3VfqlAAAAAElFTkSuQmCC',
  garlicGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAJ1JREFUSIljYBgFo2AUDDPg2WH+37PD/D8+eXz6sMkzYdOMTaFnh/l/Gf73GHLI/O0VJxnR9bHAFKFLwjRi04QOiFGDE8As8uww/586Xe0/IZ+iAyZCCrZXnGTEFWTEuJxor8Hi4MlHQbjFxOgj6ANsgJQwJ9oCGf735LiFdB+QahFJFujoa5FkOMkWxOpMI9kCYiILX1onP4MNGQAAbEJDfI/EtV8AAAAASUVORK5CYII=',
  garlicGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAALxJREFUSIljYBgqwLPD/D/NDSfJEs8O8//oGrAZQIwaol2XOl0NxVJiDGPBZ/v2ipOM2ytOMuJy+faKk4wkuxSXGLIPsAULXt/gk8QXRNgcQZRvsFlCbBygizGRZSMD7jhAFyM6kjw7zP/L8L9nePJREKtBuADOVITPAHQ5ovQRShnERDI2Pm5BNDlSMhpZuRndAkKGwORpHslkJVNSigiy88HQtEBHX4u2FsTqTCPZAmIiC19yJL4+GLIAAIDwnt7DsMsUAAAAAElFTkSuQmCC',
  garlicSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAsElEQVRIS2NkoDFgpLH5DKMWEAzh0SCibRBZGAv9P3H2Hd5gJjsOQIbvO3CRwclBnwGfJWRZADMcFj74LCHZApDhK2YVM4ipxcHDnyoWgAwGmQgKFnRAsQXYXA2z5NWtRQwRab0444FgEIEMz80JZQgMqcGaJKkSyeiRSqzrQeoI+gBmGLIloGABAXxBA9NHtAUgDbCIhmkmlMlI8gHBMgGHApJ8QI4loxYQDDWaBxEAZwZJGciZbVQAAAAASUVORK5CYIIA',
  grapeSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAdUlEQVRIDWNgGAWjITC8QiDTTPk/zEcbwrXhbJgYWTSyoSADkPk0s4Qsl6JrwuU6mDiyT9D1Es2HGQbTAOOjGw4Th6kjmUY3ENkAmhmOz1JkBxDNRjYQmU2RD9A1IxsMchm6PNGuRVZIFUOQDRxlj4bA4AsBAEAiL1mYqo82AAAAAElFTkSuQmCC',
  grapeGreenGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA10lEQVRIS9WVwQ3CMAxFmw04Mw5TcGUFBmEFDlyYgplgglRGMnJT2/8nUgX0GCX/fX+7SZk2/kqP/vG6q/fTs+tMutkKjoiLeRpwPpRqq708ahGorGVVwXJVWARFTCuRdV3LYl4AbAytsIq0exDEBag7lDtTxSqi9lAEYaOCAC9fL6ao4auI9rfXpBPCznwW1QfQ2zzbdDXlVRuOKdNApg8uAE2PdYqMfAfAXoDM/wKvigxm44liHQag7NXYbwJY9/A9iPL/G8DiBSNG1+3ncJMJ4HvL5oAZR2XBGdo0OvoAAAAASUVORK5CYIIA',
  grapePurpleGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA10lEQVRIS9WVwQ3CMAxFmw04Mw5TcGUFBmEFDlyYgplgglRGMnJT2/8nUgX0GCX/fX+7SZk2/kqP/vG6q/fTs+tMutkKjoiLeRpwPpRqq708ahGorGVVwXJVWARFTCuRdV3LYl4AbAytsIq0exDEBag7lDtTxSqi9lAEYaOCAC9fL6ao4auI9rfXpBPCznwW1QfQ2zzbdDXlVRuOKdNApg8uAE2PdYqMfAfAXoDM/wKvigxm44liHQag7NXYbwJY9/A9iPL/G8DiBSNG1+3ncJMJ4HvL5oAZR2XBGdo0OvoAAAAASUVORK5CYIIA',
  grapeGreen =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA1UlEQVRIS2NkoDFgpLH5DKMWEAzhwRFEQtm8/3E59d3Uz3gdiVcSZvAPxW9w8zn5OFHs+n+RkQGfJTgtABmOz2BkW/BZgtUCdMNBhqG4nAspxL5BjMBlCYYFJBnOwMDAEizM8GfxOypZgOTyim3/GUo/qDIIR91hYMDjC9J8gGRB1aqv4KBpC+OGRMc3Rqy+INsCjGQ7aCwAuQxvRCOnIGjQkJSKYF4nmJqQwojkfIBsCYyNLdOBDAYBsnIyeiRiK48IlUMgMwZHaUqw0MejYNQHBEMPACcseBmTrgJTAAAAAElFTkSuQmCC',
  grapePurple =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA2ElEQVRIS2NkoDFgpLH5DKMWEAzhwRFEOpx2/3E59cr3Q3gdiVcSZrD4H1G4+eyMHCh2PWJ+zIDPEpwWgAzHZzCyLfgswWoBuuEgw5BdLsAmBDf/w693YDYuSzAsIMXwTc1HGLgz3jIY89tSxwJklxv6zWUo/aDKwOPKxGBXroXTFyT5ANkCY6fJYEPP7ssF06CgwhZMZFuAnmwHjwUgl+GLaORgggUNSakI5nVCqYmifIBsCYyNnulAEQoDZOVk9EhEL48IlUEw/YOjNCVY6ONRMOoDgqEHAPCIbxlb63vgAAAAAElFTkSuQmCC',
  jalapeno =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA7klEQVRIS2NkoDFgJMH8/1C1pOhhIFbxf6cwUbD5+1a9BlHE6iNeIQMDA1mWEO0SkAV+adIMXz78IskXxFoANxwWZ8QGFdEWwOIAOVEQYwlBC9w5WP+nSUviTGyznj5n2PnjN05z8FqAbLitrgrD4ct3sFqEzxKiLMBnOMhGsiwg1vUwL+GyBKcPYBYQcj1dLPgkyMyw4soTrJFNFR9QFAeEggif6/EWWoTSPyzsybYAZAAxllAto2HLYYRcT7Bcx+cDYgwnaAGuYCLWcLIsIMVwoixA9gWphhNtAcwSEI2vaMaWEAjWByS0OrAqBQDXPaUZstITfAAAAABJRU5ErkJgggAA',
  jalapenoGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAwUlEQVRIS2NkoDFgpLH5DKMWEAzh0SAiP4hswh3+w3QfWXkAZ1DC1OFSg1UjSJO27Ue4664e5mf4/ekOnH9y+xOwPmR1IDXYLMGwAJvhMI3mnjJwX7HyqTAgOwJkITZLSLIAOTjQHUKWBcguwhYcMAthPiHKB7CwBdGwoMEXbNjUIyctojIaIQvwpVWSLcCVWnBZQpQFyMEASq6wZEowlzEwkFZcw5LpqAWgoIXnWGLCGU0NSrwSHclkWATWMvQtAAA9on8Z/HlQTAAAAABJRU5ErkJgggAA',
  jalapenoGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA/klEQVRIS+VUMQoCQQzcK2z1A5Z2PsBGwdYX+EZfcK2gjQ+ws/QD2lqczMHAXMwtWeREMc3BksxMMrlUaeCoBsZP30Ww2Eyb0XjmNn3c7V2x2Q6W23VDtMf9kgA+X93S+TBpvxp480h6CQCuIBY0SuISWHAoBSDCkvLtrQ5YTA9IwncIKvKAHVA15q/hGR0m8GYPcACgA0uk3TBPc1488AiojgSn+trW5XJJkiVQ47iyXFdVaT3JdkBl2q4q9daVgEX/AYv6PLHrGjbZ3oGPEmA88AAm6xnpUw+xoWuqBqOIWxQ59SECAtk1/W+CzkmIjEJyOmMv8qCQqE3/fYInGwy8GfZ6sOcAAAAASUVORK5CYIIA',
  jalapenoGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABH0lEQVRIS2NkoDFgpLH5DIPLAnNPmf+sfCoonj6y8gBeR+KVtAl3+A8z7fenOwwgw7VtPzJcPcwPpkEAxMZnCU4LQIbDDIEZhI1PlgXohsMsANHoloDEKPYBzJWwOEAOHlgQ4rIEbxChawZZABJDjmhCcYHVAmzhD4pkGDi5/QkjrmBE9wmGBdgMh2mC+QDmC+T4wJWiiLYAOcmCDOPmvM/w9bsi2FP4ggmvBbDIhfkKPf2DLNm54CE4uHClJpxxANOAHGToFrx/eJXh6onX5OdkkCXIrkfPzSALwGGPxxKiCjuQJaCIRk6mIL62hSg4aCi2AJY8YRaAkikxhoP0EeUDbBYQW48MXwvg9QCxQYGkDiVUSAoiMiwjLZIHpQUAD3LJGUbvuUIAAAAASUVORK5CYIIA',
  jalapenoSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAhElEQVRIiWNgGAVDDtzebPH/9maL/zQz/P+zS///P7v0/9zUDKIsYSLFcBXjWSQ7imgLyAWMpCi+vdni/+dHBgwMDAwMRtkzSNI7CoYwoFvGw2UJ2fkAPePBki/VLKAawBe+tzdb/D83NYPocgmrAaQUbGQZTmrpiQ4GtrAbLdwYGBgYAFTPX5fT1wXtAAAAAElFTkSuQmCC',
  pea =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAbVJREFUSIntlMtKw0AUhr/YokRqkSAGurAUgiLSraZvkT5BnsGlO3d5jj5B8wKum7qTrlqE0o0QkFm0xWys40InTm3Sm7gQ/GFIzgx855x/LvAXZNdMAFmtlwD4/KbxVlIQNfzAkYA8udhHj40fFC79wJmb6HcFUSjwA4fWzSPVesnYOkG1XmLUm0oAP3Dod0W6FoWC08uyMbgf85MOMA8KJJOZVLHrWZxdWQBpBzvbgMtHRQCZTGbS9SyuW+e4nkUUfnXhBw6j3lQWNwErW8bPr7jeR6WNpk3ldJ9G004TqL2wa+b6HSi4Hzi4nkWjadNo2nTaMU+DFzrtGPiwRtkUDxPW6kCH97sirVp10GnHRKHAPCgYyWQm9Q1f2cF3uK6nwctcnExmWJVdIwoFVmXXAJafoqzKATrteO4/CgXlo6Ixfn5dYOQmWGaL7vnZlUXr5jGXlWnRurYoeLVeyi00b2GlLTp81Jvm8RcT2DWTeJhIdRSX2bIKDhkWxcNk4RHLs2UVPDMBkFqjLhFsZouuzIumX/9tbNFVyJi7hTcOj/dSeBQKHu7ExvA8ye/j8/X81+/oHfIfC2frtx3xAAAAAElFTkSuQmCC',
  peaGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAelJREFUSIntlDFoE2EUx3+f3hESUbQXKFypQyg1iFNU6C0B41K7ZJIuSiI4NIJKFx0Es7YIWTK0QwsRBDchGDsUCprBG1pKx6pBkEiG4nWpJLWJfi7ekbP5rqkIXfqfvseD//+9/3vvg2McNURQMluM+uIz5yJUtuoS4NGlWyKTyhPWRgIFTgSR61qIatuR2kkdgMpWXeasBGkjTiaVl/10oAUlV1oNmTbilJ1NH1nZ2SRanhKj5pV/E8gWo0ROh2AbzNEIORIAzNnrAKSNOItfVmSysRFoMShm8ODFec8OlxSgO74WGhQ/f3UAKN3/phToOYNu8vEBUyR1Y18hobBGte3IsQs3aHVqSoGeFj21smLy6hOp70yLjQ+2L5ezPLtk17CVVvUUOMUgxcpDMf95SU4MDIul7bo3ZNcit8Ozr+6Ki8Njh+vgzdoC1bbjbZBbdS88//pOXnc+Ha4D8A5JmquTvqoBJowhMWevy5yVoPGx6a7xgRvlQ6tTo2TfIVYQ8l5piKlFk1hByGf2ZRkrCOnGrU5Nzi/fVvIoLzmsjfB27TVJ3RDNnR/sNvd8+d3mHrPWY1FZXRCZVF4pEHjJ3fv9978EcNOa+fOa2Zdzoezgf6FvgfcvvwfGKgRNvq/fsk+uYxwhfgNZt7hllq/TVQAAAABJRU5ErkJggg==',
  peaSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAQFJREFUSIntlD0KwkAQhV/EI/jTpYt2CjYBFYSQRhSsxSOJeIxcQlIG0gS0U7t0MbnD2iQhGXaXWbX0gxTDvjA782YH+GOC77kAIKpvs14ptZOp3dIulo5UZ5FYJFGAXn8IALAdT6aptcfTAaPxAACw256l2o7szyLPlDenPO4v7bk0wa+T1FAPylgK9aCMzeGaqUJlYBOWmSqUHlB0fdaNd5ebQJfkEsZ0vAW4VTLNFEkUiCQKRPoMKy0ARgW3a4rmbcpYicl4s2GPt8ku+pS6j7SXFabvQupBkWf1RFBu15S+C+3EfLyLuPunVYHvudZsvhfN+BLGXycx4mdL7k/FG2sdid9DA0ygAAAAAElFTkSuQmCC',
  pumpkin =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAu0lEQVRIie1UuxGDMAyVOUomYA52yRzpU9IzR3bJHExArzQg54S+puIur0On97GFBXB3lAYOZvhZA5wfE3283h9Xo2sVj6JPM4CSAwRuIHMCjtD1SidAoaaJub3cAPEpMBZRyOolk+IRWlCWqi3OYN3yohrnMKD06wYwDj6Z18ah1nYt/DUwk3FDLmjhym8awt/guoE2TG34HOJDi5I1Q/ehZcUtDl9i6rrYU9VGu0/cRcSVqecwwb6b4wsIwjy5qWuN/wAAAABJRU5ErkJggg==',
  pumpkinGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAgklEQVRIS2NkoDFgpLH5DKMWEAzh0SAaDSLsIVC1zu7/lYtPGTY13iWYSHAq8KtX/q+jLw22oS3oEFwdzHCQOMUWwNwPsghkCchSmBgxhoPUEvQisqGkGk6UBTBDYRYR63KYPoI+GLUAPYjgqYRgGYBfAdxcouOAXAtHLSAYcjQPIgAOZi8ZT91aaQAAAABJRU5ErkJgggAA',
  pumpkinGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA2UlEQVRIS2NkoDFgpLH5DKMWEAxhqgSRX73yf2SbNjXehZtLkQUwg1+9+4PiEzEhFgaYJWRZgMtgZFtglpBsAchwdBeDDP786jvcfF4xTgayLMBmOMxgkKEU+QCX4egGgywhKg5g4QyLLGQL8LkaZAHBVIRsGMg1IAALd5DhyK6GyaMbDAsujEiGGY5uEHqOghmM7FpsuQ7FAnTDkcPSIlcenJmINRivD2CSyK6DWXBi8kOSkjbRioeMBSiFFsGiErcC6hR2xDiA6DggxjCCyZRcQ/DpG/o+AACfiHQZOpMMxAAAAABJRU5ErkJgggAA',
  pumpkinGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA20lEQVRIS2NkoDFgpLH5DKMWgEPYr175P3JQb2q8Cw8ZsoMI2dBX7/6gRKWYEAsDzBKyLAAZjm4oemKBWUKyBeiGf371HW42rxgnnE2WBciGwwxGNhTZF2RZYJErD45MkOHYDAYZCgMkxwHM9eiGwwxFTjnIPiE6DmCuB2kmZChFFpyY/JBoR4EswqkYFiSwyIL5gCoWwAwHGYYcNCAXUWwBsuHIYUk1H4AMwuZKqllAcx/ASkdQWYPsE2r5AKXYpaC2o7y4JtZykjINsYaSlZPJMRxvTibXQHR9AG+ifxnYavyUAAAAAElFTkSuQmCC',
  pumpkinGrowing4 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA90lEQVRIS2NkoDFgpLH5DKMWEAxhqgSRX73yf2SbNjXehZtLtgXIhr569wfFJ2JCLAwwS8iyAGQ4uqHoYQWzhGQL0A3//Oo73GxeMU44mywLkA2HGYxsKLIvyLLAIlceHJkgw7EZDDIUBkiOA5jr0Q2HGYqccpB9QnQcwFwP0kzIUIosODH5IdGOAlmEUzEsSGCRBfMBVSyAGQ4yDDloQC6i2AJkw5HDkmo+ABmEzZWyfEwo5c3jT/+IigsMRdh8ADL8YrYeSmmgP/USAzGWYHUFckFmcEscbHCBwjeqWIASDAQLe9wKKC+uibWcqIgi1jBs6mhuAQBXJIAZAYF9rQAAAABJRU5ErkJgggAA',
  pumpkinGrowing5 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA/0lEQVRIS2NkoDFgpLH5DKMWgEPYr175P3JQb2q8Cw8ZsoMI2dBX7/6gRKWYEAsDzBKyLAAZjm4oemKBWUKyBeiGf371HW42rxgnnE2WBciGwwxGNhTZF2RZYJErD45MkOHYDAYZCgMkxwHM9eiGwwxFTjnIPiE6DmCuB2kmZChFFpyY/JBoR4EswqkYFiSwyIL5gCoWwAwHGYYcNCAXUWwBsuHIYQmz6OnCxyh56vGnf3iDDEMSZBA2V4LEQYZfzNZDsUB/6iUGfJZgWIDLB7J8TP/RDYfZhM8SrN5DLsgMbonDXVyg8A1r/USMBSjFLRVrOUaS0jQ5Fo9aQDDUALfWiRlPIsF9AAAAAElFTkSuQmCC',
  pumpkinSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAt0lEQVRIid1UwQ3EIAxzK/7dI2MwCaMxScfIHkzAPSoQnJKS0uvj6h8SOI7jALwWRJSJKN+957RHPqTjECkz8zJ7bx0p9CHB0okGsQAzL3vcZjntsMzBOqv/RZ1626aWmhm4Ql7jBoiRKwKuFhf34BvWvZCEuHqINot8SGoRSUjt4Iy0COhsNMJkUVtkJOZxDBfv15vZWXQlLe0bQLfNPAON/PZ3bSI/QdfBbFL2uD2TrPd/1QDwAfx6iTTKaBYOAAAAAElFTkSuQmCC',
  spinach =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7klEQVRIie1VXQqDMAz+OkfBu3gtnz1Ln3et3kUYSPegwTRNjNsYbLAPSjUmX/6aCvzxqyjbchEOCCzdgtSvT9PscmnCgjECQ1dLiYzI87LupLd+b/gumlcM3U5ASD0wRp08L+S4yVx63NO3iHgQGkQmV13LIeFyGYSA3QOLzMomL8Dt3nD6TdYiPIr6VIm4oVUmz9EGeYrqJksyWRaZpXJU9WPKjTw5OXpqDngz+bsWNe3GHEgHAdNcT6eVCc/gQMe7iwK0vmjNNUpkDZrumJeqvuhMG7vJ3LAl46S03kbBGAtSf/pf8JqTD5J/Jx5qr2HmmdxT5AAAAABJRU5ErkJggg==',
  spinachGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdklEQVRIie2S0QnAIAxEzwpO41pO5VpOI4j9UmyrMelfSx4ICnrPgwCKonwfI7odXO37mFlvDzKsrRFvn7JXgllYOwuYC4KrPWz1Y29ZLegG90AASOXaZCOZC2I2SIUvFQsoibdgybcCStJgiFazzBpBYabyV07e8yJJjGp+5wAAAABJRU5ErkJggg==',
  spinachSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAV0lEQVRIiWNgGAW0AE3Rtv+dDBT/D7Q7BhA0RdtSzftM2AQPXH1CkiE0jw9q+pi2gC4upUp40yUTDcqIczJQ/D8oHTawgKySFVc4Ui18sblohJf/QxoAANEqIe1OcIVOAAAAAElFTkSuQmCC',
  strawberry =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAR1JREFUSInlVbENwjAQPCNIhSjp0oUGJohYgClIxRCZgDnYgg0yAGXS0aVOQ5AwTWzZzv8TU8JJkWznfee/s2TgH6GdT6oBAKhY8uKc2cmlbAyHIVSmxvybRQqoYSMAYBDTxTmz49GGCPLRZqIbu2Y6mCKgAaBP89GP5F55IoGYAoBPFuk+zS153XZYHGaTyb2BJMAhuVd2zIQvdiCS120HfdrDdOiG74LrwCOv2w7b4wrP64sspuyKuqab9ZIlJ0g9UAK6T3MvUAnGqkvZkFaxDNypQ2FTx+UVZiAGy8HNyLlZKhT4itzFQO4dWjQ5tEOaU+Thgg1XupJTT84KxCD0m8I8ijGCmCsgbarbDrvHTdo3WQDgn8LY1+9H8AYaOaFdHXkaZAAAAABJRU5ErkJggg==',
  strawberryGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAZpJREFUSIntVDFPwkAYfWdQoAYMgdiIcSHK0ASHslgGBiTGGBLZXJmMHXCE0ZmasGDSVf8BA4MhTiyd7OhiogMBAhEMDmrCcA7mCpUWMDI48KZe79173/u+ywELLPDvQWYhZUoBeH0cKp06Ta1vkbfXd1xnX/5mkCkFTOvaoEtlSYSq6WAmo7AzXJpUcW3QpZzHCRe3YuzJkohKp04BGByvj7NN4LATr3TqrGLKhFVNBwAcrG0QAD85lt2wTMAOMjy0c8b3kX+TVPstWu23DM7o/tQEnMcJ9ABV0zFqki0ngTSgarohrGr6RHHLBLe9pklAlkQIvAKBV0w8VdNxyu8SgVfwGGzbXpaxBFeOFEmUBYr0UGi0/8yc9V6WRBxrN7YzGDNINAQA3y0ReAUXnjg5Ke+ZDBlkSUS2nMRhMEIiuLZMYDlkAOTe/UyUjyTZbvCGIUN82U/OV6OE/dtp8jYyFglchYJp/ZnPo+LVSc59R2UMh372tA/M+BJMRTjmQqhI6KUWpaEioeGYa+azkyqgv6xjPmkWmDu+ABYSnXTgyhitAAAAAElFTkSuQmCC',
  strawberrySeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAmJJREFUSIntlL9P1GAYxz/vtbw5rw1X7gwOhKRAIrtMjCYmJCbEyb+BBRddWJxcWHTBxb/BRUNiojExrsawuAgJeAlBPQ/uCrRHeend63Bt0/uJTjrwTG369vs83x/vA1f1r0v8yaHXj+4A6Gl3jmOvLtyFRVRL6byZF2bOZGpp9e8bHLx9nj5/3/1K48c+Z81AjzsTwl1YRBpSx9+Ef1QFoOiUuPXgRRdO7pLhNaCvu7OcNQMAceI1kIZMhhNCtznxGrrolPQgAHMUetSORBiFWhqSe0/f9zEDOK3XmHbnaAa+KFj26AYfntwHOlSnllbZ3lwHEKqlBjFDtZQoOiWs8qSwypPY5RujG5x4DT3tzkHszfzyGgBbGytsbaz0MePsPEYxsYtlHbWjPk+7GmSpZqXY+fSRolPSzcAX1Z0vWO4Mh5U9YQJjCN1S58JXPra0NT3B6TVZFCwby50hakepFAD7lV0Klq0TZoeVPX5W9jTAxXmINKRQLTWaQRKx7c11wijUtrQT6Rh3JsSxV6folNLzU7M3RRuwrlnM3H3Yi92ZOPuS6DzmOKlh0pCp4XE8kYbEVz55M4+ZMzUghl22LomagQ+gLzwPacgUMCnVUjq5YABhFGqA8PS4LwgDGxzVqunPcTR11I5Sw/NmvotxonujegCg4wGHN4h1TkF85ScSML+8hpkzIZbVlnbK8rRe6wpBtobuoqzmymsQHP0COkH49uYZGanE53evGHcmALj9+GUXztBVkb1kzcCnYNm6l12yTZM1MqguW3YAFCxb71d20/fYHxFG4chVfVX/R/0G94oNtjdxwCgAAAAASUVORK5CYII=',
  compost =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAANFJREFUSIljYBgFo2AUjAKCgJFYhSbafP8NlP8xXLjLxMDAwMBw5uonovQSpchEm+8/Pnl8lrFQariB8j8GBgaIGmwWMWHTlOLH899Em+8/suEQg0h3DIYFJtp8/2HhjAyQxXwc5LGKYwN4ZZENQgZbDjzEKl6cZIThC7wWIBtUnGSETymDj4M8Q++8cwwMDKhBhREphCKVWACLcPwBiOQ6YsSQAcyhTNgE0cGTx/cxxHDFAzrA6gP0JImcUgjFBbp+eBxgcz1y0cDAQHzxQFcAAE2zRkug2a02AAAAAElFTkSuQmCC',
  corn =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAbRJREFUSInVlDFrwkAYhh+lKB2CToVupW5C6VgQOrl07OoiCrp37WKhS/5CQUERxNVR/0CgowhxUtwEJyWDxKHpkNxpktNYLYV+S+AueZ/3e7/cwX+v2C9oOIf04ueKr6cVlsMc62klCDsb4CyHOWzLhLmBbZlKyKkAZzGrA7BJleE6txdycZLzPrBqwtwg4UE0LYttmW5HO/VTgLOeVrAtk6SWxQaSWhZWTWwPlFg1fR/Iqd89u22Nenv/LGcxq4cEAJgbbkxA+t7w6caFeKmYoavXJEjlPLFquo6Fc7YzSGrZkLgEiBqMOyqIs+wjY7HiD248XtYJbxaXt42QeAiggDjraUU6tC0T7etTwkQn6SeU4hAxZOEcAs+5IYeavqnuFVd24CvPuXAqn976VYS4BIx6xFrtSWhzN2vbMtmkyrKDfZkH62BEu4PNv1QBA8/QUeKRAJF1/q1BV69t13UovL47B87McYDHDwCDrl5jMO749rp6jQLREN9JLhUzcqPVniiFg9VqTw6dfnUHrfaEUjGjFA/+DFEdHH3ZCeFjct8t38viighGdYqwEhAEnSP8Z/UN/uTZrzroGIUAAAAASUVORK5CYII=',
  cornGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAFJJREFUSIljYBgFo2AUjALaAZdGhv8ujQz/CaljItfwPZfZiFJLsgWkGE4eCGH7zxDCRlTwkG0B7QxngAQRKerJiuRBZQEjDnFKwhiXmaNggAAALTwUmwa1nZEAAAAASUVORK5CYII=',
  cornGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAIhJREFUSIntlMENgCAMRb/GdBu36AjsY9jHEboF23DBExyMUijhxjvDf9A2BRaL6bBHYo9kvb9r4QAggWCVVAU5fFTShqMER93lUn9QuOPW/aguwYekZQD6BK9wCaT2xiTI4QDAZ6yePSwCCVSC5UK1NyYBn1ENNjNvTI1MF/zVcWQlzOnNwswDkWwuFghkVfgAAAAASUVORK5CYII=',
  cornGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA3UlEQVRIS9WVsQ3CMBREnQFoGQBqiqxCBkIMxCwU1JkiA4Au0kUfy/Y/W7EQaVLY/u/f3XcyhM7P0Ll++C1gup3fVPi4z8lmuCe3XlSAw8/XsjLGyyHYIiycW2djkkWn63FVQohaHGckADZaCLtOKYuHRgYQAhUAxJblptEFxCF6oVYpsF5b/3MTk1IhTxH9xns3ADsqjav3JXAziCFquFX3wEKsRUrgsgILQQaqbU0AwOwnohR8E4AXTZmoJoBSuClkHIL3u98DO+t/A9j+ZN5NTax/5Vodci2wO+ADXJmJGbhBn08AAAAASUVORK5CYIIA',
  cornGrowing4 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA9ElEQVRIS2NkoDFgpLH5DANrQXC98n+YD9c23mXcMtnnv0/uFjgNkoOpAcljCw28PgBpPn/5M1ifoS4vA7IlMIPR5dEtISqIlILEwD4BWWL6kJ3htPxPsDmEDAepIcoCkEJkS2AGI/sMV2Ih2gKYJSBfgCyABRmhVEjQAvRIJBSpJMUBckTCXAwSw5ViKEpFsPAG0VSzAOYibMmVUNjD5AnGAbolxEYuyRZgy7XERDjRPkD2CSgOiA02sixAz8X4Ip4sC2AZjZgURZYFxBhMViTDIprq+QA5zVM1J2PLTNSyAF6TEZtjkdShxCvJkUyqhTS3AADroZQZ0g/6xwAAAABJRU5ErkJgggAA',
  cornGrowing5 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABBklEQVRIS2NkoDFgpLH5DANrQXC98n+YD9c23mXcMtnnv0/uFjgNkoOpAcljCw28PgBpPn/5M1ifoS4vA7IlMIPR5dEtISqIlILEwD4BWWL6kJ3htPxPsDmEDAepIcoCkEJkS2AGI/sMV2Ih2gKYJSBfgCyABRmhVEjQAlhYJ4poMoAimFCkkhQHyBEJcjG7KB/Dz9efwJFNyOUweaJTESy8QTTVLIC5AltypYoPkA2BWUJs5BIVROiuRI5gUK6e/+Y6WAm+ICM6spCDCxbZVM1oyBag52J8viDLB7CMRih4SCoq0H1AbFIlywfEGk62D4aEBfCajNgci6QOJdhJjgNSLaS5BQCfTpUZV5cHzQAAAABJRU5ErkJgggAA',
  cornSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVRYhWNgGAWjYBQMRuCtxfDfW4vhPz3sYsFmuYetHpR36f/WawyM+AxAdygh9QQdAAPn774nqBnZsTD13gyPCToaGTCRazkl6pEBVpfCgpUYn1AaBXQB+BI1zjRATcvxJWqsaYAWAFc6oYsDKEmkVAH0LNhIBjizDL2yF85yAJFyIXH48tljmjgCbzYkN/GQUpBhdQBE4yWyooDUygxnCFAjuMWlZAlWTlQvCWGhJy4lS22jSQPE5n2SghnZQGrlCKINQW98UCtbklwXULtcH/AoGAUDDgAvcmw2gDIKjQAAAABJRU5ErkJggg==',
  potato =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAArUlEQVRIie2UsRWAIAxET58jULuJm1m6mZtQuwMWyhNjOAgWNl6FIP8IpwF+fa2ucV+oZVkNAgCsy/HgN2B0x3iadZ7FIERwVGqQM+mtcL9dkyk8p5oKHidnklWUKqiCp1VJMYOwLvfNcszAJQP15KPTM2BZaBmY7jzVm6+oWdRA3jG789yPZq5ACz0HB4CBwWR4WpgMzhaKQZ9gCi8tqo2tFmx5Sbbm1hb/6yPtXRM6Z/YOWwgAAAAASUVORK5CYII=',
  potatoGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAJhJREFUSIntlDEKwzAMRb+Tdg3oAJm9detBfFIfJFs2zT2AIWtI3KGkQ6gixR0KxW8y2H5PYDBQqfwMHyj7QFk7dymVd7fltQZljslJZ8WNvRAAOCbnA2Wm+b137xtMYwsp0linZZqxlwPA8FgP76sBTeLTVZzeHNhEZ+WmAMfkPoksclNgi5TIzYFvqAEV6aHUP6bAWflXnpbpO+4f7cK2AAAAAElFTkSuQmCC',
  potatoGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAP1JREFUSIntlD0OwjAMhV8L3VAlH4DZWzcOkitwwR6EjS0zB4jEGpUwFAc3JJS/CfVNUWP7s1+SAot+ITYU2FD4JLd+pXjbDbDkkUI0uNTEOlcQAGzvKjYULHnglAdb8thtazDGnLYbwKBge1dJXJUmtd2Aw+kCdk2ElKaz5MGuiWsA2G1rnI8rCCRapIvHZJngNpF8t+THbqV47ypZS75ocgZ6k12DthsmMB17Pq7uIDPaIpAsQAeUutF7uqkUos9gMkEuIJX4XrIlzX24ptHrZKIctGTLW9Les6GA/ebhvj+7abMP7Zldr8TMAr7VAphV6XA++jXP1Fz0r7oCqWWiCeEH+pYAAAAASUVORK5CYII=',
  potatoGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABQ0lEQVRIS+WULQ7CQBSEtwLBj6nClIQEj+Ai3AKJ5R5IBHfgIgg8CQEMCsOPQJS8pdPMvnbbpoAg1PRnu/O9mX27gfnyFXxZ3/wJYDSOYolyvTpax/q9KObSiESsO2yb3eFmmmfLMfcwMP1ey5w211QbcA3LALg6eRYxXAyQb/LOMIFodw5AV8sTdGUiDICMsSNxLO5kfgpgca6Yf4YjOMEYYIgP7jIAHQeyxwQIcOUshgYA0AHoQa4mD6Cr1RFi0Z2ImFy0wOKA1wfOsQ7cUWlfcytyv+dBAUDVXIweSwGoIm+yD8ixcAPkOuBKfTvTJ8JO9IZz1sC3G3UU2uVbR0WVGD4FsAfRaBxJB0Gz9Cwr/SFRihfTgX08Xx4m7DTsfbbcy6dCjSoAKw5hHcdkvi2E+ACvc7ne5WhWcVAPk8z6fcATQYkRKFHnkOsAAAAASUVORK5CYIIA',
  potatoSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAdElEQVRIiWNgGAUjD+R5MfwnR9+UVIb/2PQyoSsi12G3nmIXZ8IujAmI8dmkbQyMxDsJiwXkBh/RgJIgHAWDDFAzMrHmg1tPqWcJzoyGK2cOGMCVCalaVBAs7HABYuJj0jYGRjVpTHGifUAMyJlNQWE3cgEAMasir1+5WT8AAAAASUVORK5CYII=',
  sweetPotato =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA6klEQVRIS2NkoDFgpLH5DKMWMEQZ8P5HD+ZlFz7DQ4asIEI2tDlIE2z+1TuXGbRVdMHs2nXXGWCWkGQBzGCYobgSCMkWEGswzEKSLAAZjsvFoGCBAVjwkBRE2AzHZShycBHlA1yGI7uUojhAtwA5lRDK/QR9QIzhyBbiSqIgh2AkU2IMx+cDZNdjWAAzHFdwEAomdMNRLAAZ3lmQxvDr0WFCQYxVHpvhFFmA7huSLEDXjC9oQAaDAHIBh+xFlEjGl2uxhQsuV+O0ACSBraREz6UwPi5X47UAWZJQWU9MaiCpuCbGQHQ1Q98CAPnipBlXIGtSAAAAAElFTkSuQmCC',
  sweetPotatoGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABE0lEQVRIS+1VIQ7CQBC8fgNXQ4KrxRE0CoWo4g1oBJo3oCpQKDTBYetIMHV8o2SaTLPd7vXO1DScau72ZmZn97aJG3klI+O7P0HQ4QlblO3SmvmX16qXqTxHnBWDfdMiXN6fV+5dfhuOV/HpAOB8mc9b/xfZzF0OT5PEVCbBiSJJNAFifCQdAuviEAFIsZCNzpL3gt4ycLtJ3TF/NPGnYl3f7lUDTOW+OnhrQI+hjOAABokkoIAoixCsbfIRgIidRDEWSa8GVvdI5czAssvquJZAt6YO1iS0hvvMRr+HDoH03SoawLAv1fPbN5R6Fg29SqplJ4XAvS/ZUkP1PIsBjyVoZ9LAbPZO5QmP6+CvKjJgdIt+t2zOGYhEhSEAAAAASUVORK5CYIIA',
  sweetPotatoGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABLElEQVRIS+WVoQ7CQBBEj9/AYUhwtTiCRqEQVXwDGoHmG1AIFApNcFgcCQbHb5RMk2m22927MxWEc727zuvOTu8Goecx6Fk//CGgWI0q2Po4vbOqdzdRiD2CIOam5ThMimE4bG5ZEBMAofV+Fp6PT5OB+/EVIM5BiA6JrqwDsMQhogGxOQlpAWiBFV0AMGQVFlTb1wBS4vwq7rOA2j6806nA+vrlYhS25bXeuzvOq/Pl3VTigTDfAUBAVsJNFAZEA7CmGw4bTYC2yQMAxBizJ9J7rNHSVg9kNCGurWEFMbvMmHq5lwBpE/sEu2Q11t9dV6B951FAAS3oPVsBaVlknTESkgJGAd694AE0zHs/60S0IL8FYIKkDYxq6srNsai+YBLD1ckBpMSj670Dvl62CygLcuKEAAAAAElFTkSuQmCC',
  sweetPotatoGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABSUlEQVRIS+WVoW4CURBFZ38Dh2lSh8WR6qqqChTfgK5A8w1VK6qqqpu6WhwJBsdv0NxN7ubu7Oy8Lckq1gDz3jt35s7so7KJn2pivt2hwOJ1fqWth49z0YHBDQoCEDDEluuHhv+4mNn79qeJZ30MFwHa7Fd2PFzas7/1yQhnkCIq4AV7AhEcgEjAx6KqOgJqgS8bMDxaRVYVK2kFSnCCCY0EvXUQ6VUQNUyzpg2IaQ98f5BATwBwrUSzzazxzcbeUMDblAmw0mhswQl7oKOpDaTfbLJf0/6EY5rNPWAvz3N7W39Xu/rp+vl17rx0ak/00jVN9r4jBihhAFNAhbLMaWFnTHkl4JNQ/Y4YfkOEiemZaALTe8SLKNwnMXQfFW/DqBLCdO1mgcwuWvXv2zQ6QP+5NgaOvUWLzKz9g0kyHeSMEcgcKK5NLvAHBzcHKPX7AFMAAAAASUVORK5CYIIA',
  sweetPotatoGrowing4 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABQElEQVRIS92ULQ7CQBCFt9fA1ZDganEEjUIhqjgDGoHmDKgKFApNcNg6Ekwd1yiZJm8znZ3ubCA1rIHuz3z73sxs5kYe2cjx3Z8Cik3ewrr63PykMjhMwbfHhXvW747xqF6OQzic1q0L9ABacK6E1ufl1NfFrJi40+4ehXiAPEw358HkNyg0z4dUFCjAZm4TrOJAbU5TpOZABkIw+rVUSUigYCg4zeMw/efWDJ0hu3o5IFsoaXJoicUch/JzqL4OIKtH+mslHBBuYQCIeasBcFtNHe8PrwAbtXKUfmOPZo9szB6AFrXylJ3NrZAQFRDLgwyOQrCsgYVfdXKKNQEAKnip8bysV7m7XBvfaNYToQJk/ePlpIY5VMtWAqyXlOKZbz0F3pe3bh8gKc90kgJsosBcHYBByysTpoKUILE9owM+Bp4PKJgW4PEAAAAASUVORK5CYIIA',
  sweetPotatoSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABUElEQVRIS2NkoDFgpLH5DMPIguRM+f+w4Jo7/SGGz2Dy2OTwBTPYIJDmyAR9uLrlCy4yIBsEkq8tTgbLN/fORZEjFIeMyJrvvD2DYQmyPEwS3RJ8vkexAGYAzCKQT2Au//tEhoFZ5gncATBLCPkeHkQwg5C9DDIEBG5v/8Iwf0E3Q2JCKYOqJw9YDBSE6L5DdhgsiOGRCfMmsotBBh568JbRTkH4P8gCEEAWA/FB4jCfYQtirPkAZiDMMJBByGIgvpevF0NosCPY0raVjRhxjeEDdBXoloD4IEO3bd4GNhxEwwDIl7hSE04JXBaADAIZjs9QZMvwFhXYgoUUw0EWEbQAFBwwV8OChljXE7QAFrkwS0gNHqIsgFkCSzlUDaK//5/+Z2aUBgcjciqiahCBLMGVBGGW45InOohgPsFFU2QBcjDhYlNkAT7NxMgN/ToZAJfI8RlnygRTAAAAAElFTkSuQmCC',
  olive =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABdklEQVRIS2NkoDFgpLH5DKMWEAxhioMor0rvP8yWSW2XMMyjyAKQ4bpGInBfXD73hgHdErItgBn+9s1HuAVaGVcY/Bh+opiJ0wJkr4NMQHYZSE5KjhUj/Im2YCMDx//rM7TBBgiL8INpkPdhFuGy4Nmj38QFEbIFMGciW4TN9dgMB+nFGkS4XAizDGQYyBIQjQ0gByfeOMDmUpCBYIMZ/zJIyXKhmC8swgvmP77/laGp9CTYbAwL0CMXYsI/Bik5djDr2aM/DAwM8KQPFf8HNwoUlOIhR+CpCcWCvCrd/xCDYML/IZH8n4Xh8vnnYHGIrxgZYK4FRT5ED8hSkL5/DMipCcUCSOTqYgSrsLAQkgVsDFoZl8BqXq6xYbh87jXUgr8MDAzMcF9OajuPGUS4LIAEzU+oDxAWXJuhA44PkA+ePfwDjhf0PEMgiBCegVjwH+pahDZQnMBciy1FERnJiJyML4cTZQHWhE2BINmFHbF2jlpAMKQAvHOcGReApVIAAAAASUVORK5CYIIA',
  oliveGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABbklEQVRIS2NkoDFgRDZf20LqP4h/9cQzFHFK3AA3CGS4e4Aq2KydG27DLaHUUqwWwCwB0dgsJcVHGEGEbCCMje4rfBag+xgjrEEKqqN1GVqXXkZxPXrcYAs6bMGM1QIZJQ6wI5/c+wGmkfmgBAAyCJsYNh9jBBFMI8jgeEtVhoXHb8NDBGYhsqUwh4B8feYrxEHIiQQlktFdi42PHEcwx4AcAjIcZDB6UIItQA87mCJYOINct+fwc4aTj97A4wWkxoSbAyWusCUGDAtwJVFclsBcjSs5Y80HIJfBwhNmobmcCIOLrSTYJyAalMqQgwNXhsRaVMAMg4UrKOUkhen9BxkMAiDD0VMRrryBtcxBToagCAS5GgRgPgDFBXJqA6UuXOUX3nyAnARhLgRZNm/VJax5AZsvCGY0WPAg+wBkASz1oSdLdEtwBhG6RlgcwHyAK8yJsgCb5lELCAbpkA8icGMADRDVMCBKEcHww6MAAJp4MShPAj9kAAAAAElFTkSuQmCC',
  oliveSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA6UlEQVRIS2NkoDFgpLH5DKMWEAzhgQ2i+BCL/wvXnMDrCJAaZG+gq8epGaSxLESfoWvNRQZslsAMBqmRMTFheHLmDNgedPVYLQBpntSRjFMTujzIYJglRFuA7DJkTTCfIRsKY+dVzMXwLYYPcLkOphlZHl/QwOIFqwXIrsfmdfSIBRmGKzHgtAA9geOKbEIZgWAQ4Yo8QgbjDCKQBHpEYos8qlhAafiDHIE3o8FcCYtAXEkUX/wQXRbBDIf5CjmJgti4gpFoC9DjBl/uRY4fkiyAWYIewfgKRJItIDb14E2mpBqCT/3Q9wEAeMK+GRpnxQAAAAAASUVORK5CYIIA',
  onion =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAOxJREFUSInVVCsWgzAQnPCIqeUc2MqaCu5QhazkAlW9QGUlqndA1FRie45aTHhQ0/RBPpvl8ehnVFiWmZ0su8C3sVrL3nV2PbsQhRKaWgkO0Sy4XHBFgw7mYpLAsPqmVoLzDStJk+53WwDA+XIFV2DxKwpWEUfoAeB02IzixfEGAGg7moN8GUfoVZWTBcisJEW8VzQif9zthFdMVfnbJVvAIk9SixhJyhKZ1mQt5nLkgSXgrd50ArBc/NYk/4dA20HIrJxM5JsH2sHwj9HnUOMNeCeQnAUjRk3z4quCvexMId2nWcvOJaQRIv4YnrKKcGJDnEswAAAAAElFTkSuQmCC',
  onionGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAExJREFUSIljYBgFo2AUjIJRgAm4zFj/c5mx/qeZ4a1LY/63Lo0h2hIWUgyvzg9nePv6DUmOYiJFMamGk2wBOYARixg1IhCbuaNguAIAavoTMVykVcgAAAAASUVORK5CYII=',
  onionGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAl0lEQVRIS2NkoDFgpLH5DKMWEAxhkoJIwpT3/4vTn+F60PnYbCNoAbIhQ9MCkLdx+YIqQUQXC5AtgbmaGNeD9BGMZFjKQDd4aFqAnM6R8wO+3EZSEJXkhYPN6pm0EkwTYwlJFiREuoANFhEVBltCMwtAlixYvmfUAtS0AUr3sDigNIj+EyzkCSuAJx6iUxFhM7GrGPoWAABQhIsZroeW7AAAAABJRU5ErkJgggAA',
  onionGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA70lEQVRIS2NkoDFgpLH5DIPDAglT3v8vTn8GOwYXG1dI4PQBMYbC1CCrRbdocFiAHDTYXE2WD3CFN1UtwOdyYiObYDJFdzGID7IYW6rClpIosgDdMoosIBTRJOcDZA3YggkURPhSD0w/wSBCdzlMI1UtgFlSkhcONr9n0kowDYtofAUmUT6AWZAQ6QI2S0RUGGwJzSwAWbJg+R6qWgBO+zgA3lAgFERggz+v9mNgElJk+PfuPgbNG7oJb4LBZ8H/r3vzMQyFmYZuGbfzRJAUhnnYLMAXHPgSDLIc3FxCQUSsgeRFEMWmYwszahiKbAYAYw7wGetnhO0AAAAASUVORK5CYIIA',
  onionSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQklEQVRIiWNgGAVIQEFB4f9AuwECiHXJ4HExtQBFPhpawTG0XEspGPy+RXfh4HcxTcEI9z4UUCUUhk5QDh2X0hIAAFsvEdRqfNUJAAAAAElFTkSuQmCC',
  soybean =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxklEQVRIie2VPQ6DMAyFX3+Wbp27IuVuHXsajsCdkHqHbkyVO4RExDiOQ9NOPAkJiPO+h2MJYNcfRfOV6NDKvOv9zfOe+h4bAbJqAYjpfwGg20Mv+AZAXQ9cHDCN7QFJWzTIFoDac67aMSU3AO+XvMhHFKj7gpj8dLVvsgLitIT0HCKlF19I5iH5NPoD5cqZWwCrA+UQzRzQW1SclpJ5bpEAwA3+QZqY2bhoLhUkqcNBLiGW1EudtUXBuMo8V7z6aWwx3mXWB53sOFv+9drCAAAAAElFTkSuQmCC',
  soybeanGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAApUlEQVRIie2TwQ2AIAxFq/HCCg7Afk7ifgzgChzxYBp+qq0VboZ3Eoz/t/2VaDDoZWr5aN2o4PnYdZ3ZI4aC/BzidQ7xbug2WDcqLIQiIRLlVE0s1NZkpTnVdyickz2ixXLnSp+q5ntLnMiRQYj3UWDVMiOJ6S7njgZ4Z3XjXlMMHOGxaVl8+g/YRAZuBf2agQYLdm2R18SiuQMvWgXq2nVoDv7KCeIgQHNazaXdAAAAAElFTkSuQmCC',
  soybeanSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAr0lEQVRIiWNgGAWkgt97Ov+fm5rxn1rmMaIbDmNfvnmfwSh7BiOmFtwOu3zzPgMDAwOKPiYqOBLuMF11RQw5FAtYXcoZL9+8zwBzCTUA0UGADyDHGSnBOjQASd7BlVLwAaJTEb6UQhULKAbE5OBzUzNIzuXwcIQFAak5mBCgeRDBLYDl4kEP0OOSqtkaW2lMUj4glIKwBTFRPiClnoA5AqaGhRgLSAFkJ3FyMhldAADK8WmxC7dL5gAAAABJRU5ErkJggg==',
  sunflower =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABTUlEQVRIS7WVPQrCQBCFJzFdOlsVb2AnKIinEDyj4ClEULDzBqK2duliIhN4YXZ2N9kYTZM1bt43b342Ef35in6hX+Zp+T5nNFikFCWZodkbAPHhOqbXobAgTkBTRNKxFMdzDbEAbRFJQH6kkiPnazaN6XorqjVDkhVV2gYgJKJeDkIi0k3R5riXA8A6dVFTRC6h8ZxKBm22I9rvnvS4mGkP7iIXeLLMamEJYChABgB/8F2+0FR8QNgFO9BuaoAU1Zvaii/f1amyHGAD7gy7n1LiowA9j17H0QAAXMg6WDXQmwGSEDmtXxXZZ1l2EedeprJTF2kXLMS2XWBAXOmxjgoMjq/gPjHddXLaW9sUm13FRzGDAL6oZTfxGqnQgxVUA51jnVdfOwY50Pl3Fc0n1AnAwl2FMAvoNm+RpQus5VQ2CenvBH73/uj7hPH8Azk1pyhepQfHAAAAAElFTkSuQmCC',
  sunflowerGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGlJREFUSInt0MEJwCAMBdBv19A13ERwRsFNXEPnsCchxKQg7aWQdwyJ3wQwxhjzVyFihoh5OiPVL6kxZY+UvTqkzUj9W0BvcLUMADgK0WwBVC0DvcHx334WwD2dYm3NOalIH6AbaHXzyg1mdiJmJYRz+AAAAABJRU5ErkJggg==',
  sunflowerGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAHFJREFUSIljYBgFo2AUjIKRDGRMGf5TwxwmXIaHhEuTZAkutVgtIBXgcxCGBciKiPEFzHBcAMUCdMVrVj5leHKagRGXAxgYGBienGZgXLPyKXEWwBTjchE5cYMRRIRchAvg0sOITRDZhchBhEt8FFAEAPyuLmpSKFsiAAAAAElFTkSuQmCC',
  sunflowerGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAKlJREFUSIntkdENwyAMRI+qW5A1sgkSMyKxCWvAHMmXI5ecSVH/Kt4XAdt3FwOLxeJP2XYc245jtofdv1hhiB4herPJ6mH1N4Fa4HJqADAlYnET0OTUUAvctyLM0FAAGMeX996QKcCGhOg/kkiNnEP0Q4OXAHPaD9fLl8E5NYxELgFZri7Wkfvly5u+Z7z1Ry1wGe0xNvvXjwn6JLNYPdSF3oN2at0vfuIEQtBnyE8BEcQAAAAASUVORK5CYII=',
  sunflowerGrowing4 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAANFJREFUSIntUkEKwyAQHKW/0EM/4U8C+UYLeUY/EvAZOQT8hv6iYE+mG7ubWNqjA0Gi4+6Ms0BHR8cO1iH/u6amxYfRwDrk5/L+WkQ1861Dvj1MpuuRK44vOgCAGKD8nDCMZtsrrrgGHL/maulSKe7nhBigJBeUzwn6aEBRireGzwk6bADsw5fOa0H0XEtkThWdljIA9P05sGPKFbcOeVoNptXgescWbB2y2ICbCGpZCr8OucaF/sQA5ZFObZ9NFuugdvItpDusCpoDVSrtd/yEF231okoU8YDYAAAAAElFTkSuQmCC',
  sunflowerGrowing5 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAPNJREFUSIntVDEOgzAMPBC/SIZ+IluXjt2R+EYr8Yx+BIm9YxcGJL4Bv0BKhyrEuE5CRUdOQkBy9p1jK8CBA3uRSYtzB+u+i7PM2covJPLruf6PiaT4OSVr4538HdrA3h7KagM7d/7ZEreZT0XcO1aVxOec1RGNA7K2mVBWalkrKxU8OonPuXkoyCVvmwnjEG4y5UuGvgQoXHIXkDpryVBUAPiUTF3RkXT73BDdT44pd3W5eq4Tj2ER4E55cm1g616h7hVOdyyN5U0OCkgTQZ2Hms+bzLG6KsYBWYspWXZqssQKeCW/IhQjuqB9oE5D6wd24Q0PlLoJNXPrzwAAAABJRU5ErkJggg==',
  sunflowerSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA40lEQVRIS81UwQkCQQzMVSFiURbhQxAswPPtWYAg3MMiLErEKpR5LOztTTYxsOh+j5vJZCbTSePXNcaX3xActut3qew83kPDzH4C+HDqJ/jPx0su15tESCYECRyA5dMIcrVsAKpgv9u4CHK1mkq6V48HTC1TGTLOC441/C9B7lMtYWEFicCKr2mylv0UBOs2zEPrj0PowFLOVQLkerlaSFMCTGHt2GrjqoJmBJ4IsmvHQKXpZhexFbHGBTjrIzWmUFFrUFQ6a91yreqhYcraDbDGZZ6FLhlAYQ+s2H37PazAS/QBL7jGGVi1//gAAAAASUVORK5CYIIA',
  watermelon =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAW5JREFUSIntVbFuglAUPS81rTTwQpcmNowMGAddXDv1D/oVTv0WJ7/CP3By7SKDKQOjCUkXyYOITnTQ+/qA56MmDh08CQkh3HPuudzzAG7417h7uQeA0nSd3jkLpnv44D/iEO9KAOCTnpFAzBKqYYd4ZxawX5+QL7clAHjTvpawO7Dl/X6dy/vNxxdxsHy5bQpYIwfFKiv9xVgWiig1dk/ggSuF47dPWCOHFaus4aD0pv0K6fO7VyFSO1ah1vDAJTcMADoAYA0dFGEGEaXggdtKSKCuuwO74fr0HaWD0l+MG8SXjEgV3K9z6aJDL33PN62F9QYI1IiuISmgjqaOtlHpagWSqoBOXVdYdwPo3RMqDuo7rhM1NaLWUwAZ8JtcPukZR/UXiCiFmCWwhg4rwuzogCLOA7ex0wTdaHTbxgMXAgmKsBY0SrJ6RFy6psDxyDiXZCkCALpc1KHZ+wp5Q0AKHZN9ldPUiGv8D25oxQ++q8nB7rJdfQAAAABJRU5ErkJggg==',
  watermelonGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAWNJREFUSIntkj9Lw0AYxp+T1jYxViPFYtFJFMSl3CBE3Lp0cHR0yGhAt34FwcGthawufgOHog5SLBWEIl0LBf+QgjS1rdUMVc7pwiVpqTg45Qc33MvzPs+9xwuEhISETISMKuqFJLI0hX2qMq4j0m1AI3J21J4cIDaVhzYzNIp8RsJ9s0+2NusejTwbQ6ljMQDYXVwh/bfPkSFT4iVLUygPbRaLR93aqlnB3YsDvZCEXkgiocooD21W6ljM0CgMjeLi9ZklVDkwVWAC5uyw0wcHZrXm1gyNwqzWkFtIEwDgxgCQz0gAAN6jOMvkqfWNbtEaH8Ab/PBQHggAneYSlLU5VzNo9BBRoqR98jg2AFeNdxxc15lY5y8WOT5veczFkG7Rcn0DW+T/x7g8jctey/0W8fUAAhMA8ARE/AH+TVjfjgN7Xo10M0MiHwN8bSiMmwqMXH0/7C9HzqmYP0z/xj/kH/kBY5CYjlZ/xP0AAAAASUVORK5CYII=',
  watermelonSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAN9JREFUSIntVNsRgzAMU3odTKN4lIySUTwKm7gfJTkIsSHQz+qHOzvIL9nAH18YSajqwZFmWESkfUk2cgCVPG3sAIDXTIBSiomIqeow25FtBLfcNVtTVavVVBuArc0nrwRBNiMy8x6/PUcQIAFAKeVgG2E4A5JYlsX75zFauSICEbk8vFvBgnlEYmiIZOoOrvpyztGb0wBY9R4u4+32nfTf0771m/wEfXvaDm2NU6eiw9Qd22XiqeNq20JynEhTVS3nHAXZwW2Rpw6SIGndqag4tG32VKTqf4LT5fnjp/gAHB6L7zj2AgcAAAAASUVORK5CYII=',
  wheat =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABIElEQVRIib1VuxGEIBBd6MAxsZwLDC3DMggtgzIMDSzHxLEDuQSY3XVB/Nxtgp/Hvo8gAImyRrvUuyul32hSRMAUOzZmHeXeRYJ+2JUHumWqAQDAj84a7fphV1fVEwJPAtbQ1KzR0A97TnGZW6TeWaPJGFyc4SXcgWSZajIpXAvwg5BAikEaq+k+FYzzRrqM8wbdp4oNcQQBj0ceUfxw1mgXANKkcd4Af2gJL+HwKorqE81J9qVucURwMgnCcg0rLRNRdHE3ImeNhkxEsffdiIrcEoKSSV7IpYh4JTcax53smYgX/6ZcUQ6TcysRqKZdyQN/z+2qpl3FiDhechBJEs1FJym3Tw6cIrdPT7RTt/87MlkpvBt/QfBK8zcreYp9ARnARYgSAH7PAAAAAElFTkSuQmCC',
  wheatGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAf0lEQVRIiWNgGAWjABfYsIb1PzHqmMg1XEVZlihLiLLgynklolxLFrhyXun/hjWs/9EtoWkQUQUguxib65F9gM83WH1w5bzS/zt3H+O1JCDkNyPMcHwRTlQQ6RjeYyRGHUkA3cXIfHTXkhxE1ASjFhAE2FIHpcUC9VPcKBjcAAAkzD98KD5/RAAAAABJRU5ErkJggg==',
  wheatSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAZElEQVRIiWNgGAWo4D+6ABM1Db8xA7slRLmEWEuIUjQjm+E/BZZQzSW0dcCNGQPnS9paOuDxR3WbkTMavoxCNYuxGj7g4UpzyweDD4choJqXsVU4/2dk47WEKpbjNHwgS9GBAQB1RDSsD2ft+gAAAABJRU5ErkJggg==',
  tomato =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAPlJREFUSInlVbENgzAQPCJLVJ6ABtGlSpMJWIANskeKVBTZIxt4ASagSUUXpWECqkhIThHkfJwHbBAoUk5y43/u/t7mDfwdolRqn/zNkuTeAlMQuCT1VV4XjdP3Q9AduVlRKs0eifWirwINAFEqoe7NRyCLJQCY/SyWqAuT88XHnYEuE56cElOUyWuBcWML6C6RJaKgTnaHoxGyRaiAIR+DLX69nHtFJl/TIRGKVf8D5xaNYX97cy/uYPVRMbtNtD0A40CFYp6CBW5U6NNWIHu03mR29QB/BkFetV5OVChYcnaDQAPAkBsVCuSVibFcLvN87BWb/Sb8Np74sVisxYmO1AAAAABJRU5ErkJggg==',
  tomatoGrowing1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAGZJREFUSIljYBgFo2AUjHAQWqHxP7RC4z/VDLEpEv1vUyT6nxTDGYm1hIGBgeH5r7cMDAwMDJJswgwMDAwMqztuENTPRIwF2AwixnCSAXIQEQuI8gElYOhbgC2iKEvXRKbMUTCMAAAvbR7j6+Sr/gAAAABJRU5ErkJggg==',
  tomatoGrowing2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAJFJREFUSIljYBgF5ILQCo3/oRUa/+lqiU2R6H+bIlEMSylyDLJmdAuIMZiRWEsYGBgYnv96y8DAwMAgySYMl1vdcQOvGURZALME2QJCBsMAE7EWEGsg2RaQaxlZFsAAMZFM0AJchsDEqBLJuFIRMUFFVBBhM4jcSMcLcOVkfICiSB4ZFmCLKEqLaOpH/igY3AAAKrlIKa6/Bn8AAAAASUVORK5CYII=',
  tomatoGrowing3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA1UlEQVRIS2NkoDFgpLH5DIPLAs8Ctf8gH2+fcItoh6EojC0zARsAA4u7zqDI47MAl164ASAFyAbCNCCL4bIAXS/IgTAxsAXYFMDEQTTMEmwW4NILCwWCYYnsE3QLCBkOsoSgBcg+efPrE9hhImx8YBo9jrAleaIsgFmCbAExhhPtA5jLYEEE8gFFFmBLQSBL8KUiXEGGEUTIEYduEbZIRjYYW6QTjANcqQiXL9EjmqAFwzMVkV3YEaobKC5Nh40FKHUCIV9hkUdJmUQlUzIsgWsZ+hYAAF7KnRnkpkjpAAAAAElFTkSuQmCC',
  tomatoGrowing4 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABC0lEQVRIS2NkoDFgpLH5DPS3ILbM5D/IV4u7zmBY7lmgBpbbPuEWXofVLY373xS9CKwGrhAkeP/iNbjBIItAliArxmcBzGHojoNbADMQOU7QxdAtgFmOrg6ZD7YAm+HYNGPzATafgsyE6ScYychxgm4BNoehp0qCFsB8CKLf/PoE1i/Cxgem0eMIW5InaAFyUCFbgC2VkWUBsiZYEIF8gM0C5BQH04fVB7jyAq5kii/vYFiAHHEwjYr6WgygjINsASzfIKd7bJGOYgG6F9ENQbYAl6vRzSAYyYRSEaHCkigLYJagpyJskUpWPoBpIrawQ7aEaB+ANI1aAAs6cKVCAUAJdpLigBxLh74FACQg3hnrDTBLAAAAAElFTkSuQmCC',
  tomatoGrowing5 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABGElEQVRIS2NkoDFgpLH5DPS3ILbM5D/IV4u7zmBY7lmgBpbbPuEWXofVLY373xS9CKwGrhAkeP/iNbjBIItAliArxmcBzGHojoNbADMQOU7QxdAtgFmOrg6ZD7YAm+EPrwf+l9dcz4gsh80HMHmYepgDYZYTjGTkOEG3AJvD0FMlQQtgPgTRb359AusXYeMD0+hxhC3JE7QAOZyRLcCWysiyAFkTLIhAPsBmAXKKg+nD6gNceQFXMsWXdzAsQI44mEZFfS0GUMZBtgCUamrmP4bHBa7UiGIBuhfRDUG2AJer0c0gGMmEUhGhwpIoC2CWoKcibJFKVj6AaSK2sEO2hGgfgDSNWgALOnClQgFACXaS4oAcS4e+BQAsoN4Zr8Q2BQAAAABJRU5ErkJgggAA',
  tomatoGrowing6 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABIElEQVRIS2NkoDFgpLH5DMPQgtgyk/+gYFvcdQbDd54FamC57RNu4fV53dK4/03Ri8Bq4ApBgvcvXoMbDLIIZAmyYnwWwByG7ji4BTADkSMdXQzdApjl6OqQ+WALsBn+IsDjv8SGHYzIcth8AJOHqYc5EGY5wVSEHCfoFmBzGHqyJ2gBzIcg+s2vT2D9Imx8YBo9jrDlKYIWIIczsgXYUhlZFiBrggURyAfYLEBOcTB9WH2AKy/gSqb48g6GBcgRB9OoqK/FAMo4yBY8vB74v2b+Y3hc4EqNKBagexGU9ErV3sANQbYAl6vRzSAYyYRSEaHSmCgLYJagpyJskUpWPoBpIrawQ7aEaB+ANI1aAAs6cKVCAUAJdpLigBxLaW4BAFsM3RnfTMpLAAAAAElFTkSuQmCC',
  tomatoSeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAV0lEQVRIiWNgGAWUgorEwP+UyNPfkorEwP/4NFDFxQNiOCmOGBQOoVpwMFHDEKoCXGFMlI/JDRaaGk4RoKmPKLGELuUTVQDZlpCT3anmI1wGDZ1wH3kAAGHuPqjrva2eAAAAAElFTkSuQmCC',
  fertilizer =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAArElEQVRIiWNgGOqAEYf4f2qZh82C/0EzfMgyfV3GFgwzWQgoJhrgchROCxgYGBim5JoSZXjO5NM45fBagAyyd6AaMtWDOMuJtoAUQ5EBEymKs3ecxvAJITC4fEAOINoCclzPwEAgiPAlP4otIDc3E20BAwPxuRmfYwimov9nHfDKMxofwCtPdDI9f/YrCt/QmJsofURbQKyBJFtAKAgosoAaKYnmOZnmVebQBwBEGSTr3HTDzQAAAABJRU5ErkJggg==',
  rainbowFertilizer =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA9UlEQVRIidWVOwrCQBCGv4gIor0n0CaVSHqxyhG8gJV6ABsbG7uAj8LK1iNYib0Ee8+hWK5FDMlCspn4wvywZHYnmW9m2CFQdFkp5+pT8ZIASnl2YA0aAExqTQDmLILzaQWA6uwCwJYWAP0gXFrSGkARVCFeO1RoayqbSKuxk5UMAKPlKdVnBMQ13EdB1q4MDFASv/kMvHYdDZYlcQUQVfFXFeQCvCIxIN6WPC1K0m/mQHl27klOkvEWWfXD0wqfG81/j9J5DQCg/K7Rb3WORr94Ds7+Tdu3OzXRd2KANGBuQFYL3gKoaw/IvkUmfX2Sv/7LLL4egFJcIh1wkL8AAAAASUVORK5CYII=',
  scarecrow =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4UlEQVRIieWUvQ3CMBCF3yHEIEhsEadKQUHLEkgpvECWyBi0FBRUeIV0bEJjChzkOP45WyBF4kmWT9a9+86OY2Bh0mawRTnFn9d3sNnzvVzAp/goLmTFBBQr1EHWOcfqhXZA1oC+HDHOduzL5QK+JjbA6ngSp8S+RW5ROpxZ/qz/oMTLPSJd9wqDBAYJ1L3yAYsBepDzRbOWhKQAnC6jOeuAgez5tFW47QQaKACwYgE3F8638e3Am9g8lDeOeUIAuxsAoHsrZklmjQKeCZmromuapa6C7qq8h3A5b9H/An6uF4WMRHW3ug60AAAAAElFTkSuQmCC',
  scarecrowAnimated = '/assets/scarecrow-animated-Bwzq1lj5.gif',
  sprinkler =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAlklEQVRIie1VQQqAMAzLxO/5AP+y4/7iA3zgPDikbG1XrYKIAWFsWRLSgcCPNyOXz8UL0qWUEgAgxujiDb14RYBLeIhrkJI1AlVC7cxsIAnBKm4xaEwoeuKAYQZenKqIg6eipv913tfTYp+DVBE7XAq6pzzl/gyUdIEzbkjKWa44mVZE9zWt8aK5mff4M/0Nbof1J/QhbIFgQxZVKNMbAAAAAElFTkSuQmCC',
  cowFeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABaUlEQVRIie1VO46DMBAdom18idRQEMk3oKfbK1ClQZyFxhXHoPcNkOKCPpdw6S3Qc8aOnZBNmpV2GpBt3m8YIPqvT9U6Sfeb5w57gM/fpSMiUkPpXiV6SqCNpb4VRETU1CIgfptgnaRrakHjbImI/FUNm6M9JFmCdZJOGxuswQlKG/uUJEmwTtKNs/WR9O3NhTbbOt+Ho90EyH2cLcEF1F+uNzcg5b2Jq8g5SJFyIO6kbwVV3ZLEunOA7Hn+2livHHsgOx3zou4IkGVTCw+ArHlETS28AP6WpUi+uHK+Mc6WTsctayjOzQRcgIhXwcEBmmsaokKDc2d5PzxB3EQA8BjiOYjJ4RI4VbcUBw6ujfU2+1YEvQA4sscV5y9XCmbDO1BD6WA7pQjKeTzxmUf3QQ/imF5Z4875Od8M/hal1OaaytdTLoLpU0PpUtOaUl91S/HoQ5ebbO8kfnidpMMPJ/dxU0OZ3fu79QOnNyLrGvOANgAAAABJRU5ErkJggg==',
  adjustedcowFeed =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABlElEQVRIS81VoU4DQRCdVaQKj0AfApL+AR6Hg+BQNQQHv4AjmCocQdbh+YMmreA0Ao9qUMu+SeaYe532ruISxvRudve9eW9mr0kGjjQwvvwfgo/ncT66nu9cUOcBAD+9reTmbCTvy5WcHo9kF6JOgultlQHqAwR9FW0lAAiATQErwVqXmo0EADdLDNhUWL6PZSGB991AuXpPCqLJYx1ihUnzHSAnh6KNZSJv3TarIgL13UfOWVJa30r5XgoUvChQ/CJbGBxrUb7YGjacWTM2WpQJaSnBGmybzupWfnJe6T2JrGoIbCS91+Y/Tw1b6KetkLeK1hc/79xUDwagxadotdEAOOUNSUNgVbACvGOK+C7APm9npBKXMH3/SH69qxTEV8g2cD/QbE+MAhDWi4OruezvleEDwf3FX5MMmG9xRO5VR88gUYtA8vUybr6W7Dt/7NhO7GcFyDUEngTPUbXcVBxGUT7vibGOaI0UlLD39g4wI798qNVf3m97zP81AlNih/FrBAzm13iPX+v8w9mkqG9+cIJfYSog4zFFblAAAAAASUVORK5CYIIA',
  huggingMachine =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgUlEQVRYhe2W0QrAIAhFbexT/Sz/tb2skKYPw+kGuwd6CemeJEgiAP5Oc/Z7VZ4l0Jk5JV1ELpmrwAw/ix9jOXfmblaxLlLdaJE970KmQCUQgAAEIAABCLz+HWuBzswkIpQ5kIyMkb17hVWYb8AYLqLL7eqnHqE1CXtT810yzwYxDkKWK8nSGBQGAAAAAElFTkSuQmCC',
  milk1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAlElEQVRIie2UwRGAMAgEL45F2IIV0IB2bQNUoCXYBf70YYBkIuND+cLckoMABEcqqJEWDQ8gzGwWEJGp0zmA5gi3qC/pQiTPSMnv71WLBNC7PwWuV2S1NIB4wgrophdukTrkeQsGAMAylmwxMK26ne6aCg9mPtFu5sNn8AM+AHDX1FvDJoD1gUoj/Ni557qGUVn/TByjTiCJ3SiEogAAAABJRU5ErkJggg==',
  milk2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAt0lEQVRIicWUwREDIQhFv5ktwhZSAQ0kHVimJaQBKkhKsAty2s0hKrCGyT8q8x8CAgQrGWJkxUMDCDNPA4ho6nNRAMsKL9FmyUKkz0hJz++vJRJgnP1h8HlF12sEEM14APryCy/RsMn3VzAAAB5XyxQDt+e4nOqYCufpfaI2vQ/vgQtQqaEqGZ8GVGoonFE4uyAmwG6+ywMxAUqn0b2z04AVqWOqjeESYPaBrApfduq69jCc8b/RG+oJMonZquS9AAAAAElFTkSuQmCC',
  milk3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwUlEQVRIicWUwRECMQhFfxwryCktWAENaNc2QAVaQk5pAS9GHU0CbDYjp50J8x98WIDFEQw5MqOhAYSZhwlENNQ5KIDpWG7R0VKFSJsRgl7fXy0SoF/9S+DdRVOrBxBNuAP60VtuUXfIl/tiAABcT5YtBs63vp3qmgqn4XugPHx3zaBQRlEENwMKZUROiJxcEBOgitcOPBDTqaiC8TmPz28tXB18A3cDtKq1dqBapK3hFGD0A1lj+bFTz7WH4czfJx6xwUOYVCI2qwAAAABJRU5ErkJggg==',
  rainbowMilk1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA3UlEQVRIie2UQQrCMBBFX0WE4gH0AtKFB8i+p/AC0ivUhW7cuBM8hVfJEfQEHqBQXI2LgCg2k5ZYCuKHbDKT/yeTn4GekbTIkRiOkIBYa9UEY4zKMwoIRKP3FrW6gVQ5pRSUUoDc3dqGdDsIxEATEECkyv0Z7haC0saxj1yOy3B5QMoFgJpMaHiPwVwk56B53rFyVB98vha9HgpCK0YVABA7V+OJuanxQW36F/gRgaBNQzaMEuj6m5vgHRXPYbeeAbCZLgA4cHL7uwkA6f4KQE3WyKfNgq7lt5sr38YDiBMyusgc/RoAAAAASUVORK5CYII=',
  rainbowMilk2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABAElEQVRIicWUsY0CMRBFHwidhCiAbeBEQAHOqWEDGjhtC1zAJZeQIVEFwTbiEqCCLQAJXTQEq0WH8M7YGMSXnNiz/43HswMv1iAiRnI8LIB479UA55zqMzQA2Xp5iaJuIKcFK6lYSQXy1661xU0A5EgDCCByWvRHtLcQlDKO+sxlO7fTA8YcADgzEwLv8bYukr3ZPLdatlZ3fn0l+v+RKS0ZFQAgvlDPB65Rz9/apneqXUNtZPwwoHYNpS8ofZEEiQJ05p1SIFGAMvDQob2HATky29RqwyxA6t8cUu+ouA67rykA35NPADbs2v2fDwDGv0cAzsyCftosSE0/bq48WxfOzkS6fPRuuQAAAABJRU5ErkJggg==',
  rainbowMilk3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAABB0lEQVRIicWUOwrCQBCGP0UEsUtjLiAWHmB7T+EFxCtooY2NneApvMoeQU+QKpUgVmMRFR/JzK5R/CEQdjf/N4/NwI/VCDgjdTwsgHjv1QPOOdWnaQBq6+clCspAjiNmMmUmU5Bz8SwsbgSgjjSAACLHUfWJIgtBKWOrylw2Qzs8oMMegBMDoaQff7tFsjMvz7PGhdWbX1WJHj8ypQWjAgDEp+p+w2XqflQPcpeRG4YfA3KXkfiUxKdRkCDAzfyWQQzE7AFwN0yu/Xh8txSVwSvwa4CyaEMzMEtkXcNagNi/uUyVo+I+7CY9AObdPgBrtsX6sg1AZ3UA4MSg1E+bBbHhh82Vb+sCloZVyeeaHwgAAAAASUVORK5CYII=',
  chocolateMilk =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAo0lEQVRIiWNgoDFgJELNf0rMIGTB/5MnT+JVYG5ujtccJgIWUAxoHkQsxLhiS7wGVnGfhTcI6h3QIPrPwIDb9TCA5AusZuGy4D8hg3FYhGEezYMIZyRP/XGdRKOwBwbeVLR9JTGpmIHBMxx3SiaYTP+flMArz2j+Aq88zeNg1IIRYAHBZEooGVJkAb4MRLEF2RyaJBm0HYc4weKaBEBcuUJtAAAZkx6s4XKlkgAAAABJRU5ErkJggg==',
  inventoryBox =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAZElEQVRIiWNgGAUEACMeuf/UMAuXBf8v9/GTZLpu0Ues5mGzgGTD8VmCbgHZhuOyBNkCig3HZgnMAlIjlFjAyAJj/TsUQlWTmezWQGiqmorNolELRi0YtWAYWEDzwo5G5tIRAAC2nxYih/81pwAAAABJRU5ErkJggg==',
  watercredit =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAuklEQVRYR+2WsRWAMAhEY+8MjuEqzugqjuEM9hp4kpeoDYdPCkmVJtzlc0G75Lw6Z/0UBqwE9txCUw3T4Sz+bwP7MC1pnUd6SDBJ+CDh/7UBvr0sSxvQFrgaaMStFBACrgaK+Nl3BiB5QLKgJdAY6PMc3HKFrwzU755vLgYkB8hc0BAoBkj4uoSEtg2QARH/mgDpumbgZqDuPe21+NGvGCfgYRRD9TQZuOaujiJcBz741t90GAgCQSAIHIU+XyEa61S5AAAAAElFTkSuQmCC',
  weedYellow =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAJVJREFUSIljYBgFAw0YiVX44aHBfxhbQP4C0fqYSHHNyTM/SFFOugXmJhwkW4ABPjw0+A/D6HLSSboYYoQAVh9gCwpshuNzDF4LsAXF03mX4RErnaT7H2YhOfECB+iuRjaYgYE4H5BkCTlxQJIl6D6guiU0MxzZElL1EMxouAylqm+Q44BUw4kutJANRc4To2AU0B4AAKGOTyVh8wmJAAAAAElFTkSuQmCC',
  weedOrange =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAKRJREFUSIljYBgFAw0YiVX4YZ3BfxhbIOgC0fqYSHHNyf8/SFFOugXmjBwkW0ASkE7S/U9YFSpgocRwYuIFpwXomp/Ou8wIswTZspP/f+ANOrxxgC1SpZN0/z+dd5nx6bzLjAwMhOMFbxDBNMMMZWBgYIDRDAykJVe8ADloyIlooi2hmeHIlpCqh2BGw2UoVX2DnjxJMZzoVIBsKHJKGgWjgPYAAKhMQnagnSlUAAAAAElFTkSuQmCC',
  weedPink =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAJNJREFUSIljYBgFAw0YiVV4w+DDfxhb44IA0fqYSHHNw1oLUpQzMDDQwQdYDYJhdDnpJF0MMUIAaxBhCwpshuNzDF4L5JtPYIg9nXcZa7CQEy9wgO5qZL50ku5/YnxAkiUwNjlxQZQl0km6/6luOLIlNDMc2RJS9RDMybgMpapv0COXFMOJzvLIhuLKE6NgFNAGAACdX07JsB31AgAAAABJRU5ErkJggg==',
  manureManager =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABLklEQVRYR+2VPQ7CMAyF2/t0YmGEAyHO0DMgDgQjC1PvE+RQVyE48Q9us5CpqmK/z35O0neNV99Yv/sDUB0IG9iy6JIA13FcjeH0zs0DPKbJHWI/DJ0YANQ9IUAclgQA9gW0wQOiJP7hBdHvBcLaDRSmKkc97h6IJ8LSjazqYrEcQLQDITR2JANX7bQEQD0TNc9zq6UAYgiNODeE1D1QHEzJwFEJNR3AeHImpJ5rLSi+C3Ay0qHMACS3aCy+1oFwOD+/Et0vu/ivBkDFpYkwB+iXAFZ9EQFwhigDcFVIepzvAVHM+zPAbbYCRY6EXasBgHgqiDAchFsHUgD8zqEoi9wBKJDabLgCgFBuw2YWgHjTIbQcQYhxs2ATAKuIIo59CxS57Fstz7FdjYhsDvACjy7HIUNMDCsAAAAASUVORK5CYIIA',
  hoe =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAuklEQVRIic2UwQ3DIAxFPx2ALNSJOPRMJmjOnal7pReIHGMIGFfKl5CsyP/9YBDAjbWnxeuTHhNwl+s1RoQQ8vfpAArHGiMAYPFebB4NKP6cStqFdkSiFu+LkJkA9942MYRqNMChcluo0uj2bNCoeRZpZw5Q3qLv6wgB2Kgo/FQMwvH8FP4jkBpGAlrwqnoDVPDeRjW8p3kKfmWYhrdMJvCa0QwumU3hHGAOp5C/wAH2FlnDuS6f4VvqB7TESLgVFsd2AAAAAElFTkSuQmCC',
  hoeBronze =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxUlEQVRIic2Uuw3DMAxETxnAdQYwkAncaaIUKTKIi8yRMdJlEW/hNJJBUx9LJAP4AAGEwXtnUYKAE2sNi9c7XRRwF+tlnvC+3+J3dQCFY5knAIAfh2xzb0Dy51S5XUhHlJUfhyREE+Cuz282hKo3wKFwW6jC6NZokKh6FmFnDhDeos9jCwHYqCh8V3TC4V+Jfwukhp6AGryo1gARvLVRDG9pVsGPDGp4zWQCLxnN4DmzKZwDzOEU8hc4wN4iazjX4TN8Sv0AN2RJwOjZLUAAAAAASUVORK5CYII=',
  hoeIron =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAtUlEQVRIic2Uyw3EIAxEhy3DtaQl9k4bcUvpK3uByDGfgGGljIRkRZ43wSCAF+uMS9c3fSbgLtXMjBBC+j4dIOFgZgAAERWbRwOyP5cq7cI6oqKIKAuZCXDe+2KI1GiAQ+W2SMXRnclgUfMs4s4cYLxFx/cKAdSoJPxWDMKx7Zn/CpSGkYAWvKreABO8t9EM72megj8ZpuEt0xJ4zbgMXjIvhWvAcriE/AUOqLdoNVzr8Rl+pX42rEn4TvbkRQAAAABJRU5ErkJggg==',
  hoeSilver =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAt0lEQVRIic2U/QnEIAzFnzdIJukKrnLDFJwkK3Sv3j9aUr+qMQd9IISS93s1isCLdcaV1zd9FuAu1cyMEEL6vhwg4WBmAAARVZtnA4o/l6rtQjuiqoioCFkJcN77aojUbIBD47ZIxdGdyaBR9yzizhygvEXH9woBslFJ+K2YhGPbC/8VKA0zAT14U6MBKvhooxo+0rwEfzIsw3smE3jLaAavmU3hOcAcLiF/gQPZW2QNz/X4DL9SP/ScS3hB0In3AAAAAElFTkSuQmCC',
  hoeGold =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAvUlEQVRIic2UUQrDIBBE35Ycpl89QCnkRj1Me6JCyRV6HPvRROKqia4WMiCIum+cTRAOLDcPPQ90aoDLMnevK5+nXw8kesEC97Bxipi1CbJwIJnC2qKkzpe4VbUtWieARAoIW1WbQMj8LcEtfqbOuxi0+S1aEgC4992bAMgMjOAAgxGuJTJO3jDYsMBvj/LaUgMTvPSgGV5yuAm+V9AM3yrqAs8VdoOnirvCNaA7fA35CxzUW9QbrrX7DB9SX0XaUBQX3euqAAAAAElFTkSuQmCC',
  scythe =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAxElEQVRIS+2V2w3DIAxFnb06S9QF6DBlgSqz9C/qTES2SoQcbjCPfFQq3+QcfGU7E118pov59BdwwoEIJ9EbUbjPM72WhUVZVo8geO+lRz7rCiWtgvB+EN2eRCVJi0DgfFjAJ0qcc4eoagUaHr+XuHJR1QgQXDoJVWEVnMHjMhCJjskisMBhFSWBFQ6rOBPUwvcq0piQoAW+V5FOdU7QAz9sfy0YCtdTNxyeFXzHv9Rd5h9hCuK9DteumaguDnspesDvCzbc3VkZpaP6uQAAAABJRU5ErkJgggAA',
  scytheBronze =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA2UlEQVRIS2NkoDFgpLH5DKMWMBhriPw/e+MNzpCgKIhAhrd6ijNUb3/JgMsSsi0AGb41TRGcRi48/obTEnIt+H8kj4Ehf5cIAyFLyLEAbDgI2ExiAMUB3BLvWfcxgopUC1AMZ2CAJHNYcGELKlIswGo4sgUgNroviLUAp+GwkgDmC3IsIGg4Pl8Q8gFRhuPzBT4LSDIc2RfIwYTLApINR/YFcq7GZgHZhmMr+tEtoKrhIAuRLaC64VgtAGV/NIspqvRQfAA1iVDSJclCqhpGTCST5DpiFNPcBwAgan0Z4Vp7jQAAAABJRU5ErkJgggAA',
  scytheIron =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA2klEQVRIS2NkoDFgpLH5DKMWMORlRP2fNGMZzpCgKIhAhqsqyzHcvvuIAZclZFsAMtzY1AqcRj69e4LTEnIt+H8kj4Fh1a8oBkKWkGMB2HAQsJnEAIoDuCVnTx/DCCpSLUAxnIEBksxhwYUtqEixAKvhyBaA2Oi+INYCnIbDSgKYL8ixgKDh+HxByAdEGY7PF/gsIMlwZF8gBxMuC0g2HNkXyLkamwVkG46t6Ee3gKqGgyxEtoDqhmO1AJT90SymqNJD8QHUJEJJlyQLqWoYMZFMkuuIUUxzHwAAb2p9GTK1pfkAAAAASUVORK5CYIIA',
  scytheSilver =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAz0lEQVRIS+2VuxHDIBBEV305oAyqcKQyiDwugjIIHFKJm5DnZOM5YX6HIDORAs172uVACyavZTIffwG01pu1NtvEqYoIrpSCcw45SbeA4Ou67jPivc9KegXb4wrcnxo1SY9gh9O63EB78JUYY36qkgoOcOA95qGuVFUSQRLOBfQcp2gVZOHhJggpegRVeClFLUETvJSiJBDBeQpeU04ghvMU/FSnBN3w1NUfC4bCScgFw+FJAR3/SHzqp3dI8CHVRlckHApr2WTR17W8PD3BC4S6fRnQ192VAAAAAElFTkSuQmCC',
  scytheGold =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA2UlEQVRIS2NkoDFgpLH5DKMWMDQW2/2v7z2EMyQoCiKQ4YZa/Aznr31kwGUJ2RaADC9MVAGnkQMnX+O0hFwL/h/JY2DYy2rHQMgSciwAGw4CNpMYQHEAt6R//h2MoCLVAhTDGRggyRwWXNiCihQLsBqObAGIje4LYi3AaTisJID5ghwLCBqOzxeEfECU4fh8gc8CkgxH9gVyMOGygGTDkX2BnKuxWUC24diKfnQLqGo4yEJkC6huOFYLQNkfzWKKKj0UH0BNIpR0SbKQqoYRE8kkuY4YxTT3AQBP8HwZfM9pkQAAAABJRU5ErkJgggAA',
  shovel =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAALJJREFUSInV1cENgzAMBdDfqovQOToT5zBBOXeL7MEcMIp7akWM3Vi2OdRHK37fKAKAk+uS5JDmRgMIAKZSmuZznr/2LYJzeN023Ieh6V0zcak8ASrOt/cGmHHAf8k0lSLi+wsGAk/Q2zwSQMsI1FoPON/eE0DLeABVXGxY8Mermf28xaJlDdDwblkOunHL4RDeGwjjv4ZScG0wDZeGU3EOpON75BQcYJ+KbJwX/3H/R70B5PVOSsiwgM8AAAAASUVORK5CYII=',
  shovelBronze =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA6klEQVRIS7WVoQ7CMBCGbxa9BIXAVZLsIQjhPfBYPBrPexDCQ5Ag5xDYaWzJLbnmVjp69G7Vzfe1/+3vKph4VRb8xtWec+5tF7gqAYEvu+XgnNvzE0hSLEB4DH683rBazEAtGIPjNdSCHBwlqhvEAoyFTk6DUAkQQpIcHPeWDtk3robjZt5nzhc/fanA3/auZx6uHfAvKYaXCAJ8fWoxqiBIwf8VDOAUL5WNt5dHJp1BEi55ZiSCYrgkIhU8J1DDfwlM4GMCM3hKYAqPBeZwLpgE/iXA+isewGTveNHwxy0pnqTAYY85MLZ/AKAsiRkhT8wtAAAAAElFTkSuQmCC',
  shovelIron =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA7UlEQVRIS2NkoDFgpIb5eRlR/5HNmTRjGdxciiyAGWxsaoXizrOnjzHALCHbApDh6AZ/eveEgU9IhoFiC3AZDvIGxRYQMhxkCUU+QLcAFCwwl8MigiILQIbALCFkOEgtuZH8Py8jikFVWQ4c5sgA2fXkWvB/Z6EG2Myt340YkFMSuuHkWAA33L3/Biio4BZgM5xUC1AMhwUvLLMh517kICM2DrAaTkwxQ4wFZBtOTBBRZDghCyg2HJ8FVDEclwVUMxybBVQ1HN0CqhuObAFNDMewAJT9KSgAseY75IwGqriJyXjEZGC4GqobiG47AJ1ZiBlTJ5acAAAAAElFTkSuQmCC',
  shovelSilver =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA4ElEQVRIS7WVwQ3DIAxFnW167IEBuHUF1qjEGEgdoVdW6A4M0A06BpUjGTmUFIIdzug9+M4nC5y8Fg2+cy5zToyxcEUCAnvvN+cMIQBJpgUIr8EpJTDGgFiwB8driAU9OEpEN6gFGAudnAYhEiCEJD047p0dcnbOgbV2zZwvfvpZQX7dLyvz+bkC/5Jq+IygwG+PN0ZVBC34UcEGTvFS2Xh7eWSjM2jCR56ZEcE0fCQiEbwnEMP/CVTgewI1eEugCq8F6nAuOAX+I8D6Cx7AZu940fDHPVK8kQKXPerA2v4F7oGIGVytZc4AAAAASUVORK5CYIIA',
  shovelGold =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA7ElEQVRIS7WVsQ3CMBBFLyxABRNQIDoquoiOORghygAoA6CMwBx0iAo2oGADhnB0kc66GAcfvotr6z37X75TwMSrsOA3dek453S+e65KQODquBqcs728gSTZAoSH4NvzA/vdAtSCMTheQy1IwVGiukEowFjo5DQIlQAhJEnBcW/ukF1Tl7DdzPvM+eKnzxW4a7XumY/ZEviXFMJzBB5+aF8YlRfE4P8KBnCKl8rG28sjk84gCpc8MxJBNlwSkQqeEqjhvwQm8DGBGTwmMIWHAnM4F0wC/xJg/RUPYLR3vGj445YUT1Jgv8ccGNo7Yi6HGb8waRoAAAAASUVORK5CYIIA',
  wateringCan =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0klEQVRIie1UwRGEMAgkV8JVYAOWRjWUZgNWYAvxYzJkDwg697vbGWeMJLuyQIj+mKAEsZrc90igikhfMPNjkVdEfhHTta7G3inwr5C8WILOWROYQQGSASLSH0pmZFnUyQhqYcVnAqkiNxzLSu99G77NGiBsUy1yLGt/vyPiWoTQpFqMKLbLEzAtikQ8hHNgoYmgTVmBkBxFGpjZtSldAw+KXIt0IavyqSwaOcG0Y+zWHDjkH2d0zLMovDKivsfY7MJyU/f2YyxzI5qpfxtDZ/wWThNOcCnuawEeAAAAAElFTkSuQmCC',
  coal =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAThJREFUSIntlK9zg0AQhb/WrEecw8cwCE4wmHj+zriaKDyGqSAiLh53vuJiiOjsFQYSYCJqeIqf39t9t3ew67/18ca//RrWVoMAPRwOOOcwxiAiXK/XWd4Wgz6KIowxWGtp2xYRoes6AOI4njVZa9CnaYr3PjxwzgWw9x7n3KzJ59rKFSIiIRqFiwjGmFEBaw36NE0xxuCcoyxLvPfhPkkSRIQ8y0ZdDbUUUchdAXp9LAq+LxfyLKNumvDudruNuK86CNVrLHEccywKRIS6acizjJ/7PcCttZs66IejeCwK6qYBCLF8nc/A30IDkw5eGkRRRFmWYSSTJKGqqvDBEGyt5XQ6TZiLHcB08XQddD88y3/JYGSiMPiNSMdWs5+rfo0BDI4H3Ww6shrds2NircGs2ZucXbs26AE1fqYGir1jrgAAAABJRU5ErkJggg==',
  stone =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA8ElEQVRIidWVwRnDIAhGSb9ukyUYwxFcIqcs4Tgu4Tz2In6EIGjaS/+zvgeGKMC/Z1tcX1cZnuACTCndFsQYTdZIUEdAnpwzIKIp0gR1BgwAHc7TRJ371uC8slmw5JCEd3CpXMJGUlnAvu9wHEdnUwe3Y+HgmaoJLvPyNiEiIGIXrcBdAQ9JpMiCmwLtzGU3I/h5ngBt1Kc7kCKCl1LMtY8EPJ5EFXgj6Z27K1iN1QX9B1uMsYYQTBB93NnqueC2UZt7C0xdyDXyLjJhGkALvyrkbVrbDA/jSThcE3wlkfCR4JFEg1sCAP39tbL6vv8mH84SiYSmpt3xAAAAAElFTkSuQmCC',
  saltRock =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAABB0lEQVRIS+2VMQ6DMAxFzUm6s1XiCsz0OpyA65SZKyCxsfckqRzJlXE+sauKrVkq1OQ/5zmBhi4ezcX59Ae4hr9RlExaaG1oEhGltK6H/Kbr+Nld707g8Oc00dD3hY4IxAPkyudlOQD4mQdDPUgNcNAiEAvLniq6zgCFc121dfUzAFUdhaAd5KaK40g4z3mMIzxVECBHMhp+b1u6DUMIABt7dl25AA7f9j3/IojdAWyuvQPScA6VwRCkSQOKcFmsVUnVaFcIEgJwmK5alCCI1eQCkA4OPoPUALyuaLL2bCtGEA/wgdRca5CGRE6RrE2veXY/JlpV9B7oUPuB8YDwvea9rr1Q9/83lhuWGQG9q4IAAAAASUVORK5CYIIA',
  bronzeOre =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAYlJREFUSIntlDFPwkAYhh8bE2JhgM2pTCasEP0dMjKSsNCJRB0c3WAAYzccSBgZ+R+akjgRnCAOTopJIXFpHeAu17uCja68C+1x97xv7/vu4KCD/qujlPOivzJ+M4gAOt0e+VwWgGWwom6NABiGNW5vrvfy9hlEnW4vBhPPAN6iYixoPzwazF0GUafb4+ttJgdajh+bMLYbAFTXg1iA06unGNfal7zl+BRLZYqlsgEXYKG6NWIY1gyYbhC931/IRMOwJkEisfhV/xMSdVKlbpGEC6mJ9MXLYEU+l5Umak3UWhzrji8fJwD4+UsJrq4HeFOzqF8AzuariqXNWHU9oK3MiRmM7QbYMJ9OIJhJiEdFFlkvrnge2w2WwcrY9JjBfDoB4h2jF1TtGnXbxPnQu0hv06jf7xuFFQn15Hev5wAUMqEc089CUptKmP6uwr1FhUImpJAJaTk+n9+WcVaSvgC210PTdWPJ1MUiuXw/ewYwtmeXgTRquq4BSoJvwYm8VJddCqW9lQ8y9QNiZaVNTKTieAAAAABJRU5ErkJggg==',
  bronzeIngot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAA4ElEQVRIS2NkoDFgpLH5DKMWEAzh0SD6jxZGGCFCahChGFjnwsXgaakJtmP78esMTXu+gZgoZhKyAKeBuGLXsvksiiXYLIAbiuxCgskFSQGyJegW/CfXUGQHIAcXsgVgw0EAFq6kuBoWD5rS/AwKclIMMF+gWHC81hhs5oNHz8CKCAGQS0EGwgCyHrwW4LIEn4HojsFqAXr4k2IgMXEAUoMSyaQEFTQPINsDDn6syRTmE1wWIKUSDAPRgwpXRkPxCSkGEmsBOLgIlTOEUhmuICJGH9FqCJVFRBuES+HQtwAAGJ1YGe/MnNkAAAAASUVORK5CYIIA',
  ironOre =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAZZJREFUSIntlLFKA0EQhr+onHfYHCG6RXIKFj5AykCeSgufQCyUFNZWwSqQlwikkqusUgjxkmKjSBpJDISz2mF3cwlJJYJ/d8fONzP/zg7867dV2vF8vitz2wQ5QLfTBqDXTwFoNurOocFwwvXVpcM92Ab81H4kCgOB2+DZfAFApqeFgHUd5AAPrRvKFUWmp1ycnThwAzaJB8MJejxCVWtOF0Ud5N1Om8FwQrkSA3C0/02vn3J+eixwGwwI/OLsxIHtrYMnKpbWX9/eaTbqlCuK2XzB54cuhBfJTpA/tR8FHoUBnx9agk3VURhQrSVikR6PxDa/evHJrzwKA5kUVa3JP1u25z7cnibnDowtxu+v5eEKfDZfkOnpWrj/vWcHRmHAc/qyMt8+fJMGw4ncjZPABDYbdcajrLB6I7/6Xj8VsN/N2oeWqJhMT8U2uwgDNlLVmiT1k5gOStdXl1LF1/KwEK7HI2dqjCXmXKJiJwZWX7Iss9u7+0Jb7Or8NZGomOf0BYBWqwVQ2rTsttmcm7Trpv7XX9UPRxDlZCE0bRgAAAAASUVORK5CYII=',
  ironIngot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAwklEQVRIiWNgGAWjYNADRgr1/ydkHqkWoBiYmxHNYGxqxcDAwMBw9vQxhskzlmKYScgCnAbiAgnJ2SjmYrMAbigxBhKyBN2C/+QaigyQg4sJ3XBVZXmyDf707inD2dPHUBzIgqwAOcKI8cWnd08Zbt99iKLfWEgaRQ0LuiaYQmyWEGMgOkCxANlQY1MrsgyEmQMDeCOZ2KBCilRkwIjhAwYGBsbJM5b+z2VgwGswPgOJEmTA4hNiDSRFEcFyZhQMDQAAaMBZ6FnVQEEAAAAASUVORK5CYII=',
  silverOre =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAQhJREFUSIntlD1uhDAQhb9EuUOK5BBbeGsoOARHoF8XOUIKp+cCvgWFqTNFbkQajIgZbHaVkichIWZ4PzOW4cSJE0cwzc9DeCqR930PQNd1R/o3eD7aKCLwQJqco2kmTUVimiMc+QSpAIAxBhGhbVs+3RcUEhVHpImsv5VE9gSW5UbH6/cQAhdzBaCpq6zBbAJjzK7zSD6EMZviJUeeEoYQALiYa9F5hHYCJhHBObcp7I1lCCMAH/a24UwFpjnuQhJ/buoK5xzWWtXpEEZVQN2BRg5grcV7v9RiPULbhTqidYpUBMB7z+vb+5+epq7iociOKCuyxo98LzsBff45Abj/Br37IvwX/AKZJHqzxczScgAAAABJRU5ErkJggg==',
  silverIngot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAs0lEQVRIie2Uyw3DIBBEJ1HOThFTgSN6oUY3E1ewRZgGnEuIWAPmk0si8SQuCN7sAgIYDH6ey5f795KvNUAJl2UBSQCAiMBaGzlLAVlhDmOM8qYCPtIaYSnkGLD3SkPC47oe5Y957hbfpwkiogoMA0ASm3MQkSahH5tzUfe31EaSUSVe+FxXta50nCoglJLsEnqP5/SSU13khO9LDUm+IhWSCzgTVk0i0UmtsGVR8Z8Z/AcvcvFbDaU3IKgAAAAASUVORK5CYII=',
  goldOre =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAXZJREFUSIntlC1vwkAYx38s+wALroIvQBAVbfAkJJVIbB0OAQLRTE1MbAIz2+BQaBIS0hAMLwJBENgKXFNXycS45ijXg5GphX/SNL3r83+5J/fAAw/8CxxPz114uka8n7k0m827hQp55MnWIYwMprsqALXygumuSqvVulZ7BlWCY7J1LhZLxQO18oL9zOW0f1OirIuUPIwMSsWDsiiMDEbLCpv1iuFwqOLRJmAwb5y9sygVD2zWK0zLZj9zQZNE1+RcEXlttKxoRWSBY7J1GMwbaUNVhIN5gyAIMC0bgLYz4fUryTX4fC2BSkSg7Uzoj+uYFqIXeoEwMqiVF7kiQRAAYFo2bWdykzG5+8f3j8/Umfv2cvGzfCwy+uM6AL1uJ8upbnJ/XMf3YnwvxrRsTMvG92I265XSuS6NLFA4OUgLhDPx7XsxYWSke2Jfh2yCQq/bSYuzQvBzB4SInDgvRe4skvuhcioumoDq/HUC8PvJedPw+3N8A0QSnZsj1HFJAAAAAElFTkSuQmCC',
  goldIngot =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA00lEQVRIie2UKxLDIBRFL52YYLqRLiAKURNkVVeQZbGCKmRjKqKyADZSE+SrIgMpBYaadiZnBsW8c3n8gJ2dn4d9WU8536FCuA6tBKyRsEZCKxELzHYQFGgl0Hc8WdCe7oE3FrBKS4S5kG0A1Up9xnnBZZgAgDVb+XNpq8W3B+HIbbBAP2CdGOelqAsndFzPHEBY1yBC3/FoSIlwSxDgS/uOVwmdx5E85NKt8g7Vh711AIBdhil7k1LCUkgrQdZIskaSViJ4wYi82E+kUrP/zM5/8ALJtmHuganBugAAAABJRU5ErkJggg==',
  rainbowCow =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAACNUlEQVRoge2YPW7CMBTH/w+hIgTXQB1yCy6R3oA5GwzpwsIWqVtvUE7QjVtk4B4smV6HxE7i70BIK9U/yRLE9vuwn99zAkQikUgkEolEIr8FTaCDR9BplfGoA6rgUIRe33zyjKGhDvSE7XmnDTjhoxG98Au7bQEAh9VGnx8mg2ZeLY0u3L/aZoGN8U5yv0qfA1bDgwywCS0S0PoimwYt6nYklxMEAHOXnrstBACuWmO6j4sElJVgbsUTURuOtND6kHPtjOHM2nbAafyg1edKriIXSa+LHEfQ1dfF5MB4xk+A6sAkxnORyBXuhQ8AcNXr8x3k7hkYx3g19Ymz4JB30DqbOe8vXnXCAYalaKhx6+JEn/rDgHrwCNYsNMRwwGL8BGiHmItksPGhUFaOLjO0Ev9ZXIVsMvrh1/ktMpCliAG6A0RZyc8KIaAOIyFfXCP4fDaPTf3FbA6A+bYFrS8iEz2XnEEZAVkpDac0BQDvfxMzAKDV98N2ma7WPXLuFSXbqptoxhrrVB1CtPC9OASx5119n1dzv6eaqs4McW6GNmy08KGsvC/1cdVvHkwh4gqbLt4sxOdzLSwrx7vI5QxKSa601KHoFTR9QVnIiFCgvnzseWOZYeHY2rDEFZS+SvmmsOk4NSi5MBcJc5GItzHZOs/k2IFNzlviyktcQ8dbCdkBaoy39Y0BAeCvxuY32AuXyv+5SjzjIqbydseGmmaYvoKN8XXtKTpCd2CKT5BT6IhEIpGR+QG4Bej6ikQYYQAAAABJRU5ErkJggg==',
  cowVariation1 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8ElEQVRoge1YS3bDMAiEvN7RN0BnUm7gU9JFioMIWNhR0uZVs2j1oTADSLYLMDExMTExMTHxv8Hm90fhAgBARB9JHgDg6w0xbHJwpA9UBiMcZ6Hj9uz2bPBoBRpnRBQaXq/Xrh/5+1prs1lKER/dBGUFNAFHIOOLiHqJ6AoYTlz8WWJShVJKs7cjArcf4J8BHkHcBhdCzPfuQMRtrscyVyIezukliDuEvBAWX6MrCdAK2B5orwjkAREB8ZZUObh2vQcRsLXSO8gTUUNQx9RjaZ896EPcu3OHwhLTV+mRJEZn4DDsXX4Guo2yGCbgTPAR2BUgWa21Pp3h3kPpbAIeBAhZTbiUAqUUV5AVNqKVjiD1KlFrbTLkjcVGz+1+VIFoXQ5z9BCLFlk/CS2kEroitvxWsH1NMMSA19WNhcvS4+qCLYiIiaiZezbWXtbsGG7XNfO6Mq9rdu4i3UIevGrs2TdZCrIe2eKyuN8sp65Re4B1y+hz4LVRRFALsvM97ArIvpP0KtGrjun1cM3l6KxthxgRpXyykXKaCvzje5sbws7e8VtIB/EyckaQVJSZ7+P+LRS2QVeA2ZC17Ed5FDOMkeDXIHMLNQGPBkjCE5XyPexl7reQ/rdK9gvpGZyJ4Qr4q2Q9ZCvwekXviTExMTExGN/dZHBpuZub8gAAAABJRU5ErkJggg==',
  cowVariation2 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB+klEQVRoge2YUZLDIAiGYad3zA3MmeQGOSX7sINFI0Ia2+6D30w7jbHwo0BsARaLxWKxWCwWi2+BH/DBE3yaNu4G0BqOIn6976MzB68GUBlLKZkTicg3xmP96MsLB8AAY8EtXgDaVs65urfve9SOG8Bl4RHHKaXqfrsTeuXbuXpaeTPgV4Rrcs6nNBBBWjQilmv9Wa5VECe9P+8Uv+87MHPZwdbmKMcD+Q8A/QBuiwd45rHO53fQBjBFfFuULSmlssJtyjBzdc/T81CfzZ4mgiKr6YkXRsKYObxzsgMMRkFHBWnenTYaq4i/TnThzACICIgIELGs6Mhoznl43+rnnk0PqYFy5tBOJE9HD6WeE2mhHhGBni1dxAiqC8kOAJwL7pW66Akrjo2eL93JeohZg5dbqRVQb+WICFJK1VOaj6P7fdw2T+ucAACuBwHwFC5CnetuAF/rQtaqD+Z2n1PTArAKLVIvfBxVQO31iGEKWUU8IiIYESuBuG0nwe2YlUaPdqCFj6Pk5IxzEsDzvCMCtQ/tVxjVQHcH5CxCRKfC0vQCGu2Abpf60BboQpd++jIzc0qJ4a9wykuNlbkXX5UP/mv0kfmXaI2DiG/G7tD10RlzMVMIoGw5GmN3mObDLWIh+hPvDq/46AbwX8X2iO7AJ/6C/ISPxWKxmMwve31ULTQV7Y8AAAAASUVORK5CYII=',
  cowVariation3 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABrklEQVRoge2Ya46EIAyAy8Q7eoMeihtwyu6PEQdqS4FBd5PtlzhxtPaBfagAjuM4juM4jvNbhAds0AKbqo5vA+CKe8l2reuDIRNGA6iUIaIqGGM0lbWu79QRNtPKG+oxOEKPLkQ0g7DuwLTjLcOj+hRd4fxRoBUrzo3P6jz0XPzVUqhyvnRi1IEsH2Os9iUZ65zESzimOr8SIgIiEm20znF4AEvS5knKFDJ7Og9OWx1rERARQtHBS/nWOYkcAIEyNO66Iy29IzZ750DFXXUxg1TETSzntdXrGUozDAfw15hKodVYzUAbYgDXAEKM8bZWmtOIDzRKSZQP+27q3ODo/THG3Im+crAkO8jbJHc8O2r9lxiugVaRSs7n/cu0VVZd4pAV59R2GLBeHCpWpxgPZiS4F3zS5pI+0sr1MhNk2Pdz68VMIUppOhCe++U+dzLsO1BK58bPgVKf0kEqu0SrkL55MZGK+eLcx+ZQcyFEJEQkeNfFuRXHTtnBzbShyKv0DLIA+mP2qs8ylY3W4OL8n0eJJ55AZ2yIRSzIrPi6douN3jvwxCfIJ2w4juMs5gdcWvZP4r+1igAAAABJRU5ErkJggg==',
  cowVariation4 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAACFElEQVRoge1YW3aEMAiFnu5xdoBrijtwlfRjJEWEhHQcpx+559ipJsKFXPIQYGJiYmJiYmJiYuJTwBt88AU+QxuvBmANZyF+e+9jpw9+DTpmfTEzRFfGDhG57xIREJH0ayIbgJAOSS7LkjT1xE6w+Z70aaEnocoyympEYF3XJjHdbm0jYthXd6t/ArAYKKU0urWzaJ0LIU0aEeu9/l/uVRAnvpGEKvmI5LIs9WpBNG3tCbkIrTaNb8+n50xGYVTro/1HYUfAJX81iKhm2EqGmQ9tPS56BLrkvWyWUv6U5ZafkQTKCDAEBd0q4F5x3wGvBgAgT+7dGu9BL+kI++rqQYhGgelAooJf19WVh2fTexcGplEX75BMZDPrKx2ANWjXAWn3st8jiYjuJe1R9vVDXcShjISYJuRJyw6/nqlERqWUOl3ytrm+8PHwuJ7ARFQ3a3sAaRBRup9cILvZbWPetuy9i7SEom2Dl/nUFiPIeqOvG4QcGA6/vf28lZFtE3h1A/CU0UgAAFVO7iwkD0+NUkwWXqG+sh4YrYfPsqi6hV2H8HsCG64F0b19Bkrj2gcY/fdqwKvsKiFErEPtZaQntZOz4KCSmIXCGagbgGmQZ9lDeeSPZUVundwCfgeEeyFjJCrsqz7LIJyDStke/Srx75AZAQDIH/FeQUdOLtwacPpc8XXtLT6yI3DHJ8g7fExMTExcjB/HIw4rhmRWFQAAAABJRU5ErkJggg==',
  cowVariation5 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB/klEQVRoge2YbXLEIAiGcad3zA3ImfQGnpL+2JoiQcWPzewPn5nMtAnKi4BrArDZbDabzWYzjHvYHw34Jfb3bdxrSk4f1DbpH/NiRiMORhn1dRv3AgBAxE+L/9j8P5PjZ4VNB5aagsDWWJlDRKwae+/fTpw+dRqf7BLneQIAQAhBG5ZNZs0AcYdWzvME7z0Q0S0Iy1yIKIO4rUQrAwQAQESXoBG891kAUlia/xJVtu3aRgkRs8llqkdIgojourhg51z2LIRQzVYpAOotFwtyzlJvtJ5xtAAy8bxsRkuohCwd6zOObOLlK6+VHSLe6vwSIEqqpScF4MCwJ3vvl2WhJqxnEXkJLT/YrWj6Fk8e5orIQHsCbwagTZ6uFrzclB+lJQxnoKcXVu9enOJRQlthKURrannPIr51VvrLnGokA3AhBLLswSnAnp0plZEQBhSjau+Oozln8zCXDmQ1kT1Nx3shCU9CW/9rVHugJHrF9lha9YqtWhbmF5oe0dzWUl4ymJ7gqhkIIXxk6yvhjsNU99kY5d7VxM45oBj/a9J4wKrB37b4SkvhyjPzSYESAEAUI1GMBO8azK5e+Ni/DwmqD8VnkWYGxIN0j7/J9XCNk1tph76mgQzAFe7NsMzHVxzmZjBvo9ZXvBlGfKgBfKtYDWsGnviK/fSX8s1ms1nAL4ZTXaf8TqprAAAAAElFTkSuQmCC',
  cowVariation6 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAABsUlEQVRoge2YWXLDIAxARSd3zA10KN3Ap6QfLVQm2sDU/tGbScYJsjYkMTZAkiRJkiRJkjxFucFG3WBT1XE1gFFxlGbXu784MmU2gJDDiAhEFJKzCOgoXxGH4Mfx1WyLeM5HZV7O+rTTUcd4dsd7xjVlJ0r/UljKuOXMSXn9U19K6fcR0cca48NfrYQqIoay6WHpKUYLWmscqYQqN8ivI415N+MOVCvr3o7M7FjLMC+fpoOvefAALk2ZHeW2QiuhCv6hAQDnqfCU05zoOXBiV4M3XZH/NLxzIIzX4NHTmctH9KoBWAeNJjdDNMte4C2AXv9SfRORaHCX85qeQU4cSS9BoHpH/Sqj3nZdj0OUL++3q1OKyjwLOLM7MNZ1c7w56vwWd2BpCu1Ay7ohK474bVPoCmMwM8GZO0BEZpnM9IYlK9V6pP4BnB4gIqjH0ZXNPEFFZHmmR4eFNbEHQgFIBiJOSk7zeyem0NSjb0XEiojtMbJ/2H9ddvLj2lDkVSJNXEAfrbtey5xs/O5MSPdjY3QX4TF6x9PYig2xiQWZHW/X/sVGdAfueAV5h40kSZLNfAP8suojqxWMSgAAAABJRU5ErkJggg==',
  cowVariation7 =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB1klEQVRoge2YXZKDMAiAYad39AZ4JnODnjL7UixBkJim7j7wzdixJuEvJEQBkiRJkiRJkuSvwBt01Ak6XRmfOqAF98J6o/EY9MGfi4qrukyIqEsOEQERQa21ufh5YDwAAPQ60CjsMDBEyljXNezj8Qja9whoYfy/lBIqsZDjWBY7otscHbj/OBymz4qI54DnIBtU61s8Ijb9rbaXnIO93gyMLs4dNlwaJgOAiI2hkrM2jbUG3JE6mj3pM5pivWgHPo58DzwTiNikz7ZtbpuHTKHQ+Bm7jydr27YhPTwDFYKipoXOTA1pvLzv4bAGrH1+ZuRn49aB2UbzVjhb7tWjxM5MQ9Z1datxRFSJT4mqca+TPN4qeuK5uUblqXC/H4mup9zqpx2vz6fZF5fFshX0w6pK9ZAD0qBovDacDQ3+mw58lEKaK457Uff64rKYW/0DAKCUEr04fBXtzBXnfuDt1cG7UsrXzzIeKv9dwhR6TR8AzNs6iQhwWZpIa4ONtvE1wE707jQe+kVFLlYrbYRTl97dKxFVItLvv/LZ3vfiFepw+rv0zMDZ1jrrs0yj46xwaYaPEv+F7jpwx240osOaJusr2Iyva1/R0TsDd3yCvENHkiTJZH4BOxYPBJ6xfbsAAAAASUVORK5CYII=',
  pixel =
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAC4jAAAuIwF4pT92AAAAB3RJTUUH4goFDRc7VmYGWwAAABl0RVh0Q29tbWVudABDcmVhdGVkIHdpdGggR0lNUFeBDhcAAAALSURBVAjXY2AAAgAABQAB4iYFmwAAAABJRU5ErkJggg==',
  plotStates = {
    'watered-plot': wateredPlot,
    'fertilized-plot': fertilizedPlot,
    'rainbow-fertilized-plot': rainbowFertilizedPlot,
    'shoveled-plot': shoveledPlot,
  },
  smeltedItems = {
    'bronze-ingot': bronzeIngot,
    'iron-ingot': ironIngot,
    'silver-ingot': silverIngot,
    'gold-ingot': goldIngot,
    'hoe-bronze': hoeBronze,
    'hoe-iron': hoeIron,
    'hoe-silver': hoeSilver,
    'hoe-gold': hoeGold,
    'scythe-bronze': scytheBronze,
    'scythe-iron': scytheIron,
    'scythe-silver': scytheSilver,
    'scythe-gold': scytheGold,
    'shovel-bronze': shovelBronze,
    'shovel-iron': shovelIron,
    'shovel-silver': shovelSilver,
    'shovel-gold': shovelGold,
  },
  craftedItems = {
    'carrot-soup': carrotSoup,
    cheese,
    'chickn-pot-pie': chicknPotPie,
    chocolate,
    'chocolate-soy-milk': chocolateSoyMilk,
    compost,
    bread,
    burger,
    butter,
    fertilizer,
    'french-onion-soup': frenchOnionSoup,
    'fried-tofu': friedTofu,
    'garlic-bread': garlicBread,
    'garlic-fries': garlicFries,
    flour,
    jackolantern,
    'hot-sauce': hotSauce,
    'olive-oil': oliveOil,
    'onion-rings': onionRings,
    popcorn,
    'pumpkin-pie': pumpkinPie,
    rainbowCheese,
    salsa,
    'soy-milk': soyMilk,
    'spicy-cheese': spicyCheese,
    'spicy-pickled-garlic': spicyPickledGarlic,
    spaghetti,
    'strawberry-jam': strawberryJam,
    salt,
    'summer-salad': summerSalad,
    'sun-butter': sunButter,
    'sweet-potato-fries': sweetPotatoFries,
    'sweet-potato-pie': sweetPotatoPie,
    tofu,
    'vegetable-oil': vegetableOil,
    yeast,
    ...smeltedItems,
  },
  items = {
    asparagus,
    'asparagus-growing-1': asparagusGrowing1,
    'asparagus-growing-2': asparagusGrowing2,
    'asparagus-growing-3': asparagusGrowing3,
    'asparagus-seed': asparagusSeed,
    carrot,
    'carrot-growing-1': carrotGrowing1,
    'carrot-growing-2': carrotGrowing2,
    'carrot-growing-3': carrotGrowing3,
    'carrot-seed': carrotSeed,
    garlic,
    'garlic-growing-1': garlicGrowing1,
    'garlic-growing-2': garlicGrowing2,
    'garlic-growing-3': garlicGrowing3,
    'garlic-seed': garlicSeed,
    'grape-seed': grapeSeed,
    'grape-cabernet-sauvignon': grapePurple,
    'grape-cabernet-sauvignon-growing-1': grapePurpleGrowing1,
    'grape-cabernet-sauvignon-seed': grapeSeed,
    'grape-chardonnay': grapeGreen,
    'grape-chardonnay-growing-1': grapeGreenGrowing1,
    'grape-chardonnay-seed': grapeSeed,
    'grape-nebbiolo': grapePurple,
    'grape-nebbiolo-growing-1': grapePurpleGrowing1,
    'grape-nebbiolo-seed': grapeSeed,
    'grape-sauvignon-blanc': grapeGreen,
    'grape-sauvignon-blanc-growing-1': grapeGreenGrowing1,
    'grape-sauvignon-blanc-seed': grapeSeed,
    'grape-tempranillo': grapePurple,
    'grape-tempranillo-growing-1': grapePurpleGrowing1,
    'grape-tempranillo-seed': grapeSeed,
    jalapeno,
    'jalapeno-growing-1': jalapenoGrowing1,
    'jalapeno-growing-2': jalapenoGrowing2,
    'jalapeno-growing-3': jalapenoGrowing3,
    'jalapeno-seed': jalapenoSeed,
    pumpkin,
    'pumpkin-growing-1': pumpkinGrowing1,
    'pumpkin-growing-2': pumpkinGrowing2,
    'pumpkin-growing-3': pumpkinGrowing3,
    'pumpkin-growing-4': pumpkinGrowing4,
    'pumpkin-growing-5': pumpkinGrowing5,
    'pumpkin-seed': pumpkinSeed,
    pea,
    'pea-growing-1': peaGrowing1,
    'pea-seed': peaSeed,
    spinach,
    'spinach-growing-1': spinachGrowing1,
    'spinach-seed': spinachSeed,
    corn,
    'corn-growing-1': cornGrowing1,
    'corn-growing-2': cornGrowing2,
    'corn-growing-3': cornGrowing3,
    'corn-growing-4': cornGrowing4,
    'corn-growing-5': cornGrowing5,
    'corn-seed': cornSeed,
    potato,
    'potato-growing-1': potatoGrowing1,
    'potato-growing-2': potatoGrowing2,
    'potato-growing-3': potatoGrowing3,
    'potato-seed': potatoSeed,
    olive,
    'olive-growing-1': oliveGrowing1,
    'olive-seed': oliveSeed,
    onion,
    'onion-growing-1': onionGrowing1,
    'onion-growing-2': onionGrowing2,
    'onion-growing-3': onionGrowing3,
    'onion-seed': onionSeed,
    soybean,
    'soybean-growing-1': soybeanGrowing1,
    'soybean-seed': soybeanSeed,
    'sweet-potato': sweetPotato,
    'sweet-potato-growing-1': sweetPotatoGrowing1,
    'sweet-potato-growing-2': sweetPotatoGrowing2,
    'sweet-potato-growing-3': sweetPotatoGrowing3,
    'sweet-potato-growing-4': sweetPotatoGrowing4,
    'sweet-potato-seed': sweetPotatoSeed,
    wheat,
    'wheat-growing-1': wheatGrowing1,
    'wheat-seed': wheatSeed,
    tomato,
    'tomato-growing-1': tomatoGrowing1,
    'tomato-growing-2': tomatoGrowing2,
    'tomato-growing-3': tomatoGrowing3,
    'tomato-growing-4': tomatoGrowing4,
    'tomato-growing-5': tomatoGrowing5,
    'tomato-growing-6': tomatoGrowing6,
    'tomato-seed': tomatoSeed,
    strawberry,
    'strawberry-growing-1': strawberryGrowing1,
    'strawberry-seed': strawberrySeed,
    sunflower,
    'sunflower-growing-1': sunflowerGrowing1,
    'sunflower-growing-2': sunflowerGrowing2,
    'sunflower-growing-3': sunflowerGrowing3,
    'sunflower-growing-4': sunflowerGrowing4,
    'sunflower-growing-5': sunflowerGrowing5,
    'sunflower-seed': sunflowerSeed,
    watermelon,
    'watermelon-growing-1': watermelonGrowing1,
    'watermelon-seed': watermelonSeed,
    weed: weedPink,
    'weed-yellow': weedYellow,
    'weed-orange': weedOrange,
    'weed-pink': weedPink,
    coal,
    stone,
    'salt-rock': saltRock,
    'bronze-ore': bronzeOre,
    'iron-ore': ironOre,
    'silver-ore': silverOre,
    'gold-ore': goldOre,
    'rainbow-fertilizer': rainbowFertilizer,
    scarecrow,
    sprinkler,
    'cow-feed': cowFeed,
    'adjusted-cow-feed': adjustedcowFeed,
    'water-credit': watercredit,
    'manure-manager': manureManager,
    'hugging-machine': huggingMachine,
    'milk-1': milk1,
    'milk-2': milk2,
    'milk-3': milk3,
    'rainbow-milk-1': rainbowMilk1,
    'rainbow-milk-2': rainbowMilk2,
    'rainbow-milk-3': rainbowMilk3,
    'chocolate-milk': chocolateMilk,
    'scarecrow-animated': scarecrowAnimated,
    'inventory-box': inventoryBox,
    ...craftedItems,
  },
  wines = {
    [grapeVariety.CHARDONNAY]: wineGreen,
    [grapeVariety.SAUVIGNON_BLANC]: wineGreen,
    [grapeVariety.CABERNET_SAUVIGNON]: winePurple,
    [grapeVariety.TEMPRANILLO]: winePurple,
    [grapeVariety.NEBBIOLO]: winePurple,
  },
  tools$1 = { hoe, scythe, shovel, 'watering-can': wateringCan },
  animals = {
    cow: {
      rainbow: rainbowCow,
      variations: [
        cowVariation1,
        cowVariation2,
        cowVariation3,
        cowVariation4,
        cowVariation5,
        cowVariation6,
        cowVariation7,
      ],
    },
  }
var alea$1 = { exports: {} }
alea$1.exports
;(function(o) {
  ;(function(a, s, $) {
    function j(rt) {
      var nt = this,
        it = tt()
      ;(nt.next = function() {
        var ot = 2091639 * nt.s0 + nt.c * 23283064365386963e-26
        return (nt.s0 = nt.s1), (nt.s1 = nt.s2), (nt.s2 = ot - (nt.c = ot | 0))
      }),
        (nt.c = 1),
        (nt.s0 = it(' ')),
        (nt.s1 = it(' ')),
        (nt.s2 = it(' ')),
        (nt.s0 -= it(rt)),
        nt.s0 < 0 && (nt.s0 += 1),
        (nt.s1 -= it(rt)),
        nt.s1 < 0 && (nt.s1 += 1),
        (nt.s2 -= it(rt)),
        nt.s2 < 0 && (nt.s2 += 1),
        (it = null)
    }
    function _e(rt, nt) {
      return (
        (nt.c = rt.c), (nt.s0 = rt.s0), (nt.s1 = rt.s1), (nt.s2 = rt.s2), nt
      )
    }
    function et(rt, nt) {
      var it = new j(rt),
        ot = nt && nt.state,
        at = it.next
      return (
        (at.int32 = function() {
          return (it.next() * 4294967296) | 0
        }),
        (at.double = function() {
          return at() + ((at() * 2097152) | 0) * 11102230246251565e-32
        }),
        (at.quick = at),
        ot &&
          (typeof ot == 'object' && _e(ot, it),
          (at.state = function() {
            return _e(it, {})
          })),
        at
      )
    }
    function tt() {
      var rt = 4022871197,
        nt = function(it) {
          it = String(it)
          for (var ot = 0; ot < it.length; ot++) {
            rt += it.charCodeAt(ot)
            var at = 0.02519603282416938 * rt
            ;(rt = at >>> 0),
              (at -= rt),
              (at *= rt),
              (rt = at >>> 0),
              (at -= rt),
              (rt += at * 4294967296)
          }
          return (rt >>> 0) * 23283064365386963e-26
        }
      return nt
    }
    s && s.exports ? (s.exports = et) : (this.alea = et)
  })(commonjsGlobal$1, o)
})(alea$1)
var aleaExports = alea$1.exports,
  xor128$1 = { exports: {} }
xor128$1.exports
;(function(o) {
  ;(function(a, s, $) {
    function j(tt) {
      var rt = this,
        nt = ''
      ;(rt.x = 0),
        (rt.y = 0),
        (rt.z = 0),
        (rt.w = 0),
        (rt.next = function() {
          var ot = rt.x ^ (rt.x << 11)
          return (
            (rt.x = rt.y),
            (rt.y = rt.z),
            (rt.z = rt.w),
            (rt.w ^= (rt.w >>> 19) ^ ot ^ (ot >>> 8))
          )
        }),
        tt === (tt | 0) ? (rt.x = tt) : (nt += tt)
      for (var it = 0; it < nt.length + 64; it++)
        (rt.x ^= nt.charCodeAt(it) | 0), rt.next()
    }
    function _e(tt, rt) {
      return (rt.x = tt.x), (rt.y = tt.y), (rt.z = tt.z), (rt.w = tt.w), rt
    }
    function et(tt, rt) {
      var nt = new j(tt),
        it = rt && rt.state,
        ot = function() {
          return (nt.next() >>> 0) / 4294967296
        }
      return (
        (ot.double = function() {
          do
            var at = nt.next() >>> 11,
              st = (nt.next() >>> 0) / 4294967296,
              ut = (at + st) / (1 << 21)
          while (ut === 0)
          return ut
        }),
        (ot.int32 = nt.next),
        (ot.quick = ot),
        it &&
          (typeof it == 'object' && _e(it, nt),
          (ot.state = function() {
            return _e(nt, {})
          })),
        ot
      )
    }
    s && s.exports ? (s.exports = et) : (this.xor128 = et)
  })(commonjsGlobal$1, o)
})(xor128$1)
var xor128Exports = xor128$1.exports,
  xorwow$1 = { exports: {} }
xorwow$1.exports
;(function(o) {
  ;(function(a, s, $) {
    function j(tt) {
      var rt = this,
        nt = ''
      ;(rt.next = function() {
        var ot = rt.x ^ (rt.x >>> 2)
        return (
          (rt.x = rt.y),
          (rt.y = rt.z),
          (rt.z = rt.w),
          (rt.w = rt.v),
          ((rt.d = (rt.d + 362437) | 0) +
            (rt.v = rt.v ^ (rt.v << 4) ^ (ot ^ (ot << 1)))) |
            0
        )
      }),
        (rt.x = 0),
        (rt.y = 0),
        (rt.z = 0),
        (rt.w = 0),
        (rt.v = 0),
        tt === (tt | 0) ? (rt.x = tt) : (nt += tt)
      for (var it = 0; it < nt.length + 64; it++)
        (rt.x ^= nt.charCodeAt(it) | 0),
          it == nt.length && (rt.d = (rt.x << 10) ^ (rt.x >>> 4)),
          rt.next()
    }
    function _e(tt, rt) {
      return (
        (rt.x = tt.x),
        (rt.y = tt.y),
        (rt.z = tt.z),
        (rt.w = tt.w),
        (rt.v = tt.v),
        (rt.d = tt.d),
        rt
      )
    }
    function et(tt, rt) {
      var nt = new j(tt),
        it = rt && rt.state,
        ot = function() {
          return (nt.next() >>> 0) / 4294967296
        }
      return (
        (ot.double = function() {
          do
            var at = nt.next() >>> 11,
              st = (nt.next() >>> 0) / 4294967296,
              ut = (at + st) / (1 << 21)
          while (ut === 0)
          return ut
        }),
        (ot.int32 = nt.next),
        (ot.quick = ot),
        it &&
          (typeof it == 'object' && _e(it, nt),
          (ot.state = function() {
            return _e(nt, {})
          })),
        ot
      )
    }
    s && s.exports ? (s.exports = et) : (this.xorwow = et)
  })(commonjsGlobal$1, o)
})(xorwow$1)
var xorwowExports = xorwow$1.exports,
  xorshift7$1 = { exports: {} }
xorshift7$1.exports
;(function(o) {
  ;(function(a, s, $) {
    function j(tt) {
      var rt = this
      rt.next = function() {
        var it = rt.x,
          ot = rt.i,
          at,
          st
        return (
          (at = it[ot]),
          (at ^= at >>> 7),
          (st = at ^ (at << 24)),
          (at = it[(ot + 1) & 7]),
          (st ^= at ^ (at >>> 10)),
          (at = it[(ot + 3) & 7]),
          (st ^= at ^ (at >>> 3)),
          (at = it[(ot + 4) & 7]),
          (st ^= at ^ (at << 7)),
          (at = it[(ot + 7) & 7]),
          (at = at ^ (at << 13)),
          (st ^= at ^ (at << 9)),
          (it[ot] = st),
          (rt.i = (ot + 1) & 7),
          st
        )
      }
      function nt(it, ot) {
        var at,
          st = []
        if (ot === (ot | 0)) st[0] = ot
        else
          for (ot = '' + ot, at = 0; at < ot.length; ++at)
            st[at & 7] =
              (st[at & 7] << 15) ^
              ((ot.charCodeAt(at) + st[(at + 1) & 7]) << 13)
        for (; st.length < 8; ) st.push(0)
        for (at = 0; at < 8 && st[at] === 0; ++at);
        for (
          at == 8 ? (st[7] = -1) : st[at], it.x = st, it.i = 0, at = 256;
          at > 0;
          --at
        )
          it.next()
      }
      nt(rt, tt)
    }
    function _e(tt, rt) {
      return (rt.x = tt.x.slice()), (rt.i = tt.i), rt
    }
    function et(tt, rt) {
      tt == null && (tt = +new Date())
      var nt = new j(tt),
        it = rt && rt.state,
        ot = function() {
          return (nt.next() >>> 0) / 4294967296
        }
      return (
        (ot.double = function() {
          do
            var at = nt.next() >>> 11,
              st = (nt.next() >>> 0) / 4294967296,
              ut = (at + st) / (1 << 21)
          while (ut === 0)
          return ut
        }),
        (ot.int32 = nt.next),
        (ot.quick = ot),
        it &&
          (it.x && _e(it, nt),
          (ot.state = function() {
            return _e(nt, {})
          })),
        ot
      )
    }
    s && s.exports ? (s.exports = et) : (this.xorshift7 = et)
  })(commonjsGlobal$1, o)
})(xorshift7$1)
var xorshift7Exports = xorshift7$1.exports,
  xor4096$1 = { exports: {} }
xor4096$1.exports
;(function(o) {
  ;(function(a, s, $) {
    function j(tt) {
      var rt = this
      rt.next = function() {
        var it = rt.w,
          ot = rt.X,
          at = rt.i,
          st,
          ut
        return (
          (rt.w = it = (it + 1640531527) | 0),
          (ut = ot[(at + 34) & 127]),
          (st = ot[(at = (at + 1) & 127)]),
          (ut ^= ut << 13),
          (st ^= st << 17),
          (ut ^= ut >>> 15),
          (st ^= st >>> 12),
          (ut = ot[at] = ut ^ st),
          (rt.i = at),
          (ut + (it ^ (it >>> 16))) | 0
        )
      }
      function nt(it, ot) {
        var at,
          st,
          ut,
          ct,
          dt,
          ft = [],
          mt = 128
        for (
          ot === (ot | 0)
            ? ((st = ot), (ot = null))
            : ((ot = ot + '\0'), (st = 0), (mt = Math.max(mt, ot.length))),
            ut = 0,
            ct = -32;
          ct < mt;
          ++ct
        )
          ot && (st ^= ot.charCodeAt((ct + 32) % ot.length)),
            ct === 0 && (dt = st),
            (st ^= st << 10),
            (st ^= st >>> 15),
            (st ^= st << 4),
            (st ^= st >>> 13),
            ct >= 0 &&
              ((dt = (dt + 1640531527) | 0),
              (at = ft[ct & 127] ^= st + dt),
              (ut = at == 0 ? ut + 1 : 0))
        for (
          ut >= 128 && (ft[((ot && ot.length) || 0) & 127] = -1),
            ut = 127,
            ct = 4 * 128;
          ct > 0;
          --ct
        )
          (st = ft[(ut + 34) & 127]),
            (at = ft[(ut = (ut + 1) & 127)]),
            (st ^= st << 13),
            (at ^= at << 17),
            (st ^= st >>> 15),
            (at ^= at >>> 12),
            (ft[ut] = st ^ at)
        ;(it.w = dt), (it.X = ft), (it.i = ut)
      }
      nt(rt, tt)
    }
    function _e(tt, rt) {
      return (rt.i = tt.i), (rt.w = tt.w), (rt.X = tt.X.slice()), rt
    }
    function et(tt, rt) {
      tt == null && (tt = +new Date())
      var nt = new j(tt),
        it = rt && rt.state,
        ot = function() {
          return (nt.next() >>> 0) / 4294967296
        }
      return (
        (ot.double = function() {
          do
            var at = nt.next() >>> 11,
              st = (nt.next() >>> 0) / 4294967296,
              ut = (at + st) / (1 << 21)
          while (ut === 0)
          return ut
        }),
        (ot.int32 = nt.next),
        (ot.quick = ot),
        it &&
          (it.X && _e(it, nt),
          (ot.state = function() {
            return _e(nt, {})
          })),
        ot
      )
    }
    s && s.exports ? (s.exports = et) : (this.xor4096 = et)
  })(commonjsGlobal$1, o)
})(xor4096$1)
var xor4096Exports = xor4096$1.exports,
  tychei$1 = { exports: {} }
tychei$1.exports
;(function(o) {
  ;(function(a, s, $) {
    function j(tt) {
      var rt = this,
        nt = ''
      ;(rt.next = function() {
        var ot = rt.b,
          at = rt.c,
          st = rt.d,
          ut = rt.a
        return (
          (ot = (ot << 25) ^ (ot >>> 7) ^ at),
          (at = (at - st) | 0),
          (st = (st << 24) ^ (st >>> 8) ^ ut),
          (ut = (ut - ot) | 0),
          (rt.b = ot = (ot << 20) ^ (ot >>> 12) ^ at),
          (rt.c = at = (at - st) | 0),
          (rt.d = (st << 16) ^ (at >>> 16) ^ ut),
          (rt.a = (ut - ot) | 0)
        )
      }),
        (rt.a = 0),
        (rt.b = 0),
        (rt.c = -1640531527),
        (rt.d = 1367130551),
        tt === Math.floor(tt)
          ? ((rt.a = (tt / 4294967296) | 0), (rt.b = tt | 0))
          : (nt += tt)
      for (var it = 0; it < nt.length + 20; it++)
        (rt.b ^= nt.charCodeAt(it) | 0), rt.next()
    }
    function _e(tt, rt) {
      return (rt.a = tt.a), (rt.b = tt.b), (rt.c = tt.c), (rt.d = tt.d), rt
    }
    function et(tt, rt) {
      var nt = new j(tt),
        it = rt && rt.state,
        ot = function() {
          return (nt.next() >>> 0) / 4294967296
        }
      return (
        (ot.double = function() {
          do
            var at = nt.next() >>> 11,
              st = (nt.next() >>> 0) / 4294967296,
              ut = (at + st) / (1 << 21)
          while (ut === 0)
          return ut
        }),
        (ot.int32 = nt.next),
        (ot.quick = ot),
        it &&
          (typeof it == 'object' && _e(it, nt),
          (ot.state = function() {
            return _e(nt, {})
          })),
        ot
      )
    }
    s && s.exports ? (s.exports = et) : (this.tychei = et)
  })(commonjsGlobal$1, o)
})(tychei$1)
var tycheiExports = tychei$1.exports,
  seedrandom$2 = { exports: {} }
;(function(o) {
  ;(function(a, s, $) {
    var j = 256,
      _e = 6,
      et = 52,
      tt = 'random',
      rt = $.pow(j, _e),
      nt = $.pow(2, et),
      it = nt * 2,
      ot = j - 1,
      at
    function st(yt, pt, ht) {
      var At = []
      pt = pt == !0 ? { entropy: !0 } : pt || {}
      var wt = ft(dt(pt.entropy ? [yt, vt(s)] : yt ?? mt(), 3), At),
        Ct = new ut(At),
        Dt = function() {
          for (var jt = Ct.g(_e), Et = rt, St = 0; jt < nt; )
            (jt = (jt + St) * j), (Et *= j), (St = Ct.g(1))
          for (; jt >= it; ) (jt /= 2), (Et /= 2), (St >>>= 1)
          return (jt + St) / Et
        }
      return (
        (Dt.int32 = function() {
          return Ct.g(4) | 0
        }),
        (Dt.quick = function() {
          return Ct.g(4) / 4294967296
        }),
        (Dt.double = Dt),
        ft(vt(Ct.S), s),
        (
          pt.pass ||
          ht ||
          function(jt, Et, St, Bt) {
            return (
              Bt &&
                (Bt.S && ct(Bt, Ct),
                (jt.state = function() {
                  return ct(Ct, {})
                })),
              St ? (($[tt] = jt), Et) : jt
            )
          }
        )(Dt, wt, 'global' in pt ? pt.global : this == $, pt.state)
      )
    }
    function ut(yt) {
      var pt,
        ht = yt.length,
        At = this,
        wt = 0,
        Ct = (At.i = At.j = 0),
        Dt = (At.S = [])
      for (ht || (yt = [ht++]); wt < j; ) Dt[wt] = wt++
      for (wt = 0; wt < j; wt++)
        (Dt[wt] = Dt[(Ct = ot & (Ct + yt[wt % ht] + (pt = Dt[wt])))]),
          (Dt[Ct] = pt)
      ;(At.g = function(jt) {
        for (var Et, St = 0, Bt = At.i, Mt = At.j, Ut = At.S; jt--; )
          (Et = Ut[(Bt = ot & (Bt + 1))]),
            (St =
              St * j +
              Ut[ot & ((Ut[Bt] = Ut[(Mt = ot & (Mt + Et))]) + (Ut[Mt] = Et))])
        return (At.i = Bt), (At.j = Mt), St
      })(j)
    }
    function ct(yt, pt) {
      return (pt.i = yt.i), (pt.j = yt.j), (pt.S = yt.S.slice()), pt
    }
    function dt(yt, pt) {
      var ht = [],
        At = typeof yt,
        wt
      if (pt && At == 'object')
        for (wt in yt)
          try {
            ht.push(dt(yt[wt], pt - 1))
          } catch {}
      return ht.length ? ht : At == 'string' ? yt : yt + '\0'
    }
    function ft(yt, pt) {
      for (var ht = yt + '', At, wt = 0; wt < ht.length; )
        pt[ot & wt] = ot & ((At ^= pt[ot & wt] * 19) + ht.charCodeAt(wt++))
      return vt(pt)
    }
    function mt() {
      try {
        var yt
        return (
          at && (yt = at.randomBytes)
            ? (yt = yt(j))
            : ((yt = new Uint8Array(j)),
              (a.crypto || a.msCrypto).getRandomValues(yt)),
          vt(yt)
        )
      } catch {
        var pt = a.navigator,
          ht = pt && pt.plugins
        return [+new Date(), a, ht, a.screen, vt(s)]
      }
    }
    function vt(yt) {
      return String.fromCharCode.apply(0, yt)
    }
    if ((ft($.random(), s), o.exports)) {
      o.exports = st
      try {
        at = require$$0$3
      } catch {}
    } else $['seed' + tt] = st
  })(typeof self < 'u' ? self : commonjsGlobal$1, [], Math)
})(seedrandom$2)
var seedrandomExports = seedrandom$2.exports,
  alea = aleaExports,
  xor128 = xor128Exports,
  xorwow = xorwowExports,
  xorshift7 = xorshift7Exports,
  xor4096 = xor4096Exports,
  tychei = tycheiExports,
  sr = seedrandomExports
sr.alea = alea
sr.xor128 = xor128
sr.xorwow = xorwow
sr.xorshift7 = xorshift7
sr.xor4096 = xor4096
sr.tychei = tychei
var seedrandom = sr
const seedrandom$1 = getDefaultExportFromCjs(seedrandom)
class RandomNumberService {
  constructor() {
    Wr(this, 'seededRandom', null)
    var s
    const a = new URLSearchParams(
      (s = window$1.location) == null ? void 0 : s.search
    ).get('seed')
    a && this.seedRandomNumber(a)
  }
  seedRandomNumber(a) {
    this.seededRandom = seedrandom$1(a)
  }
  generateRandomNumber() {
    return this.seededRandom ? this.seededRandom() : Math.random()
  }
  unseedRandomNumber() {
    this.seededRandom = null
  }
  isRandomNumberLessThan(a) {
    return this.generateRandomNumber() <= a
  }
}
const randomNumberService = new RandomNumberService(),
  random = () => randomNumberService.generateRandomNumber(),
  generateValueAdjustments = (o = {}, a = {}) =>
    Object.keys(itemsMap).reduce(
      (s, $) => (
        itemsMap[$].doesPriceFluctuate &&
          (o[$] ? (s[$] = 0.5) : a[$] ? (s[$] = 1.5) : (s[$] = random() + 0.5)),
        s
      ),
      {}
    ),
  isItemAGrownCrop = o => o.type === itemType.CROP && !o.growsInto,
  FARM_PRODUCT_TYPES = [
    itemType.CRAFTED_ITEM,
    itemType.FUEL,
    itemType.MILK,
    itemType.ORE,
    itemType.STONE,
  ],
  isItemAFarmProduct = o =>
    !!(isItemAGrownCrop(o) || FARM_PRODUCT_TYPES.includes(o.type)),
  farmProductsSold = memoize(o =>
    Object.entries(o).reduce(
      (a, [s, $]) => a + (isItemAFarmProduct(itemsMap[s]) ? $ : 0),
      0
    )
  ),
  getInventoryQuantityMap = memoize(o =>
    o.reduce((a, { id: s, quantity: $ }) => ((a[s] = $), a), {})
  ),
  getItemBaseValue = o => itemsMap[o].value,
  getLevelEntitlements = memoize(o => {
    const a = {
      sprinklerRange: INITIAL_SPRINKLER_RANGE,
      items: {},
      tools: {},
      stageFocusType: {},
    }
    return (
      levels.find(
        ({
          unlocksShopItem: s,
          unlocksStageFocusType: $,
          unlocksTool: j,
          id: _e,
          increasesSprinklerRange: et,
        }) => (
          et && a.sprinklerRange++,
          s && (a.items[s] = !0),
          j && (a.tools[j] = !0),
          $ && (a.stageFocusType[$] = !0),
          _e === o
        )
      ),
      a
    )
  }),
  Jimp = configure({ types: [jimpPng] }),
  { SEED, GROWING, GROWN: GROWN$2 } = cropLifeStage,
  isPlotContent = (o = {}) => !!(o && o.itemId && o.fertilizerType),
  isShoveledPlot = (o = {}) => !!(o && o.isShoveled && o.daysUntilClear),
  purchasableItemMap = [...inventory$1, ...inventory].reduce(
    (o, a) => ((o[a.id] = a), o),
    {}
  ),
  chooseRandomIndex = o => Math.round(random() * (o.length - 1)),
  chooseRandom = o => o[chooseRandomIndex(o)],
  memoizationSerializer = o =>
    JSON.stringify(
      [...o].map(a => (typeof a == 'function' ? a.toString() : a))
    ),
  clampNumber = (o, a, s) => (o <= a ? a : o >= s ? s : o),
  castToMoney = o => Math.round(o * 100) / 100,
  moneyTotal = (...o) =>
    o.reduce((a, s) => (a += Math.round(s * 100)), 0) / 100,
  scaleNumber = (o, a, s, $, j) => ((o - a) * (j - $)) / (s - a) + $,
  convertStringToInteger = o =>
    o.split('').reduce((a, s, $) => a + s.charCodeAt(0) * $, 0),
  createNewField = () =>
    new Array(INITIAL_FIELD_HEIGHT)
      .fill(void 0)
      .map(() => new Array(INITIAL_FIELD_WIDTH).fill(null)),
  createNewForest = () =>
    new Array(INITIAL_FOREST_HEIGHT)
      .fill(void 0)
      .map(() => new Array(INITIAL_FOREST_WIDTH).fill(null)),
  formatNumber = (o, a) =>
    dinero({ amount: Math.round(o * 100), precision: 2 })
      .convertPrecision(0)
      .toFormat(a),
  dollarString = o => formatNumber(o, '$0,0'),
  integerString = o => formatNumber(o, '0,0'),
  getItemCurrentValue = ({ id: o }, a) =>
    dinero({
      amount: Math.round(
        (a[o]
          ? getItemBaseValue(o) * (itemsMap[o].doesPriceFluctuate ? a[o] : 1)
          : getItemBaseValue(o)) * 100
      ),
      precision: 2,
    }).toUnit(),
  getAdjustedItemValue = (o, a) =>
    Number(((o[a] || 1) * itemsMap[a].value).toFixed(2)),
  isItemSoldInShop = ({ id: o }) => !!purchasableItemMap[o],
  getResaleValue = ({ id: o }) => itemsMap[o].value / 2,
  getPlotContentFromItemId = o => ({
    itemId: o,
    fertilizerType: fertilizerType.NONE,
  }),
  getCropFromItemId = o => ({
    ...getPlotContentFromItemId(o),
    daysOld: 0,
    daysWatered: 0,
    wasWateredToday: !1,
  }),
  getPlotContentType = ({ itemId: o }) => (o ? itemsMap[o].type : null),
  doesPlotContainCrop = o =>
    o !== null && getPlotContentType(o) === itemType.CROP,
  getLifeStageRange = memoize(o => {
    let a = Array(o[0]).fill(SEED)
    return (
      (a = a.concat(
        o.slice(1).reduce((s, $) => s.concat(Array($).fill(GROWING)), [])
      )),
      a
    )
  }),
  getGrowingPhase = memoize(
    o => {
      const { itemId: a, daysWatered: s } = o,
        { cropTimeline: $ = [] } = itemsMap[a]
      let j = s + 1,
        _e = 0
      for (let et of $) {
        if (j - et <= 0) break
        ;(j -= et), (_e += 1)
      }
      return _e
    },
    {
      cacheSize:
        LARGEST_PURCHASABLE_FIELD_SIZE.columns *
        LARGEST_PURCHASABLE_FIELD_SIZE.rows,
    }
  ),
  getCropLifeStage = o => {
    const { itemId: a, daysWatered: s } = o,
      { cropTimeline: $ } = itemsMap[a]
    if (!$) throw new Error(`${a} has no cropTimeline`)
    return getLifeStageRange($)[Math.floor(s)] || GROWN$2
  },
  getPlotImage = (o, a, s) => {
    if (isPlotContent(o)) {
      if (isPlotContentACrop(o)) {
        let $
        switch (getCropLifeStage(o)) {
          case GROWN$2:
            $ = o.itemId
            break
          case GROWING:
            const j = getGrowingPhase(o)
            $ = `${o.itemId}-growing-${j}`
            break
          default:
            $ = cropItemIdToSeedItemMap[o.itemId].id
        }
        return items[$]
      }
      if (getPlotContentType(o) === itemType.WEED) {
        const $ = ['yellow', 'orange', 'pink'],
          j = $[(a * s) % $.length]
        return items[`weed-${j}`]
      }
    }
    return isShoveledPlot(o) && o != null && o.oreId
      ? items[o.oreId]
      : isPlotContent(o)
      ? items[o.itemId]
      : null
  },
  getRangeCoords = (o, a, s) => {
    const $ = 2 * o + 1,
      j = a - o,
      _e = s - o
    return new Array($)
      .fill(null)
      .map((et, tt) =>
        new Array($).fill(null).map((rt, nt) => ({ x: j + nt, y: _e + tt }))
      )
  },
  getFinalCropItemFromSeedItem = ({ id: o }, a = 0) => {
    const s = getFinalCropItemIdFromSeedItemId(o, a)
    if (s) return itemsMap[s]
  },
  getFinalCropItemIdFromSeedItemId = (o, a = 0) => {
    const { growsInto: s } = itemsMap[o]
    return Array.isArray(s) ? s[a] : s
  },
  getSeedItemIdFromFinalStageCropItemId = memoize(
    o => {
      var s
      const a =
        (s = Object.values(itemsMap).find(({ growsInto: $ }) =>
          Array.isArray($) ? $.includes(o) : $ === o
        )) == null
          ? void 0
          : s.id
      if (!a)
        throw new Error(`Crop item ID ${o} does not have a corresponding seed`)
      return a
    },
    { cacheSize: Object.keys(itemsMap).length }
  ),
  getDefaultCowName = ({ id: o }) =>
    fruitNames[convertStringToInteger(o) % fruitNames.length],
  getCowDisplayName = (o, a, s) =>
    o.originalOwnerId !== a && !s ? getDefaultCowName(o) : o.name,
  generateCow = (o = {}) => {
    const a = o.gender || chooseRandom(Object.values(genders)),
      s = o.color || chooseRandom(Object.values(standardCowColors)),
      $ = o.id || uuid_1.v4(),
      _e = {
        baseWeight: Math.round(
          COW_STARTING_WEIGHT_BASE *
            (a === genders.MALE ? MALE_COW_WEIGHT_MULTIPLIER : 1) -
            COW_STARTING_WEIGHT_VARIANCE +
            random() * (COW_STARTING_WEIGHT_VARIANCE * 2)
        ),
        color: s,
        colorsInBloodline: { [s]: !0 },
        daysOld: 1,
        daysSinceMilking: 0,
        daysSinceProducingFertilizer: 0,
        gender: a,
        happiness: 0,
        happinessBoostsToday: 0,
        id: $,
        isBred: !1,
        isUsingHuggingMachine: !1,
        name: '',
        ownerId: '',
        originalOwnerId: '',
        timesTraded: 0,
        weightMultiplier: 1,
        ...o,
      }
    return (_e.name = getDefaultCowName(_e)), _e
  },
  generateOffspringCow = (o, a, s, $ = {}) => {
    if (o.gender === a.gender)
      throw new Error(
        `${JSON.stringify(o)} ${JSON.stringify(
          a
        )} cannot produce offspring because they have the same gender`
      )
    const j = o.gender === genders.MALE ? o : a,
      _e = o.gender === genders.MALE ? a : o,
      et = {
        [j.color]: !0,
        [_e.color]: !0,
        ...j.colorsInBloodline,
        ..._e.colorsInBloodline,
      }
    delete et[cowColors.RAINBOW]
    const tt = Object.keys(et).length === Object.keys(standardCowColors).length
    return generateCow({
      color: tt ? cowColors.RAINBOW : chooseRandom([_e.color, j.color]),
      colorsInBloodline: et,
      baseWeight: (j.baseWeight + _e.baseWeight) / 2,
      isBred: !0,
      ownerId: s,
      originalOwnerId: s,
      ...$,
    })
  },
  getCowMilkItem = ({ color: o, happiness: a }) => {
    if (o === cowColors.BROWN) return chocolateMilk$1
    const s = o === cowColors.RAINBOW
    return a < 1 / 3
      ? s
        ? rainbowMilk1$1
        : milk1$1
      : a < 2 / 3
      ? s
        ? rainbowMilk2$1
        : milk2$1
      : s
      ? rainbowMilk3$1
      : milk3$1
  },
  getCowFertilizerItem = ({ color: o }) =>
    itemsMap[o === cowColors.RAINBOW ? 'rainbow-fertilizer' : 'fertilizer'],
  getCowMilkRate = o =>
    o.gender === genders.FEMALE
      ? scaleNumber(
          o.weightMultiplier,
          COW_WEIGHT_MULTIPLIER_MINIMUM,
          COW_WEIGHT_MULTIPLIER_MAXIMUM,
          COW_MILK_RATE_SLOWEST,
          COW_MILK_RATE_FASTEST
        )
      : 1 / 0,
  getCowFertilizerProductionRate = o =>
    o.gender === genders.MALE
      ? scaleNumber(
          o.weightMultiplier,
          COW_WEIGHT_MULTIPLIER_MINIMUM,
          COW_WEIGHT_MULTIPLIER_MAXIMUM,
          COW_FERTILIZER_PRODUCTION_RATE_SLOWEST,
          COW_FERTILIZER_PRODUCTION_RATE_FASTEST
        )
      : 1 / 0,
  getCowWeight = ({ baseWeight: o, weightMultiplier: a }) => Math.round(o * a),
  getCowValue = (o, a = !1) =>
    a
      ? getCowWeight(o) *
        clampNumber(
          scaleNumber(
            o.daysOld,
            1,
            COW_MAXIMUM_VALUE_MATURITY_AGE,
            COW_MINIMUM_VALUE_MULTIPLIER,
            COW_MAXIMUM_VALUE_MULTIPLIER
          ),
          COW_MINIMUM_VALUE_MULTIPLIER,
          COW_MAXIMUM_VALUE_MULTIPLIER
        )
      : getCowWeight(o) * 1.5,
  getCowSellValue = o => getCowValue(o, !0),
  maxYieldOfRecipe = memoize(({ ingredients: o }, a) => {
    const s = getInventoryQuantityMap(a)
    return Math.min(...Object.keys(o).map($ => Math.floor(s[$] / o[$]))) || 0
  }),
  canMakeRecipe = (o, a, s) => maxYieldOfRecipe(o, a) >= s,
  filterItemIdsToSeeds = o => o.filter(a => itemsMap[a].type === itemType.CROP),
  getRandomUnlockedCrop = o => {
    const a = chooseRandom(o),
      s = itemsMap[a],
      $ = Array.isArray(s.growsInto) ? chooseRandomIndex(s.growsInto) : 0,
      j = getFinalCropItemIdFromSeedItemId(a, $)
    if (!j)
      throw new Error(`Seed item ID ${a} has no corresponding final crop ID`)
    return itemsMap[j]
  },
  getPriceEventForCrop = o => ({
    itemId: o.id,
    daysRemaining:
      getCropLifecycleDuration(o) - PRICE_EVENT_STANDARD_DURATION_DECREASE,
  }),
  doesMenuObstructStage = () => window.innerWidth < BREAKPOINTS.MD,
  itemTypesToShowInReverse = new Set([itemType.MILK]),
  sortItemIdsByTypeAndValue = memoize(o =>
    sortBy(o, [
      a => +(itemsMap[a].type !== itemType.CROP),
      a => {
        const { type: s, value: $ } = itemsMap[a]
        return itemTypesToShowInReverse.has(s) ? -$ : $
      },
    ])
  ),
  sortItems = o => {
    const a = {}
    return (
      o.forEach(s => (a[s.id] = s)),
      sortItemIdsByTypeAndValue(o.map(({ id: s }) => s)).map(s => a[s])
    )
  },
  inventorySpaceConsumed = memoize(o =>
    o.reduce((a, { quantity: s = 0 }) => a + s, 0)
  ),
  inventorySpaceRemaining = ({ inventory: o, inventoryLimit: a }) =>
    a === INFINITE_STORAGE_LIMIT
      ? 1 / 0
      : Math.max(0, a - inventorySpaceConsumed(o)),
  doesInventorySpaceRemain = o => inventorySpaceRemaining(o) > 0,
  areHuggingMachinesInInventory = memoize(o =>
    o.some(({ id: a }) => a === HUGGING_MACHINE_ITEM_ID)
  ),
  nullArray = memoize(o => Object.freeze(new Array(o).fill(null)), {
    cacheSize: 30,
  }),
  findCowById = memoize((o, a) => o.find(s => a === s.id)),
  experienceNeededForLevel = o => ((o - 1) * 10) ** 2,
  getAvailableShopInventory = memoize(o =>
    inventory.filter(
      ({ id: a }) =>
        !(unlockableItems.hasOwnProperty(a) && !o.items.hasOwnProperty(a))
    )
  ),
  getRandomLevelUpReward = o =>
    itemsMap[
      chooseRandom(
        filterItemIdsToSeeds(Object.keys(getLevelEntitlements(o).items))
      )
    ],
  getRandomLevelUpRewardQuantity = o => o * 10,
  getPeerMetadata = o => {
    const a = PEER_METADATA_STATE_KEYS.reduce((s, $) => ((s[$] = o[$]), s), {})
    return (
      Object.assign(a, {
        cowOfferedForTrade: o.cowInventory.find(
          ({ id: s }) => s === o.cowIdOfferedForTrade
        ),
      }),
      a
    )
  },
  reduceByPersistedKeys = o =>
    PERSISTED_STATE_KEYS.reduce(
      (a, s) => (typeof o[s] < 'u' && (a[s] = o[s]), a),
      {}
    ),
  get7DayAverage = o =>
    o.reduce((a, s) => moneyTotal(a, s), 0) /
    DAILY_FINANCIAL_HISTORY_RECORD_LENGTH,
  cowColorToIdMap = {
    [cowColors.BLUE]: 'blue',
    [cowColors.BROWN]: 'brown',
    [cowColors.GREEN]: 'green',
    [cowColors.ORANGE]: 'orange',
    [cowColors.PURPLE]: 'purple',
    [cowColors.RAINBOW]: 'rainbow',
    [cowColors.WHITE]: 'white',
    [cowColors.YELLOW]: 'yellow',
  },
  getCowColorId = ({ color: o }) => `${cowColorToIdMap[o]}-cow`,
  getProfit = (o, a) => moneyTotal(o, a),
  getProfitRecord = (o, a, s) => Math.max(o, getProfit(a, s)),
  computeMarketPositions = (o, a, s) =>
    s.reduce(($, { id: j, quantity: _e }) => {
      const et = o[j] || 0,
        tt = a[j] || 0
      return (
        itemsMap[j].doesPriceFluctuate &&
          et !== _e &&
          (_e < et || _e < tt
            ? ($[j] = -1)
            : (_e > et || _e > tt) && ($[j] = 1)),
        $
      )
    }, {}),
  transformStateDataForImport = o => {
    let a = { ...o }
    return (
      ['version'].forEach($ => delete a[$]),
      a.experience === 0 && (a.experience = farmProductsSold(a.itemsSold)),
      a.showHomeScreen === !1 &&
        a.stageFocus === stageFocusType.HOME &&
        (a = { ...a, stageFocus: STANDARD_VIEW_LIST[0] }),
      a
    )
  },
  getPlayerName = memoize(o => funAnimalName(o)),
  getCostOfNextStorageExpansion = o => {
    const a = (o - INITIAL_STORAGE_LIMIT) / STORAGE_EXPANSION_AMOUNT
    return STORAGE_EXPANSION_BASE_PRICE + a * STORAGE_EXPANSION_SCALE_PREMIUM
  },
  sleep = o => new Promise(a => setTimeout(a, o)),
  getSalePriceMultiplier = (o = {}) => {
    let a = 1
    return (
      o['i-am-rich-3']
        ? (a += I_AM_RICH_BONUSES[2])
        : o['i-am-rich-2']
        ? (a += I_AM_RICH_BONUSES[1])
        : o['i-am-rich-1'] && (a += I_AM_RICH_BONUSES[0]),
      a
    )
  },
  isPlotContentACrop = o => getPlotContentType(o) === itemType.CROP
function randomChoice(o) {
  let a = 0,
    s = []
  for (let et of o) (a += et.weight), s.push(et)
  s.sort(et => et.weight)
  let $ = random() * a,
    j,
    _e = 0
  for (let et in s) {
    if (((j = s[et]), $ < j.weight + _e)) return j
    _e += j.weight
  }
}
const colorizeCowTemplate = (() => {
    const s = document.createElement('canvas')
    s.setAttribute('height', String(48)), s.setAttribute('width', String(48))
    const $ = {},
      j = memoize(_e => {
        const [, et, tt, rt] = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
          _e
        ) ?? ['', '0', '0', '0']
        return { r: parseInt(et, 16), g: parseInt(tt, 16), b: parseInt(rt, 16) }
      })
    return async (_e, et) => {
      if (et === cowColors.RAINBOW) return animals.cow.rainbow
      const tt = `${et}_${_e}`
      if ($[tt]) return $[tt]
      try {
        const rt = buffer$1.Buffer.from(_e.split(',')[1] ?? '', 'base64'),
          nt = await Jimp.read(rt)
        return (
          nt.scan(0, 0, nt.bitmap.width, nt.bitmap.height, function(it, ot) {
            const { r: at, g: st, b: ut } = Jimp.intToRGBA(
              nt.getPixelColor(it, ot)
            )
            if (at === 102 && st === 102 && ut === 102) {
              const ct = j(COW_COLORS_HEX_MAP[et]),
                dt = Jimp.rgbaToInt(ct.r, ct.g, ct.b, 255)
              nt.setPixelColor(dt, it, ot)
            }
          }),
          ($[tt] = await nt.getBase64Async(Jimp.MIME_PNG)),
          $[tt]
        )
      } catch (rt) {
        return console.error(rt), pixel
      }
    }
  })(),
  getCowImage = async o => {
    const a = convertStringToInteger(o.id),
      { variations: s } = animals.cow,
      $ = s[a % s.length]
    return await colorizeCowTemplate($, o.color)
  },
  isInViewport = o => {
    const { top: a, left: s, bottom: $, right: j } = o.getBoundingClientRect()
    return (
      a >= 0 &&
      s >= 0 &&
      $ <= (window.innerHeight || document.documentElement.clientHeight) &&
      j <= (window.innerWidth || document.documentElement.clientWidth)
    )
  },
  shouldPrecipitateToday = () => random() < PRECIPITATION_CHANCE,
  shouldStormToday = () => random() < STORM_CHANCE,
  isCowInBreedingPen = (o, a) => a.cowId1 === o.id || a.cowId2 === o.id,
  isOctober = () => new Date().getMonth() === 9,
  isDecember = () => new Date().getMonth() === 11,
  PROGRESS_SAVED_MESSAGE = 'Progress saved!',
  RAIN_MESSAGE = 'It rained in the night!',
  STORM_MESSAGE = 'There was a storm in the night!',
  STORM_DESTROYS_SCARECROWS_MESSAGE =
    'There was a storm in the night! No scarecrows survived!',
  FARM_PRODUCTS_TOOLTIP_TEXT =
    'This figure only includes sales of grown crops, crafted items, and animal products.',
  COW_SOLD_TOOLTIP_TEXT =
    'This figure only includes cows you were not the original owner for.',
  DATA_DELETED = 'Your local game data has been deleted.',
  INVALID_DATA_PROVIDED = 'Invalid Farmhand data provided.',
  UPDATE_AVAILABLE =
    "A game update is available! Click this message to reload and see what's new.",
  SERVER_ERROR =
    'There was an issue connecting to the server. Please try again in a moment.',
  CONNECTING_TO_SERVER = 'Connecting...',
  DISCONNECTING_FROM_SERVER = 'Disconnecting...',
  DISCONNECTED_FROM_SERVER = 'You are now playing offline.',
  REQUESTED_COW_TRADE_UNAVAILABLE = 'The requested cow is no longer available.',
  UNKNOWN_COW_TRADE_FAILURE =
    'Something went wrong with your cow trade request. Please try again!',
  COW_ALREADY_OWNED = 'It looks like you already have this cow!',
  OUT_OF_COW_FEED_NOTIFICATION =
    "You're out of cow feed! Buy some more before your cows get hungry and run away!",
  OUT_OF_WATER_CREDIT_NOTIFICATION =
    "You don't have enough water credit! Buy some more before going to the next day!",
  INVENTORY_FULL_NOTIFICATION = 'Your inventory is full!',
  SHOVELED = 'Shoveled plot',
  WATERING_CAN_ALT_TEXT = 'A watering can for hydrating plants.',
  WATERING_CAN_HIDDEN_TEXT = 'Select the watering can to water your crops',
  SCYTHE_ALT_TEXT = 'A scythe for crop harvesting.',
  SCYTHE_HIDDEN_TEXT = 'Select the scythe to harvest ripened crops',
  HOE_ALT_TEXT =
    'A hoe for removing crops and disposing of them. Also returns replantable items to your inventory.',
  HOE_HIDDEN_TEXT = 'Select the hoe to clear crops, or replantable field items',
  SHOVEL_ALT_TEXT = 'A shovel for digging up rocks.',
  SHOVEL_HIDDEN_TEXT = 'Select the shovel to dig for ore',
  TOOL_LEVEL_INFO = {
    SCYTHE: {
      DEFAULT: '**Basic**: Harvests one crop per plot.',
      BRONZE: '**Bronze**: Harvests two crops per plot.',
      IRON: '**Iron**: Harvests three crops per plot.',
      SILVER: '**Silver**: Harvests four crops per plot.',
      GOLD: '**Gold**: Harvests five crops per plot.',
    },
    SHOVEL: {
      DEFAULT: '**Basic**: Has a 30% chance of digging up resources.',
      BRONZE: '**Bronze**: Has a 40% chance of digging up resources.',
      IRON: '**Iron**: Has a 50% chance of digging up resources.',
      SILVER: '**Silver**: Has a 60% chance of digging up resources.',
      GOLD: '**Gold**: Has a 70% chance of digging up resources.',
    },
    WATERING_CAN: {
      DEFAULT: '**Basic**: Keeps plots watered for one day.',
      BRONZE: '**Bronze**: Keeps plots watered for two days.',
      IRON: '**Iron**: Keeps plots watered for three days.',
      SILVER: '**Silver**: Keeps plots watered for four days.',
      GOLD: '**Gold**: Keeps plots watered for five days.',
    },
    HOE: {
      DEFAULT: '**Basic**: Destroys crops.',
      BRONZE: '**Bronze**: 25% chance to retrieve seeds when digging up crops.',
      IRON: '**Iron**: 50% chance to retrieve seeds when digging up crops.',
      SILVER: '**Silver**: 75% chance to retrieve seeds when digging up crops.',
      GOLD: '**Gold**: 100% chance to retrieve seeds when digging up crops.',
    },
  },
  FORGE_AVAILABLE_NOTIFICATION =
    '**The Forge** is now available in the Workshop!',
  RECYCLING_AVAILABLE_NOTIFICATION =
    '**Recycling** is now available in the Workshop!',
  FOREST_AVAILABLE_NOTIFICATION = 'The **Forest** is now available!',
  COW_COLOR_NAMES = {
    [cowColors.BLUE]: 'Blue',
    [cowColors.BROWN]: 'Brown',
    [cowColors.GREEN]: 'Green',
    [cowColors.ORANGE]: 'Orange',
    [cowColors.PURPLE]: 'Purple',
    [cowColors.RAINBOW]: 'Rainbow',
    [cowColors.WHITE]: 'White',
    [cowColors.YELLOW]: 'Yellow',
  },
  SHOVEL_UNLOCKED = "You've unlocked a new tool for the field, The **Shovel**!",
  addCowToInventory = (o, a) => {
    const { cowInventory: s } = o
    return { ...o, cowInventory: [...s, a] }
  }
function levelAchieved(o = 0) {
  return Math.floor(Math.sqrt(o) / 10) + 1
}
const moneyString = o => dinero({ amount: Math.round(o * 100) }).toFormat(),
  CROWS_DESTROYED = (o, a) =>
    `Oh no! Crows destroyed ${a} crop${a > 1 ? 's' : ''}!`,
  COW_PEN_PURCHASED = (o, a) =>
    `Purchased a cow pen with capacity for ${a} cows! You can visit your cow pen by going to the "Cows" page.`,
  CELLAR_PURCHASED = (o, a) =>
    `Purchased a cellar with capacity for ${a} kegs! View your keg inventory by going to the "Cellar" page.`,
  MILKS_PRODUCED = (o, a) => {
    let s = `Your cows produced milk:
`
    return (
      Object.keys(a)
        .sort()
        .forEach(
          $ =>
            (s += `  - ${a[$]} ${$}${a[$] > 1 ? 's' : ''}
`)
        ),
      s
    )
  },
  FERTILIZERS_PRODUCED = (o, a) => {
    let s = `Your cows produced fertilizer:
`
    return (
      Object.keys(a)
        .sort()
        .forEach(
          $ =>
            (s += `  - ${a[$]} ${$}${a[$] > 1 ? 's' : ''}
`)
        ),
      s
    )
  },
  COW_ATTRITION_MESSAGE = (o, { name: a }) =>
    `${a} got hungry from being underfed and ran away!`,
  COW_BORN_MESSAGE = (o, a, s, $) =>
    `${a.name} and ${s.name} had a baby: ${$.name}! Welcome to the world, ${$.name}!`,
  RECIPE_LEARNED = (o, a) => `You learned a new recipe: **${a.name}**!`,
  RECIPES_LEARNED = (o, a) => {
    let s = ''
    const $ = a.map(({ name: j }) => j)
    return (
      a.length === 2
        ? (s = `**${$[0]}** and **${$[1]}**`)
        : a.length > 2 &&
          (s = `**${$.slice(0, -1).join(', ')},** and **${$.slice(-1)}**`),
      `You learned the recipes for ${s}!`
    )
  },
  PRICE_CRASH = (o, { name: a }) =>
    `${a} prices have bottomed out! Avoid selling them until prices return to normal.`,
  PRICE_SURGE = (o, { name: a }) =>
    `${a} prices are at their peak! Now is the time to sell!`,
  ACHIEVEMENT_COMPLETED = (
    o,
    { name: a, rewardDescription: s }
  ) => `You achieved "${a}!" Way to go!

You earned: ${s}`,
  LOAN_PAYOFF = () =>
    "You paid off your loan to the bank! You're finally free!",
  LOAN_INCREASED = (o, a) =>
    `You took out a new loan. Your current balance is ${moneyString(a)}.`,
  LOAN_BALANCE_NOTIFICATION = (o, a) =>
    `Your loan balance has grown to ${moneyString(a)}.`,
  LEVEL_GAINED_NOTIFICATION = (o, a, s) => {
    let $ = [
      `You reached **level ${a}!** Way to go!

`,
    ]
    const j = levels[a]
    return (
      itemUnlockLevels[a]
        ? $.push(
            `Now available in the shop: **${
              itemsMap[itemUnlockLevels[a]].name
            }**.`
          )
        : j && j.increasesSprinklerRange
        ? $.push('Sprinkler range has increased.')
        : s
        ? $.push(
            `You got **${getRandomLevelUpRewardQuantity(a)} units of ${
              s.name
            }** as a reward!`
          )
        : j && j.unlocksTool
        ? j.unlocksTool === toolType.SHOVEL && $.push(SHOVEL_UNLOCKED)
        : j &&
          j.unlocksStageFocusType &&
          j.unlocksStageFocusType === stageFocusType.FOREST &&
          $.push(FOREST_AVAILABLE_NOTIFICATION),
      $.join(' ')
    )
  },
  CONNECTED_TO_ROOM = (o, a) => `Connected to room **${a}**!`,
  POSITIONS_POSTED_NOTIFICATION = (o, a, s) => {
    const $ = [],
      j = [],
      _e = Object.keys(s)
    _e.forEach(tt => (s[tt] > 0 ? $ : j).push(tt))
    const et = _e.length
      ? [
          `${a} impacted the market!
`,
        ]
      : []
    return (
      $.length &&
        (et.push('Values raised:'),
        $.forEach(tt => et.push(`  - ${itemsMap[tt].name}`))),
      j.length &&
        ($.length && et.push(''),
        et.push('Values lowered:'),
        j.forEach(tt => et.push(`  - ${itemsMap[tt].name}`))),
      et.join(`
`)
    )
  },
  PURCHASED_ITEM_PEER_NOTIFICATION = (o, a, { name: s }) =>
    `purchased ${integerString(a)} unit${a > 1 ? 's' : ''} of ${s}.`,
  SOLD_ITEM_PEER_NOTIFICATION = (o, a, { name: s }) =>
    `sold ${integerString(a)} unit${a > 1 ? 's' : ''} of ${s}.`,
  SOLD_FERMENTED_ITEM_PEER_NOTIFICATION = (o, a) =>
    `sold one unit of ${FERMENTED_CROP_NAME`${a}`}.`,
  TOOL_UPGRADED_NOTIFICATION = (o, a, s) =>
    `Your ${a} has been upgraded to a **${s}**!`,
  INGREDIENTS_LIST_ITEM = (o, a, s, $) => `${a} x ${s} (On hand: ${$})`,
  OFFER_COW_FOR_TRADE = (o, a) => `Offer ${a} for trade with online players`,
  WITHDRAW_COW_FROM_TRADE = (o, a) => `Keep ${a} from being traded`,
  COW_TRADED_NOTIFICATION = (o, a, s, $, j) =>
    `You traded ${getCowDisplayName(a, $, j)} for ${getCowDisplayName(
      s,
      $,
      j
    )}!`,
  SHOVELED_PLOT = (o, a) => `Shoveled plot of ${a.name}`,
  FERMENTED_CROP_NAME = (o, a) => `Fermented ${a.name}`,
  KEG_SPOILED_MESSAGE = (o, a) =>
    `Oh no! Your ${FERMENTED_CROP_NAME`${itemsMap[a.itemId]}`} has spoiled!`,
  NEW_COW_OFFERED_FOR_TRADE = (o, a) =>
    `A new cow is being offered for trade by ${getPlayerName(a.id)}!`,
  FOREST_EXPANDED = (o, a) =>
    `The Forest has expanded! You can now plant up to ${a} trees.`,
  EXPERIENCE_GAUGE_TOOLTIP_LABEL = (o, a, s) =>
    a === 1
      ? `Just 1 more experience point needed to reach level ${integerString(
          s
        )}!`
      : `${integerString(
          a
        )} more experience points needed to reach level ${integerString(s)}`,
  addItemToInventory = (o, a, s = 1, $ = !1) => {
    const { id: j } = a,
      _e = [...o.inventory]
    if (j === MANURE_MANAGER_ID && _e.some(nt => nt.id === MANURE_MANAGER_ID))
      return {
        ...o,
        latestNotification: {
          message: 'You already own a Manure Manager!',
          severity: 'error',
        },
        inventoryAddBlocked: !0,
      }
    const et = $ ? s : Math.min(s, inventorySpaceRemaining(o))
    if (et === 0) return o
    const tt = _e.findIndex(({ id: rt }) => j === rt)
    if (~tt) {
      const rt = _e[tt]
      _e[tt] = { ...rt, quantity: rt.quantity + et }
    } else _e.push({ id: j, quantity: et })
    return { ...o, inventory: _e }
  },
  showNotification = (o, a, s = 'info', $ = void 0) => {
    const { showNotifications: j, todaysNotifications: _e } = o
    return {
      ...o,
      ...(j && { latestNotification: { message: a, onClick: $, severity: s } }),
      todaysNotifications: _e.find(et => et.message === a)
        ? _e
        : _e.concat({ message: a, onClick: $, severity: s }),
    }
  },
  unlockTool = (o, a) => {
    const { toolLevels: s } = o
    return s[a] === toolLevel.UNAVAILABLE
      ? { ...o, toolLevels: { ...s, [a]: toolLevel.DEFAULT } }
      : o
  },
  processLevelUp = (o, a) => {
    const { experience: s, selectedItemId: $ } = o,
      j = levelAchieved(s)
    for (let _e = j; _e > a; _e--) {
      const et = levels[_e] || {}
      let tt
      if (Object.keys(et).length < 2)
        (tt = getRandomLevelUpReward(_e)),
          (o = addItemToInventory(
            o,
            tt,
            getRandomLevelUpRewardQuantity(_e),
            !0
          ))
      else if (et != null && et.unlocksTool) o = unlockTool(o, et.unlocksTool)
      else if (et && et.increasesSprinklerRange && $ === SPRINKLER_ITEM_ID) {
        const { sprinklerRange: rt } = getLevelEntitlements(levelAchieved(s))
        rt > o.hoveredPlotRangeSize && (o = { ...o, hoveredPlotRangeSize: rt })
      }
      o = showNotification(o, LEVEL_GAINED_NOTIFICATION`${_e}${tt}`, 'success')
    }
    return o
  },
  addExperience = (o, a) => {
    const { experience: s } = o,
      $ = levelAchieved(s)
    let j = { ...o, experience: s + a }
    return (j = processLevelUp(j, $)), j
  },
  addPeer = (o, a) => {
    const s = { ...o.peers }
    return (
      (s[a] = null),
      { ...o, peers: s, activePlayers: (o.activePlayers ?? 1) + 1 }
    )
  },
  addRevenue = (o, a) => {
    const { money: s, revenue: $, todaysRevenue: j } = o
    return {
      ...o,
      money: moneyTotal(s, a),
      revenue: moneyTotal($, a),
      todaysRevenue: moneyTotal(j, a),
    }
  },
  adjustLoan = (o, a) => {
    const s = moneyTotal(o.loanBalance, a),
      $ = moneyTotal(o.money, a)
    return (
      s === 0 && a < 0
        ? (o = showNotification(o, LOAN_PAYOFF``, 'success'))
        : a > 0 &&
          (o = {
            ...showNotification(o, LOAN_INCREASED`${s}`, 'info'),
            loansTakenOut: o.loansTakenOut + 1,
          }),
      { ...o, loanBalance: s, money: $ }
    )
  },
  findInField = memoize(
    (o, a) => {
      for (const s of o) for (const $ of s) if (a($)) return $
      return null
    },
    { serializer: memoizationSerializer }
  ),
  setWasWateredProperty = (o, a) =>
    o === null
      ? null
      : getPlotContentType(o) === itemType.CROP
      ? { ...o, wasWateredToday: a }
      : { ...o },
  setWasWatered = o => setWasWateredProperty(o, !0),
  fieldHasScarecrow = o => findInField(o, plotContainsScarecrow),
  applyChanceEvent = (o, a) => o.reduce((s, [$, j]) => ($() ? j(s) : s), a),
  plotContainsScarecrow = o => o && o.itemId === SCARECROW_ITEM_ID,
  updateField = (o, a) => o.map((s, $) => s.map((j, _e) => a(j, _e, $))),
  decrementItemFromInventory = (o, a, s = 1) => {
    const $ = [...o.inventory],
      j = $.findIndex(({ id: et }) => et === a)
    if (j === -1) return o
    const { quantity: _e } = $[j]
    return (
      _e > s ? ($[j] = { ...$[j], quantity: _e - s }) : $.splice(j, 1),
      { ...o, inventory: $ }
    )
  },
  waterField = o => ({ ...o, field: updateField(o.field, setWasWatered) }),
  applyPrecipitation = o => {
    let { field: a } = o,
      s = 0,
      $
    if (shouldStormToday())
      if (fieldHasScarecrow(a)) {
        $ = { message: STORM_DESTROYS_SCARECROWS_MESSAGE, severity: 'error' }
        let { scarecrow: j = 0 } = getInventoryQuantityMap(o.inventory)
        a = updateField(a, _e =>
          plotContainsScarecrow(_e)
            ? j && _e.fertilizerType === fertilizerType.RAINBOW
              ? (j--, s++, _e)
              : null
            : _e
        )
      } else $ = { message: STORM_MESSAGE, severity: 'info' }
    else $ = { message: RAIN_MESSAGE, severity: 'info' }
    return (
      (o = decrementItemFromInventory({ ...o, field: a }, 'scarecrow', s)),
      (o = { ...o, newDayNotifications: [...o.newDayNotifications, $] }),
      (o = waterField(o)),
      o
    )
  },
  modifyCow = (o, a, s) => {
    const $ = [...o.cowInventory],
      j = $.find(({ id: et }) => et === a),
      _e = $.indexOf(j)
    return ($[_e] = { ...j, ...s(j) }), { ...o, cowInventory: $ }
  },
  changeCowAutomaticHugState = (o, a, s) => (
    (s &&
      (a.isUsingHuggingMachine ||
        !areHuggingMachinesInInventory(o.inventory))) ||
      ((o = modifyCow(o, a.id, $ => ({ ...$, isUsingHuggingMachine: s }))),
      (o = s
        ? decrementItemFromInventory(o, HUGGING_MACHINE_ITEM_ID)
        : addItemToInventory(o, itemsMap[HUGGING_MACHINE_ITEM_ID]))),
    o
  ),
  cowCanBeAdded = (o, a, s) => {
    const { cowId1: $, cowId2: j } = a,
      _e = $ !== null && j !== null,
      et = $ === o.id || j === o.id
    return !!s.find(({ id: rt }) => rt === o.id) && !_e && !et
  },
  changeCowBreedingPenResident = (o, a, s) => {
    const { cowBreedingPen: $, cowInventory: j } = o,
      { cowId1: _e, cowId2: et } = $,
      tt = _e === a.id || et === a.id
    let rt = { ...$ }
    return (s && !cowCanBeAdded(a, $, j)) || (!s && !tt)
      ? o
      : (s
          ? (rt = { ...rt, [_e === null ? 'cowId1' : 'cowId2']: a.id })
          : (_e === a.id && (rt = { ...rt, cowId1: rt.cowId2 }),
            (rt = { ...rt, cowId2: null })),
        {
          ...o,
          cowBreedingPen: { ...rt, daysUntilBirth: COW_GESTATION_PERIOD_DAYS },
        })
  },
  changeCowName = (o, a, s) =>
    modifyCow(o, a, () => ({ name: s.slice(0, MAX_ANIMAL_NAME_LENGTH) })),
  modifyFieldPlotAt = (o, a, s, $) => {
    const { field: j } = o,
      _e = [...j[s]],
      et = $(_e[a])
    _e[a] = et
    const tt = [...j]
    return (tt[s] = _e), { ...o, field: tt }
  },
  removeFieldPlotAt = (o, a, s) => modifyFieldPlotAt(o, a, s, () => null),
  { GROWN: GROWN$1 } = cropLifeStage,
  clearPlot = (o, a, s) => {
    const $ = o.field[s][a],
      j = o.toolLevels[toolType.HOE]
    if (!$ || $.isShoveled) return o
    if (
      getPlotContentType($) === itemType.CROP &&
      getCropLifeStage($) !== GROWN$1 &&
      randomNumberService.isRandomNumberLessThan(
        HOE_LEVEL_TO_SEED_RECLAIM_RATE[j]
      )
    ) {
      const tt = getSeedItemIdFromFinalStageCropItemId($.itemId)
      o = addItemToInventory(o, itemsMap[tt])
    }
    const _e = itemsMap[$.itemId]
    return _e.isReplantable && !doesInventorySpaceRemain(o)
      ? o
      : ((o = removeFieldPlotAt(o, a, s)),
        _e.isReplantable ||
        getPlotContentType($) === itemType.WEED ||
        getCropLifeStage($) === GROWN$1
          ? addItemToInventory(o, _e)
          : o)
  },
  computeCowInventoryForNextDay = o => ({
    ...o,
    cowInventory: o.cowInventory.map(a => ({
      ...a,
      daysOld: a.daysOld + 1,
      daysSinceMilking: a.daysSinceMilking + 1,
      daysSinceProducingFertilizer: (a.daysSinceProducingFertilizer || 0) + 1,
      happiness: Math.max(
        0,
        a.isUsingHuggingMachine
          ? Math.min(
              1,
              a.happiness + (MAX_DAILY_COW_HUG_BENEFITS - 1) * COW_HUG_BENEFIT
            )
          : a.happiness - COW_HUG_BENEFIT
      ),
      happinessBoostsToday: a.isUsingHuggingMachine
        ? MAX_DAILY_COW_HUG_BENEFITS
        : 0,
    })),
  }),
  applyLoanInterest = o => {
    const a = moneyTotal(
        o.loanBalance,
        castToMoney(o.loanBalance * LOAN_INTEREST_RATE)
      ),
      s =
        a > 0
          ? [
              ...o.newDayNotifications,
              { severity: 'warning', message: LOAN_BALANCE_NOTIFICATION`${a}` },
            ]
          : o.newDayNotifications
    return { ...o, loanBalance: a, newDayNotifications: s }
  },
  createPriceEvent = (o, a, s) => ({ [s]: { ...o[s], [a.itemId]: a } }),
  TYPE_CRASH = 'priceCrashes',
  TYPE_SURGE = 'priceSurges',
  generatePriceEvents = o => {
    const a = { ...o.priceCrashes },
      s = { ...o.priceSurges }
    let $ = [...o.newDayNotifications],
      j
    if (random() < PRICE_EVENT_CHANCE) {
      const { items: _e } = getLevelEntitlements(levelAchieved(o.experience)),
        et = getRandomUnlockedCrop(filterItemIdsToSeeds(Object.keys(_e))),
        { id: tt } = et
      if (!!!(a[tt] || s[tt])) {
        const nt = random() < 0.5 ? TYPE_CRASH : TYPE_SURGE
        ;(j = createPriceEvent(o, getPriceEventForCrop(et), nt)),
          $.push(
            nt === TYPE_CRASH
              ? { message: PRICE_CRASH`${et}`, severity: 'warning' }
              : { message: PRICE_SURGE`${et}`, severity: 'success' }
          )
      }
    }
    return { ...o, ...j, newDayNotifications: $ }
  }
class WineService {
  constructor() {
    Wr(this, 'maturityDayMultiplier', 3)
    Wr(
      this,
      'getDaysToMature',
      a => wineVarietyValueMap[a] * this.maturityDayMultiplier
    )
    Wr(
      this,
      'isWineRecipe',
      a => 'recipeType' in a && a.recipeType === recipeType.WINE
    )
    Wr(
      this,
      'getMaxWineYield',
      ({ grape: a, inventory: s, cellarInventory: $, cellarSize: j }) => {
        const {
            [a.id]: _e = 0,
            [itemsMap.yeast.id]: et = 0,
          } = getInventoryQuantityMap(s),
          tt = j - $.length,
          rt = Math.floor(_e / GRAPES_REQUIRED_FOR_WINE),
          nt = Math.floor(et / getYeastRequiredForWine(a.variety))
        return Math.min(tt, rt, nt)
      }
    )
  }
}
const wineService = new WineService()
class CellarService {
  constructor() {
    Wr(this, '_uuid', uuid_1.v4)
    Wr(
      this,
      'getItemInstancesInCellar',
      memoize((a, s) => a.filter($ => $.itemId === s.id).length, {
        cacheSize: Object.keys(fermentableItemsMap).length,
      })
    )
    Wr(this, 'generateKeg', a => {
      const s = {
        id: this._uuid(),
        itemId: a.id,
        daysUntilMature: a.daysToFerment ?? 0,
      }
      return (
        wineService.isWineRecipe(a) &&
          (s.daysUntilMature = getYeastRequiredForWine(a.variety)),
        s
      )
    })
    Wr(this, 'doesCellarSpaceRemain', (a, s) => {
      var $
      return (
        a.length <
        ((($ = PURCHASEABLE_CELLARS.get(s)) == null ? void 0 : $.space) ?? 0)
      )
    })
    Wr(this, 'doesKegSpoil', a => {
      const s = itemsMap[a.itemId]
      return !wineService.isWineRecipe(s)
    })
  }
}
const cellarService = new CellarService(),
  getKegSpoilageRate = o =>
    !cellarService.doesKegSpoil(o) || o.daysUntilMature > 0
      ? 0
      : Math.abs(o.daysUntilMature) * KEG_SPOILAGE_RATE_MULTIPLIER,
  removeKegFromCellar = (o, a) => {
    const { cellarInventory: s } = o,
      $ = s.findIndex(({ id: _e }) => _e === a)
    if ($ === -1)
      return console.error(`removeKegFromCellar: kegId ${a} not found`), o
    const j = [...s.slice(0, $), ...s.slice($ + 1, s.length)]
    return (o = { ...o, cellarInventory: j }), o
  },
  processCellarSpoilage = o => {
    const { cellarInventory: a } = o,
      s = [...a]
    for (let $ = s.length - 1; $ > -1; $--) {
      const j = s[$],
        _e = itemsMap[j.itemId],
        et = getKegSpoilageRate(j)
      !wineService.isWineRecipe(_e) &&
        randomNumberService.isRandomNumberLessThan(et) &&
        ((o = removeKegFromCellar(o, j.id)),
        (o = {
          ...o,
          newDayNotifications: [
            ...o.newDayNotifications,
            { message: KEG_SPOILED_MESSAGE`${j}`, severity: 'error' },
          ],
        }))
    }
    return (o = { ...o }), o
  },
  processCellar = o => {
    o = processCellarSpoilage(o)
    const { cellarInventory: a } = o,
      s = [...a]
    for (let $ = 0; $ < s.length; $++) {
      const j = s[$]
      s[$] = { ...j, daysUntilMature: j.daysUntilMature - 1 }
    }
    return (o = { ...o, cellarInventory: s }), o
  },
  removeCowFromInventory = (o, a) => {
    const s = [...o.cowInventory],
      { isUsingHuggingMachine: $ } = a
    return (
      s.splice(s.indexOf(a), 1),
      $ && (o = addItemToInventory(o, itemsMap[HUGGING_MACHINE_ITEM_ID])),
      (o = changeCowBreedingPenResident(o, a, !1)),
      { ...o, cowInventory: s }
    )
  },
  processCowAttrition = o => {
    const a = [...o.newDayNotifications],
      s = [...o.cowInventory]
    for (let $ = 0; $ < s.length; $++) {
      const j = s[$]
      Number(j.weightMultiplier.toFixed(2)) === COW_WEIGHT_MULTIPLIER_MINIMUM &&
        ((o = removeCowFromInventory(o, j)),
        a.push({ message: COW_ATTRITION_MESSAGE`${j}`, severity: 'error' }))
    }
    return { ...o, newDayNotifications: a }
  },
  processCowBreeding = o => {
    const {
        cowBreedingPen: a,
        cowInventory: s,
        id: $,
        newDayNotifications: j,
        purchasedCowPen: _e,
      } = o,
      { cowId1: et, cowId2: tt } = a
    if (!tt) return o
    const rt = findCowById(s, et),
      nt = findCowById(s, tt)
    if (rt.gender === nt.gender) return o
    const it =
        rt.happiness >= COW_MINIMUM_HAPPINESS_TO_BREED &&
        nt.happiness >= COW_MINIMUM_HAPPINESS_TO_BREED
          ? a.daysUntilBirth - 1
          : COW_GESTATION_PERIOD_DAYS,
      ot = s.length < PURCHASEABLE_COW_PENS.get(_e).cows && it === 0,
      at = ot && generateOffspringCow(rt, nt, $)
    if (at) {
      const st =
        at.color === cowColors.RAINBOW
          ? EXPERIENCE_VALUES.RAINBOW_COW_BRED
          : EXPERIENCE_VALUES.COW_BRED
      o = addExperience(o, st)
    }
    return {
      ...o,
      cowInventory: ot ? [...s, at] : s,
      cowBreedingPen: {
        ...a,
        daysUntilBirth: ot ? COW_GESTATION_PERIOD_DAYS : it,
      },
      newDayNotifications: at
        ? [
            ...j,
            { message: COW_BORN_MESSAGE`${rt}${nt}${at}`, severity: 'success' },
          ]
        : j,
    }
  },
  processCowFertilizerProduction = o => {
    const a = [...o.cowInventory],
      s = [...o.newDayNotifications],
      { length: $ } = a,
      j = {}
    for (let _e = 0; _e < $; _e++) {
      const et = a[_e]
      if (
        (et.daysSinceProducingFertilizer || 0) >
        getCowFertilizerProductionRate(et)
      ) {
        a[_e] = { ...et, daysSinceProducingFertilizer: 0 }
        const tt = getCowFertilizerItem(et),
          { name: rt } = tt
        if (!doesInventorySpaceRemain(o)) break
        ;(j[rt] = (j[rt] || 0) + 1), (o = addItemToInventory(o, tt))
      }
    }
    return (
      Object.keys(j).length &&
        s.push({ message: FERTILIZERS_PRODUCED`${j}`, severity: 'success' }),
      { ...o, cowInventory: a, newDayNotifications: s }
    )
  },
  processFeedingCows = o => {
    const a = [...o.cowInventory],
      { length: s } = a,
      $ = [...o.newDayNotifications],
      j = [...o.inventory],
      _e = j.findIndex(({ id: yt }) => yt === COW_FEED_ITEM_ID),
      et = j[_e],
      tt = et ? et.quantity : 0,
      rt = j.findIndex(({ id: yt }) => yt === ADJUSTED_COW_FEED_ITEM_ID),
      nt = j[rt],
      it = nt ? nt.quantity : 0,
      ot = j.findIndex(({ id: yt }) => yt === WATER_CREDIT_ID),
      at = j[ot],
      st = at ? at.quantity : 0,
      ut = j.some(({ id: yt }) => yt === MANURE_MANAGER_ID)
    let ct = 0,
      dt = 0,
      ft = 0,
      mt = 0
    mt += ut ? s : 0
    for (let yt = 0; yt < s; yt++) {
      const pt = a[yt],
        ht = ct < it,
        At = dt < tt,
        wt = ft < st
      ht ? (ct++, mt++) : At && dt++,
        wt && ft++,
        (a[yt] = {
          ...pt,
          weightMultiplier: clampNumber(
            ht || At
              ? pt.weightMultiplier + COW_WEIGHT_MULTIPLIER_FEED_BENEFIT
              : pt.weightMultiplier - COW_WEIGHT_MULTIPLIER_FEED_BENEFIT,
            COW_WEIGHT_MULTIPLIER_MINIMUM,
            COW_WEIGHT_MULTIPLIER_MAXIMUM
          ),
        })
    }
    return (
      tt <= s &&
        s > 0 &&
        $.push({ message: OUT_OF_COW_FEED_NOTIFICATION, severity: 'error' }),
      st <= s &&
        s > 0 &&
        $.push({
          message: OUT_OF_WATER_CREDIT_NOTIFICATION,
          severity: 'error',
        }),
      decrementItemFromInventory(
        decrementItemFromInventory(
          decrementItemFromInventory(
            { ...o, cowInventory: a, inventory: j, newDayNotifications: $ },
            COW_FEED_ITEM_ID,
            dt
          ),
          WATER_CREDIT_ID,
          ft - mt
        ),
        ADJUSTED_COW_FEED_ITEM_ID,
        ct
      )
    )
  },
  incrementPlotContentAge = o =>
    o && getPlotContentType(o) === itemType.CROP
      ? {
          ...o,
          daysOld: o.daysOld + 1,
          daysWatered:
            o.daysWatered +
            (o.wasWateredToday
              ? 1 +
                (o.fertilizerType === fertilizerType.NONE
                  ? 0
                  : FERTILIZER_BONUS)
              : 0),
        }
      : o,
  updatePlotShoveledState = o =>
    o && o.isShoveled && o.daysUntilClear > 1
      ? { ...o, daysUntilClear: o.daysUntilClear - 1 }
      : o && !o.isShoveled
      ? o
      : null
function spawnWeeds(o) {
  if (o) return o
  let a = null
  return (
    randomNumberService.isRandomNumberLessThan(WEEDS_SPAWN_CHANCE) &&
      (a = getPlotContentFromItemId(weed.id)),
    a
  )
}
const fieldReducer = (o, a) => a(o),
  resetWasWatered = o => setWasWateredProperty(o, !1),
  fieldUpdaters = [
    incrementPlotContentAge,
    resetWasWatered,
    spawnWeeds,
    updatePlotShoveledState,
  ],
  processField = o => ({
    ...o,
    field: updateField(o.field, a => fieldUpdaters.reduce(fieldReducer, a)),
  }),
  processMilkingCows = o => {
    const a = [...o.cowInventory],
      s = [...o.newDayNotifications],
      { length: $ } = a,
      j = {}
    for (let _e = 0; _e < $; _e++) {
      const et = a[_e]
      if (et.daysSinceMilking > getCowMilkRate(et)) {
        a[_e] = { ...et, daysSinceMilking: 0 }
        const tt = getCowMilkItem(et),
          { name: rt } = tt
        if (!doesInventorySpaceRemain(o)) break
        ;(j[rt] = (j[rt] || 0) + 1), (o = addItemToInventory(o, tt))
      }
    }
    return (
      Object.keys(j).length &&
        s.push({ message: MILKS_PRODUCED`${j}`, severity: 'success' }),
      { ...o, cowInventory: a, newDayNotifications: s }
    )
  }
function forEachPlot(o, a) {
  o.field.forEach((s, $) => s.forEach((j, _e) => a(j, _e, $)))
}
const applyCrows = o => {
    const { field: a, purchasedField: s } = o
    if (
      fieldHasScarecrow(a) ||
      randomNumberService.isRandomNumberLessThan(1 - CROW_CHANCE)
    )
      return o
    const $ = [...o.newDayNotifications]
    let j = []
    const _e = []
    forEachPlot(o, (rt, nt, it) => {
      doesPlotContainCrop(o.field[it][nt]) && _e.push({ x: nt, y: it })
    })
    const et = Math.min(_e.length, Math.floor(random() * (s + 1) * MAX_CROWS))
    let tt = 0
    for (let rt = 0; rt < et; rt++) {
      const nt = Math.floor(random() * _e.length),
        it = _e.splice(nt, 1)[0]
      ;(o = modifyFieldPlotAt(o, it.x, it.y, () => null)), (tt += 1)
    }
    return (
      tt > 0 && j.push(CROWS_DESTROYED`${tt}`),
      j.length &&
        $.push({
          message: j.join(`

`),
          severity: 'error',
        }),
      { ...o, newDayNotifications: $ }
    )
  },
  processNerfs = o => applyChanceEvent([[() => !0, applyCrows]], o),
  processSprinklers = o => {
    const { field: a, experience: s } = o,
      $ = new Map()
    let j = [...a]
    const { sprinklerRange: _e } = getLevelEntitlements(levelAchieved(s))
    return (
      a.forEach((et, tt) => {
        et.forEach((rt, nt) => {
          !rt ||
            getPlotContentType(rt) !== itemType.SPRINKLER ||
            []
              .concat(...getRangeCoords(_e, nt, tt))
              .forEach(({ x: it, y: ot }) => {
                const at = a[ot]
                if (!at) return
                const st = at[it]
                st &&
                  getPlotContentType(st) === itemType.CROP &&
                  ($.has(st) ||
                    (j = modifyFieldPlotAt(
                      { ...o, field: j },
                      it,
                      ot,
                      setWasWatered
                    ).field),
                  $.set(st, { x: it, y: ot }))
              })
        })
      }),
      { ...o, field: j }
    )
  },
  processWeather = o =>
    applyChanceEvent([[shouldPrecipitateToday, applyPrecipitation]], o),
  rotateNotificationLogs = o => {
    const a = [...o.notificationLog],
      { dayCount: s, newDayNotifications: $ } = o,
      j = { error: [], info: [], success: [], warning: [] }
    return (
      $.forEach(({ message: _e, severity: et }) => j[et].push(_e)),
      $.length && a.unshift({ day: s, notifications: j }),
      (a.length = Math.min(a.length, NOTIFICATION_LOG_SIZE)),
      { ...o, notificationLog: a }
    )
  },
  updateFinancialRecords = o => {
    const {
      profitabilityStreak: a,
      todaysLosses: s,
      todaysRevenue: $,
      record7dayProfitAverage: j,
      recordProfitabilityStreak: _e,
    } = o
    let {
      historicalDailyLosses: et,
      historicalDailyRevenue: tt,
      recordSingleDayProfit: rt,
    } = o
    ;(et = [s, ...et].slice(0, DAILY_FINANCIAL_HISTORY_RECORD_LENGTH)),
      (tt = [$, ...tt].slice(0, DAILY_FINANCIAL_HISTORY_RECORD_LENGTH))
    const nt = get7DayAverage(et.map((at, st) => moneyTotal(tt[st], at))),
      ot = $ + s > 0 ? a + 1 : 0
    return {
      ...o,
      historicalDailyLosses: et,
      historicalDailyRevenue: tt,
      profitabilityStreak: ot,
      record7dayProfitAverage: Math.max(j, nt),
      recordProfitabilityStreak: Math.max(_e, ot),
      recordSingleDayProfit: Math.max(rt, getProfit($, s)),
      todaysLosses: 0,
      todaysRevenue: 0,
    }
  },
  updateInventoryRecordsForNextDay = o => ({
    ...o,
    todaysPurchases: {},
    todaysStartingInventory: o.inventory.reduce(
      (a, { id: s, quantity: $ }) => ((a[s] = $), a),
      {}
    ),
  }),
  decrementPriceEventDays = o =>
    Object.keys(o).reduce((a, s) => {
      const { itemId: $, daysRemaining: j } = o[s]
      return j > 1 && (a[s] = { itemId: $, daysRemaining: j - 1 }), a
    }, {}),
  updatePriceEvents = o => {
    const { priceCrashes: a, priceSurges: s } = o
    return {
      ...o,
      priceCrashes: decrementPriceEventDays(a),
      priceSurges: decrementPriceEventDays(s),
    }
  },
  adjustItemValues = o => ({
    ...o,
    historicalValueAdjustments: [o.valueAdjustments],
    valueAdjustments: generateValueAdjustments(o.priceCrashes, o.priceSurges),
  }),
  computeStateForNextDay = (o, a = !1) => {
    ;[...o.newDayNotifications]
    const s = [...o.inventory],
      $ = s.findIndex(({ id: nt }) => nt === WATER_CREDIT_ID),
      j = s[$],
      _e = j ? j.quantity : 0,
      et = [...o.cowInventory],
      { length: tt } = et
    return _e < tt && tt > 0
      ? ((o = {
          ...o,
          latestNotification: {
            message: 'Not enough water credit to advance to the next day.',
            severity: 'error',
          },
          todaysNotifications: o.todaysNotifications.find(
            nt =>
              nt.message ===
              'Not enough water credit to advance to the next day.'
          )
            ? o.todaysNotifications
            : [
                ...o.todaysNotifications,
                {
                  message:
                    'Not enough water credit to advance to the next day.',
                  severity: 'error',
                },
              ],
        }),
        o)
      : ((o = (a
          ? [processField]
          : [
              computeCowInventoryForNextDay,
              processCowBreeding,
              processField,
              processNerfs,
              processWeather,
              processSprinklers,
              processFeedingCows,
              processCowAttrition,
              processMilkingCows,
              processCowFertilizerProduction,
              processCellar,
              updatePriceEvents,
              updateFinancialRecords,
              updateInventoryRecordsForNextDay,
              generatePriceEvents,
              applyLoanInterest,
              rotateNotificationLogs,
            ]
        )
          .concat([adjustItemValues])
          .reduce((nt, it) => it({ ...nt }), {
            ...o,
            cowForSale: generateCow(),
            dayCount: o.dayCount + 1,
            todaysNotifications: [],
          })),
        o.dayCount % 365 === 0 &&
          (o = addExperience(o, EXPERIENCE_VALUES.NEW_YEAR)),
        o)
  },
  { FERTILIZE: FERTILIZE$2, OBSERVE: OBSERVE$4 } = fieldMode,
  fertilizerItemIdToTypeMap = {
    [itemsMap.fertilizer.id]: fertilizerType.STANDARD,
    [itemsMap['rainbow-fertilizer'].id]: fertilizerType.RAINBOW,
  },
  fertilizePlot = (o, a, s) => {
    var at
    const { field: $, selectedItemId: j } = o,
      et = $[s][a]
    if (
      !et ||
      ((at = itemsMap[j]) == null ? void 0 : at.type) !== itemType.FERTILIZER
    )
      return o
    const { id: tt } = itemsMap[j],
      rt = o.inventory.find(st => st.id === tt),
      nt = getPlotContentType(et)
    if (
      !et ||
      !rt ||
      et.fertilizerType !== fertilizerType.NONE ||
      (j === 'fertilizer' && nt !== itemType.CROP) ||
      (j === 'rainbow-fertilizer' &&
        nt !== itemType.CROP &&
        nt !== itemType.SCARECROW)
    )
      return o
    const { quantity: it } = rt
    o = decrementItemFromInventory(o, tt)
    const ot = it > 1
    return (
      (o = modifyFieldPlotAt(o, a, s, st => ({
        ...st,
        fertilizerType: fertilizerItemIdToTypeMap[tt],
      }))),
      {
        ...o,
        fieldMode: ot ? FERTILIZE$2 : OBSERVE$4,
        selectedItemId: ot ? tt : '',
      }
    )
  },
  forRange = (o, a, s, $, j, ..._e) => {
    const et = Math.max($ - s, 0),
      tt = Math.min($ + s, o.field[0].length - 1),
      rt = Math.max(j - s, 0),
      nt = Math.min(j + s, o.field.length - 1)
    for (let it = rt; it <= nt; it++)
      for (let ot = et; ot <= tt; ot++) o = a(o, ot, it, ..._e)
    return o
  },
  plantInPlot = (o, a, s, $) => {
    if (!$ || !o.inventory.some(({ id: nt }) => nt === $)) return o
    const { field: j } = o
    if (j[s][a]) return o
    const { growsInto: et } = itemsMap[$],
      tt = Array.isArray(et) ? chooseRandomIndex(et) : 0,
      rt = getFinalCropItemIdFromSeedItemId($, tt)
    return (
      (o = modifyFieldPlotAt(o, a, s, () => getCropFromItemId(rt))),
      (o = decrementItemFromInventory(o, $)),
      (o = processSprinklers(o)),
      {
        ...o,
        selectedItemId: o.inventory.find(({ id: nt }) => nt === $) ? $ : '',
      }
    )
  },
  { GROWN } = cropLifeStage
function getHarvestedQuantity(o) {
  let a = 1
  switch (o.toolLevels[toolType.SCYTHE]) {
    case toolLevel.BRONZE:
      a += 1
      break
    case toolLevel.IRON:
      a += 2
      break
    case toolLevel.SILVER:
      a += 3
      break
    case toolLevel.GOLD:
      a += 4
      break
    default:
      a = 1
  }
  return a
}
function harvestCrops(o, a, s) {
  const j = o.field[s][a],
    _e = itemsMap[j.itemId],
    et = getSeedItemIdFromFinalStageCropItemId(_e.id),
    tt = j.fertilizerType === fertilizerType.RAINBOW,
    rt = getHarvestedQuantity(o)
  ;(o = removeFieldPlotAt(o, a, s)), (o = addItemToInventory(o, _e, rt))
  const { cropType: nt } = _e
  tt &&
    getInventoryQuantityMap(o.inventory)[et] > 0 &&
    ((o = plantInPlot(o, a, s, et)),
    (o = modifyFieldPlotAt(o, a, s, at => ({
      ...at,
      fertilizerType: fertilizerType.RAINBOW,
    }))))
  const { cropsHarvested: it } = o
  return { ...o, cropsHarvested: { ...it, [nt]: (it[nt] || 0) + rt } }
}
function harvestWeed(o, a, s) {
  const j = o.field[s][a],
    _e = itemsMap[j.itemId],
    et = getHarvestedQuantity(o)
  return (
    (o = removeFieldPlotAt(o, a, s)), (o = addItemToInventory(o, _e, et)), o
  )
}
const harvestPlot = (o, a, s) => {
    const j = o.field[s][a]
    return !j || !doesInventorySpaceRemain(o)
      ? o
      : getPlotContentType(j) === itemType.CROP && getCropLifeStage(j) === GROWN
      ? harvestCrops(o, a, s)
      : getPlotContentType(j) === itemType.WEED
      ? harvestWeed(o, a, s)
      : o
  },
  hugCow = (o, a) =>
    modifyCow(o, a, s =>
      s.happinessBoostsToday >= MAX_DAILY_COW_HUG_BENEFITS
        ? s
        : {
            happiness: Math.min(1, s.happiness + COW_HUG_BENEFIT),
            happinessBoostsToday: s.happinessBoostsToday + 1,
          }
    ),
  EXPERIENCE_FOR_RECIPE = {
    [recipeType.FERMENTATION]: EXPERIENCE_VALUES.FERMENTATION_RECIPE_MADE,
    [recipeType.FORGE]: EXPERIENCE_VALUES.FORGE_RECIPE_MADE,
    [recipeType.KITCHEN]: EXPERIENCE_VALUES.KITCHEN_RECIPE_MADE,
    [recipeType.RECYCLING]: EXPERIENCE_VALUES.RECYCLING_RECIPE_MADE,
  },
  makeRecipe = (o, a, s = 1) =>
    canMakeRecipe(a, o.inventory, s)
      ? ((o = addExperience(o, EXPERIENCE_FOR_RECIPE[a.recipeType] || 0)),
        (o = Object.keys(a.ingredients).reduce(
          ($, j) => decrementItemFromInventory($, j, a.ingredients[j] * s),
          o
        )),
        addItemToInventory(o, a, s))
      : o,
  saltRequirementMultiplier = 2 / 3,
  getSaltRequirementsForFermentationRecipe = o => {
    const { daysToFerment: a = 0, tier: s = 1 } = o
    return Math.ceil(a * saltRequirementMultiplier) * s
  },
  getMaxYieldOfFermentationRecipe = (o, a, s, $) => {
    const {
        [o.id]: j = 0,
        [itemsMap.salt.id]: _e = 0,
      } = getInventoryQuantityMap(a),
      et = Math.floor(_e / getSaltRequirementsForFermentationRecipe(o))
    return Math.min($ - s.length, j, et)
  },
  addKegToCellarInventory = (o, a) => {
    const { cellarInventory: s } = o
    return { ...o, cellarInventory: [...s, a] }
  },
  makeFermentationRecipe = (o, a, s = 1) => {
    const { inventory: $, cellarInventory: j, purchasedCellar: _e } = o,
      { space: et } = PURCHASEABLE_CELLARS.get(_e) ?? { space: 0 }
    if (getMaxYieldOfFermentationRecipe(a, $, j, et) < s) return o
    for (let nt = 0; nt < s; nt++) {
      const it = cellarService.generateKeg(a)
      o = addKegToCellarInventory(o, it)
    }
    const rt = getSaltRequirementsForFermentationRecipe(a)
    return (
      (o = decrementItemFromInventory(o, a.id, s)),
      (o = decrementItemFromInventory(o, itemsMap.salt.id, s * rt)),
      o
    )
  },
  makeWine = (o, a, s = 1) => {
    const { inventory: $, cellarInventory: j, purchasedCellar: _e } = o,
      { space: et } = PURCHASEABLE_CELLARS.get(_e) ?? { space: 0 },
      tt = wineService.getMaxWineYield({
        grape: a,
        inventory: $,
        cellarInventory: j,
        cellarSize: et,
      }),
      rt = itemsMap[a.wineId],
      nt = Math.min(s, tt)
    for (let ot = 0; ot < nt; ot++) {
      const at = cellarService.generateKeg(rt)
      o = addKegToCellarInventory(o, at)
    }
    o = decrementItemFromInventory(o, a.id, nt * GRAPES_REQUIRED_FOR_WINE)
    const it = getYeastRequiredForWine(a.variety)
    return (o = decrementItemFromInventory(o, itemsMap.yeast.id, nt * it)), o
  }
class Factory {
  generate() {}
}
const SPAWNABLE_ORES = [goldOre$1, ironOre$1, bronzeOre$1, silverOre$1]
class OreFactory extends Factory {
  constructor() {
    super(), (this.oreOptions = [])
    for (let a of SPAWNABLE_ORES)
      this.oreOptions.push({ ore: a, weight: a.spawnChance })
  }
  generate() {
    return [this.spawn()]
  }
  spawn() {
    return randomChoice(this.oreOptions).ore
  }
}
class CoalFactory extends Factory {
  generate() {
    let a = []
    const s = chooseRandom([1, 1, 1, 2, 3])
    for (let $ = 0; $ < s; $++) a.push(this.spawnCoal())
    return a.push(this.spawnStone()), a
  }
  spawnCoal() {
    return coal$2
  }
  spawnStone() {
    return stone$1
  }
}
const spawnableResources = [
  [stone$1, STONE_SPAWN_CHANCE],
  [saltRock$1, SALT_ROCK_SPAWN_CHANCE],
  [coal$2, COAL_SPAWN_CHANCE],
]
class StoneFactory extends Factory {
  generate() {
    let a = []
    for (const [s, $] of spawnableResources)
      randomNumberService.isRandomNumberLessThan($) && a.push(s)
    return a
  }
}
const factoryInstances = {}
let instance = null
const zn = class zn {
  constructor() {
    this.resourceOptions = [
      { weight: ORE_SPAWN_CHANCE, itemType: itemType.ORE },
      { weight: COAL_SPAWN_CHANCE, itemType: itemType.FUEL },
      { weight: STONE_SPAWN_CHANCE, itemType: itemType.STONE },
    ]
  }
  static instance() {
    return instance || (instance = new zn()), instance
  }
  static generateFactoryInstance(a) {
    switch (a) {
      case itemType.STONE:
        return new StoneFactory()
      case itemType.FUEL:
        return new CoalFactory()
      case itemType.ORE:
        return new OreFactory()
      default:
        return null
    }
  }
  generateResources(a) {
    let s = [],
      $ = RESOURCE_SPAWN_CHANCE
    switch (a) {
      case toolLevel.BRONZE:
        $ += 0.1
        break
      case toolLevel.IRON:
        $ += 0.2
        break
      case toolLevel.SILVER:
        $ += 0.3
        break
      case toolLevel.GOLD:
        $ += 0.5
        break
    }
    if (randomNumberService.isRandomNumberLessThan($)) {
      const j = randomChoice(this.resourceOptions),
        _e = zn.getFactoryForItemType(j.itemType)
      _e && (s = _e.generate())
    }
    return s
  }
}
Wr(
  zn,
  'getFactoryForItemType',
  a => (
    factoryInstances[a] ||
      (factoryInstances[a] = zn.generateFactoryInstance(a)),
    factoryInstances[a]
  )
)
let ResourceFactory = zn
const daysUntilClearPeriods = [1, 2, 2, 3],
  minePlot = (o, a, s) => {
    const { field: $ } = o
    if ($[s][a]) return o
    if (!doesInventorySpaceRemain(o))
      return showNotification(o, INVENTORY_FULL_NOTIFICATION)
    const _e = o.toolLevels[toolType.SHOVEL],
      et = ResourceFactory.instance().generateResources(_e),
      [tt] = et
    let rt = chooseRandom(daysUntilClearPeriods)
    if (tt) {
      const nt = et.map(({ spawnChance: ot }) => ot),
        it = Math.min(...nt)
      rt += Math.round(random() * (1 - it) * 10)
    }
    for (let nt of et) o = addItemToInventory(o, nt)
    return (
      (o = modifyFieldPlotAt(o, a, s, () => ({
        isShoveled: !0,
        daysUntilClear: rt,
        oreId: (tt == null ? void 0 : tt.id) ?? null,
      }))),
      { ...o }
    )
  },
  offerCow = (o, a) => ((o = { ...o, cowIdOfferedForTrade: a }), o),
  prependPendingPeerMessage = (o, a, s = 'info') => ({
    ...o,
    pendingPeerMessages: [
      { id: o.id, message: a, severity: s },
      ...o.pendingPeerMessages,
    ].slice(0, MAX_PENDING_PEER_MESSAGES),
  }),
  purchaseCombine = (o, a) => {
    const { money: s, purchasedCombine: $ } = o
    return $ >= a
      ? o
      : {
          purchasedCombine: a,
          money: moneyTotal(s, -PURCHASEABLE_COMBINES.get(a).price),
        }
  },
  updateLearnedRecipes = o => ({
    ...o,
    learnedRecipes: Object.keys(recipesMap).reduce(
      (a, s) => (recipesMap[s].condition(o) && (a[s] = !0), a),
      {}
    ),
  }),
  purchaseComposter = (o, a) => {
    const { money: s, purchasedComposter: $ } = o
    return $ >= a
      ? o
      : ((o = {
          ...o,
          purchasedComposter: a,
          money: moneyTotal(s, -PURCHASEABLE_COMPOSTERS.get(a).price),
        }),
        (o = showNotification(o, RECYCLING_AVAILABLE_NOTIFICATION)),
        (o = addExperience(o, EXPERIENCE_VALUES.COMPOSTER_ACQUIRED)),
        updateLearnedRecipes(o))
  },
  purchaseCow = (o, a) => {
    const {
        cowInventory: s,
        cowColorsPurchased: $,
        id: j,
        money: _e,
        purchasedCowPen: et,
      } = o,
      { color: tt } = a,
      rt = getCowValue(a, !1)
    return _e < rt || et === 0 || s.length >= PURCHASEABLE_COW_PENS.get(et).cows
      ? o
      : ((o = addCowToInventory(o, { ...a, ownerId: j, originalOwnerId: j })),
        {
          ...o,
          cowColorsPurchased: { ...$, [tt]: ($[tt] || 0) + 1 },
          money: moneyTotal(_e, -rt),
          cowForSale: generateCow(),
        })
  },
  purchaseCowPen = (o, a) => {
    const { money: s, purchasedCowPen: $ } = o
    if ($ >= a) return o
    const { cows: j, price: _e } = PURCHASEABLE_COW_PENS.get(a)
    o = showNotification(o, COW_PEN_PURCHASED`${j}`, 'success')
    const et =
      a > 1
        ? EXPERIENCE_VALUES.COW_PEN_EXPANDED
        : EXPERIENCE_VALUES.COW_PEN_ACQUIRED
    return (
      (o = addExperience(o, et)),
      { ...o, purchasedCowPen: a, money: moneyTotal(s, -_e) }
    )
  },
  purchaseCellar = (o, a) => {
    const { money: s, purchasedCellar: $ } = o
    if ($ >= a) return o
    const { price: j, space: _e } = PURCHASEABLE_CELLARS.get(a)
    o = showNotification(o, CELLAR_PURCHASED`${_e}`, 'success')
    const et =
      a > 1
        ? EXPERIENCE_VALUES.CELLAR_EXPANDED
        : EXPERIENCE_VALUES.CELLAR_ACQUIRED
    return (
      (o = addExperience(o, et)),
      { ...o, purchasedCellar: a, money: moneyTotal(s, -j) }
    )
  },
  purchaseField = (o, a) => {
    const { field: s, money: $, purchasedField: j } = o
    if (j >= a) return o
    o = addExperience(o, EXPERIENCE_VALUES.FIELD_EXPANDED)
    const { columns: _e, price: et, rows: tt } = PURCHASEABLE_FIELD_SIZES.get(a)
    return {
      ...o,
      purchasedField: a,
      field: nullArray(tt).map((rt, nt) =>
        nullArray(_e).map((it, ot) => (s[nt] && s[nt][ot]) || null)
      ),
      money: moneyTotal($, -et),
    }
  },
  purchaseForest = (o, a) => {
    const { forest: s, money: $, purchasedForest: j } = o
    if (j >= a) return o
    o = addExperience(o, EXPERIENCE_VALUES.FOREST_EXPANDED)
    const { columns: _e, price: et, rows: tt } = PURCHASABLE_FOREST_SIZES.get(
        a
      ),
      rt = a === 1 ? FOREST_AVAILABLE_NOTIFICATION : FOREST_EXPANDED`${tt * _e}`
    return (
      (o = showNotification(o, rt, 'success')),
      {
        ...o,
        purchasedForest: a,
        forest: nullArray(tt).map((nt, it) =>
          nullArray(_e).map((ot, at) => (s[it] && s[it][at]) || null)
        ),
        money: moneyTotal($, -et),
      }
    )
  },
  purchaseItem = (o, a, s = 1) => {
    const { money: $, todaysPurchases: j, valueAdjustments: _e } = o,
      et = Math.min(s, inventorySpaceRemaining(o))
    if (et === 0) return o
    const rt = getAdjustedItemValue(_e, a.id) * et
    if (rt > $) return o
    o = prependPendingPeerMessage(o, PURCHASED_ITEM_PEER_NOTIFICATION`${s}${a}`)
    const nt = addItemToInventory(o, a)
    return nt.inventoryAddBlocked
      ? nt
      : addItemToInventory(
          {
            ...o,
            money: moneyTotal($, -rt),
            todaysPurchases: { ...j, [a.id]: (j[a.id] || 0) + et },
          },
          a,
          et
        )
  },
  purchaseSmelter = (o, a) => {
    const { money: s, purchasedSmelter: $ } = o
    return $ >= a
      ? o
      : ((o = {
          ...o,
          purchasedSmelter: a,
          money: moneyTotal(s, -PURCHASEABLE_SMELTERS.get(a).price),
        }),
        (o = showNotification(o, FORGE_AVAILABLE_NOTIFICATION)),
        (o = addExperience(o, EXPERIENCE_VALUES.SMELTER_ACQUIRED)),
        updateLearnedRecipes(o))
  },
  purchaseStorageExpansion = o => {
    const { money: a, inventoryLimit: s } = o,
      $ = getCostOfNextStorageExpansion(s)
    return a < $ || s === INFINITE_STORAGE_LIMIT
      ? o
      : {
          ...o,
          inventoryLimit: s + STORAGE_EXPANSION_AMOUNT,
          money: moneyTotal(a, -$),
        }
  },
  removePeer = (o, a) => {
    const s = { ...o.peers }
    return (
      delete s[a], { ...o, peers: s, activePlayers: (o.activePlayers ?? 1) - 1 }
    )
  },
  selectCow = (o, { id: a }) => ({ ...o, selectedCowId: a }),
  sellCow = (o, a) => {
    const { cowsSold: s } = o,
      $ = getCowColorId(a),
      j = getCowValue(a, !0)
    ;(o = removeCowFromInventory(o, a)), (o = addRevenue(o, j))
    const _e = { ...s, [$]: (s[$] || 0) + 1 }
    return (o = { ...o, cowsSold: _e }), o
  },
  sellItem = (o, { id: a }, s = 1) => {
    if (s === 0) return o
    const $ = itemsMap[a],
      {
        completedAchievements: j,
        itemsSold: _e,
        money: et,
        valueAdjustments: tt,
      } = o
    let { loanBalance: rt } = o
    const nt = isItemSoldInShop($)
        ? getResaleValue($)
        : getAdjustedItemValue(tt, a),
      it = isItemAFarmProduct($)
    let ot = 0,
      at = 0,
      st = 1
    for (let ct = 0; ct < s; ct++) {
      const dt = it ? Math.min(rt, castToMoney(nt * LOAN_GARNISHMENT_RATE)) : 0
      isItemAFarmProduct($) &&
        ((st = getSalePriceMultiplier(j)), (at += EXPERIENCE_VALUES.ITEM_SOLD))
      const ft = nt * st - dt
      ;(rt = moneyTotal(rt, -dt)), (ot = moneyTotal(ot, ft))
    }
    it && (o = adjustLoan(o, moneyTotal(rt, -o.loanBalance)))
    const ut = { ..._e, [a]: (_e[a] || 0) + s }
    return (
      $.isPlantableCrop
        ? (o = { ...o, money: moneyTotal(et, ot) })
        : (o = addRevenue({ ...o, money: et }, ot)),
      (o = addExperience(o, at)),
      (o = { ...o, itemsSold: ut }),
      (o = decrementItemFromInventory(o, a, s)),
      (o = prependPendingPeerMessage(
        o,
        SOLD_ITEM_PEER_NOTIFICATION`${s}${$}`,
        'warning'
      )),
      updateLearnedRecipes(o)
    )
  },
  getKegValue = o => {
    const { itemId: a, daysUntilMature: s } = o,
      $ = itemsMap[a]
    if (s > 0) return 0
    let j = 0,
      _e = 0,
      et = 0
    return (
      wineService.isWineRecipe($)
        ? ((j = $.value),
          (_e = WINE_INTEREST_RATE),
          (et = Math.min(Math.max(-s, 1), WINE_GROWTH_TIMELINE_CAP)))
        : ((j = ($.tier ?? 1) * getItemBaseValue(a)),
          (_e = KEG_INTEREST_RATE),
          (et = Math.abs(o.daysUntilMature))),
      j * (1 + _e) ** et
    )
  },
  sellKeg = (o, a) => {
    const { itemId: s } = a,
      $ = itemsMap[s],
      {
        cellarItemsSold: j,
        completedAchievements: _e,
        itemsSold: et,
        money: tt,
      } = o
    let { loanBalance: rt } = o,
      nt = 0
    const it = getKegValue(a),
      ot = Math.min(rt, castToMoney(it * LOAN_GARNISHMENT_RATE)),
      at = getSalePriceMultiplier(_e),
      st = it * at - ot
    ;(rt = moneyTotal(rt, -ot)),
      (nt = moneyTotal(nt, st)),
      (o = adjustLoan(o, moneyTotal(rt, -o.loanBalance)))
    const ut = { ...et, [s]: (et[s] ?? 0) + 1 },
      ct = { ...j, [s]: (j[s] ?? 0) + 1 }
    return (
      (o = { ...o, itemsSold: ut, cellarItemsSold: ct }),
      (o = addRevenue({ ...o, money: tt }, nt)),
      (o = addExperience(o, EXPERIENCE_VALUES.KEG_SOLD)),
      (o = removeKegFromCellar(o, a.id)),
      (o = prependPendingPeerMessage(
        o,
        SOLD_FERMENTED_ITEM_PEER_NOTIFICATION`${$}`,
        'warning'
      )),
      (o = updateLearnedRecipes(o)),
      o
    )
  },
  { OBSERVE: OBSERVE$3, SET_SCARECROW: SET_SCARECROW$2 } = fieldMode,
  setScarecrow = (o, a, s) => {
    if (o.field[s][a] !== null) return o
    o = decrementItemFromInventory(o, SCARECROW_ITEM_ID)
    const j = o.inventory.some(_e => _e.id === SCARECROW_ITEM_ID)
    return (
      (o = modifyFieldPlotAt(o, a, s, () =>
        getPlotContentFromItemId(SCARECROW_ITEM_ID)
      )),
      {
        ...o,
        fieldMode: j ? SET_SCARECROW$2 : OBSERVE$3,
        selectedItemId: j ? SCARECROW_ITEM_ID : '',
      }
    )
  },
  { OBSERVE: OBSERVE$2, SET_SPRINKLER: SET_SPRINKLER$2 } = fieldMode,
  setSprinkler = (o, a, s) => {
    const { field: $ } = o
    if ($[s][a] !== null) return o
    o = decrementItemFromInventory(o, SPRINKLER_ITEM_ID)
    const _e = o.inventory.some(et => et.id === SPRINKLER_ITEM_ID)
    return (
      (o = modifyFieldPlotAt(o, a, s, () =>
        getPlotContentFromItemId(SPRINKLER_ITEM_ID)
      )),
      (o = processSprinklers(o)),
      {
        ...o,
        fieldMode: _e ? SET_SPRINKLER$2 : OBSERVE$2,
        selectedItemId: _e ? SPRINKLER_ITEM_ID : '',
      }
    )
  }
memoize(o => Object.values(o).reduce((a, s) => a + s, 0))
itemsMap[COW_FEED_ITEM_ID]
const achievements = [],
  achievementsMap = {},
  updateAchievements = (o, a) =>
    achievements.reduce(
      (s, $) => (
        !s.completedAchievements[$.id] &&
          $.condition(s, a) &&
          ((s = {
            ...$.reward(s),
            completedAchievements: { ...s.completedAchievements, [$.id]: !0 },
          }),
          (s = showNotification(s, ACHIEVEMENT_COMPLETED`${$}`, 'success'))),
        s
      ),
      o
    ),
  updatePeer = (o, a, s, $) => {
    var it, ot
    const j = { ...o.peers },
      _e = j[$],
      et =
        (it = _e == null ? void 0 : _e.cowOfferedForTrade) == null
          ? void 0
          : it.id,
      tt = (ot = s.cowOfferedForTrade) == null ? void 0 : ot.id,
      rt = tt && et !== tt
    j[$] = s
    const { pendingPeerMessages: nt = [] } = s
    return (
      rt &&
        (o = showNotification(
          o,
          NEW_COW_OFFERED_FOR_TRADE`${s}`,
          'info',
          () => {
            a.openDialogView(dialogView.ONLINE_PEERS)
          }
        )),
      {
        ...o,
        peers: j,
        latestPeerMessages: [...nt, ...o.latestPeerMessages].slice(
          0,
          MAX_LATEST_PEER_MESSAGES
        ),
      }
    )
  },
  upgradeTool = (o, a) => {
    o = makeRecipe(o, a)
    const s = upgrades[a.toolType][o.toolLevels[a.toolType]].name
    return (
      (o.toolLevels[a.toolType] = a.level),
      (o = showNotification(o, TOOL_UPGRADED_NOTIFICATION`${s}${a.name}`)),
      { ...o }
    )
  },
  waterAllPlots = o => waterField(o),
  waterPlot = (o, a, s) => {
    const $ = o.field[s][a]
    return $ && getPlotContentType($) === itemType.CROP
      ? modifyFieldPlotAt(o, a, s, _e => ({ ..._e, wasWateredToday: !0 }))
      : o
  },
  withdrawCow = (o, a) => {
    const { cowIdOfferedForTrade: s } = o
    return a === s && (o = { ...o, cowIdOfferedForTrade: '' }), o
  },
  reducers = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        addCowToInventory,
        addExperience,
        addItemToInventory,
        addPeer,
        addRevenue,
        adjustLoan,
        applyPrecipitation,
        changeCowAutomaticHugState,
        changeCowBreedingPenResident,
        changeCowName,
        clearPlot,
        computeCowInventoryForNextDay,
        computeStateForNextDay,
        createPriceEvent,
        decrementItemFromInventory,
        fertilizePlot,
        forRange,
        generatePriceEvents,
        harvestPlot,
        hugCow,
        incrementPlotContentAge,
        makeFermentationRecipe,
        makeRecipe,
        makeWine,
        minePlot,
        modifyCow,
        modifyFieldPlotAt,
        offerCow,
        plantInPlot,
        prependPendingPeerMessage,
        processCowAttrition,
        processCowBreeding,
        processCowFertilizerProduction,
        processFeedingCows,
        processField,
        processLevelUp,
        processMilkingCows,
        processNerfs,
        processSprinklers,
        processWeather,
        purchaseCellar,
        purchaseCombine,
        purchaseComposter,
        purchaseCow,
        purchaseCowPen,
        purchaseField,
        purchaseForest,
        purchaseItem,
        purchaseSmelter,
        purchaseStorageExpansion,
        removeCowFromInventory,
        removeFieldPlotAt,
        removeKegFromCellar,
        removePeer,
        rotateNotificationLogs,
        selectCow,
        sellCow,
        sellItem,
        sellKeg,
        setScarecrow,
        setSprinkler,
        showNotification,
        spawnWeeds,
        unlockTool,
        updateAchievements,
        updateFinancialRecords,
        updateInventoryRecordsForNextDay,
        updateLearnedRecipes,
        updatePeer,
        updatePlotShoveledState,
        updatePriceEvents,
        upgradeTool,
        waterAllPlots,
        waterField,
        waterPlot,
        withdrawCow,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  {
    CLEANUP: CLEANUP$3,
    FERTILIZE: FERTILIZE$1,
    HARVEST: HARVEST$3,
    MINE: MINE$3,
    PLANT: PLANT$2,
    SET_SCARECROW: SET_SCARECROW$1,
    SET_SPRINKLER: SET_SPRINKLER$1,
    WATER: WATER$3,
  } = fieldMode,
  eventHandlers = {
    handleItemPurchaseClick(o, a = 1) {
      this.purchaseItem(o, a)
    },
    handleMakeRecipeClick(o, a = 1) {
      this.makeRecipe(o, a)
    },
    handleMakeFermentationRecipeClick(o, a = 1) {
      this.makeFermentationRecipe(o, a)
    },
    handleMakeWineClick(o, a = 1) {
      this.makeWine(o, a)
    },
    handleSellKegClick(o) {
      this.sellKeg(o)
    },
    handleThrowAwayKegClick(o) {
      this.removeKegFromCellar(o.id)
    },
    handleUpgradeTool(o) {
      this.upgradeTool(o)
    },
    handleCowPurchaseClick(o) {
      this.purchaseCow(o)
    },
    handleCowSellClick(o) {
      this.sellCow(o)
    },
    handleCowTradeClick(o) {
      this.tradeForPeerCow(o)
    },
    handleCowAutomaticHugChange({ target: { checked: o } }, a) {
      this.changeCowAutomaticHugState(a, o)
    },
    handleCowBreedChange({ target: { checked: o } }, a) {
      this.changeCowBreedingPenResident(a, o)
    },
    handleCowHugClick(o) {
      this.hugCow(o.id)
    },
    handleCowOfferClick(o) {
      this.offerCow(o.id)
    },
    handleCowWithdrawClick(o) {
      this.withdrawCow(o.id)
    },
    handleCowNameInputChange({ target: { value: o } }, a) {
      this.changeCowName(a.id, o)
    },
    handleItemSellClick(o, a = 1) {
      this.sellItem(o, a)
    },
    handleViewChange({ target: { value: o } }) {
      this.setState({ stageFocus: o })
    },
    handleViewChangeButtonClick(o) {
      this.setState({ stageFocus: o })
    },
    handleFieldModeSelect(o) {
      this.setState(({ selectedItemId: a }) => ({
        selectedItemId: o !== PLANT$2 || TOOLBELT_FIELD_MODES.has(o) ? '' : a,
        fieldMode: o,
      }))
    },
    handleItemSelectClick({ id: o, enablesFieldMode: a }) {
      this.setState({ fieldMode: a, selectedItemId: o })
    },
    handlePlotClick(o, a) {
      const {
        fieldMode: s,
        hoveredPlotRangeSize: $,
        selectedItemId: j,
      } = this.state
      s === PLANT$2
        ? this.forRange(plantInPlot, $, o, a, j)
        : s === HARVEST$3
        ? this.forRange(harvestPlot, $, o, a)
        : s === MINE$3
        ? this.forRange(minePlot, $, o, a)
        : s === CLEANUP$3
        ? this.forRange(clearPlot, $, o, a)
        : s === WATER$3
        ? this.forRange(waterPlot, $, o, a)
        : s === FERTILIZE$1
        ? this.forRange(fertilizePlot, $, o, a)
        : s === SET_SPRINKLER$1
        ? this.setSprinkler(o, a)
        : s === SET_SCARECROW$1 && this.setScarecrow(o, a)
    },
    handleFieldActionRangeChange(o) {
      this.setState(() => ({ hoveredPlotRangeSize: o }))
    },
    handleClickEndDayButton() {
      this.incrementDay(), document.activeElement.blur()
    },
    handleAddMoneyClick(o) {
      this.setState(({ money: a }) => ({ money: moneyTotal(a, o) }))
    },
    handleClearPersistedDataClick() {
      this.clearPersistedData()
    },
    handleWaterAllPlotsClick() {
      this.waterAllPlots(this.state)
    },
    handleFieldPurchase(o) {
      this.purchaseField(o)
    },
    handleForestPurchase(o) {
      this.purchaseForest(o)
    },
    handleCombinePurchase(o) {
      this.purchaseCombine(o)
    },
    handleComposterPurchase(o) {
      this.purchaseComposter(o)
    },
    handleSmelterPurchase(o) {
      this.purchaseSmelter(o)
    },
    handleCowPenPurchase(o) {
      this.purchaseCowPen(o)
    },
    handleCellarPurchase(o) {
      this.purchaseCellar(o)
    },
    handleStorageExpansionPurchase() {
      this.purchaseStorageExpansion()
    },
    handleMenuToggle(o = null) {
      this.setState(({ isMenuOpen: a }) => ({
        isMenuOpen: o === null ? !a : o,
      }))
    },
    handleClickNextMenuButton() {
      this.focusNextView()
    },
    handleClickPreviousMenuButton() {
      this.focusPreviousView()
    },
    handleCowSelect(o) {
      this.selectCow(o)
    },
    handleCowClick(o) {
      this.selectCow(o), this.hugCow(o.id)
    },
    handleCowPenUnmount() {
      this.setState({ selectedCowId: '' })
    },
    handleClickDialogViewButton(o) {
      this.openDialogView(o)
    },
    handleCloseDialogView() {
      this.state.isAwaitingCowTradeRequest || this.closeDialogView()
    },
    handleDialogViewExited() {
      this.setState({ currentDialogView: dialogView.NONE })
    },
    handleClickLoanPaydownButton(o) {
      this.adjustLoan(-o)
    },
    handleClickTakeOutLoanButton(o) {
      this.adjustLoan(o)
    },
    handleExportDataClick() {
      const o = new Blob(
          [JSON.stringify(reduceByPersistedKeys(this.state), null, 2)],
          { type: 'application/json;charset=utf-8' }
        ),
        [a] = new Date().toISOString().split('T')
      FileSaver_minExports.saveAs(o, `farmhand-${a}.json`)
    },
    handleImportDataClick([o]) {
      const [, a] = o,
        s = new FileReader()
      s.addEventListener('loadend', $ => {
        try {
          const { result: j } = $.srcElement,
            _e = reduceByPersistedKeys(JSON.parse(j))
          if (
            Object.keys(_e).some(et => typeof this.state[et] != typeof _e[et])
          )
            throw new Error(INVALID_DATA_PROVIDED)
          this.setState({
            ...transformStateDataForImport({
              ...this.createInitialState(),
              ..._e,
            }),
            hasBooted: !0,
          }),
            this.showNotification('Data loaded!', 'success')
        } catch (j) {
          console.error(j), this.showNotification(j.message, 'error')
        }
      }),
        s.readAsText(a.slice())
    },
    async handleSaveButtonClick() {
      await this.persistState(),
        this.showNotification(PROGRESS_SAVED_MESSAGE, 'info')
    },
    handleFarmNameUpdate(o) {
      this.setState({ farmName: o })
    },
    handleCombineEnabledChange(o, a) {
      this.setState({ isCombineEnabled: a })
    },
    handleUseAlternateEndDayButtonPositionChange(o, a) {
      this.setState({ useAlternateEndDayButtonPosition: a })
    },
    handleAllowCustomPeerCowNamesChange(o, a) {
      this.setState({ allowCustomPeerCowNames: a })
    },
    handleShowHomeScreenChange(o, a) {
      this.state.stageFocus === stageFocusType.HOME &&
        !a &&
        this.focusNextView(),
        this.setState({ showHomeScreen: a })
    },
    handleShowNotificationsChange({ target: { checked: o } }) {
      this.setState({ showNotifications: o })
    },
    handleClickNotificationIndicator() {
      this.openDialogView(dialogView.FARMERS_LOG)
    },
    handleOnlineToggleChange(o) {
      o || this.showNotification(DISCONNECTING_FROM_SERVER, 'info'),
        this.setState(({ room: a }) =>
          o
            ? { redirect: `/online/${encodeURIComponent(a)}` }
            : { redirect: '/', cowIdOfferedForTrade: '' }
        )
    },
    handleRoomChange(o) {
      this.setState(() => ({
        room: o,
        redirect: `/online/${encodeURIComponent(o.trim() || DEFAULT_ROOM)}`,
      }))
    },
    handleActivePlayerButtonClick() {
      this.openDialogView(dialogView.ONLINE_PEERS)
    },
    handleRNGSeedChange(o) {
      const { origin: a, pathname: s, search: $, hash: j } = window$1.location,
        _e = new URLSearchParams($),
        et = o.trim()
      et === ''
        ? (randomNumberService.unseedRandomNumber(),
          _e.delete('seed'),
          this.showNotification('Random seed reset', 'info'))
        : (randomNumberService.seedRandomNumber(et),
          _e.set('seed', et),
          this.showNotification(`Random seed set to "${et}"`, 'success'))
      const tt = _e.toString(),
        rt = tt.length > 0 ? `?${tt}` : '',
        nt = `${a}${s}${rt}${j}`
      window$1.history.replaceState({}, '', nt)
    },
    handleChatRoomOpenStateChange(o) {
      this.setState({ isChatOpen: o })
    },
    handleGameUpdateAvailable(o) {
      this.showNotification(UPDATE_AVAILABLE, 'success', () => {
        o(!0)
      })
    },
  },
  handlePeerMetadataRequest = (o, a, s) => {
    o.updatePeer(o, a, s)
  },
  handleCowTradeRequest = async (o, { cowOffered: a, cowRequested: s }, $) => {
    let j = !1
    o.setState(
      _e => {
        const {
          allowCustomPeerCowNames: et,
          cowIdOfferedForTrade: tt,
          cowsTraded: rt,
          cowInventory: nt,
          id: it,
          isAwaitingCowTradeRequest: ot,
          peers: at,
          sendCowAccept: st,
          sendCowReject: ut,
        } = _e
        if (!st || !ut)
          return console.error('Peer connection not set up correctly'), null
        const ct = nt.find(({ id: mt }) => mt === tt)
        if (ot || s.id !== tt || !ct)
          return (
            ut(
              { reason: cowTradeRejectionReason.REQUESTED_COW_UNAVAILABLE },
              $
            ),
            null
          )
        const dt = {
            ...a,
            timesTraded:
              a.originalOwnerId === it ? a.timesTraded : a.timesTraded + 1,
          },
          [, ft] =
            Object.entries(at).find(
              ([, mt]) => (mt == null ? void 0 : mt.id) === dt.ownerId
            ) ?? []
        return ft
          ? ((_e = changeCowAutomaticHugState(_e, ct, !1)),
            (_e = removeCowFromInventory(_e, ct)),
            (_e = addCowToInventory(_e, { ...dt, ownerId: it })),
            (_e = showNotification(
              _e,
              COW_TRADED_NOTIFICATION`${ct}${a}${it}${et}`,
              'success'
            )),
            st({ ...ct, isUsingHuggingMachine: !1 }, $),
            (j = !0),
            {
              ..._e,
              cowIdOfferedForTrade: dt.id,
              cowsTraded: dt.originalOwnerId === it ? rt : rt + 1,
              isAwaitingCowTradeRequest: !0,
              selectedCowId: dt.id,
              peers: {
                ...at,
                [$]: { ...ft, cowOfferedForTrade: { ...ct, ownerId: ft.id } },
              },
            })
          : (console.error(`No data for peer ${dt.ownerId}`), null)
      },
      async () => {
        j &&
          (await sleep(750),
          await o.persistState(),
          o.showNotification(PROGRESS_SAVED_MESSAGE, 'info'),
          o.setState(() => ({ isAwaitingCowTradeRequest: !1 })))
      }
    )
  },
  handleCowTradeRequestAccept = (o, a, s) => {
    let $ = !1
    o.setState(
      j => {
        const {
            allowCustomPeerCowNames: _e,
            cowIdOfferedForTrade: et,
            cowInventory: tt,
            cowsTraded: rt,
            cowTradeTimeoutId: nt,
            id: it,
            peers: ot,
          } = j,
          at = tt.find(({ id: dt }) => dt === et)
        if (!at)
          return (
            console.error(
              `handleCowTradeRequestAccept: cow with ID ${et} is no longer available`
            ),
            (j = showNotification(j, UNKNOWN_COW_TRADE_FAILURE, 'error')),
            { ...j, isAwaitingCowTradeRequest: !1 }
          )
        const [, st] = Object.entries(ot).find(
            ([, { id: dt }]) => dt === a.ownerId
          ),
          ut = a.originalOwnerId === it,
          ct = { ...a, timesTraded: ut ? a.timesTraded : a.timesTraded + 1 }
        return (
          (j = removeCowFromInventory(j, at)),
          (j = addCowToInventory(j, { ...ct, ownerId: it })),
          (j = showNotification(
            j,
            COW_TRADED_NOTIFICATION`${at}${ct}${it}${_e}`,
            'success'
          )),
          ut || (j = addExperience(j, EXPERIENCE_VALUES.COW_TRADED)),
          clearTimeout(nt),
          ($ = !0),
          {
            ...j,
            cowsTraded: ct.originalOwnerId === it ? rt : rt + 1,
            cowTradeTimeoutId: null,
            isAwaitingCowTradeRequest: !1,
            cowIdOfferedForTrade: ct.id,
            selectedCowId: ct.id,
            peers: {
              ...ot,
              [s]: { ...st, cowOfferedForTrade: { ...at, ownerId: st.id } },
            },
          }
        )
      },
      async () => {
        $ &&
          (await o.persistState(),
          o.showNotification(PROGRESS_SAVED_MESSAGE, 'info'))
      }
    )
  },
  handleCowTradeRequestReject = (o, { reason: a }) => {
    const { cowTradeTimeoutId: s } = o.state
    clearTimeout(s),
      o.setState({ cowTradeTimeoutId: null, isAwaitingCowTradeRequest: !1 }),
      o.showNotification(REQUESTED_COW_TRADE_UNAVAILABLE, 'error')
  }
var shifty = { exports: {} }
/*! For license information please see shifty.js.LICENSE.txt */ ;(function(
  o,
  a
) {
  ;(function(s, $) {
    o.exports = $()
  })(self, function() {
    return (function() {
      var s = {
          55: function(_e, et, tt) {
            Object.defineProperty(et, '__esModule', { value: !0 }),
              (et.setBezierFunction = et.getCubicBezierTransition = void 0)
            const rt = tt(188)
            ;(et.getCubicBezierTransition = (
              nt = 0.25,
              it = 0.25,
              ot = 0.75,
              at = 0.75
            ) => st =>
              (function(ut, ct, dt, ft, mt, vt) {
                let yt = 0,
                  pt = 0,
                  ht = 0,
                  At = 0,
                  wt = 0,
                  Ct = 0
                const Dt = Mt => ((yt * Mt + pt) * Mt + ht) * Mt,
                  jt = Mt => (3 * yt * Mt + 2 * pt) * Mt + ht,
                  Et = Mt => (Mt >= 0 ? Mt : 0 - Mt)
                return (
                  (ht = 3 * ct),
                  (pt = 3 * (ft - ct) - ht),
                  (yt = 1 - ht - pt),
                  (Ct = 3 * dt),
                  (wt = 3 * (mt - dt) - Ct),
                  (At = 1 - Ct - wt),
                  (St = ut),
                  (Bt = (Mt => 1 / (200 * Mt))(vt)),
                  (Mt => ((At * Mt + wt) * Mt + Ct) * Mt)(
                    ((Mt, Ut) => {
                      let Wt, Tt, kt, Ot, Nt, $t
                      for (kt = Mt, $t = 0; $t < 8; $t++) {
                        if (((Ot = Dt(kt) - Mt), Et(Ot) < Ut)) return kt
                        if (((Nt = jt(kt)), Et(Nt) < 1e-6)) break
                        kt -= Ot / Nt
                      }
                      if (((Wt = 0), (Tt = 1), (kt = Mt), kt < Wt)) return Wt
                      if (kt > Tt) return Tt
                      for (; Wt < Tt; ) {
                        if (((Ot = Dt(kt)), Et(Ot - Mt) < Ut)) return kt
                        Mt > Ot ? (Wt = kt) : (Tt = kt),
                          (kt = 0.5 * (Tt - Wt) + Wt)
                      }
                      return kt
                    })(St, Bt)
                  )
                )
                var St, Bt
              })(st, nt, it, ot, at, 1)),
              (et.setBezierFunction = (nt, it, ot, at, st) => {
                const ut = (0, et.getCubicBezierTransition)(it, ot, at, st)
                return (
                  (ut.displayName = nt),
                  (ut.x1 = it),
                  (ut.y1 = ot),
                  (ut.x2 = at),
                  (ut.y2 = st),
                  (rt.Tweenable.easing[nt] = ut)
                )
              })
          },
          607: function(_e, et, tt) {
            var rt =
                (this && this.__createBinding) ||
                (Object.create
                  ? function(ct, dt, ft, mt) {
                      mt === void 0 && (mt = ft)
                      var vt = Object.getOwnPropertyDescriptor(dt, ft)
                      ;(vt &&
                        !('get' in vt
                          ? !dt.__esModule
                          : vt.writable || vt.configurable)) ||
                        (vt = {
                          enumerable: !0,
                          get: function() {
                            return dt[ft]
                          },
                        }),
                        Object.defineProperty(ct, mt, vt)
                    }
                  : function(ct, dt, ft, mt) {
                      mt === void 0 && (mt = ft), (ct[mt] = dt[ft])
                    }),
              nt =
                (this && this.__exportStar) ||
                function(ct, dt) {
                  for (var ft in ct)
                    ft === 'default' ||
                      Object.prototype.hasOwnProperty.call(dt, ft) ||
                      rt(dt, ct, ft)
                }
            Object.defineProperty(et, '__esModule', { value: !0 }),
              (et.VERSION = et.standardEasingFunctions = et.setBezierFunction = et.Scene = et.interpolate = et.tween = et.Tweenable = et.shouldScheduleUpdate = et.processTweens = void 0)
            const it = tt(188)
            Object.defineProperty(et, 'processTweens', {
              enumerable: !0,
              get: function() {
                return it.processTweens
              },
            }),
              Object.defineProperty(et, 'shouldScheduleUpdate', {
                enumerable: !0,
                get: function() {
                  return it.shouldScheduleUpdate
                },
              }),
              Object.defineProperty(et, 'Tweenable', {
                enumerable: !0,
                get: function() {
                  return it.Tweenable
                },
              }),
              Object.defineProperty(et, 'tween', {
                enumerable: !0,
                get: function() {
                  return it.tween
                },
              })
            var ot = tt(166)
            Object.defineProperty(et, 'interpolate', {
              enumerable: !0,
              get: function() {
                return ot.interpolate
              },
            })
            var at = tt(147)
            Object.defineProperty(et, 'Scene', {
              enumerable: !0,
              get: function() {
                return at.Scene
              },
            })
            var st = tt(55)
            Object.defineProperty(et, 'setBezierFunction', {
              enumerable: !0,
              get: function() {
                return st.setBezierFunction
              },
            })
            var ut = tt(64)
            Object.defineProperty(et, 'standardEasingFunctions', {
              enumerable: !0,
              get: function() {
                return ut.standardEasingFunctions
              },
            }),
              nt(tt(699), et),
              (et.VERSION = '3.0.3')
          },
          166: function(_e, et, tt) {
            Object.defineProperty(et, '__esModule', { value: !0 }),
              (et.interpolate = void 0)
            const rt = tt(188),
              nt = new rt.Tweenable(),
              { filters: it } = rt.Tweenable
            et.interpolate = (
              ot,
              at,
              st,
              ut = rt.Tweenable.easing.linear,
              ct = 0
            ) => {
              const dt = Object.assign({}, ot),
                ft = (0, rt.composeEasingObject)(ot, ut)
              ;(nt._filters.length = 0),
                nt.setState({}),
                (nt._currentState = dt),
                (nt._originalState = ot),
                (nt._targetState = at),
                (nt._easing = ft)
              for (const vt in it)
                it[vt].doesApply(nt) && nt._filters.push(it[vt])
              nt._applyFilter('tweenCreated'), nt._applyFilter('beforeTween')
              const mt = (0, rt.tweenProps)(st, dt, ot, at, 1, ct, ft)
              return nt._applyFilter('afterTween'), mt
            }
          },
          147: function(_e, et) {
            Object.defineProperty(et, '__esModule', { value: !0 }),
              (et.Scene = void 0),
              (et.Scene = class {
                constructor(...tt) {
                  ;(this._tweenables = []), tt.forEach(this.add.bind(this))
                }
                get tweenables() {
                  return [...this._tweenables]
                }
                get promises() {
                  return this._tweenables.map(tt => tt.then())
                }
                add(tt) {
                  return this._tweenables.push(tt), tt
                }
                remove(tt) {
                  const rt = this._tweenables.indexOf(tt)
                  return rt > -1 && this._tweenables.splice(rt, 1), tt
                }
                empty() {
                  return this.tweenables.map(this.remove.bind(this))
                }
                get isPlaying() {
                  return this._tweenables.some(({ isPlaying: tt }) => tt)
                }
                tween() {
                  return this._tweenables.forEach(tt => tt.tween()), this
                }
                pause() {
                  return this._tweenables.forEach(tt => tt.pause()), this
                }
                resume() {
                  return (
                    this._tweenables
                      .filter(({ hasEnded: tt }) => !tt)
                      .forEach(tt => tt.resume()),
                    this
                  )
                }
                stop(tt) {
                  return this._tweenables.forEach(rt => rt.stop(tt)), this
                }
              })
          },
          64: function(_e, et) {
            Object.defineProperty(et, '__esModule', { value: !0 }),
              (et.standardEasingFunctions = void 0),
              (et.standardEasingFunctions = Object.freeze({
                linear: tt => tt,
                easeInQuad: tt => Math.pow(tt, 2),
                easeOutQuad: tt => -(Math.pow(tt - 1, 2) - 1),
                easeInOutQuad: tt =>
                  (tt /= 0.5) < 1
                    ? 0.5 * Math.pow(tt, 2)
                    : -0.5 * ((tt -= 2) * tt - 2),
                easeInCubic: tt => Math.pow(tt, 3),
                easeOutCubic: tt => Math.pow(tt - 1, 3) + 1,
                easeInOutCubic: tt =>
                  (tt /= 0.5) < 1
                    ? 0.5 * Math.pow(tt, 3)
                    : 0.5 * (Math.pow(tt - 2, 3) + 2),
                easeInQuart: tt => Math.pow(tt, 4),
                easeOutQuart: tt => -(Math.pow(tt - 1, 4) - 1),
                easeInOutQuart: tt =>
                  (tt /= 0.5) < 1
                    ? 0.5 * Math.pow(tt, 4)
                    : -0.5 * ((tt -= 2) * Math.pow(tt, 3) - 2),
                easeInQuint: tt => Math.pow(tt, 5),
                easeOutQuint: tt => Math.pow(tt - 1, 5) + 1,
                easeInOutQuint: tt =>
                  (tt /= 0.5) < 1
                    ? 0.5 * Math.pow(tt, 5)
                    : 0.5 * (Math.pow(tt - 2, 5) + 2),
                easeInSine: tt => 1 - Math.cos(tt * (Math.PI / 2)),
                easeOutSine: tt => Math.sin(tt * (Math.PI / 2)),
                easeInOutSine: tt => -0.5 * (Math.cos(Math.PI * tt) - 1),
                easeInExpo: tt => (tt === 0 ? 0 : Math.pow(2, 10 * (tt - 1))),
                easeOutExpo: tt => (tt === 1 ? 1 : 1 - Math.pow(2, -10 * tt)),
                easeInOutExpo: tt =>
                  tt === 0
                    ? 0
                    : tt === 1
                    ? 1
                    : (tt /= 0.5) < 1
                    ? 0.5 * Math.pow(2, 10 * (tt - 1))
                    : 0.5 * (2 - Math.pow(2, -10 * --tt)),
                easeInCirc: tt => -(Math.sqrt(1 - tt * tt) - 1),
                easeOutCirc: tt => Math.sqrt(1 - Math.pow(tt - 1, 2)),
                easeInOutCirc: tt =>
                  (tt /= 0.5) < 1
                    ? -0.5 * (Math.sqrt(1 - tt * tt) - 1)
                    : 0.5 * (Math.sqrt(1 - (tt -= 2) * tt) + 1),
                easeOutBounce: tt =>
                  tt < 0.36363636363636365
                    ? 7.5625 * tt * tt
                    : tt < 0.7272727272727273
                    ? 7.5625 * (tt -= 0.5454545454545454) * tt + 0.75
                    : tt < 0.9090909090909091
                    ? 7.5625 * (tt -= 0.8181818181818182) * tt + 0.9375
                    : 7.5625 * (tt -= 0.9545454545454546) * tt + 0.984375,
                easeInBack: tt => tt * tt * (2.70158 * tt - 1.70158),
                easeOutBack: tt =>
                  (tt -= 1) * tt * (2.70158 * tt + 1.70158) + 1,
                easeInOutBack: tt => {
                  let rt = 1.70158
                  return (tt /= 0.5) < 1
                    ? tt * tt * ((1 + (rt *= 1.525)) * tt - rt) * 0.5
                    : 0.5 *
                        ((tt -= 2) * tt * ((1 + (rt *= 1.525)) * tt + rt) + 2)
                },
                elastic: tt =>
                  -1 *
                    Math.pow(4, -8 * tt) *
                    Math.sin(((6 * tt - 1) * (2 * Math.PI)) / 2) +
                  1,
                swingFromTo: tt => {
                  let rt = 1.70158
                  return (tt /= 0.5) < 1
                    ? tt * tt * ((1 + (rt *= 1.525)) * tt - rt) * 0.5
                    : 0.5 *
                        ((tt -= 2) * tt * ((1 + (rt *= 1.525)) * tt + rt) + 2)
                },
                swingFrom: tt => tt * tt * (2.70158 * tt - 1.70158),
                swingTo: tt => (tt -= 1) * tt * (2.70158 * tt + 1.70158) + 1,
                bounce: tt =>
                  tt < 0.36363636363636365
                    ? 7.5625 * tt * tt
                    : tt < 0.7272727272727273
                    ? 7.5625 * (tt -= 0.5454545454545454) * tt + 0.75
                    : tt < 0.9090909090909091
                    ? 7.5625 * (tt -= 0.8181818181818182) * tt + 0.9375
                    : 7.5625 * (tt -= 0.9545454545454546) * tt + 0.984375,
                bouncePast: tt =>
                  tt < 0.36363636363636365
                    ? 7.5625 * tt * tt
                    : tt < 0.7272727272727273
                    ? 2 - (7.5625 * (tt -= 0.5454545454545454) * tt + 0.75)
                    : tt < 0.9090909090909091
                    ? 2 - (7.5625 * (tt -= 0.8181818181818182) * tt + 0.9375)
                    : 2 - (7.5625 * (tt -= 0.9545454545454546) * tt + 0.984375),
                easeFromTo: tt =>
                  (tt /= 0.5) < 1
                    ? 0.5 * Math.pow(tt, 4)
                    : -0.5 * ((tt -= 2) * Math.pow(tt, 3) - 2),
                easeFrom: tt => Math.pow(tt, 4),
                easeTo: tt => Math.pow(tt, 0.25),
              }))
          },
          432: function(_e, et, tt) {
            Object.defineProperty(et, '__esModule', { value: !0 }),
              (et.afterTween = et.beforeTween = et.tweenCreated = et.doesApply = void 0)
            const rt = tt(699),
              nt = /(\d|-|\.)/,
              it = /([^\-0-9.]+)/g,
              ot = /[0-9.-]+/g,
              at = (() => {
                const jt = ot.source,
                  Et = /,\s*/.source
                return new RegExp(
                  `rgba?\\(${jt}${Et}${jt}${Et}${jt}(${Et}${jt})?\\)`,
                  'g'
                )
              })(),
              st = /^.*\(/,
              ut = /#([0-9]|[a-f]){3,6}/gi,
              ct = 'VAL',
              dt = (jt, Et) => jt.map((St, Bt) => `_${Et}_${Bt}`),
              ft = jt => {
                let Et = jt.match(it)
                return (
                  Et
                    ? (Et.length === 1 || jt.charAt(0).match(nt)) &&
                      Et.unshift('')
                    : (Et = ['', '']),
                  Et.join(ct)
                )
              }
            function mt(jt) {
              return parseInt(jt, 16)
            }
            const vt = jt =>
                `rgb(${(Et => {
                  if ((Et = Et.replace(/#/, '')).length === 3) {
                    const [St, Bt, Mt] = Et.split('')
                    Et = St + St + Bt + Bt + Mt + Mt
                  }
                  return [
                    mt(Et.substring(0, 2)),
                    mt(Et.substring(2, 4)),
                    mt(Et.substring(4, 6)),
                  ]
                })(jt).join(',')})`,
              yt = (jt, Et, St) => {
                const Bt = Et.match(jt)
                let Mt = Et.replace(jt, ct)
                return Bt && Bt.forEach(Ut => (Mt = Mt.replace(ct, St(Ut)))), Mt
              },
              pt = jt => {
                for (const Et in jt) {
                  const St = jt[Et]
                  typeof St == 'string' &&
                    St.match(ut) &&
                    (jt[Et] = yt(ut, St, vt))
                }
              },
              ht = jt => {
                var Et, St
                const Bt =
                    (Et = jt.match(ot)) !== null && Et !== void 0 ? Et : [],
                  Mt = Bt.slice(0, 3).map(Wt => Math.floor(Number(Wt))),
                  Ut =
                    (St = jt.match(st)) === null || St === void 0
                      ? void 0
                      : St[0]
                if (Bt.length === 3) return `${Ut}${Mt.join(',')})`
                if (Bt.length === 4) return `${Ut}${Mt.join(',')},${Bt[3]})`
                throw new Error(`Invalid rgbChunk: ${jt}`)
              },
              At = jt => {
                var Et
                return (Et = jt.match(ot)) !== null && Et !== void 0 ? Et : []
              },
              wt = (jt, Et) => {
                const St = {}
                return (
                  Et.forEach(Bt => {
                    ;(St[Bt] = jt[Bt]), delete jt[Bt]
                  }),
                  St
                )
              },
              Ct = (jt, Et) => Et.map(St => Number(jt[St])),
              Dt = (jt, Et) => (
                Et.forEach(St => (jt = jt.replace(ct, String(+St.toFixed(4))))),
                jt
              )
            ;(et.doesApply = jt => {
              for (const Et in jt._currentState)
                if (typeof jt._currentState[Et] == 'string') return !0
              return !1
            }),
              (et.tweenCreated = function(jt) {
                const {
                  _currentState: Et,
                  _originalState: St,
                  _targetState: Bt,
                } = jt
                ;[Et, St, Bt].forEach(pt),
                  (jt._tokenData = (Mt => {
                    var Ut
                    const Wt = {}
                    for (const Tt in Mt) {
                      const kt = Mt[Tt]
                      typeof kt == 'string' &&
                        (Wt[Tt] = {
                          formatString: ft(kt),
                          chunkNames: dt(
                            (Ut = At(kt)) === null || Ut === void 0
                              ? void 0
                              : Ut.map(Number),
                            Tt
                          ),
                        })
                    }
                    return Wt
                  })(Et))
              }),
              (et.beforeTween = function(jt) {
                const {
                  _currentState: Et,
                  _originalState: St,
                  _targetState: Bt,
                  _easing: Mt,
                  _tokenData: Ut,
                } = jt
                typeof Mt != 'function' &&
                  Ut &&
                  ((Wt, Tt) => {
                    var kt
                    for (const Ot in Tt) {
                      const { chunkNames: Nt } = Tt[Ot],
                        $t = Wt[Ot]
                      if (typeof $t == 'string') {
                        const Pt = $t.split(' '),
                          Ft = Pt[Pt.length - 1]
                        for (let Vt = 0; Vt < Nt.length; Vt++) {
                          const Xt = Nt[Vt],
                            Yt =
                              (kt = Pt[Vt]) !== null && kt !== void 0 ? kt : Ft
                          ;(0, rt.isEasingKey)(Yt) && (Wt[Xt] = Yt)
                        }
                      } else Nt.forEach(Pt => (Wt[Pt] = $t))
                      delete Wt[Ot]
                    }
                  })(Mt, Ut),
                  [Et, St, Bt].forEach(Wt =>
                    ((Tt, kt) => {
                      for (const Ot in kt)
                        At(String(Tt[Ot])).forEach(
                          (Nt, $t) => (Tt[kt[Ot].chunkNames[$t]] = +Nt)
                        ),
                          delete Tt[Ot]
                    })(Wt, Ut ?? {})
                  )
              }),
              (et.afterTween = function(jt) {
                const {
                  _currentState: Et,
                  _originalState: St,
                  _targetState: Bt,
                  _easing: Mt,
                  _tokenData: Ut,
                } = jt
                ;[Et, St, Bt].forEach(Wt =>
                  ((Tt, kt) => {
                    for (const Ot in kt) {
                      const { chunkNames: Nt, formatString: $t } = kt[Ot],
                        Pt = Dt($t, Ct(wt(Tt, Nt), Nt))
                      Tt[Ot] = yt(at, Pt, ht)
                    }
                  })(Wt, Ut ?? {})
                ),
                  typeof Mt != 'function' &&
                    Ut &&
                    ((Wt, Tt) => {
                      for (const kt in Tt) {
                        const { chunkNames: Ot } = Tt[kt],
                          Nt = Wt[Ot[0]]
                        Wt[kt] =
                          typeof Nt == 'string'
                            ? Ot.map($t => {
                                const Pt = Wt[$t]
                                return delete Wt[$t], Pt
                              }).join(' ')
                            : Nt
                      }
                    })(Mt, Ut)
              })
          },
          188: function(_e, et, tt) {
            var rt,
              nt =
                (this && this.__createBinding) ||
                (Object.create
                  ? function(Wt, Tt, kt, Ot) {
                      Ot === void 0 && (Ot = kt)
                      var Nt = Object.getOwnPropertyDescriptor(Tt, kt)
                      ;(Nt &&
                        !('get' in Nt
                          ? !Tt.__esModule
                          : Nt.writable || Nt.configurable)) ||
                        (Nt = {
                          enumerable: !0,
                          get: function() {
                            return Tt[kt]
                          },
                        }),
                        Object.defineProperty(Wt, Ot, Nt)
                    }
                  : function(Wt, Tt, kt, Ot) {
                      Ot === void 0 && (Ot = kt), (Wt[Ot] = Tt[kt])
                    }),
              it =
                (this && this.__setModuleDefault) ||
                (Object.create
                  ? function(Wt, Tt) {
                      Object.defineProperty(Wt, 'default', {
                        enumerable: !0,
                        value: Tt,
                      })
                    }
                  : function(Wt, Tt) {
                      Wt.default = Tt
                    }),
              ot =
                (this && this.__importStar) ||
                function(Wt) {
                  if (Wt && Wt.__esModule) return Wt
                  var Tt = {}
                  if (Wt != null)
                    for (var kt in Wt)
                      kt !== 'default' &&
                        Object.prototype.hasOwnProperty.call(Wt, kt) &&
                        nt(Tt, Wt, kt)
                  return it(Tt, Wt), Tt
                }
            Object.defineProperty(et, '__esModule', { value: !0 }),
              (et.shouldScheduleUpdate = et.tween = et.Tweenable = et.composeEasingObject = et.scheduleUpdate = et.processTweens = et.tweenProps = et.getListTail = et.getListHead = et.resetList = void 0)
            const at = tt(64),
              st = tt(55),
              ut = tt(699),
              ct = ot(tt(432)),
              dt = 'linear',
              ft = typeof window < 'u' ? window : tt.g,
              mt = 'afterTween',
              vt = 'beforeTween',
              yt = 'string',
              pt = 'function'
            let ht = ft.requestAnimationFrame
            ht ||
              (ht =
                typeof window > 'u'
                  ? setTimeout
                  : window.webkitRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    (window.mozCancelRequestAnimationFrame &&
                      window.mozRequestAnimationFrame) ||
                    setTimeout)
            const At = () => {}
            let wt = null,
              Ct = null
            ;(et.resetList = () => {
              wt = Ct = null
            }),
              (et.getListHead = () => wt),
              (et.getListTail = () => Ct),
              (et.tweenProps = (Wt, Tt, kt, Ot, Nt, $t, Pt) => {
                var Ft
                let Vt,
                  Xt = 0
                const Yt = Wt < $t ? 0 : (Wt - $t) / Nt
                let xt
                for (const It in Tt) {
                  if (typeof Pt === pt) xt = Pt
                  else {
                    const Kt = Pt[It]
                    xt =
                      typeof Kt === pt
                        ? Kt
                        : (Ft = Ut.easing[Kt]) !== null && Ft !== void 0
                        ? Ft
                        : at.standardEasingFunctions.linear
                  }
                  ;(Xt = xt(Yt)),
                    (Vt = kt[It]),
                    (Tt[It] = Vt + (Ot[It] - Vt) * Xt)
                }
                return Tt
              })
            const Dt = (Wt, Tt) => {
              var kt
              let Ot = (kt = Wt._timestamp) !== null && kt !== void 0 ? kt : 0
              const Nt = Wt._currentState,
                $t = Wt._delay
              if (Tt < Ot + $t) return
              let Pt = Wt._duration
              const Ft = Wt._targetState,
                Vt = Ot + $t + Pt
              let Xt = Tt > Vt ? Vt : Tt
              Wt._hasEnded = Xt >= Vt
              const Yt = Pt - (Vt - Xt)
              if (Wt._hasEnded) return Wt._render(Ft, Yt, Wt._data), Wt.stop(!0)
              Wt._applyFilter(vt),
                Xt < Ot + $t ? (Ot = Pt = Xt = 1) : (Ot += $t),
                (0, et.tweenProps)(
                  Xt,
                  Nt,
                  Wt._originalState,
                  Ft,
                  Pt,
                  Ot,
                  Wt._easing
                ),
                Wt._applyFilter(mt),
                Wt._render(Nt, Yt, Wt._data)
            }
            et.processTweens = () => {
              let Wt
              const Tt = Ut.now()
              let kt = wt
              for (; kt; ) (Wt = kt._next), Dt(kt, Tt), (kt = Wt)
            }
            const { now: jt } = Date
            let Et,
              St = !1
            ;(et.scheduleUpdate = () => {
              ;(Et = jt()),
                St && ht.call(ft, et.scheduleUpdate, 16.666666666666668),
                (0, et.processTweens)()
            }),
              (et.composeEasingObject = (Wt, Tt = dt, kt = {}) => {
                if (typeof Tt === yt && (0, ut.isEasingKey)(Tt))
                  return Ut.easing[Tt]
                if (Array.isArray(Tt))
                  return (0, st.getCubicBezierTransition)(...Tt)
                if (typeof kt == 'object')
                  if (typeof Tt === yt || typeof Tt === pt)
                    for (const Ot in Wt) kt[Ot] = Tt
                  else for (const Ot in Wt) kt[Ot] = Tt[Ot] || dt
                return kt
              })
            const Bt = (() => {
                let Wt, Tt
                return kt => {
                  ;(Wt = null),
                    (Tt = null),
                    kt === wt
                      ? ((wt = kt._next),
                        wt ? (wt._previous = null) : (Ct = null))
                      : kt === Ct
                      ? ((Ct = kt._previous),
                        Ct ? (Ct._next = null) : (wt = null))
                      : ((Wt = kt._previous),
                        (Tt = kt._next),
                        Wt && (Wt._next = Tt),
                        Tt && (Tt._previous = Wt)),
                    (kt._previous = kt._next = null)
                }
              })(),
              Mt = typeof Promise === pt ? Promise : null
            class Ut {
              constructor(Tt = {}, kt) {
                ;(this[rt] = 'Promise'),
                  (this._next = null),
                  (this._previous = null),
                  (this._config = {}),
                  (this._data = {}),
                  (this._delay = 0),
                  (this._duration = 500),
                  (this._filters = []),
                  (this._timestamp = null),
                  (this._hasEnded = !1),
                  (this._resolve = null),
                  (this._reject = null),
                  (this._originalState = {}),
                  (this._targetState = {}),
                  (this._start = At),
                  (this._render = At),
                  (this._promiseCtor = Mt),
                  (this._promise = null),
                  (this._isPlaying = !1),
                  (this._pausedAtTime = null),
                  (this._easing = {}),
                  (this._currentState = Tt || {}),
                  kt && this.setConfig(kt)
              }
              _applyFilter(Tt) {
                var kt
                for (let Ot = this._filters.length; Ot > 0; Ot--) {
                  const Nt = this._filters[Ot - Ot]
                  ;(kt = Nt[Tt]) === null || kt === void 0 || kt.call(Nt, this)
                }
              }
              tween(Tt) {
                return (
                  this._isPlaying && this.stop(),
                  (!Tt && this._config) || this.setConfig(Tt),
                  (this._pausedAtTime = null),
                  (this._timestamp = Ut.now()),
                  this._start(this.state, this._data),
                  this._delay &&
                    this._render(this._currentState, 0, this._data),
                  this._resume(this._timestamp)
                )
              }
              setConfig(Tt = {}) {
                var kt
                const { _config: Ot } = this
                let Nt
                for (Nt in Tt) Ot[Nt] = Tt[Nt]
                const {
                  promise: $t = this._promiseCtor,
                  start: Pt = At,
                  finish: Ft,
                  render: Vt = At,
                } = Ot
                ;(this._data = Ot.data || this._data),
                  (this._isPlaying = !1),
                  (this._pausedAtTime = null),
                  (this._delay = Tt.delay || 0),
                  (this._start = Pt),
                  (this._render = Vt),
                  (this._duration = Ot.duration || 500),
                  (this._promiseCtor = $t),
                  Ft && (this._resolve = Ft)
                const { from: Xt, to: Yt = {} } = Tt,
                  {
                    _currentState: xt,
                    _originalState: It,
                    _targetState: Kt,
                  } = this
                for (const Ht in Xt) xt[Ht] = Xt[Ht]
                let Qt = !1
                for (const Ht in xt) {
                  const Lt = xt[Ht]
                  Qt || typeof Lt !== yt || (Qt = !0),
                    (It[Ht] = Lt),
                    (Kt[Ht] = (kt = Yt[Ht]) !== null && kt !== void 0 ? kt : Lt)
                }
                if (
                  ((this._easing = (0, et.composeEasingObject)(
                    this._currentState,
                    Ot.easing,
                    this._easing
                  )),
                  (this._filters.length = 0),
                  Qt)
                ) {
                  for (const Ht in Ut.filters)
                    Ut.filters[Ht].doesApply(this) &&
                      this._filters.push(Ut.filters[Ht])
                  this._applyFilter('tweenCreated')
                }
                return this
              }
              then(Tt, kt) {
                if (!this._promiseCtor)
                  throw new Error('Promise implementation is unavailable')
                return (
                  (this._promise = new this._promiseCtor((Ot, Nt) => {
                    ;(this._resolve = Ot), (this._reject = Nt)
                  })),
                  this._promise.then(Tt, kt)
                )
              }
              catch(Tt) {
                return this.then().catch(Tt)
              }
              finally(Tt) {
                return this.then().finally(Tt)
              }
              get state() {
                return Object.assign({}, this._currentState)
              }
              setState(Tt) {
                this._currentState = Tt
              }
              pause() {
                return this._isPlaying
                  ? ((this._pausedAtTime = Ut.now()),
                    (this._isPlaying = !1),
                    Bt(this),
                    this)
                  : this
              }
              resume() {
                return this._resume()
              }
              _resume(Tt = Ut.now()) {
                return this._timestamp === null
                  ? this.tween()
                  : ((this._isPlaying && this._promise) ||
                      (this._pausedAtTime &&
                        ((this._timestamp += Tt - this._pausedAtTime),
                        (this._pausedAtTime = null)),
                      (this._isPlaying = !0),
                      wt === null
                        ? ((wt = this), (Ct = this))
                        : ((this._previous = Ct),
                          Ct && (Ct._next = this),
                          (Ct = this))),
                    this)
              }
              seek(Tt) {
                var kt
                Tt = Math.max(Tt, 0)
                const Ot = Ut.now()
                return (
                  ((kt = this._timestamp) !== null && kt !== void 0 ? kt : 0) +
                    Tt ===
                    0 || ((this._timestamp = Ot - Tt), Dt(this, Ot)),
                  this
                )
              }
              stop(Tt = !1) {
                var kt
                return this._isPlaying
                  ? ((this._isPlaying = !1),
                    Bt(this),
                    Tt &&
                      (this._applyFilter(vt),
                      (0, et.tweenProps)(
                        1,
                        this._currentState,
                        this._originalState,
                        this._targetState,
                        1,
                        0,
                        this._easing
                      ),
                      this._applyFilter(mt),
                      this._applyFilter('afterTweenEnd')),
                    (kt = this._resolve) === null ||
                      kt === void 0 ||
                      kt.call(this, {
                        data: this._data,
                        state: this._currentState,
                        tweenable: this,
                      }),
                    (this._resolve = null),
                    (this._reject = null),
                    this)
                  : this
              }
              cancel(Tt = !1) {
                var kt
                const { _currentState: Ot, _data: Nt, _isPlaying: $t } = this
                return $t
                  ? ((kt = this._reject) === null ||
                      kt === void 0 ||
                      kt.call(this, { data: Nt, state: Ot, tweenable: this }),
                    (this._resolve = null),
                    (this._reject = null),
                    this.stop(Tt))
                  : this
              }
              get isPlaying() {
                return this._isPlaying
              }
              get hasEnded() {
                return this._hasEnded
              }
              data(Tt = null) {
                return Tt && (this._data = Object.assign({}, Tt)), this._data
              }
              dispose() {
                for (const Tt in this) delete this[Tt]
              }
            }
            ;(et.Tweenable = Ut),
              (rt = Symbol.toStringTag),
              (Ut.now = () => Et),
              (Ut.setScheduleFunction = Wt => (ht = Wt)),
              (Ut.filters = { token: ct }),
              (Ut.easing = Object.create(at.standardEasingFunctions)),
              (et.tween = function(Wt = {}) {
                return new Ut({}, {}).tween(Wt)
              }),
              (et.shouldScheduleUpdate = Wt => {
                ;(Wt && St) || ((St = Wt), Wt && (0, et.scheduleUpdate)())
              }),
              (0, et.shouldScheduleUpdate)(!0)
          },
          699: function(_e, et, tt) {
            Object.defineProperty(et, '__esModule', { value: !0 }),
              (et.isEasingKey = void 0)
            const rt = tt(188)
            et.isEasingKey = nt => nt in rt.Tweenable.easing
          },
        },
        $ = {}
      function j(_e) {
        var et = $[_e]
        if (et !== void 0) return et.exports
        var tt = ($[_e] = { exports: {} })
        return s[_e].call(tt.exports, tt, tt.exports, j), tt.exports
      }
      return (
        (j.g = (function() {
          if (typeof globalThis == 'object') return globalThis
          try {
            return this || new Function('return this')()
          } catch {
            if (typeof window == 'object') return window
          }
        })()),
        j(607)
      )
    })()
  })
})(shifty)
var shiftyExports = shifty.exports
function getAppBarUtilityClass(o) {
  return generateUtilityClass('MuiAppBar', o)
}
generateUtilityClasses('MuiAppBar', [
  'root',
  'positionFixed',
  'positionAbsolute',
  'positionSticky',
  'positionStatic',
  'positionRelative',
  'colorDefault',
  'colorPrimary',
  'colorSecondary',
  'colorInherit',
  'colorTransparent',
  'colorError',
  'colorInfo',
  'colorSuccess',
  'colorWarning',
])
const _excluded$U = ['className', 'color', 'enableColorOnDark', 'position'],
  useUtilityClasses$O = o => {
    const { color: a, position: s, classes: $ } = o,
      j = {
        root: ['root', `color${capitalize$2(a)}`, `position${capitalize$2(s)}`],
      }
    return composeClasses(j, getAppBarUtilityClass, $)
  },
  joinVars = (o, a) =>
    o ? `${o == null ? void 0 : o.replace(')', '')}, ${a})` : a,
  AppBarRoot = styled(Paper, {
    name: 'MuiAppBar',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        a[`position${capitalize$2(s.position)}`],
        a[`color${capitalize$2(s.color)}`],
      ]
    },
  })(({ theme: o, ownerState: a }) => {
    const s =
      o.palette.mode === 'light' ? o.palette.grey[100] : o.palette.grey[900]
    return _extends$5(
      {
        display: 'flex',
        flexDirection: 'column',
        width: '100%',
        boxSizing: 'border-box',
        flexShrink: 0,
      },
      a.position === 'fixed' && {
        position: 'fixed',
        zIndex: (o.vars || o).zIndex.appBar,
        top: 0,
        left: 'auto',
        right: 0,
        '@media print': { position: 'absolute' },
      },
      a.position === 'absolute' && {
        position: 'absolute',
        zIndex: (o.vars || o).zIndex.appBar,
        top: 0,
        left: 'auto',
        right: 0,
      },
      a.position === 'sticky' && {
        position: 'sticky',
        zIndex: (o.vars || o).zIndex.appBar,
        top: 0,
        left: 'auto',
        right: 0,
      },
      a.position === 'static' && { position: 'static' },
      a.position === 'relative' && { position: 'relative' },
      !o.vars &&
        _extends$5(
          {},
          a.color === 'default' && {
            backgroundColor: s,
            color: o.palette.getContrastText(s),
          },
          a.color &&
            a.color !== 'default' &&
            a.color !== 'inherit' &&
            a.color !== 'transparent' && {
              backgroundColor: o.palette[a.color].main,
              color: o.palette[a.color].contrastText,
            },
          a.color === 'inherit' && { color: 'inherit' },
          o.palette.mode === 'dark' &&
            !a.enableColorOnDark && { backgroundColor: null, color: null },
          a.color === 'transparent' &&
            _extends$5(
              { backgroundColor: 'transparent', color: 'inherit' },
              o.palette.mode === 'dark' && { backgroundImage: 'none' }
            )
        ),
      o.vars &&
        _extends$5(
          {},
          a.color === 'default' && {
            '--AppBar-background': a.enableColorOnDark
              ? o.vars.palette.AppBar.defaultBg
              : joinVars(
                  o.vars.palette.AppBar.darkBg,
                  o.vars.palette.AppBar.defaultBg
                ),
            '--AppBar-color': a.enableColorOnDark
              ? o.vars.palette.text.primary
              : joinVars(
                  o.vars.palette.AppBar.darkColor,
                  o.vars.palette.text.primary
                ),
          },
          a.color &&
            !a.color.match(/^(default|inherit|transparent)$/) && {
              '--AppBar-background': a.enableColorOnDark
                ? o.vars.palette[a.color].main
                : joinVars(
                    o.vars.palette.AppBar.darkBg,
                    o.vars.palette[a.color].main
                  ),
              '--AppBar-color': a.enableColorOnDark
                ? o.vars.palette[a.color].contrastText
                : joinVars(
                    o.vars.palette.AppBar.darkColor,
                    o.vars.palette[a.color].contrastText
                  ),
            },
          !['inherit', 'transparent'].includes(a.color) && {
            backgroundColor: 'var(--AppBar-background)',
          },
          { color: a.color === 'inherit' ? 'inherit' : 'var(--AppBar-color)' },
          a.color === 'transparent' && {
            backgroundImage: 'none',
            backgroundColor: 'transparent',
            color: 'inherit',
          }
        )
    )
  }),
  AppBar$1 = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiAppBar' }),
      {
        className: j,
        color: _e = 'primary',
        enableColorOnDark: et = !1,
        position: tt = 'fixed',
      } = $,
      rt = _objectWithoutPropertiesLoose$3($, _excluded$U),
      nt = _extends$5({}, $, {
        color: _e,
        position: tt,
        enableColorOnDark: et,
      }),
      it = useUtilityClasses$O(nt)
    return jsxRuntimeExports.jsx(
      AppBarRoot,
      _extends$5(
        {
          square: !0,
          component: 'header',
          ownerState: nt,
          elevation: 4,
          className: clsx$1(it.root, j, tt === 'fixed' && 'mui-fixed'),
          ref: s,
        },
        rt
      )
    )
  })
function getToolbarUtilityClass(o) {
  return generateUtilityClass('MuiToolbar', o)
}
generateUtilityClasses('MuiToolbar', ['root', 'gutters', 'regular', 'dense'])
const _excluded$T = ['className', 'component', 'disableGutters', 'variant'],
  useUtilityClasses$N = o => {
    const { classes: a, disableGutters: s, variant: $ } = o
    return composeClasses(
      { root: ['root', !s && 'gutters', $] },
      getToolbarUtilityClass,
      a
    )
  },
  ToolbarRoot = styled('div', {
    name: 'MuiToolbar',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, !s.disableGutters && a.gutters, a[s.variant]]
    },
  })(
    ({ theme: o, ownerState: a }) =>
      _extends$5(
        { position: 'relative', display: 'flex', alignItems: 'center' },
        !a.disableGutters && {
          paddingLeft: o.spacing(2),
          paddingRight: o.spacing(2),
          [o.breakpoints.up('sm')]: {
            paddingLeft: o.spacing(3),
            paddingRight: o.spacing(3),
          },
        },
        a.variant === 'dense' && { minHeight: 48 }
      ),
    ({ theme: o, ownerState: a }) => a.variant === 'regular' && o.mixins.toolbar
  ),
  Toolbar = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiToolbar' }),
      {
        className: j,
        component: _e = 'div',
        disableGutters: et = !1,
        variant: tt = 'regular',
      } = $,
      rt = _objectWithoutPropertiesLoose$3($, _excluded$T),
      nt = _extends$5({}, $, {
        component: _e,
        disableGutters: et,
        variant: tt,
      }),
      it = useUtilityClasses$N(nt)
    return jsxRuntimeExports.jsx(
      ToolbarRoot,
      _extends$5(
        { as: _e, className: clsx$1(it.root, j), ref: s, ownerState: nt },
        rt
      )
    )
  })
function getTypographyUtilityClass(o) {
  return generateUtilityClass('MuiTypography', o)
}
generateUtilityClasses('MuiTypography', [
  'root',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'subtitle1',
  'subtitle2',
  'body1',
  'body2',
  'inherit',
  'button',
  'caption',
  'overline',
  'alignLeft',
  'alignRight',
  'alignCenter',
  'alignJustify',
  'noWrap',
  'gutterBottom',
  'paragraph',
])
const _excluded$S = [
    'align',
    'className',
    'component',
    'gutterBottom',
    'noWrap',
    'paragraph',
    'variant',
    'variantMapping',
  ],
  useUtilityClasses$M = o => {
    const {
        align: a,
        gutterBottom: s,
        noWrap: $,
        paragraph: j,
        variant: _e,
        classes: et,
      } = o,
      tt = {
        root: [
          'root',
          _e,
          o.align !== 'inherit' && `align${capitalize$2(a)}`,
          s && 'gutterBottom',
          $ && 'noWrap',
          j && 'paragraph',
        ],
      }
    return composeClasses(tt, getTypographyUtilityClass, et)
  },
  TypographyRoot = styled('span', {
    name: 'MuiTypography',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        s.variant && a[s.variant],
        s.align !== 'inherit' && a[`align${capitalize$2(s.align)}`],
        s.noWrap && a.noWrap,
        s.gutterBottom && a.gutterBottom,
        s.paragraph && a.paragraph,
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      { margin: 0 },
      a.variant === 'inherit' && { font: 'inherit' },
      a.variant !== 'inherit' && o.typography[a.variant],
      a.align !== 'inherit' && { textAlign: a.align },
      a.noWrap && {
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap',
      },
      a.gutterBottom && { marginBottom: '0.35em' },
      a.paragraph && { marginBottom: 16 }
    )
  ),
  defaultVariantMapping = {
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6',
    subtitle1: 'h6',
    subtitle2: 'h6',
    body1: 'p',
    body2: 'p',
    inherit: 'p',
  },
  colorTransformations = {
    primary: 'primary.main',
    textPrimary: 'text.primary',
    secondary: 'secondary.main',
    textSecondary: 'text.secondary',
    error: 'error.main',
  },
  transformDeprecatedColors = o => colorTransformations[o] || o,
  Typography = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTypography' }),
      j = transformDeprecatedColors($.color),
      _e = extendSxProp(_extends$5({}, $, { color: j })),
      {
        align: et = 'inherit',
        className: tt,
        component: rt,
        gutterBottom: nt = !1,
        noWrap: it = !1,
        paragraph: ot = !1,
        variant: at = 'body1',
        variantMapping: st = defaultVariantMapping,
      } = _e,
      ut = _objectWithoutPropertiesLoose$3(_e, _excluded$S),
      ct = _extends$5({}, _e, {
        align: et,
        color: j,
        className: tt,
        component: rt,
        gutterBottom: nt,
        noWrap: it,
        paragraph: ot,
        variant: at,
        variantMapping: st,
      }),
      dt = rt || (ot ? 'p' : st[at] || defaultVariantMapping[at]) || 'span',
      ft = useUtilityClasses$M(ct)
    return jsxRuntimeExports.jsx(
      TypographyRoot,
      _extends$5(
        { as: dt, ref: s, ownerState: ct, className: clsx$1(ft.root, tt) },
        ut
      )
    )
  }),
  CheckCircle = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M12 0a12 12 0 1 0 0 24 12 12 0 0 0 0-24zm-2 17l-5-5 1.4-1.4 3.6 3.6 7.6-7.6L19 8l-9 9z',
    }),
    'CheckCircle'
  ),
  Warning = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d: 'M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z',
    }),
    'Warning'
  )
function getStepIconUtilityClass(o) {
  return generateUtilityClass('MuiStepIcon', o)
}
const stepIconClasses = generateUtilityClasses('MuiStepIcon', [
  'root',
  'active',
  'completed',
  'error',
  'text',
])
var _circle
const _excluded$R = ['active', 'className', 'completed', 'error', 'icon'],
  useUtilityClasses$L = o => {
    const { classes: a, active: s, completed: $, error: j } = o
    return composeClasses(
      {
        root: ['root', s && 'active', $ && 'completed', j && 'error'],
        text: ['text'],
      },
      getStepIconUtilityClass,
      a
    )
  },
  StepIconRoot = styled(SvgIcon, {
    name: 'MuiStepIcon',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })(({ theme: o }) => ({
    display: 'block',
    transition: o.transitions.create('color', {
      duration: o.transitions.duration.shortest,
    }),
    color: (o.vars || o).palette.text.disabled,
    [`&.${stepIconClasses.completed}`]: {
      color: (o.vars || o).palette.primary.main,
    },
    [`&.${stepIconClasses.active}`]: {
      color: (o.vars || o).palette.primary.main,
    },
    [`&.${stepIconClasses.error}`]: { color: (o.vars || o).palette.error.main },
  })),
  StepIconText = styled('text', {
    name: 'MuiStepIcon',
    slot: 'Text',
    overridesResolver: (o, a) => a.text,
  })(({ theme: o }) => ({
    fill: (o.vars || o).palette.primary.contrastText,
    fontSize: o.typography.caption.fontSize,
    fontFamily: o.typography.fontFamily,
  })),
  StepIcon = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiStepIcon' }),
      {
        active: j = !1,
        className: _e,
        completed: et = !1,
        error: tt = !1,
        icon: rt,
      } = $,
      nt = _objectWithoutPropertiesLoose$3($, _excluded$R),
      it = _extends$5({}, $, { active: j, completed: et, error: tt }),
      ot = useUtilityClasses$L(it)
    if (typeof rt == 'number' || typeof rt == 'string') {
      const at = clsx$1(_e, ot.root)
      return tt
        ? jsxRuntimeExports.jsx(
            StepIconRoot,
            _extends$5(
              { as: Warning, className: at, ref: s, ownerState: it },
              nt
            )
          )
        : et
        ? jsxRuntimeExports.jsx(
            StepIconRoot,
            _extends$5(
              { as: CheckCircle, className: at, ref: s, ownerState: it },
              nt
            )
          )
        : jsxRuntimeExports.jsxs(
            StepIconRoot,
            _extends$5({ className: at, ref: s, ownerState: it }, nt, {
              children: [
                _circle ||
                  (_circle = jsxRuntimeExports.jsx('circle', {
                    cx: '12',
                    cy: '12',
                    r: '12',
                  })),
                jsxRuntimeExports.jsx(StepIconText, {
                  className: ot.text,
                  x: '12',
                  y: '12',
                  textAnchor: 'middle',
                  dominantBaseline: 'central',
                  ownerState: it,
                  children: rt,
                }),
              ],
            })
          )
    }
    return rt
  }),
  createContextData = () => ({
    gameState: {
      viewTitle: '',
      viewList: [],
      features: {},
      blockInput: !1,
      shopInventory: [],
      isChatAvailable: !1,
      playerInventory: [],
      levelEntitlements: { items: {}, tools: {}, sprinklerRange: 0 },
      fieldToolInventory: [],
      plantableCropInventory: [],
      playerInventoryQuantities: {},
      activePlayers: null,
      allowCustomPeerCowNames: !1,
      cellarInventory: [],
      currentDialogView: '',
      completedAchievements: {},
      cowForSale: generateCow(),
      cowBreedingPen: { cowId1: null, cowId2: null, daysUntilBirth: 0 },
      cowInventory: [],
      cowColorsPurchased: {},
      cowIdOfferedForTrade: '',
      cowsSold: {},
      cowsTraded: 0,
      cowTradeTimeoutId: null,
      cropsHarvested: {},
      dayCount: 0,
      experience: 0,
      farmName: '',
      field: [[]],
      forest: [[]],
      fieldMode: 'default',
      getCowAccept: () => {},
      getCowReject: () => {},
      getCowTradeRequest: () => {},
      getPeerMetadata: () => {},
      hasBooted: !0,
      heartbeatTimeoutId: null,
      historicalDailyLosses: [],
      historicalDailyRevenue: [],
      historicalValueAdjustments: [],
      hoveredPlotRangeSize: 0,
      id: '',
      inventory: [{ id: '', quantity: 0 }],
      inventoryLimit: -1,
      isAwaitingCowTradeRequest: !1,
      isAwaitingNetworkRequest: !1,
      isCombineEnabled: !0,
      isMenuOpen: !1,
      itemsSold: {},
      cellarItemsSold: {},
      isChatOpen: !1,
      isDialogViewOpen: !1,
      isOnline: !0,
      isWaitingForDayToCompleteIncrementing: !1,
      learnedRecipes: {},
      loanBalance: 0,
      loansTakenOut: 0,
      money: 0,
      latestNotification: null,
      newDayNotifications: [],
      notificationLog: [],
      peers: {},
      peerRoom: null,
      pendingPeerMessages: [],
      latestPeerMessages: [],
      sendCowAccept: () => {},
      sendCowReject: () => {},
      sendCowTradeRequest: () => {},
      sendPeerMetadata: () => {},
      selectedCowId: '',
      selectedItemId: '',
      priceCrashes: {},
      priceSurges: {},
      purchasedCombine: 0,
      purchasedComposter: 0,
      purchasedCowPen: 0,
      purchasedCellar: 0,
      purchasedField: 0,
      purchasedForest: 0,
      purchasedSmelter: 0,
      profitabilityStreak: 0,
      record7dayProfitAverage: 0,
      recordProfitabilityStreak: 0,
      recordSingleDayProfit: 0,
      revenue: 0,
      redirect: '',
      room: '',
      showHomeScreen: !0,
      showNotifications: !0,
      stageFocus: 'default',
      todaysLosses: 0,
      todaysPurchases: {},
      todaysRevenue: 0,
      todaysStartingInventory: {},
      toolLevels: {},
      valueAdjustments: {},
      version: '1.0.0',
      todaysNotifications: [],
      useAlternateEndDayButtonPosition: !1,
    },
    handlers: { ...eventHandlers, debounced: { ...eventHandlers } },
  }),
  FarmhandContext = reactExports.createContext(createContextData()),
  MoneyDisplay = ({ money: o }) => {
    const a = 'rgb(255, 255, 255)',
      [s, $] = reactExports.useState(o),
      [j, _e] = reactExports.useState(a),
      [et, tt] = reactExports.useState(o),
      [rt, nt] = reactExports.useState()
    return (
      reactExports.useEffect(() => {
        tt(o)
      }, [o, tt]),
      reactExports.useEffect(() => {
        if (o !== et) {
          rt == null || rt.cancel()
          const it = shiftyExports.tween({
            easing: 'easeOutQuad',
            duration: 750,
            render: ({ color: ot, money: at }) => {
              _e(String(ot)), $(Number(at))
            },
            from: {
              color: o > et ? 'rgb(0, 255, 0)' : 'rgb(255, 0, 0)',
              money: et,
            },
            to: { color: a, money: o },
          })
          nt(it)
        }
        return () => {
          rt == null || rt.cancel()
        }
      }, [rt, o, et]),
      jsxRuntimeExports.jsx('span', {
        style: { color: j },
        children: moneyString(s),
      })
    )
  },
  AppBar = ({
    handleClickNotificationIndicator: o,
    money: a,
    showNotifications: s,
    todaysNotifications: $,
    viewTitle: j,
    areAnyNotificationsErrors: _e = $.some(
      ({ severity: et }) => et === 'error'
    ),
  }) =>
    jsxRuntimeExports.jsx(AppBar$1, {
      className: 'AppBar top-level',
      position: 'fixed',
      children: jsxRuntimeExports.jsxs(Toolbar, {
        className: 'toolbar',
        children: [
          !s &&
            jsxRuntimeExports.jsxs('div', {
              className: 'notification-indicator-container',
              onClick: o,
              children: [
                jsxRuntimeExports.jsx(Typography, {
                  children: jsxRuntimeExports.jsx(StepIcon, {
                    icon: Math.max(0, $.length - 1),
                  }),
                }),
                _e &&
                  jsxRuntimeExports.jsx(Typography, {
                    className: 'error-indicator',
                    children: jsxRuntimeExports.jsx(StepIcon, {
                      error: !0,
                      icon: '',
                    }),
                  }),
              ],
            }),
          jsxRuntimeExports.jsx(Typography, {
            className: 'stage-header',
            variant: 'h2',
            children: j,
          }),
          jsxRuntimeExports.jsx(Typography, {
            className: 'money-display',
            variant: 'h2',
            children: jsxRuntimeExports.jsx(MoneyDisplay, { money: a }),
          }),
        ],
      }),
    })
AppBar.propTypes = {
  handleClickNotificationIndicator: propTypesExports.func.isRequired,
  money: propTypesExports.number.isRequired,
  showNotifications: propTypesExports.bool.isRequired,
  todaysNotifications: propTypesExports.array.isRequired,
  viewTitle: propTypesExports.string.isRequired,
}
function Consumer$n(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(AppBar, { ...a, ...s, ...o }),
  })
}
var AccountBalance = {},
  _interopRequireDefault$b = interopRequireDefaultExports
Object.defineProperty(AccountBalance, '__esModule', { value: !0 })
var default_1$a = (AccountBalance.default = void 0),
  _createSvgIcon$a = _interopRequireDefault$b(requireCreateSvgIcon()),
  _jsxRuntime$a = jsxRuntimeExports
default_1$a = AccountBalance.default = (0, _createSvgIcon$a.default)(
  (0, _jsxRuntime$a.jsx)('path', {
    d: 'M4 10h3v7H4zm6.5 0h3v7h-3zM2 19h20v3H2zm15-9h3v7h-3zm-5-9L2 6v2h20V6z',
  }),
  'AccountBalance'
)
var Assessment = {},
  _interopRequireDefault$a = interopRequireDefaultExports
Object.defineProperty(Assessment, '__esModule', { value: !0 })
var default_1$9 = (Assessment.default = void 0),
  _createSvgIcon$9 = _interopRequireDefault$a(requireCreateSvgIcon()),
  _jsxRuntime$9 = jsxRuntimeExports
default_1$9 = Assessment.default = (0, _createSvgIcon$9.default)(
  (0, _jsxRuntime$9.jsx)('path', {
    d:
      'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2M9 17H7v-7h2zm4 0h-2V7h2zm4 0h-2v-4h2z',
  }),
  'Assessment'
)
var Book = {},
  _interopRequireDefault$9 = interopRequireDefaultExports
Object.defineProperty(Book, '__esModule', { value: !0 })
var default_1$8 = (Book.default = void 0),
  _createSvgIcon$8 = _interopRequireDefault$9(requireCreateSvgIcon()),
  _jsxRuntime$8 = jsxRuntimeExports
default_1$8 = Book.default = (0, _createSvgIcon$8.default)(
  (0, _jsxRuntime$8.jsx)('path', {
    d:
      'M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2M6 4h5v8l-2.5-1.5L6 12z',
  }),
  'Book'
)
function getButtonUtilityClass(o) {
  return generateUtilityClass('MuiButton', o)
}
const buttonClasses = generateUtilityClasses('MuiButton', [
    'root',
    'text',
    'textInherit',
    'textPrimary',
    'textSecondary',
    'textSuccess',
    'textError',
    'textInfo',
    'textWarning',
    'outlined',
    'outlinedInherit',
    'outlinedPrimary',
    'outlinedSecondary',
    'outlinedSuccess',
    'outlinedError',
    'outlinedInfo',
    'outlinedWarning',
    'contained',
    'containedInherit',
    'containedPrimary',
    'containedSecondary',
    'containedSuccess',
    'containedError',
    'containedInfo',
    'containedWarning',
    'disableElevation',
    'focusVisible',
    'disabled',
    'colorInherit',
    'colorPrimary',
    'colorSecondary',
    'colorSuccess',
    'colorError',
    'colorInfo',
    'colorWarning',
    'textSizeSmall',
    'textSizeMedium',
    'textSizeLarge',
    'outlinedSizeSmall',
    'outlinedSizeMedium',
    'outlinedSizeLarge',
    'containedSizeSmall',
    'containedSizeMedium',
    'containedSizeLarge',
    'sizeMedium',
    'sizeSmall',
    'sizeLarge',
    'fullWidth',
    'startIcon',
    'endIcon',
    'icon',
    'iconSizeSmall',
    'iconSizeMedium',
    'iconSizeLarge',
  ]),
  ButtonGroupContext = reactExports.createContext({}),
  ButtonGroupButtonContext = reactExports.createContext(void 0),
  _excluded$Q = [
    'children',
    'color',
    'component',
    'className',
    'disabled',
    'disableElevation',
    'disableFocusRipple',
    'endIcon',
    'focusVisibleClassName',
    'fullWidth',
    'size',
    'startIcon',
    'type',
    'variant',
  ],
  useUtilityClasses$K = o => {
    const {
        color: a,
        disableElevation: s,
        fullWidth: $,
        size: j,
        variant: _e,
        classes: et,
      } = o,
      tt = {
        root: [
          'root',
          _e,
          `${_e}${capitalize$2(a)}`,
          `size${capitalize$2(j)}`,
          `${_e}Size${capitalize$2(j)}`,
          `color${capitalize$2(a)}`,
          s && 'disableElevation',
          $ && 'fullWidth',
        ],
        label: ['label'],
        startIcon: ['icon', 'startIcon', `iconSize${capitalize$2(j)}`],
        endIcon: ['icon', 'endIcon', `iconSize${capitalize$2(j)}`],
      },
      rt = composeClasses(tt, getButtonUtilityClass, et)
    return _extends$5({}, et, rt)
  },
  commonIconStyles = o =>
    _extends$5(
      {},
      o.size === 'small' && { '& > *:nth-of-type(1)': { fontSize: 18 } },
      o.size === 'medium' && { '& > *:nth-of-type(1)': { fontSize: 20 } },
      o.size === 'large' && { '& > *:nth-of-type(1)': { fontSize: 22 } }
    ),
  ButtonRoot = styled(ButtonBase, {
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    name: 'MuiButton',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        a[s.variant],
        a[`${s.variant}${capitalize$2(s.color)}`],
        a[`size${capitalize$2(s.size)}`],
        a[`${s.variant}Size${capitalize$2(s.size)}`],
        s.color === 'inherit' && a.colorInherit,
        s.disableElevation && a.disableElevation,
        s.fullWidth && a.fullWidth,
      ]
    },
  })(
    ({ theme: o, ownerState: a }) => {
      var s, $
      const j =
          o.palette.mode === 'light'
            ? o.palette.grey[300]
            : o.palette.grey[800],
        _e =
          o.palette.mode === 'light' ? o.palette.grey.A100 : o.palette.grey[700]
      return _extends$5(
        {},
        o.typography.button,
        {
          minWidth: 64,
          padding: '6px 16px',
          borderRadius: (o.vars || o).shape.borderRadius,
          transition: o.transitions.create(
            ['background-color', 'box-shadow', 'border-color', 'color'],
            { duration: o.transitions.duration.short }
          ),
          '&:hover': _extends$5(
            {
              textDecoration: 'none',
              backgroundColor: o.vars
                ? `rgba(${o.vars.palette.text.primaryChannel} / ${o.vars.palette.action.hoverOpacity})`
                : alpha_1(
                    o.palette.text.primary,
                    o.palette.action.hoverOpacity
                  ),
              '@media (hover: none)': { backgroundColor: 'transparent' },
            },
            a.variant === 'text' &&
              a.color !== 'inherit' && {
                backgroundColor: o.vars
                  ? `rgba(${o.vars.palette[a.color].mainChannel} / ${
                      o.vars.palette.action.hoverOpacity
                    })`
                  : alpha_1(
                      o.palette[a.color].main,
                      o.palette.action.hoverOpacity
                    ),
                '@media (hover: none)': { backgroundColor: 'transparent' },
              },
            a.variant === 'outlined' &&
              a.color !== 'inherit' && {
                border: `1px solid ${(o.vars || o).palette[a.color].main}`,
                backgroundColor: o.vars
                  ? `rgba(${o.vars.palette[a.color].mainChannel} / ${
                      o.vars.palette.action.hoverOpacity
                    })`
                  : alpha_1(
                      o.palette[a.color].main,
                      o.palette.action.hoverOpacity
                    ),
                '@media (hover: none)': { backgroundColor: 'transparent' },
              },
            a.variant === 'contained' && {
              backgroundColor: o.vars
                ? o.vars.palette.Button.inheritContainedHoverBg
                : _e,
              boxShadow: (o.vars || o).shadows[4],
              '@media (hover: none)': {
                boxShadow: (o.vars || o).shadows[2],
                backgroundColor: (o.vars || o).palette.grey[300],
              },
            },
            a.variant === 'contained' &&
              a.color !== 'inherit' && {
                backgroundColor: (o.vars || o).palette[a.color].dark,
                '@media (hover: none)': {
                  backgroundColor: (o.vars || o).palette[a.color].main,
                },
              }
          ),
          '&:active': _extends$5(
            {},
            a.variant === 'contained' && { boxShadow: (o.vars || o).shadows[8] }
          ),
          [`&.${buttonClasses.focusVisible}`]: _extends$5(
            {},
            a.variant === 'contained' && { boxShadow: (o.vars || o).shadows[6] }
          ),
          [`&.${buttonClasses.disabled}`]: _extends$5(
            { color: (o.vars || o).palette.action.disabled },
            a.variant === 'outlined' && {
              border: `1px solid ${
                (o.vars || o).palette.action.disabledBackground
              }`,
            },
            a.variant === 'contained' && {
              color: (o.vars || o).palette.action.disabled,
              boxShadow: (o.vars || o).shadows[0],
              backgroundColor: (o.vars || o).palette.action.disabledBackground,
            }
          ),
        },
        a.variant === 'text' && { padding: '6px 8px' },
        a.variant === 'text' &&
          a.color !== 'inherit' && {
            color: (o.vars || o).palette[a.color].main,
          },
        a.variant === 'outlined' && {
          padding: '5px 15px',
          border: '1px solid currentColor',
        },
        a.variant === 'outlined' &&
          a.color !== 'inherit' && {
            color: (o.vars || o).palette[a.color].main,
            border: o.vars
              ? `1px solid rgba(${o.vars.palette[a.color].mainChannel} / 0.5)`
              : `1px solid ${alpha_1(o.palette[a.color].main, 0.5)}`,
          },
        a.variant === 'contained' && {
          color: o.vars
            ? o.vars.palette.text.primary
            : (s = ($ = o.palette).getContrastText) == null
            ? void 0
            : s.call($, o.palette.grey[300]),
          backgroundColor: o.vars
            ? o.vars.palette.Button.inheritContainedBg
            : j,
          boxShadow: (o.vars || o).shadows[2],
        },
        a.variant === 'contained' &&
          a.color !== 'inherit' && {
            color: (o.vars || o).palette[a.color].contrastText,
            backgroundColor: (o.vars || o).palette[a.color].main,
          },
        a.color === 'inherit' && {
          color: 'inherit',
          borderColor: 'currentColor',
        },
        a.size === 'small' &&
          a.variant === 'text' && {
            padding: '4px 5px',
            fontSize: o.typography.pxToRem(13),
          },
        a.size === 'large' &&
          a.variant === 'text' && {
            padding: '8px 11px',
            fontSize: o.typography.pxToRem(15),
          },
        a.size === 'small' &&
          a.variant === 'outlined' && {
            padding: '3px 9px',
            fontSize: o.typography.pxToRem(13),
          },
        a.size === 'large' &&
          a.variant === 'outlined' && {
            padding: '7px 21px',
            fontSize: o.typography.pxToRem(15),
          },
        a.size === 'small' &&
          a.variant === 'contained' && {
            padding: '4px 10px',
            fontSize: o.typography.pxToRem(13),
          },
        a.size === 'large' &&
          a.variant === 'contained' && {
            padding: '8px 22px',
            fontSize: o.typography.pxToRem(15),
          },
        a.fullWidth && { width: '100%' }
      )
    },
    ({ ownerState: o }) =>
      o.disableElevation && {
        boxShadow: 'none',
        '&:hover': { boxShadow: 'none' },
        [`&.${buttonClasses.focusVisible}`]: { boxShadow: 'none' },
        '&:active': { boxShadow: 'none' },
        [`&.${buttonClasses.disabled}`]: { boxShadow: 'none' },
      }
  ),
  ButtonStartIcon = styled('span', {
    name: 'MuiButton',
    slot: 'StartIcon',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.startIcon, a[`iconSize${capitalize$2(s.size)}`]]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      { display: 'inherit', marginRight: 8, marginLeft: -4 },
      o.size === 'small' && { marginLeft: -2 },
      commonIconStyles(o)
    )
  ),
  ButtonEndIcon = styled('span', {
    name: 'MuiButton',
    slot: 'EndIcon',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.endIcon, a[`iconSize${capitalize$2(s.size)}`]]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      { display: 'inherit', marginRight: -4, marginLeft: 8 },
      o.size === 'small' && { marginRight: -2 },
      commonIconStyles(o)
    )
  ),
  Button = reactExports.forwardRef(function o(a, s) {
    const $ = reactExports.useContext(ButtonGroupContext),
      j = reactExports.useContext(ButtonGroupButtonContext),
      _e = resolveProps($, a),
      et = useDefaultProps({ props: _e, name: 'MuiButton' }),
      {
        children: tt,
        color: rt = 'primary',
        component: nt = 'button',
        className: it,
        disabled: ot = !1,
        disableElevation: at = !1,
        disableFocusRipple: st = !1,
        endIcon: ut,
        focusVisibleClassName: ct,
        fullWidth: dt = !1,
        size: ft = 'medium',
        startIcon: mt,
        type: vt,
        variant: yt = 'text',
      } = et,
      pt = _objectWithoutPropertiesLoose$3(et, _excluded$Q),
      ht = _extends$5({}, et, {
        color: rt,
        component: nt,
        disabled: ot,
        disableElevation: at,
        disableFocusRipple: st,
        fullWidth: dt,
        size: ft,
        type: vt,
        variant: yt,
      }),
      At = useUtilityClasses$K(ht),
      wt =
        mt &&
        jsxRuntimeExports.jsx(ButtonStartIcon, {
          className: At.startIcon,
          ownerState: ht,
          children: mt,
        }),
      Ct =
        ut &&
        jsxRuntimeExports.jsx(ButtonEndIcon, {
          className: At.endIcon,
          ownerState: ht,
          children: ut,
        }),
      Dt = j || ''
    return jsxRuntimeExports.jsxs(
      ButtonRoot,
      _extends$5(
        {
          ownerState: ht,
          className: clsx$1($.className, At.root, it, Dt),
          component: nt,
          disabled: ot,
          focusRipple: !st,
          focusVisibleClassName: clsx$1(At.focusVisible, ct),
          ref: s,
          type: vt,
        },
        pt,
        { classes: At, children: [wt, tt, Ct] }
      )
    )
  })
function getDialogUtilityClass(o) {
  return generateUtilityClass('MuiDialog', o)
}
const dialogClasses = generateUtilityClasses('MuiDialog', [
    'root',
    'scrollPaper',
    'scrollBody',
    'container',
    'paper',
    'paperScrollPaper',
    'paperScrollBody',
    'paperWidthFalse',
    'paperWidthXs',
    'paperWidthSm',
    'paperWidthMd',
    'paperWidthLg',
    'paperWidthXl',
    'paperFullWidth',
    'paperFullScreen',
  ]),
  DialogContext = reactExports.createContext({}),
  _excluded$P = [
    'aria-describedby',
    'aria-labelledby',
    'BackdropComponent',
    'BackdropProps',
    'children',
    'className',
    'disableEscapeKeyDown',
    'fullScreen',
    'fullWidth',
    'maxWidth',
    'onBackdropClick',
    'onClick',
    'onClose',
    'open',
    'PaperComponent',
    'PaperProps',
    'scroll',
    'TransitionComponent',
    'transitionDuration',
    'TransitionProps',
  ],
  DialogBackdrop = styled(Backdrop, {
    name: 'MuiDialog',
    slot: 'Backdrop',
    overrides: (o, a) => a.backdrop,
  })({ zIndex: -1 }),
  useUtilityClasses$J = o => {
    const {
        classes: a,
        scroll: s,
        maxWidth: $,
        fullWidth: j,
        fullScreen: _e,
      } = o,
      et = {
        root: ['root'],
        container: ['container', `scroll${capitalize$2(s)}`],
        paper: [
          'paper',
          `paperScroll${capitalize$2(s)}`,
          `paperWidth${capitalize$2(String($))}`,
          j && 'paperFullWidth',
          _e && 'paperFullScreen',
        ],
      }
    return composeClasses(et, getDialogUtilityClass, a)
  },
  DialogRoot = styled(Modal, {
    name: 'MuiDialog',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({ '@media print': { position: 'absolute !important' } }),
  DialogContainer = styled('div', {
    name: 'MuiDialog',
    slot: 'Container',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.container, a[`scroll${capitalize$2(s.scroll)}`]]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      { height: '100%', '@media print': { height: 'auto' }, outline: 0 },
      o.scroll === 'paper' && {
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
      },
      o.scroll === 'body' && {
        overflowY: 'auto',
        overflowX: 'hidden',
        textAlign: 'center',
        '&::after': {
          content: '""',
          display: 'inline-block',
          verticalAlign: 'middle',
          height: '100%',
          width: '0',
        },
      }
    )
  ),
  DialogPaper = styled(Paper, {
    name: 'MuiDialog',
    slot: 'Paper',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.paper,
        a[`scrollPaper${capitalize$2(s.scroll)}`],
        a[`paperWidth${capitalize$2(String(s.maxWidth))}`],
        s.fullWidth && a.paperFullWidth,
        s.fullScreen && a.paperFullScreen,
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        margin: 32,
        position: 'relative',
        overflowY: 'auto',
        '@media print': { overflowY: 'visible', boxShadow: 'none' },
      },
      a.scroll === 'paper' && {
        display: 'flex',
        flexDirection: 'column',
        maxHeight: 'calc(100% - 64px)',
      },
      a.scroll === 'body' && {
        display: 'inline-block',
        verticalAlign: 'middle',
        textAlign: 'left',
      },
      !a.maxWidth && { maxWidth: 'calc(100% - 64px)' },
      a.maxWidth === 'xs' && {
        maxWidth:
          o.breakpoints.unit === 'px'
            ? Math.max(o.breakpoints.values.xs, 444)
            : `max(${o.breakpoints.values.xs}${o.breakpoints.unit}, 444px)`,
        [`&.${dialogClasses.paperScrollBody}`]: {
          [o.breakpoints.down(
            Math.max(o.breakpoints.values.xs, 444) + 32 * 2
          )]: { maxWidth: 'calc(100% - 64px)' },
        },
      },
      a.maxWidth &&
        a.maxWidth !== 'xs' && {
          maxWidth: `${o.breakpoints.values[a.maxWidth]}${o.breakpoints.unit}`,
          [`&.${dialogClasses.paperScrollBody}`]: {
            [o.breakpoints.down(o.breakpoints.values[a.maxWidth] + 32 * 2)]: {
              maxWidth: 'calc(100% - 64px)',
            },
          },
        },
      a.fullWidth && { width: 'calc(100% - 64px)' },
      a.fullScreen && {
        margin: 0,
        width: '100%',
        maxWidth: '100%',
        height: '100%',
        maxHeight: 'none',
        borderRadius: 0,
        [`&.${dialogClasses.paperScrollBody}`]: { margin: 0, maxWidth: '100%' },
      }
    )
  ),
  Dialog = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiDialog' }),
      j = useTheme$1(),
      _e = {
        enter: j.transitions.duration.enteringScreen,
        exit: j.transitions.duration.leavingScreen,
      },
      {
        'aria-describedby': et,
        'aria-labelledby': tt,
        BackdropComponent: rt,
        BackdropProps: nt,
        children: it,
        className: ot,
        disableEscapeKeyDown: at = !1,
        fullScreen: st = !1,
        fullWidth: ut = !1,
        maxWidth: ct = 'sm',
        onBackdropClick: dt,
        onClick: ft,
        onClose: mt,
        open: vt,
        PaperComponent: yt = Paper,
        PaperProps: pt = {},
        scroll: ht = 'paper',
        TransitionComponent: At = Fade,
        transitionDuration: wt = _e,
        TransitionProps: Ct,
      } = $,
      Dt = _objectWithoutPropertiesLoose$3($, _excluded$P),
      jt = _extends$5({}, $, {
        disableEscapeKeyDown: at,
        fullScreen: st,
        fullWidth: ut,
        maxWidth: ct,
        scroll: ht,
      }),
      Et = useUtilityClasses$J(jt),
      St = reactExports.useRef(),
      Bt = Tt => {
        St.current = Tt.target === Tt.currentTarget
      },
      Mt = Tt => {
        ft && ft(Tt),
          St.current &&
            ((St.current = null), dt && dt(Tt), mt && mt(Tt, 'backdropClick'))
      },
      Ut = useId(tt),
      Wt = reactExports.useMemo(() => ({ titleId: Ut }), [Ut])
    return jsxRuntimeExports.jsx(
      DialogRoot,
      _extends$5(
        {
          className: clsx$1(Et.root, ot),
          closeAfterTransition: !0,
          components: { Backdrop: DialogBackdrop },
          componentsProps: {
            backdrop: _extends$5({ transitionDuration: wt, as: rt }, nt),
          },
          disableEscapeKeyDown: at,
          onClose: mt,
          open: vt,
          ref: s,
          onClick: Mt,
          ownerState: jt,
        },
        Dt,
        {
          children: jsxRuntimeExports.jsx(
            At,
            _extends$5(
              { appear: !0, in: vt, timeout: wt, role: 'presentation' },
              Ct,
              {
                children: jsxRuntimeExports.jsx(DialogContainer, {
                  className: clsx$1(Et.container),
                  onMouseDown: Bt,
                  ownerState: jt,
                  children: jsxRuntimeExports.jsx(
                    DialogPaper,
                    _extends$5(
                      {
                        as: yt,
                        elevation: 24,
                        role: 'dialog',
                        'aria-describedby': et,
                        'aria-labelledby': Ut,
                      },
                      pt,
                      {
                        className: clsx$1(Et.paper, pt.className),
                        ownerState: jt,
                        children: jsxRuntimeExports.jsx(
                          DialogContext.Provider,
                          { value: Wt, children: it }
                        ),
                      }
                    )
                  ),
                }),
              }
            )
          ),
        }
      )
    )
  })
function getDialogActionsUtilityClass(o) {
  return generateUtilityClass('MuiDialogActions', o)
}
generateUtilityClasses('MuiDialogActions', ['root', 'spacing'])
const _excluded$O = ['className', 'disableSpacing'],
  useUtilityClasses$I = o => {
    const { classes: a, disableSpacing: s } = o
    return composeClasses(
      { root: ['root', !s && 'spacing'] },
      getDialogActionsUtilityClass,
      a
    )
  },
  DialogActionsRoot = styled('div', {
    name: 'MuiDialogActions',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, !s.disableSpacing && a.spacing]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      {
        display: 'flex',
        alignItems: 'center',
        padding: 8,
        justifyContent: 'flex-end',
        flex: '0 0 auto',
      },
      !o.disableSpacing && {
        '& > :not(style) ~ :not(style)': { marginLeft: 8 },
      }
    )
  ),
  DialogActions = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiDialogActions' }),
      { className: j, disableSpacing: _e = !1 } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$O),
      tt = _extends$5({}, $, { disableSpacing: _e }),
      rt = useUtilityClasses$I(tt)
    return jsxRuntimeExports.jsx(
      DialogActionsRoot,
      _extends$5({ className: clsx$1(rt.root, j), ownerState: tt, ref: s }, et)
    )
  })
function getDialogContentUtilityClass(o) {
  return generateUtilityClass('MuiDialogContent', o)
}
generateUtilityClasses('MuiDialogContent', ['root', 'dividers'])
function getDialogTitleUtilityClass(o) {
  return generateUtilityClass('MuiDialogTitle', o)
}
const dialogTitleClasses = generateUtilityClasses('MuiDialogTitle', ['root']),
  _excluded$N = ['className', 'dividers'],
  useUtilityClasses$H = o => {
    const { classes: a, dividers: s } = o
    return composeClasses(
      { root: ['root', s && 'dividers'] },
      getDialogContentUtilityClass,
      a
    )
  },
  DialogContentRoot = styled('div', {
    name: 'MuiDialogContent',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, s.dividers && a.dividers]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        flex: '1 1 auto',
        WebkitOverflowScrolling: 'touch',
        overflowY: 'auto',
        padding: '20px 24px',
      },
      a.dividers
        ? {
            padding: '16px 24px',
            borderTop: `1px solid ${(o.vars || o).palette.divider}`,
            borderBottom: `1px solid ${(o.vars || o).palette.divider}`,
          }
        : { [`.${dialogTitleClasses.root} + &`]: { paddingTop: 0 } }
    )
  ),
  DialogContent = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiDialogContent' }),
      { className: j, dividers: _e = !1 } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$N),
      tt = _extends$5({}, $, { dividers: _e }),
      rt = useUtilityClasses$H(tt)
    return jsxRuntimeExports.jsx(
      DialogContentRoot,
      _extends$5({ className: clsx$1(rt.root, j), ownerState: tt, ref: s }, et)
    )
  }),
  _excluded$M = ['className', 'id'],
  useUtilityClasses$G = o => {
    const { classes: a } = o
    return composeClasses({ root: ['root'] }, getDialogTitleUtilityClass, a)
  },
  DialogTitleRoot = styled(Typography, {
    name: 'MuiDialogTitle',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({ padding: '16px 24px', flex: '0 0 auto' }),
  DialogTitle = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiDialogTitle' }),
      { className: j, id: _e } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$M),
      tt = $,
      rt = useUtilityClasses$G(tt),
      { titleId: nt = _e } = reactExports.useContext(DialogContext)
    return jsxRuntimeExports.jsx(
      DialogTitleRoot,
      _extends$5(
        {
          component: 'h2',
          className: clsx$1(rt.root, j),
          ownerState: tt,
          ref: s,
          variant: 'h6',
          id: _e ?? nt,
        },
        et
      )
    )
  })
function hasValue(o) {
  return o != null && !(Array.isArray(o) && o.length === 0)
}
function isFilled(o, a = !1) {
  return (
    o &&
    ((hasValue(o.value) && o.value !== '') ||
      (a && hasValue(o.defaultValue) && o.defaultValue !== ''))
  )
}
function isAdornedStart(o) {
  return o.startAdornment
}
const FormControlContext = reactExports.createContext(void 0)
function getFormControlUtilityClasses(o) {
  return generateUtilityClass('MuiFormControl', o)
}
generateUtilityClasses('MuiFormControl', [
  'root',
  'marginNone',
  'marginNormal',
  'marginDense',
  'fullWidth',
  'disabled',
])
const _excluded$L = [
    'children',
    'className',
    'color',
    'component',
    'disabled',
    'error',
    'focused',
    'fullWidth',
    'hiddenLabel',
    'margin',
    'required',
    'size',
    'variant',
  ],
  useUtilityClasses$F = o => {
    const { classes: a, margin: s, fullWidth: $ } = o,
      j = {
        root: [
          'root',
          s !== 'none' && `margin${capitalize$2(s)}`,
          $ && 'fullWidth',
        ],
      }
    return composeClasses(j, getFormControlUtilityClasses, a)
  },
  FormControlRoot = styled('div', {
    name: 'MuiFormControl',
    slot: 'Root',
    overridesResolver: ({ ownerState: o }, a) =>
      _extends$5(
        {},
        a.root,
        a[`margin${capitalize$2(o.margin)}`],
        o.fullWidth && a.fullWidth
      ),
  })(({ ownerState: o }) =>
    _extends$5(
      {
        display: 'inline-flex',
        flexDirection: 'column',
        position: 'relative',
        minWidth: 0,
        padding: 0,
        margin: 0,
        border: 0,
        verticalAlign: 'top',
      },
      o.margin === 'normal' && { marginTop: 16, marginBottom: 8 },
      o.margin === 'dense' && { marginTop: 8, marginBottom: 4 },
      o.fullWidth && { width: '100%' }
    )
  ),
  FormControl = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiFormControl' }),
      {
        children: j,
        className: _e,
        color: et = 'primary',
        component: tt = 'div',
        disabled: rt = !1,
        error: nt = !1,
        focused: it,
        fullWidth: ot = !1,
        hiddenLabel: at = !1,
        margin: st = 'none',
        required: ut = !1,
        size: ct = 'medium',
        variant: dt = 'outlined',
      } = $,
      ft = _objectWithoutPropertiesLoose$3($, _excluded$L),
      mt = _extends$5({}, $, {
        color: et,
        component: tt,
        disabled: rt,
        error: nt,
        fullWidth: ot,
        hiddenLabel: at,
        margin: st,
        required: ut,
        size: ct,
        variant: dt,
      }),
      vt = useUtilityClasses$F(mt),
      [yt, pt] = reactExports.useState(() => {
        let St = !1
        return (
          j &&
            reactExports.Children.forEach(j, Bt => {
              if (!isMuiElement(Bt, ['Input', 'Select'])) return
              const Mt = isMuiElement(Bt, ['Select']) ? Bt.props.input : Bt
              Mt && isAdornedStart(Mt.props) && (St = !0)
            }),
          St
        )
      }),
      [ht, At] = reactExports.useState(() => {
        let St = !1
        return (
          j &&
            reactExports.Children.forEach(j, Bt => {
              isMuiElement(Bt, ['Input', 'Select']) &&
                (isFilled(Bt.props, !0) || isFilled(Bt.props.inputProps, !0)) &&
                (St = !0)
            }),
          St
        )
      }),
      [wt, Ct] = reactExports.useState(!1)
    rt && wt && Ct(!1)
    const Dt = it !== void 0 && !rt ? it : wt
    let jt
    const Et = reactExports.useMemo(
      () => ({
        adornedStart: yt,
        setAdornedStart: pt,
        color: et,
        disabled: rt,
        error: nt,
        filled: ht,
        focused: Dt,
        fullWidth: ot,
        hiddenLabel: at,
        size: ct,
        onBlur: () => {
          Ct(!1)
        },
        onEmpty: () => {
          At(!1)
        },
        onFilled: () => {
          At(!0)
        },
        onFocus: () => {
          Ct(!0)
        },
        registerEffect: jt,
        required: ut,
        variant: dt,
      }),
      [yt, et, rt, nt, ht, Dt, ot, at, jt, ut, ct, dt]
    )
    return jsxRuntimeExports.jsx(FormControlContext.Provider, {
      value: Et,
      children: jsxRuntimeExports.jsx(
        FormControlRoot,
        _extends$5(
          { as: tt, ownerState: mt, className: clsx$1(vt.root, _e), ref: s },
          ft,
          { children: j }
        )
      ),
    })
  })
function useFormControl() {
  return reactExports.useContext(FormControlContext)
}
function getFormGroupUtilityClass(o) {
  return generateUtilityClass('MuiFormGroup', o)
}
generateUtilityClasses('MuiFormGroup', ['root', 'row', 'error'])
function formControlState({ props: o, states: a, muiFormControl: s }) {
  return a.reduce(
    ($, j) => (($[j] = o[j]), s && typeof o[j] > 'u' && ($[j] = s[j]), $),
    {}
  )
}
const _excluded$K = ['className', 'row'],
  useUtilityClasses$E = o => {
    const { classes: a, row: s, error: $ } = o
    return composeClasses(
      { root: ['root', s && 'row', $ && 'error'] },
      getFormGroupUtilityClass,
      a
    )
  },
  FormGroupRoot = styled('div', {
    name: 'MuiFormGroup',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, s.row && a.row]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      { display: 'flex', flexDirection: 'column', flexWrap: 'wrap' },
      o.row && { flexDirection: 'row' }
    )
  ),
  FormGroup = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiFormGroup' }),
      { className: j, row: _e = !1 } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$K),
      tt = useFormControl(),
      rt = formControlState({
        props: $,
        muiFormControl: tt,
        states: ['error'],
      }),
      nt = _extends$5({}, $, { row: _e, error: rt.error }),
      it = useUtilityClasses$E(nt)
    return jsxRuntimeExports.jsx(
      FormGroupRoot,
      _extends$5({ className: clsx$1(it.root, j), ownerState: nt, ref: s }, et)
    )
  }),
  ListContext = reactExports.createContext({})
function getDividerUtilityClass(o) {
  return generateUtilityClass('MuiDivider', o)
}
const dividerClasses = generateUtilityClasses('MuiDivider', [
    'root',
    'absolute',
    'fullWidth',
    'inset',
    'middle',
    'flexItem',
    'light',
    'vertical',
    'withChildren',
    'withChildrenVertical',
    'textAlignRight',
    'textAlignLeft',
    'wrapper',
    'wrapperVertical',
  ]),
  _excluded$J = [
    'absolute',
    'children',
    'className',
    'component',
    'flexItem',
    'light',
    'orientation',
    'role',
    'textAlign',
    'variant',
  ],
  useUtilityClasses$D = o => {
    const {
      absolute: a,
      children: s,
      classes: $,
      flexItem: j,
      light: _e,
      orientation: et,
      textAlign: tt,
      variant: rt,
    } = o
    return composeClasses(
      {
        root: [
          'root',
          a && 'absolute',
          rt,
          _e && 'light',
          et === 'vertical' && 'vertical',
          j && 'flexItem',
          s && 'withChildren',
          s && et === 'vertical' && 'withChildrenVertical',
          tt === 'right' && et !== 'vertical' && 'textAlignRight',
          tt === 'left' && et !== 'vertical' && 'textAlignLeft',
        ],
        wrapper: ['wrapper', et === 'vertical' && 'wrapperVertical'],
      },
      getDividerUtilityClass,
      $
    )
  },
  DividerRoot = styled('div', {
    name: 'MuiDivider',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        s.absolute && a.absolute,
        a[s.variant],
        s.light && a.light,
        s.orientation === 'vertical' && a.vertical,
        s.flexItem && a.flexItem,
        s.children && a.withChildren,
        s.children && s.orientation === 'vertical' && a.withChildrenVertical,
        s.textAlign === 'right' &&
          s.orientation !== 'vertical' &&
          a.textAlignRight,
        s.textAlign === 'left' &&
          s.orientation !== 'vertical' &&
          a.textAlignLeft,
      ]
    },
  })(
    ({ theme: o, ownerState: a }) =>
      _extends$5(
        {
          margin: 0,
          flexShrink: 0,
          borderWidth: 0,
          borderStyle: 'solid',
          borderColor: (o.vars || o).palette.divider,
          borderBottomWidth: 'thin',
        },
        a.absolute && {
          position: 'absolute',
          bottom: 0,
          left: 0,
          width: '100%',
        },
        a.light && {
          borderColor: o.vars
            ? `rgba(${o.vars.palette.dividerChannel} / 0.08)`
            : alpha_1(o.palette.divider, 0.08),
        },
        a.variant === 'inset' && { marginLeft: 72 },
        a.variant === 'middle' &&
          a.orientation === 'horizontal' && {
            marginLeft: o.spacing(2),
            marginRight: o.spacing(2),
          },
        a.variant === 'middle' &&
          a.orientation === 'vertical' && {
            marginTop: o.spacing(1),
            marginBottom: o.spacing(1),
          },
        a.orientation === 'vertical' && {
          height: '100%',
          borderBottomWidth: 0,
          borderRightWidth: 'thin',
        },
        a.flexItem && { alignSelf: 'stretch', height: 'auto' }
      ),
    ({ ownerState: o }) =>
      _extends$5(
        {},
        o.children && {
          display: 'flex',
          whiteSpace: 'nowrap',
          textAlign: 'center',
          border: 0,
          borderTopStyle: 'solid',
          borderLeftStyle: 'solid',
          '&::before, &::after': { content: '""', alignSelf: 'center' },
        }
      ),
    ({ theme: o, ownerState: a }) =>
      _extends$5(
        {},
        a.children &&
          a.orientation !== 'vertical' && {
            '&::before, &::after': {
              width: '100%',
              borderTop: `thin solid ${(o.vars || o).palette.divider}`,
              borderTopStyle: 'inherit',
            },
          }
      ),
    ({ theme: o, ownerState: a }) =>
      _extends$5(
        {},
        a.children &&
          a.orientation === 'vertical' && {
            flexDirection: 'column',
            '&::before, &::after': {
              height: '100%',
              borderLeft: `thin solid ${(o.vars || o).palette.divider}`,
              borderLeftStyle: 'inherit',
            },
          }
      ),
    ({ ownerState: o }) =>
      _extends$5(
        {},
        o.textAlign === 'right' &&
          o.orientation !== 'vertical' && {
            '&::before': { width: '90%' },
            '&::after': { width: '10%' },
          },
        o.textAlign === 'left' &&
          o.orientation !== 'vertical' && {
            '&::before': { width: '10%' },
            '&::after': { width: '90%' },
          }
      )
  ),
  DividerWrapper = styled('span', {
    name: 'MuiDivider',
    slot: 'Wrapper',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.wrapper, s.orientation === 'vertical' && a.wrapperVertical]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        display: 'inline-block',
        paddingLeft: `calc(${o.spacing(1)} * 1.2)`,
        paddingRight: `calc(${o.spacing(1)} * 1.2)`,
      },
      a.orientation === 'vertical' && {
        paddingTop: `calc(${o.spacing(1)} * 1.2)`,
        paddingBottom: `calc(${o.spacing(1)} * 1.2)`,
      }
    )
  ),
  Divider = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiDivider' }),
      {
        absolute: j = !1,
        children: _e,
        className: et,
        component: tt = _e ? 'div' : 'hr',
        flexItem: rt = !1,
        light: nt = !1,
        orientation: it = 'horizontal',
        role: ot = tt !== 'hr' ? 'separator' : void 0,
        textAlign: at = 'center',
        variant: st = 'fullWidth',
      } = $,
      ut = _objectWithoutPropertiesLoose$3($, _excluded$J),
      ct = _extends$5({}, $, {
        absolute: j,
        component: tt,
        flexItem: rt,
        light: nt,
        orientation: it,
        role: ot,
        textAlign: at,
        variant: st,
      }),
      dt = useUtilityClasses$D(ct)
    return jsxRuntimeExports.jsx(
      DividerRoot,
      _extends$5(
        {
          as: tt,
          className: clsx$1(dt.root, et),
          role: ot,
          ref: s,
          ownerState: ct,
        },
        ut,
        {
          children: _e
            ? jsxRuntimeExports.jsx(DividerWrapper, {
                className: dt.wrapper,
                ownerState: ct,
                children: _e,
              })
            : null,
        }
      )
    )
  })
Divider.muiSkipListHighlight = !0
const listItemIconClasses = generateUtilityClasses('MuiListItemIcon', [
    'root',
    'alignItemsFlexStart',
  ]),
  listItemTextClasses = generateUtilityClasses('MuiListItemText', [
    'root',
    'multiline',
    'dense',
    'inset',
    'primary',
    'secondary',
  ])
function getMenuItemUtilityClass(o) {
  return generateUtilityClass('MuiMenuItem', o)
}
const menuItemClasses = generateUtilityClasses('MuiMenuItem', [
    'root',
    'focusVisible',
    'dense',
    'disabled',
    'divider',
    'gutters',
    'selected',
  ]),
  _excluded$I = [
    'autoFocus',
    'component',
    'dense',
    'divider',
    'disableGutters',
    'focusVisibleClassName',
    'role',
    'tabIndex',
    'className',
  ],
  overridesResolver = (o, a) => {
    const { ownerState: s } = o
    return [
      a.root,
      s.dense && a.dense,
      s.divider && a.divider,
      !s.disableGutters && a.gutters,
    ]
  },
  useUtilityClasses$C = o => {
    const {
        disabled: a,
        dense: s,
        divider: $,
        disableGutters: j,
        selected: _e,
        classes: et,
      } = o,
      rt = composeClasses(
        {
          root: [
            'root',
            s && 'dense',
            a && 'disabled',
            !j && 'gutters',
            $ && 'divider',
            _e && 'selected',
          ],
        },
        getMenuItemUtilityClass,
        et
      )
    return _extends$5({}, et, rt)
  },
  MenuItemRoot = styled(ButtonBase, {
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    name: 'MuiMenuItem',
    slot: 'Root',
    overridesResolver,
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {},
      o.typography.body1,
      {
        display: 'flex',
        justifyContent: 'flex-start',
        alignItems: 'center',
        position: 'relative',
        textDecoration: 'none',
        minHeight: 48,
        paddingTop: 6,
        paddingBottom: 6,
        boxSizing: 'border-box',
        whiteSpace: 'nowrap',
      },
      !a.disableGutters && { paddingLeft: 16, paddingRight: 16 },
      a.divider && {
        borderBottom: `1px solid ${(o.vars || o).palette.divider}`,
        backgroundClip: 'padding-box',
      },
      {
        '&:hover': {
          textDecoration: 'none',
          backgroundColor: (o.vars || o).palette.action.hover,
          '@media (hover: none)': { backgroundColor: 'transparent' },
        },
        [`&.${menuItemClasses.selected}`]: {
          backgroundColor: o.vars
            ? `rgba(${o.vars.palette.primary.mainChannel} / ${o.vars.palette.action.selectedOpacity})`
            : alpha_1(o.palette.primary.main, o.palette.action.selectedOpacity),
          [`&.${menuItemClasses.focusVisible}`]: {
            backgroundColor: o.vars
              ? `rgba(${o.vars.palette.primary.mainChannel} / calc(${o.vars.palette.action.selectedOpacity} + ${o.vars.palette.action.focusOpacity}))`
              : alpha_1(
                  o.palette.primary.main,
                  o.palette.action.selectedOpacity +
                    o.palette.action.focusOpacity
                ),
          },
        },
        [`&.${menuItemClasses.selected}:hover`]: {
          backgroundColor: o.vars
            ? `rgba(${o.vars.palette.primary.mainChannel} / calc(${o.vars.palette.action.selectedOpacity} + ${o.vars.palette.action.hoverOpacity}))`
            : alpha_1(
                o.palette.primary.main,
                o.palette.action.selectedOpacity + o.palette.action.hoverOpacity
              ),
          '@media (hover: none)': {
            backgroundColor: o.vars
              ? `rgba(${o.vars.palette.primary.mainChannel} / ${o.vars.palette.action.selectedOpacity})`
              : alpha_1(
                  o.palette.primary.main,
                  o.palette.action.selectedOpacity
                ),
          },
        },
        [`&.${menuItemClasses.focusVisible}`]: {
          backgroundColor: (o.vars || o).palette.action.focus,
        },
        [`&.${menuItemClasses.disabled}`]: {
          opacity: (o.vars || o).palette.action.disabledOpacity,
        },
        [`& + .${dividerClasses.root}`]: {
          marginTop: o.spacing(1),
          marginBottom: o.spacing(1),
        },
        [`& + .${dividerClasses.inset}`]: { marginLeft: 52 },
        [`& .${listItemTextClasses.root}`]: { marginTop: 0, marginBottom: 0 },
        [`& .${listItemTextClasses.inset}`]: { paddingLeft: 36 },
        [`& .${listItemIconClasses.root}`]: { minWidth: 36 },
      },
      !a.dense && { [o.breakpoints.up('sm')]: { minHeight: 'auto' } },
      a.dense &&
        _extends$5(
          { minHeight: 32, paddingTop: 4, paddingBottom: 4 },
          o.typography.body2,
          { [`& .${listItemIconClasses.root} svg`]: { fontSize: '1.25rem' } }
        )
    )
  ),
  MenuItem = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiMenuItem' }),
      {
        autoFocus: j = !1,
        component: _e = 'li',
        dense: et = !1,
        divider: tt = !1,
        disableGutters: rt = !1,
        focusVisibleClassName: nt,
        role: it = 'menuitem',
        tabIndex: ot,
        className: at,
      } = $,
      st = _objectWithoutPropertiesLoose$3($, _excluded$I),
      ut = reactExports.useContext(ListContext),
      ct = reactExports.useMemo(
        () => ({ dense: et || ut.dense || !1, disableGutters: rt }),
        [ut.dense, et, rt]
      ),
      dt = reactExports.useRef(null)
    useEnhancedEffect$1(() => {
      j && dt.current && dt.current.focus()
    }, [j])
    const ft = _extends$5({}, $, {
        dense: ct.dense,
        divider: tt,
        disableGutters: rt,
      }),
      mt = useUtilityClasses$C($),
      vt = useForkRef(dt, s)
    let yt
    return (
      $.disabled || (yt = ot !== void 0 ? ot : -1),
      jsxRuntimeExports.jsx(ListContext.Provider, {
        value: ct,
        children: jsxRuntimeExports.jsx(
          MenuItemRoot,
          _extends$5(
            {
              ref: vt,
              role: it,
              tabIndex: yt,
              component: _e,
              focusVisibleClassName: clsx$1(mt.focusVisible, nt),
              className: clsx$1(mt.root, at),
            },
            st,
            { ownerState: ft, classes: mt }
          )
        ),
      })
    )
  })
function getListUtilityClass(o) {
  return generateUtilityClass('MuiList', o)
}
generateUtilityClasses('MuiList', ['root', 'padding', 'dense', 'subheader'])
const _excluded$H = [
    'children',
    'className',
    'component',
    'dense',
    'disablePadding',
    'subheader',
  ],
  useUtilityClasses$B = o => {
    const { classes: a, disablePadding: s, dense: $, subheader: j } = o
    return composeClasses(
      { root: ['root', !s && 'padding', $ && 'dense', j && 'subheader'] },
      getListUtilityClass,
      a
    )
  },
  ListRoot = styled('ul', {
    name: 'MuiList',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        !s.disablePadding && a.padding,
        s.dense && a.dense,
        s.subheader && a.subheader,
      ]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      { listStyle: 'none', margin: 0, padding: 0, position: 'relative' },
      !o.disablePadding && { paddingTop: 8, paddingBottom: 8 },
      o.subheader && { paddingTop: 0 }
    )
  ),
  List$1 = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiList' }),
      {
        children: j,
        className: _e,
        component: et = 'ul',
        dense: tt = !1,
        disablePadding: rt = !1,
        subheader: nt,
      } = $,
      it = _objectWithoutPropertiesLoose$3($, _excluded$H),
      ot = reactExports.useMemo(() => ({ dense: tt }), [tt]),
      at = _extends$5({}, $, { component: et, dense: tt, disablePadding: rt }),
      st = useUtilityClasses$B(at)
    return jsxRuntimeExports.jsx(ListContext.Provider, {
      value: ot,
      children: jsxRuntimeExports.jsxs(
        ListRoot,
        _extends$5(
          { as: et, className: clsx$1(st.root, _e), ref: s, ownerState: at },
          it,
          { children: [nt, j] }
        )
      ),
    })
  }),
  _excluded$G = [
    'actions',
    'autoFocus',
    'autoFocusItem',
    'children',
    'className',
    'disabledItemsFocusable',
    'disableListWrap',
    'onKeyDown',
    'variant',
  ]
function nextItem$1(o, a, s) {
  return o === a
    ? o.firstChild
    : a && a.nextElementSibling
    ? a.nextElementSibling
    : s
    ? null
    : o.firstChild
}
function previousItem$1(o, a, s) {
  return o === a
    ? s
      ? o.firstChild
      : o.lastChild
    : a && a.previousElementSibling
    ? a.previousElementSibling
    : s
    ? null
    : o.lastChild
}
function textCriteriaMatches(o, a) {
  if (a === void 0) return !0
  let s = o.innerText
  return (
    s === void 0 && (s = o.textContent),
    (s = s.trim().toLowerCase()),
    s.length === 0
      ? !1
      : a.repeating
      ? s[0] === a.keys[0]
      : s.indexOf(a.keys.join('')) === 0
  )
}
function moveFocus$1(o, a, s, $, j, _e) {
  let et = !1,
    tt = j(o, a, a ? s : !1)
  for (; tt; ) {
    if (tt === o.firstChild) {
      if (et) return !1
      et = !0
    }
    const rt = $
      ? !1
      : tt.disabled || tt.getAttribute('aria-disabled') === 'true'
    if (!tt.hasAttribute('tabindex') || !textCriteriaMatches(tt, _e) || rt)
      tt = j(o, tt, s)
    else return tt.focus(), !0
  }
  return !1
}
const MenuList = reactExports.forwardRef(function o(a, s) {
  const {
      actions: $,
      autoFocus: j = !1,
      autoFocusItem: _e = !1,
      children: et,
      className: tt,
      disabledItemsFocusable: rt = !1,
      disableListWrap: nt = !1,
      onKeyDown: it,
      variant: ot = 'selectedMenu',
    } = a,
    at = _objectWithoutPropertiesLoose$3(a, _excluded$G),
    st = reactExports.useRef(null),
    ut = reactExports.useRef({
      keys: [],
      repeating: !0,
      previousKeyMatched: !0,
      lastTime: null,
    })
  useEnhancedEffect$1(() => {
    j && st.current.focus()
  }, [j]),
    reactExports.useImperativeHandle(
      $,
      () => ({
        adjustStyleForScrollbar: (vt, { direction: yt }) => {
          const pt = !st.current.style.width
          if (vt.clientHeight < st.current.clientHeight && pt) {
            const ht = `${getScrollbarSize(ownerDocument(vt))}px`
            ;(st.current.style[
              yt === 'rtl' ? 'paddingLeft' : 'paddingRight'
            ] = ht),
              (st.current.style.width = `calc(100% + ${ht})`)
          }
          return st.current
        },
      }),
      []
    )
  const ct = vt => {
      const yt = st.current,
        pt = vt.key,
        ht = ownerDocument(yt).activeElement
      if (pt === 'ArrowDown')
        vt.preventDefault(), moveFocus$1(yt, ht, nt, rt, nextItem$1)
      else if (pt === 'ArrowUp')
        vt.preventDefault(), moveFocus$1(yt, ht, nt, rt, previousItem$1)
      else if (pt === 'Home')
        vt.preventDefault(), moveFocus$1(yt, null, nt, rt, nextItem$1)
      else if (pt === 'End')
        vt.preventDefault(), moveFocus$1(yt, null, nt, rt, previousItem$1)
      else if (pt.length === 1) {
        const At = ut.current,
          wt = pt.toLowerCase(),
          Ct = performance.now()
        At.keys.length > 0 &&
          (Ct - At.lastTime > 500
            ? ((At.keys = []),
              (At.repeating = !0),
              (At.previousKeyMatched = !0))
            : At.repeating && wt !== At.keys[0] && (At.repeating = !1)),
          (At.lastTime = Ct),
          At.keys.push(wt)
        const Dt = ht && !At.repeating && textCriteriaMatches(ht, At)
        At.previousKeyMatched &&
        (Dt || moveFocus$1(yt, ht, !1, rt, nextItem$1, At))
          ? vt.preventDefault()
          : (At.previousKeyMatched = !1)
      }
      it && it(vt)
    },
    dt = useForkRef(st, s)
  let ft = -1
  reactExports.Children.forEach(et, (vt, yt) => {
    if (!reactExports.isValidElement(vt)) {
      ft === yt && ((ft += 1), ft >= et.length && (ft = -1))
      return
    }
    vt.props.disabled ||
      (((ot === 'selectedMenu' && vt.props.selected) || ft === -1) &&
        (ft = yt)),
      ft === yt &&
        (vt.props.disabled ||
          vt.props.muiSkipListHighlight ||
          vt.type.muiSkipListHighlight) &&
        ((ft += 1), ft >= et.length && (ft = -1))
  })
  const mt = reactExports.Children.map(et, (vt, yt) => {
    if (yt === ft) {
      const pt = {}
      return (
        _e && (pt.autoFocus = !0),
        vt.props.tabIndex === void 0 &&
          ot === 'selectedMenu' &&
          (pt.tabIndex = 0),
        reactExports.cloneElement(vt, pt)
      )
    }
    return vt
  })
  return jsxRuntimeExports.jsx(
    List$1,
    _extends$5(
      {
        role: 'menu',
        ref: dt,
        className: tt,
        onKeyDown: ct,
        tabIndex: j ? 0 : -1,
      },
      at,
      { children: mt }
    )
  )
})
function getPopoverUtilityClass(o) {
  return generateUtilityClass('MuiPopover', o)
}
generateUtilityClasses('MuiPopover', ['root', 'paper'])
const _excluded$F = ['onEntering'],
  _excluded2$3 = [
    'action',
    'anchorEl',
    'anchorOrigin',
    'anchorPosition',
    'anchorReference',
    'children',
    'className',
    'container',
    'elevation',
    'marginThreshold',
    'open',
    'PaperProps',
    'slots',
    'slotProps',
    'transformOrigin',
    'TransitionComponent',
    'transitionDuration',
    'TransitionProps',
    'disableScrollLock',
  ],
  _excluded3$1 = ['slotProps']
function getOffsetTop(o, a) {
  let s = 0
  return (
    typeof a == 'number'
      ? (s = a)
      : a === 'center'
      ? (s = o.height / 2)
      : a === 'bottom' && (s = o.height),
    s
  )
}
function getOffsetLeft(o, a) {
  let s = 0
  return (
    typeof a == 'number'
      ? (s = a)
      : a === 'center'
      ? (s = o.width / 2)
      : a === 'right' && (s = o.width),
    s
  )
}
function getTransformOriginValue(o) {
  return [o.horizontal, o.vertical]
    .map(a => (typeof a == 'number' ? `${a}px` : a))
    .join(' ')
}
function resolveAnchorEl(o) {
  return typeof o == 'function' ? o() : o
}
const useUtilityClasses$A = o => {
    const { classes: a } = o
    return composeClasses(
      { root: ['root'], paper: ['paper'] },
      getPopoverUtilityClass,
      a
    )
  },
  PopoverRoot = styled(Modal, {
    name: 'MuiPopover',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({}),
  PopoverPaper = styled(Paper, {
    name: 'MuiPopover',
    slot: 'Paper',
    overridesResolver: (o, a) => a.paper,
  })({
    position: 'absolute',
    overflowY: 'auto',
    overflowX: 'hidden',
    minWidth: 16,
    minHeight: 16,
    maxWidth: 'calc(100% - 32px)',
    maxHeight: 'calc(100% - 32px)',
    outline: 0,
  }),
  Popover = reactExports.forwardRef(function o(a, s) {
    var $, j, _e
    const et = useDefaultProps({ props: a, name: 'MuiPopover' }),
      {
        action: tt,
        anchorEl: rt,
        anchorOrigin: nt = { vertical: 'top', horizontal: 'left' },
        anchorPosition: it,
        anchorReference: ot = 'anchorEl',
        children: at,
        className: st,
        container: ut,
        elevation: ct = 8,
        marginThreshold: dt = 16,
        open: ft,
        PaperProps: mt = {},
        slots: vt,
        slotProps: yt,
        transformOrigin: pt = { vertical: 'top', horizontal: 'left' },
        TransitionComponent: ht = Grow,
        transitionDuration: At = 'auto',
        TransitionProps: { onEntering: wt } = {},
        disableScrollLock: Ct = !1,
      } = et,
      Dt = _objectWithoutPropertiesLoose$3(et.TransitionProps, _excluded$F),
      jt = _objectWithoutPropertiesLoose$3(et, _excluded2$3),
      Et = ($ = yt == null ? void 0 : yt.paper) != null ? $ : mt,
      St = reactExports.useRef(),
      Bt = useForkRef(St, Et.ref),
      Mt = _extends$5({}, et, {
        anchorOrigin: nt,
        anchorReference: ot,
        elevation: ct,
        marginThreshold: dt,
        externalPaperSlotProps: Et,
        transformOrigin: pt,
        TransitionComponent: ht,
        transitionDuration: At,
        TransitionProps: Dt,
      }),
      Ut = useUtilityClasses$A(Mt),
      Wt = reactExports.useCallback(() => {
        if (ot === 'anchorPosition') return it
        const Lt = resolveAnchorEl(rt),
          lr = (Lt && Lt.nodeType === 1
            ? Lt
            : ownerDocument(St.current).body
          ).getBoundingClientRect()
        return {
          top: lr.top + getOffsetTop(lr, nt.vertical),
          left: lr.left + getOffsetLeft(lr, nt.horizontal),
        }
      }, [rt, nt.horizontal, nt.vertical, it, ot]),
      Tt = reactExports.useCallback(
        Lt => ({
          vertical: getOffsetTop(Lt, pt.vertical),
          horizontal: getOffsetLeft(Lt, pt.horizontal),
        }),
        [pt.horizontal, pt.vertical]
      ),
      kt = reactExports.useCallback(
        Lt => {
          const tr = { width: Lt.offsetWidth, height: Lt.offsetHeight },
            lr = Tt(tr)
          if (ot === 'none')
            return {
              top: null,
              left: null,
              transformOrigin: getTransformOriginValue(lr),
            }
          const yr = Wt()
          let mr = yr.top - lr.vertical,
            Er = yr.left - lr.horizontal
          const ur = mr + tr.height,
            _r = Er + tr.width,
            Rr = ownerWindow(resolveAnchorEl(rt)),
            nr = Rr.innerHeight - dt,
            fr = Rr.innerWidth - dt
          if (dt !== null && mr < dt) {
            const gr = mr - dt
            ;(mr -= gr), (lr.vertical += gr)
          } else if (dt !== null && ur > nr) {
            const gr = ur - nr
            ;(mr -= gr), (lr.vertical += gr)
          }
          if (dt !== null && Er < dt) {
            const gr = Er - dt
            ;(Er -= gr), (lr.horizontal += gr)
          } else if (_r > fr) {
            const gr = _r - fr
            ;(Er -= gr), (lr.horizontal += gr)
          }
          return {
            top: `${Math.round(mr)}px`,
            left: `${Math.round(Er)}px`,
            transformOrigin: getTransformOriginValue(lr),
          }
        },
        [rt, ot, Wt, Tt, dt]
      ),
      [Ot, Nt] = reactExports.useState(ft),
      $t = reactExports.useCallback(() => {
        const Lt = St.current
        if (!Lt) return
        const tr = kt(Lt)
        tr.top !== null && (Lt.style.top = tr.top),
          tr.left !== null && (Lt.style.left = tr.left),
          (Lt.style.transformOrigin = tr.transformOrigin),
          Nt(!0)
      }, [kt])
    reactExports.useEffect(
      () => (
        Ct && window.addEventListener('scroll', $t),
        () => window.removeEventListener('scroll', $t)
      ),
      [rt, Ct, $t]
    )
    const Pt = (Lt, tr) => {
        wt && wt(Lt, tr), $t()
      },
      Ft = () => {
        Nt(!1)
      }
    reactExports.useEffect(() => {
      ft && $t()
    }),
      reactExports.useImperativeHandle(
        tt,
        () =>
          ft
            ? {
                updatePosition: () => {
                  $t()
                },
              }
            : null,
        [ft, $t]
      ),
      reactExports.useEffect(() => {
        if (!ft) return
        const Lt = debounce$4(() => {
            $t()
          }),
          tr = ownerWindow(rt)
        return (
          tr.addEventListener('resize', Lt),
          () => {
            Lt.clear(), tr.removeEventListener('resize', Lt)
          }
        )
      }, [rt, ft, $t])
    let Vt = At
    At === 'auto' && !ht.muiSupportAuto && (Vt = void 0)
    const Xt = ut || (rt ? ownerDocument(resolveAnchorEl(rt)).body : void 0),
      Yt = (j = vt == null ? void 0 : vt.root) != null ? j : PopoverRoot,
      xt = (_e = vt == null ? void 0 : vt.paper) != null ? _e : PopoverPaper,
      It = useSlotProps({
        elementType: xt,
        externalSlotProps: _extends$5({}, Et, {
          style: Ot ? Et.style : _extends$5({}, Et.style, { opacity: 0 }),
        }),
        additionalProps: { elevation: ct, ref: Bt },
        ownerState: Mt,
        className: clsx$1(Ut.paper, Et == null ? void 0 : Et.className),
      }),
      Kt = useSlotProps({
        elementType: Yt,
        externalSlotProps: (yt == null ? void 0 : yt.root) || {},
        externalForwardedProps: jt,
        additionalProps: {
          ref: s,
          slotProps: { backdrop: { invisible: !0 } },
          container: Xt,
          open: ft,
        },
        ownerState: Mt,
        className: clsx$1(Ut.root, st),
      }),
      { slotProps: Qt } = Kt,
      Ht = _objectWithoutPropertiesLoose$3(Kt, _excluded3$1)
    return jsxRuntimeExports.jsx(
      Yt,
      _extends$5(
        {},
        Ht,
        !isHostComponent(Yt) && { slotProps: Qt, disableScrollLock: Ct },
        {
          children: jsxRuntimeExports.jsx(
            ht,
            _extends$5(
              { appear: !0, in: ft, onEntering: Pt, onExited: Ft, timeout: Vt },
              Dt,
              {
                children: jsxRuntimeExports.jsx(
                  xt,
                  _extends$5({}, It, { children: at })
                ),
              }
            )
          ),
        }
      )
    )
  })
function getMenuUtilityClass(o) {
  return generateUtilityClass('MuiMenu', o)
}
generateUtilityClasses('MuiMenu', ['root', 'paper', 'list'])
const _excluded$E = ['onEntering'],
  _excluded2$2 = [
    'autoFocus',
    'children',
    'className',
    'disableAutoFocusItem',
    'MenuListProps',
    'onClose',
    'open',
    'PaperProps',
    'PopoverClasses',
    'transitionDuration',
    'TransitionProps',
    'variant',
    'slots',
    'slotProps',
  ],
  RTL_ORIGIN = { vertical: 'top', horizontal: 'right' },
  LTR_ORIGIN = { vertical: 'top', horizontal: 'left' },
  useUtilityClasses$z = o => {
    const { classes: a } = o
    return composeClasses(
      { root: ['root'], paper: ['paper'], list: ['list'] },
      getMenuUtilityClass,
      a
    )
  },
  MenuRoot = styled(Popover, {
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    name: 'MuiMenu',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({}),
  MenuPaper = styled(PopoverPaper, {
    name: 'MuiMenu',
    slot: 'Paper',
    overridesResolver: (o, a) => a.paper,
  })({ maxHeight: 'calc(100% - 96px)', WebkitOverflowScrolling: 'touch' }),
  MenuMenuList = styled(MenuList, {
    name: 'MuiMenu',
    slot: 'List',
    overridesResolver: (o, a) => a.list,
  })({ outline: 0 }),
  Menu = reactExports.forwardRef(function o(a, s) {
    var $, j
    const _e = useDefaultProps({ props: a, name: 'MuiMenu' }),
      {
        autoFocus: et = !0,
        children: tt,
        className: rt,
        disableAutoFocusItem: nt = !1,
        MenuListProps: it = {},
        onClose: ot,
        open: at,
        PaperProps: st = {},
        PopoverClasses: ut,
        transitionDuration: ct = 'auto',
        TransitionProps: { onEntering: dt } = {},
        variant: ft = 'selectedMenu',
        slots: mt = {},
        slotProps: vt = {},
      } = _e,
      yt = _objectWithoutPropertiesLoose$3(_e.TransitionProps, _excluded$E),
      pt = _objectWithoutPropertiesLoose$3(_e, _excluded2$2),
      ht = useRtl(),
      At = _extends$5({}, _e, {
        autoFocus: et,
        disableAutoFocusItem: nt,
        MenuListProps: it,
        onEntering: dt,
        PaperProps: st,
        transitionDuration: ct,
        TransitionProps: yt,
        variant: ft,
      }),
      wt = useUtilityClasses$z(At),
      Ct = et && !nt && at,
      Dt = reactExports.useRef(null),
      jt = (Tt, kt) => {
        Dt.current &&
          Dt.current.adjustStyleForScrollbar(Tt, {
            direction: ht ? 'rtl' : 'ltr',
          }),
          dt && dt(Tt, kt)
      },
      Et = Tt => {
        Tt.key === 'Tab' && (Tt.preventDefault(), ot && ot(Tt, 'tabKeyDown'))
      }
    let St = -1
    reactExports.Children.map(tt, (Tt, kt) => {
      reactExports.isValidElement(Tt) &&
        (Tt.props.disabled ||
          (((ft === 'selectedMenu' && Tt.props.selected) || St === -1) &&
            (St = kt)))
    })
    const Bt = ($ = mt.paper) != null ? $ : MenuPaper,
      Mt = (j = vt.paper) != null ? j : st,
      Ut = useSlotProps({
        elementType: mt.root,
        externalSlotProps: vt.root,
        ownerState: At,
        className: [wt.root, rt],
      }),
      Wt = useSlotProps({
        elementType: Bt,
        externalSlotProps: Mt,
        ownerState: At,
        className: wt.paper,
      })
    return jsxRuntimeExports.jsx(
      MenuRoot,
      _extends$5(
        {
          onClose: ot,
          anchorOrigin: {
            vertical: 'bottom',
            horizontal: ht ? 'right' : 'left',
          },
          transformOrigin: ht ? RTL_ORIGIN : LTR_ORIGIN,
          slots: { paper: Bt, root: mt.root },
          slotProps: { root: Ut, paper: Wt },
          open: at,
          ref: s,
          transitionDuration: ct,
          TransitionProps: _extends$5({ onEntering: jt }, yt),
          ownerState: At,
        },
        pt,
        {
          classes: ut,
          children: jsxRuntimeExports.jsx(
            MenuMenuList,
            _extends$5(
              {
                onKeyDown: Et,
                actions: Dt,
                autoFocus: et && (St === -1 || nt),
                autoFocusItem: Ct,
                variant: ft,
              },
              it,
              { className: clsx$1(wt.list, it.className), children: tt }
            )
          ),
        }
      )
    )
  })
function getNativeSelectUtilityClasses(o) {
  return generateUtilityClass('MuiNativeSelect', o)
}
const nativeSelectClasses = generateUtilityClasses('MuiNativeSelect', [
    'root',
    'select',
    'multiple',
    'filled',
    'outlined',
    'standard',
    'disabled',
    'icon',
    'iconOpen',
    'iconFilled',
    'iconOutlined',
    'iconStandard',
    'nativeInput',
    'error',
  ]),
  _excluded$D = [
    'className',
    'disabled',
    'error',
    'IconComponent',
    'inputRef',
    'variant',
  ],
  useUtilityClasses$y = o => {
    const {
        classes: a,
        variant: s,
        disabled: $,
        multiple: j,
        open: _e,
        error: et,
      } = o,
      tt = {
        select: ['select', s, $ && 'disabled', j && 'multiple', et && 'error'],
        icon: [
          'icon',
          `icon${capitalize$2(s)}`,
          _e && 'iconOpen',
          $ && 'disabled',
        ],
      }
    return composeClasses(tt, getNativeSelectUtilityClasses, a)
  },
  nativeSelectSelectStyles = ({ ownerState: o, theme: a }) =>
    _extends$5(
      {
        MozAppearance: 'none',
        WebkitAppearance: 'none',
        userSelect: 'none',
        borderRadius: 0,
        cursor: 'pointer',
        '&:focus': _extends$5(
          {},
          a.vars
            ? {
                backgroundColor: `rgba(${a.vars.palette.common.onBackgroundChannel} / 0.05)`,
              }
            : {
                backgroundColor:
                  a.palette.mode === 'light'
                    ? 'rgba(0, 0, 0, 0.05)'
                    : 'rgba(255, 255, 255, 0.05)',
              },
          { borderRadius: 0 }
        ),
        '&::-ms-expand': { display: 'none' },
        [`&.${nativeSelectClasses.disabled}`]: { cursor: 'default' },
        '&[multiple]': { height: 'auto' },
        '&:not([multiple]) option, &:not([multiple]) optgroup': {
          backgroundColor: (a.vars || a).palette.background.paper,
        },
        '&&&': { paddingRight: 24, minWidth: 16 },
      },
      o.variant === 'filled' && { '&&&': { paddingRight: 32 } },
      o.variant === 'outlined' && {
        borderRadius: (a.vars || a).shape.borderRadius,
        '&:focus': { borderRadius: (a.vars || a).shape.borderRadius },
        '&&&': { paddingRight: 32 },
      }
    ),
  NativeSelectSelect = styled('select', {
    name: 'MuiNativeSelect',
    slot: 'Select',
    shouldForwardProp: rootShouldForwardProp,
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.select,
        a[s.variant],
        s.error && a.error,
        { [`&.${nativeSelectClasses.multiple}`]: a.multiple },
      ]
    },
  })(nativeSelectSelectStyles),
  nativeSelectIconStyles = ({ ownerState: o, theme: a }) =>
    _extends$5(
      {
        position: 'absolute',
        right: 0,
        top: 'calc(50% - .5em)',
        pointerEvents: 'none',
        color: (a.vars || a).palette.action.active,
        [`&.${nativeSelectClasses.disabled}`]: {
          color: (a.vars || a).palette.action.disabled,
        },
      },
      o.open && { transform: 'rotate(180deg)' },
      o.variant === 'filled' && { right: 7 },
      o.variant === 'outlined' && { right: 7 }
    ),
  NativeSelectIcon = styled('svg', {
    name: 'MuiNativeSelect',
    slot: 'Icon',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.icon,
        s.variant && a[`icon${capitalize$2(s.variant)}`],
        s.open && a.iconOpen,
      ]
    },
  })(nativeSelectIconStyles),
  NativeSelectInput = reactExports.forwardRef(function o(a, s) {
    const {
        className: $,
        disabled: j,
        error: _e,
        IconComponent: et,
        inputRef: tt,
        variant: rt = 'standard',
      } = a,
      nt = _objectWithoutPropertiesLoose$3(a, _excluded$D),
      it = _extends$5({}, a, { disabled: j, variant: rt, error: _e }),
      ot = useUtilityClasses$y(it)
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [
        jsxRuntimeExports.jsx(
          NativeSelectSelect,
          _extends$5(
            {
              ownerState: it,
              className: clsx$1(ot.select, $),
              disabled: j,
              ref: tt || s,
            },
            nt
          )
        ),
        a.multiple
          ? null
          : jsxRuntimeExports.jsx(NativeSelectIcon, {
              as: et,
              ownerState: it,
              className: ot.icon,
            }),
      ],
    })
  })
function getSelectUtilityClasses(o) {
  return generateUtilityClass('MuiSelect', o)
}
const selectClasses = generateUtilityClasses('MuiSelect', [
  'root',
  'select',
  'multiple',
  'filled',
  'outlined',
  'standard',
  'disabled',
  'focused',
  'icon',
  'iconOpen',
  'iconFilled',
  'iconOutlined',
  'iconStandard',
  'nativeInput',
  'error',
])
var _span$2
const _excluded$C = [
    'aria-describedby',
    'aria-label',
    'autoFocus',
    'autoWidth',
    'children',
    'className',
    'defaultOpen',
    'defaultValue',
    'disabled',
    'displayEmpty',
    'error',
    'IconComponent',
    'inputRef',
    'labelId',
    'MenuProps',
    'multiple',
    'name',
    'onBlur',
    'onChange',
    'onClose',
    'onFocus',
    'onOpen',
    'open',
    'readOnly',
    'renderValue',
    'SelectDisplayProps',
    'tabIndex',
    'type',
    'value',
    'variant',
  ],
  SelectSelect = styled('div', {
    name: 'MuiSelect',
    slot: 'Select',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        { [`&.${selectClasses.select}`]: a.select },
        { [`&.${selectClasses.select}`]: a[s.variant] },
        { [`&.${selectClasses.error}`]: a.error },
        { [`&.${selectClasses.multiple}`]: a.multiple },
      ]
    },
  })(nativeSelectSelectStyles, {
    [`&.${selectClasses.select}`]: {
      height: 'auto',
      minHeight: '1.4375em',
      textOverflow: 'ellipsis',
      whiteSpace: 'nowrap',
      overflow: 'hidden',
    },
  }),
  SelectIcon = styled('svg', {
    name: 'MuiSelect',
    slot: 'Icon',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.icon,
        s.variant && a[`icon${capitalize$2(s.variant)}`],
        s.open && a.iconOpen,
      ]
    },
  })(nativeSelectIconStyles),
  SelectNativeInput = styled('input', {
    shouldForwardProp: o => slotShouldForwardProp(o) && o !== 'classes',
    name: 'MuiSelect',
    slot: 'NativeInput',
    overridesResolver: (o, a) => a.nativeInput,
  })({
    bottom: 0,
    left: 0,
    position: 'absolute',
    opacity: 0,
    pointerEvents: 'none',
    width: '100%',
    boxSizing: 'border-box',
  })
function areEqualValues(o, a) {
  return typeof a == 'object' && a !== null ? o === a : String(o) === String(a)
}
function isEmpty$1(o) {
  return o == null || (typeof o == 'string' && !o.trim())
}
const useUtilityClasses$x = o => {
    const {
        classes: a,
        variant: s,
        disabled: $,
        multiple: j,
        open: _e,
        error: et,
      } = o,
      tt = {
        select: ['select', s, $ && 'disabled', j && 'multiple', et && 'error'],
        icon: [
          'icon',
          `icon${capitalize$2(s)}`,
          _e && 'iconOpen',
          $ && 'disabled',
        ],
        nativeInput: ['nativeInput'],
      }
    return composeClasses(tt, getSelectUtilityClasses, a)
  },
  SelectInput = reactExports.forwardRef(function o(a, s) {
    var $
    const {
        'aria-describedby': j,
        'aria-label': _e,
        autoFocus: et,
        autoWidth: tt,
        children: rt,
        className: nt,
        defaultOpen: it,
        defaultValue: ot,
        disabled: at,
        displayEmpty: st,
        error: ut = !1,
        IconComponent: ct,
        inputRef: dt,
        labelId: ft,
        MenuProps: mt = {},
        multiple: vt,
        name: yt,
        onBlur: pt,
        onChange: ht,
        onClose: At,
        onFocus: wt,
        onOpen: Ct,
        open: Dt,
        readOnly: jt,
        renderValue: Et,
        SelectDisplayProps: St = {},
        tabIndex: Bt,
        value: Mt,
        variant: Ut = 'standard',
      } = a,
      Wt = _objectWithoutPropertiesLoose$3(a, _excluded$C),
      [Tt, kt] = useControlled({ controlled: Mt, default: ot, name: 'Select' }),
      [Ot, Nt] = useControlled({ controlled: Dt, default: it, name: 'Select' }),
      $t = reactExports.useRef(null),
      Pt = reactExports.useRef(null),
      [Ft, Vt] = reactExports.useState(null),
      { current: Xt } = reactExports.useRef(Dt != null),
      [Yt, xt] = reactExports.useState(),
      It = useForkRef(s, dt),
      Kt = reactExports.useCallback(ir => {
        ;(Pt.current = ir), ir && Vt(ir)
      }, []),
      Qt = Ft == null ? void 0 : Ft.parentNode
    reactExports.useImperativeHandle(
      It,
      () => ({
        focus: () => {
          Pt.current.focus()
        },
        node: $t.current,
        value: Tt,
      }),
      [Tt]
    ),
      reactExports.useEffect(() => {
        it &&
          Ot &&
          Ft &&
          !Xt &&
          (xt(tt ? null : Qt.clientWidth), Pt.current.focus())
      }, [Ft, tt]),
      reactExports.useEffect(() => {
        et && Pt.current.focus()
      }, [et]),
      reactExports.useEffect(() => {
        if (!ft) return
        const ir = ownerDocument(Pt.current).getElementById(ft)
        if (ir) {
          const Tr = () => {
            getSelection().isCollapsed && Pt.current.focus()
          }
          return (
            ir.addEventListener('click', Tr),
            () => {
              ir.removeEventListener('click', Tr)
            }
          )
        }
      }, [ft])
    const Ht = (ir, Tr) => {
        ir ? Ct && Ct(Tr) : At && At(Tr),
          Xt || (xt(tt ? null : Qt.clientWidth), Nt(ir))
      },
      Lt = ir => {
        ir.button === 0 && (ir.preventDefault(), Pt.current.focus(), Ht(!0, ir))
      },
      tr = ir => {
        Ht(!1, ir)
      },
      lr = reactExports.Children.toArray(rt),
      yr = ir => {
        const Tr = lr.find(vr => vr.props.value === ir.target.value)
        Tr !== void 0 && (kt(Tr.props.value), ht && ht(ir, Tr))
      },
      mr = ir => Tr => {
        let vr
        if (Tr.currentTarget.hasAttribute('tabindex')) {
          if (vt) {
            vr = Array.isArray(Tt) ? Tt.slice() : []
            const Ar = Tt.indexOf(ir.props.value)
            Ar === -1 ? vr.push(ir.props.value) : vr.splice(Ar, 1)
          } else vr = ir.props.value
          if (
            (ir.props.onClick && ir.props.onClick(Tr),
            Tt !== vr && (kt(vr), ht))
          ) {
            const Ar = Tr.nativeEvent || Tr,
              Nr = new Ar.constructor(Ar.type, Ar)
            Object.defineProperty(Nr, 'target', {
              writable: !0,
              value: { value: vr, name: yt },
            }),
              ht(Nr, ir)
          }
          vt || Ht(!1, Tr)
        }
      },
      Er = ir => {
        jt ||
          ([' ', 'ArrowUp', 'ArrowDown', 'Enter'].indexOf(ir.key) !== -1 &&
            (ir.preventDefault(), Ht(!0, ir)))
      },
      ur = Ft !== null && Ot,
      _r = ir => {
        !ur &&
          pt &&
          (Object.defineProperty(ir, 'target', {
            writable: !0,
            value: { value: Tt, name: yt },
          }),
          pt(ir))
      }
    delete Wt['aria-invalid']
    let Rr, nr
    const fr = []
    let gr = !1
    ;(isFilled({ value: Tt }) || st) && (Et ? (Rr = Et(Tt)) : (gr = !0))
    const br = lr.map(ir => {
      if (!reactExports.isValidElement(ir)) return null
      let Tr
      if (vt) {
        if (!Array.isArray(Tt)) throw new Error(formatMuiErrorMessage$1(2))
        ;(Tr = Tt.some(vr => areEqualValues(vr, ir.props.value))),
          Tr && gr && fr.push(ir.props.children)
      } else
        (Tr = areEqualValues(Tt, ir.props.value)),
          Tr && gr && (nr = ir.props.children)
      return reactExports.cloneElement(ir, {
        'aria-selected': Tr ? 'true' : 'false',
        onClick: mr(ir),
        onKeyUp: vr => {
          vr.key === ' ' && vr.preventDefault(),
            ir.props.onKeyUp && ir.props.onKeyUp(vr)
        },
        role: 'option',
        selected: Tr,
        value: void 0,
        'data-value': ir.props.value,
      })
    })
    gr &&
      (vt
        ? fr.length === 0
          ? (Rr = null)
          : (Rr = fr.reduce(
              (ir, Tr, vr) => (
                ir.push(Tr), vr < fr.length - 1 && ir.push(', '), ir
              ),
              []
            ))
        : (Rr = nr))
    let Sr = Yt
    !tt && Xt && Ft && (Sr = Qt.clientWidth)
    let zt
    typeof Bt < 'u' ? (zt = Bt) : (zt = at ? null : 0)
    const bt = St.id || (yt ? `mui-component-select-${yt}` : void 0),
      Rt = _extends$5({}, a, { variant: Ut, value: Tt, open: ur, error: ut }),
      qt = useUtilityClasses$x(Rt),
      rr = _extends$5(
        {},
        mt.PaperProps,
        ($ = mt.slotProps) == null ? void 0 : $.paper
      ),
      ar = useId()
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
      children: [
        jsxRuntimeExports.jsx(
          SelectSelect,
          _extends$5(
            {
              ref: Kt,
              tabIndex: zt,
              role: 'combobox',
              'aria-controls': ar,
              'aria-disabled': at ? 'true' : void 0,
              'aria-expanded': ur ? 'true' : 'false',
              'aria-haspopup': 'listbox',
              'aria-label': _e,
              'aria-labelledby': [ft, bt].filter(Boolean).join(' ') || void 0,
              'aria-describedby': j,
              onKeyDown: Er,
              onMouseDown: at || jt ? null : Lt,
              onBlur: _r,
              onFocus: wt,
            },
            St,
            {
              ownerState: Rt,
              className: clsx$1(St.className, qt.select, nt),
              id: bt,
              children: isEmpty$1(Rr)
                ? _span$2 ||
                  (_span$2 = jsxRuntimeExports.jsx('span', {
                    className: 'notranslate',
                    children: '',
                  }))
                : Rr,
            }
          )
        ),
        jsxRuntimeExports.jsx(
          SelectNativeInput,
          _extends$5(
            {
              'aria-invalid': ut,
              value: Array.isArray(Tt) ? Tt.join(',') : Tt,
              name: yt,
              ref: $t,
              'aria-hidden': !0,
              onChange: yr,
              tabIndex: -1,
              disabled: at,
              className: qt.nativeInput,
              autoFocus: et,
              ownerState: Rt,
            },
            Wt
          )
        ),
        jsxRuntimeExports.jsx(SelectIcon, {
          as: ct,
          className: qt.icon,
          ownerState: Rt,
        }),
        jsxRuntimeExports.jsx(
          Menu,
          _extends$5(
            {
              id: `menu-${yt || ''}`,
              anchorEl: Qt,
              open: ur,
              onClose: tr,
              anchorOrigin: { vertical: 'bottom', horizontal: 'center' },
              transformOrigin: { vertical: 'top', horizontal: 'center' },
            },
            mt,
            {
              MenuListProps: _extends$5(
                {
                  'aria-labelledby': ft,
                  role: 'listbox',
                  'aria-multiselectable': vt ? 'true' : void 0,
                  disableListWrap: !0,
                  id: ar,
                },
                mt.MenuListProps
              ),
              slotProps: _extends$5({}, mt.slotProps, {
                paper: _extends$5({}, rr, {
                  style: _extends$5(
                    { minWidth: Sr },
                    rr != null ? rr.style : null
                  ),
                }),
              }),
              children: br,
            }
          )
        ),
      ],
    })
  }),
  ArrowDropDownIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', { d: 'M7 10l5 5 5-5z' }),
    'ArrowDropDown'
  ),
  _excluded$B = ['onChange', 'maxRows', 'minRows', 'style', 'value']
function getStyleValue(o) {
  return parseInt(o, 10) || 0
}
const styles$3 = {
  shadow: {
    visibility: 'hidden',
    position: 'absolute',
    overflow: 'hidden',
    height: 0,
    top: 0,
    left: 0,
    transform: 'translateZ(0)',
  },
}
function isEmpty(o) {
  return (
    o == null ||
    Object.keys(o).length === 0 ||
    (o.outerHeightStyle === 0 && !o.overflowing)
  )
}
const TextareaAutosize = reactExports.forwardRef(function o(a, s) {
  const { onChange: $, maxRows: j, minRows: _e = 1, style: et, value: tt } = a,
    rt = _objectWithoutPropertiesLoose$3(a, _excluded$B),
    { current: nt } = reactExports.useRef(tt != null),
    it = reactExports.useRef(null),
    ot = useForkRef(s, it),
    at = reactExports.useRef(null),
    st = reactExports.useRef(null),
    ut = reactExports.useCallback(() => {
      const ft = it.current,
        vt = ownerWindow(ft).getComputedStyle(ft)
      if (vt.width === '0px') return { outerHeightStyle: 0, overflowing: !1 }
      const yt = st.current
      ;(yt.style.width = vt.width),
        (yt.value = ft.value || a.placeholder || 'x'),
        yt.value.slice(-1) ===
          `
` && (yt.value += ' ')
      const pt = vt.boxSizing,
        ht = getStyleValue(vt.paddingBottom) + getStyleValue(vt.paddingTop),
        At =
          getStyleValue(vt.borderBottomWidth) +
          getStyleValue(vt.borderTopWidth),
        wt = yt.scrollHeight
      yt.value = 'x'
      const Ct = yt.scrollHeight
      let Dt = wt
      _e && (Dt = Math.max(Number(_e) * Ct, Dt)),
        j && (Dt = Math.min(Number(j) * Ct, Dt)),
        (Dt = Math.max(Dt, Ct))
      const jt = Dt + (pt === 'border-box' ? ht + At : 0),
        Et = Math.abs(Dt - wt) <= 1
      return { outerHeightStyle: jt, overflowing: Et }
    }, [j, _e, a.placeholder]),
    ct = reactExports.useCallback(() => {
      const ft = ut()
      if (isEmpty(ft)) return
      const mt = ft.outerHeightStyle,
        vt = it.current
      at.current !== mt && ((at.current = mt), (vt.style.height = `${mt}px`)),
        (vt.style.overflow = ft.overflowing ? 'hidden' : '')
    }, [ut])
  useEnhancedEffect$1(() => {
    const ft = () => {
      ct()
    }
    let mt
    const vt = debounce$4(ft),
      yt = it.current,
      pt = ownerWindow(yt)
    pt.addEventListener('resize', vt)
    let ht
    return (
      typeof ResizeObserver < 'u' &&
        ((ht = new ResizeObserver(ft)), ht.observe(yt)),
      () => {
        vt.clear(),
          cancelAnimationFrame(mt),
          pt.removeEventListener('resize', vt),
          ht && ht.disconnect()
      }
    )
  }, [ut, ct]),
    useEnhancedEffect$1(() => {
      ct()
    })
  const dt = ft => {
    nt || ct(), $ && $(ft)
  }
  return jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [
      jsxRuntimeExports.jsx(
        'textarea',
        _extends$5(
          { value: tt, onChange: dt, ref: ot, rows: _e, style: et },
          rt
        )
      ),
      jsxRuntimeExports.jsx('textarea', {
        'aria-hidden': !0,
        className: a.className,
        readOnly: !0,
        ref: st,
        tabIndex: -1,
        style: _extends$5({}, styles$3.shadow, et, {
          paddingTop: 0,
          paddingBottom: 0,
        }),
      }),
    ],
  })
})
function GlobalStyles(o) {
  return jsxRuntimeExports.jsx(
    GlobalStyles$1,
    _extends$5({}, o, { defaultTheme: defaultTheme$1, themeId: THEME_ID })
  )
}
function getInputBaseUtilityClass(o) {
  return generateUtilityClass('MuiInputBase', o)
}
const inputBaseClasses = generateUtilityClasses('MuiInputBase', [
    'root',
    'formControl',
    'focused',
    'disabled',
    'adornedStart',
    'adornedEnd',
    'error',
    'sizeSmall',
    'multiline',
    'colorSecondary',
    'fullWidth',
    'hiddenLabel',
    'readOnly',
    'input',
    'inputSizeSmall',
    'inputMultiline',
    'inputTypeSearch',
    'inputAdornedStart',
    'inputAdornedEnd',
    'inputHiddenLabel',
  ]),
  _excluded$A = [
    'aria-describedby',
    'autoComplete',
    'autoFocus',
    'className',
    'color',
    'components',
    'componentsProps',
    'defaultValue',
    'disabled',
    'disableInjectingGlobalStyles',
    'endAdornment',
    'error',
    'fullWidth',
    'id',
    'inputComponent',
    'inputProps',
    'inputRef',
    'margin',
    'maxRows',
    'minRows',
    'multiline',
    'name',
    'onBlur',
    'onChange',
    'onClick',
    'onFocus',
    'onKeyDown',
    'onKeyUp',
    'placeholder',
    'readOnly',
    'renderSuffix',
    'rows',
    'size',
    'slotProps',
    'slots',
    'startAdornment',
    'type',
    'value',
  ],
  rootOverridesResolver = (o, a) => {
    const { ownerState: s } = o
    return [
      a.root,
      s.formControl && a.formControl,
      s.startAdornment && a.adornedStart,
      s.endAdornment && a.adornedEnd,
      s.error && a.error,
      s.size === 'small' && a.sizeSmall,
      s.multiline && a.multiline,
      s.color && a[`color${capitalize$2(s.color)}`],
      s.fullWidth && a.fullWidth,
      s.hiddenLabel && a.hiddenLabel,
    ]
  },
  inputOverridesResolver = (o, a) => {
    const { ownerState: s } = o
    return [
      a.input,
      s.size === 'small' && a.inputSizeSmall,
      s.multiline && a.inputMultiline,
      s.type === 'search' && a.inputTypeSearch,
      s.startAdornment && a.inputAdornedStart,
      s.endAdornment && a.inputAdornedEnd,
      s.hiddenLabel && a.inputHiddenLabel,
    ]
  },
  useUtilityClasses$w = o => {
    const {
        classes: a,
        color: s,
        disabled: $,
        error: j,
        endAdornment: _e,
        focused: et,
        formControl: tt,
        fullWidth: rt,
        hiddenLabel: nt,
        multiline: it,
        readOnly: ot,
        size: at,
        startAdornment: st,
        type: ut,
      } = o,
      ct = {
        root: [
          'root',
          `color${capitalize$2(s)}`,
          $ && 'disabled',
          j && 'error',
          rt && 'fullWidth',
          et && 'focused',
          tt && 'formControl',
          at && at !== 'medium' && `size${capitalize$2(at)}`,
          it && 'multiline',
          st && 'adornedStart',
          _e && 'adornedEnd',
          nt && 'hiddenLabel',
          ot && 'readOnly',
        ],
        input: [
          'input',
          $ && 'disabled',
          ut === 'search' && 'inputTypeSearch',
          it && 'inputMultiline',
          at === 'small' && 'inputSizeSmall',
          nt && 'inputHiddenLabel',
          st && 'inputAdornedStart',
          _e && 'inputAdornedEnd',
          ot && 'readOnly',
        ],
      }
    return composeClasses(ct, getInputBaseUtilityClass, a)
  },
  InputBaseRoot = styled('div', {
    name: 'MuiInputBase',
    slot: 'Root',
    overridesResolver: rootOverridesResolver,
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {},
      o.typography.body1,
      {
        color: (o.vars || o).palette.text.primary,
        lineHeight: '1.4375em',
        boxSizing: 'border-box',
        position: 'relative',
        cursor: 'text',
        display: 'inline-flex',
        alignItems: 'center',
        [`&.${inputBaseClasses.disabled}`]: {
          color: (o.vars || o).palette.text.disabled,
          cursor: 'default',
        },
      },
      a.multiline &&
        _extends$5(
          { padding: '4px 0 5px' },
          a.size === 'small' && { paddingTop: 1 }
        ),
      a.fullWidth && { width: '100%' }
    )
  ),
  InputBaseComponent = styled('input', {
    name: 'MuiInputBase',
    slot: 'Input',
    overridesResolver: inputOverridesResolver,
  })(({ theme: o, ownerState: a }) => {
    const s = o.palette.mode === 'light',
      $ = _extends$5(
        { color: 'currentColor' },
        o.vars
          ? { opacity: o.vars.opacity.inputPlaceholder }
          : { opacity: s ? 0.42 : 0.5 },
        {
          transition: o.transitions.create('opacity', {
            duration: o.transitions.duration.shorter,
          }),
        }
      ),
      j = { opacity: '0 !important' },
      _e = o.vars
        ? { opacity: o.vars.opacity.inputPlaceholder }
        : { opacity: s ? 0.42 : 0.5 }
    return _extends$5(
      {
        font: 'inherit',
        letterSpacing: 'inherit',
        color: 'currentColor',
        padding: '4px 0 5px',
        border: 0,
        boxSizing: 'content-box',
        background: 'none',
        height: '1.4375em',
        margin: 0,
        WebkitTapHighlightColor: 'transparent',
        display: 'block',
        minWidth: 0,
        width: '100%',
        animationName: 'mui-auto-fill-cancel',
        animationDuration: '10ms',
        '&::-webkit-input-placeholder': $,
        '&::-moz-placeholder': $,
        '&:-ms-input-placeholder': $,
        '&::-ms-input-placeholder': $,
        '&:focus': { outline: 0 },
        '&:invalid': { boxShadow: 'none' },
        '&::-webkit-search-decoration': { WebkitAppearance: 'none' },
        [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
          '&::-webkit-input-placeholder': j,
          '&::-moz-placeholder': j,
          '&:-ms-input-placeholder': j,
          '&::-ms-input-placeholder': j,
          '&:focus::-webkit-input-placeholder': _e,
          '&:focus::-moz-placeholder': _e,
          '&:focus:-ms-input-placeholder': _e,
          '&:focus::-ms-input-placeholder': _e,
        },
        [`&.${inputBaseClasses.disabled}`]: {
          opacity: 1,
          WebkitTextFillColor: (o.vars || o).palette.text.disabled,
        },
        '&:-webkit-autofill': {
          animationDuration: '5000s',
          animationName: 'mui-auto-fill',
        },
      },
      a.size === 'small' && { paddingTop: 1 },
      a.multiline && {
        height: 'auto',
        resize: 'none',
        padding: 0,
        paddingTop: 0,
      },
      a.type === 'search' && { MozAppearance: 'textfield' }
    )
  }),
  inputGlobalStyles = jsxRuntimeExports.jsx(GlobalStyles, {
    styles: {
      '@keyframes mui-auto-fill': { from: { display: 'block' } },
      '@keyframes mui-auto-fill-cancel': { from: { display: 'block' } },
    },
  }),
  InputBase = reactExports.forwardRef(function o(a, s) {
    var $
    const j = useDefaultProps({ props: a, name: 'MuiInputBase' }),
      {
        'aria-describedby': _e,
        autoComplete: et,
        autoFocus: tt,
        className: rt,
        components: nt = {},
        componentsProps: it = {},
        defaultValue: ot,
        disabled: at,
        disableInjectingGlobalStyles: st,
        endAdornment: ut,
        fullWidth: ct = !1,
        id: dt,
        inputComponent: ft = 'input',
        inputProps: mt = {},
        inputRef: vt,
        maxRows: yt,
        minRows: pt,
        multiline: ht = !1,
        name: At,
        onBlur: wt,
        onChange: Ct,
        onClick: Dt,
        onFocus: jt,
        onKeyDown: Et,
        onKeyUp: St,
        placeholder: Bt,
        readOnly: Mt,
        renderSuffix: Ut,
        rows: Wt,
        slotProps: Tt = {},
        slots: kt = {},
        startAdornment: Ot,
        type: Nt = 'text',
        value: $t,
      } = j,
      Pt = _objectWithoutPropertiesLoose$3(j, _excluded$A),
      Ft = mt.value != null ? mt.value : $t,
      { current: Vt } = reactExports.useRef(Ft != null),
      Xt = reactExports.useRef(),
      Yt = reactExports.useCallback(bt => {}, []),
      xt = useForkRef(Xt, vt, mt.ref, Yt),
      [It, Kt] = reactExports.useState(!1),
      Qt = useFormControl(),
      Ht = formControlState({
        props: j,
        muiFormControl: Qt,
        states: [
          'color',
          'disabled',
          'error',
          'hiddenLabel',
          'size',
          'required',
          'filled',
        ],
      })
    ;(Ht.focused = Qt ? Qt.focused : It),
      reactExports.useEffect(() => {
        !Qt && at && It && (Kt(!1), wt && wt())
      }, [Qt, at, It, wt])
    const Lt = Qt && Qt.onFilled,
      tr = Qt && Qt.onEmpty,
      lr = reactExports.useCallback(
        bt => {
          isFilled(bt) ? Lt && Lt() : tr && tr()
        },
        [Lt, tr]
      )
    useEnhancedEffect$1(() => {
      Vt && lr({ value: Ft })
    }, [Ft, lr, Vt])
    const yr = bt => {
        if (Ht.disabled) {
          bt.stopPropagation()
          return
        }
        jt && jt(bt),
          mt.onFocus && mt.onFocus(bt),
          Qt && Qt.onFocus ? Qt.onFocus(bt) : Kt(!0)
      },
      mr = bt => {
        wt && wt(bt),
          mt.onBlur && mt.onBlur(bt),
          Qt && Qt.onBlur ? Qt.onBlur(bt) : Kt(!1)
      },
      Er = (bt, ...Rt) => {
        if (!Vt) {
          const qt = bt.target || Xt.current
          if (qt == null) throw new Error(formatMuiErrorMessage$1(1))
          lr({ value: qt.value })
        }
        mt.onChange && mt.onChange(bt, ...Rt), Ct && Ct(bt, ...Rt)
      }
    reactExports.useEffect(() => {
      lr(Xt.current)
    }, [])
    const ur = bt => {
      Xt.current && bt.currentTarget === bt.target && Xt.current.focus(),
        Dt && Dt(bt)
    }
    let _r = ft,
      Rr = mt
    ht &&
      _r === 'input' &&
      (Wt
        ? (Rr = _extends$5({ type: void 0, minRows: Wt, maxRows: Wt }, Rr))
        : (Rr = _extends$5({ type: void 0, maxRows: yt, minRows: pt }, Rr)),
      (_r = TextareaAutosize))
    const nr = bt => {
      lr(
        bt.animationName === 'mui-auto-fill-cancel'
          ? Xt.current
          : { value: 'x' }
      )
    }
    reactExports.useEffect(() => {
      Qt && Qt.setAdornedStart(!!Ot)
    }, [Qt, Ot])
    const fr = _extends$5({}, j, {
        color: Ht.color || 'primary',
        disabled: Ht.disabled,
        endAdornment: ut,
        error: Ht.error,
        focused: Ht.focused,
        formControl: Qt,
        fullWidth: ct,
        hiddenLabel: Ht.hiddenLabel,
        multiline: ht,
        size: Ht.size,
        startAdornment: Ot,
        type: Nt,
      }),
      gr = useUtilityClasses$w(fr),
      br = kt.root || nt.Root || InputBaseRoot,
      Sr = Tt.root || it.root || {},
      zt = kt.input || nt.Input || InputBaseComponent
    return (
      (Rr = _extends$5({}, Rr, ($ = Tt.input) != null ? $ : it.input)),
      jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [
          !st && inputGlobalStyles,
          jsxRuntimeExports.jsxs(
            br,
            _extends$5(
              {},
              Sr,
              !isHostComponent(br) && {
                ownerState: _extends$5({}, fr, Sr.ownerState),
              },
              { ref: s, onClick: ur },
              Pt,
              {
                className: clsx$1(
                  gr.root,
                  Sr.className,
                  rt,
                  Mt && 'MuiInputBase-readOnly'
                ),
                children: [
                  Ot,
                  jsxRuntimeExports.jsx(FormControlContext.Provider, {
                    value: null,
                    children: jsxRuntimeExports.jsx(
                      zt,
                      _extends$5(
                        {
                          ownerState: fr,
                          'aria-invalid': Ht.error,
                          'aria-describedby': _e,
                          autoComplete: et,
                          autoFocus: tt,
                          defaultValue: ot,
                          disabled: Ht.disabled,
                          id: dt,
                          onAnimationStart: nr,
                          name: At,
                          placeholder: Bt,
                          readOnly: Mt,
                          required: Ht.required,
                          rows: Wt,
                          value: Ft,
                          onKeyDown: Et,
                          onKeyUp: St,
                          type: Nt,
                        },
                        Rr,
                        !isHostComponent(zt) && {
                          as: _r,
                          ownerState: _extends$5({}, fr, Rr.ownerState),
                        },
                        {
                          ref: xt,
                          className: clsx$1(
                            gr.input,
                            Rr.className,
                            Mt && 'MuiInputBase-readOnly'
                          ),
                          onBlur: mr,
                          onChange: Er,
                          onFocus: yr,
                        }
                      )
                    ),
                  }),
                  ut,
                  Ut ? Ut(_extends$5({}, Ht, { startAdornment: Ot })) : null,
                ],
              }
            )
          ),
        ],
      })
    )
  }),
  InputBase$1 = InputBase
function getInputUtilityClass(o) {
  return generateUtilityClass('MuiInput', o)
}
const inputClasses = _extends$5(
    {},
    inputBaseClasses,
    generateUtilityClasses('MuiInput', ['root', 'underline', 'input'])
  ),
  _excluded$z = [
    'disableUnderline',
    'components',
    'componentsProps',
    'fullWidth',
    'inputComponent',
    'multiline',
    'slotProps',
    'slots',
    'type',
  ],
  useUtilityClasses$v = o => {
    const { classes: a, disableUnderline: s } = o,
      j = composeClasses(
        { root: ['root', !s && 'underline'], input: ['input'] },
        getInputUtilityClass,
        a
      )
    return _extends$5({}, a, j)
  },
  InputRoot = styled(InputBaseRoot, {
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    name: 'MuiInput',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        ...rootOverridesResolver(o, a),
        !s.disableUnderline && a.underline,
      ]
    },
  })(({ theme: o, ownerState: a }) => {
    let $ =
      o.palette.mode === 'light'
        ? 'rgba(0, 0, 0, 0.42)'
        : 'rgba(255, 255, 255, 0.7)'
    return (
      o.vars &&
        ($ = `rgba(${o.vars.palette.common.onBackgroundChannel} / ${o.vars.opacity.inputUnderline})`),
      _extends$5(
        { position: 'relative' },
        a.formControl && { 'label + &': { marginTop: 16 } },
        !a.disableUnderline && {
          '&::after': {
            borderBottom: `2px solid ${(o.vars || o).palette[a.color].main}`,
            left: 0,
            bottom: 0,
            content: '""',
            position: 'absolute',
            right: 0,
            transform: 'scaleX(0)',
            transition: o.transitions.create('transform', {
              duration: o.transitions.duration.shorter,
              easing: o.transitions.easing.easeOut,
            }),
            pointerEvents: 'none',
          },
          [`&.${inputClasses.focused}:after`]: {
            transform: 'scaleX(1) translateX(0)',
          },
          [`&.${inputClasses.error}`]: {
            '&::before, &::after': {
              borderBottomColor: (o.vars || o).palette.error.main,
            },
          },
          '&::before': {
            borderBottom: `1px solid ${$}`,
            left: 0,
            bottom: 0,
            content: '"\\00a0"',
            position: 'absolute',
            right: 0,
            transition: o.transitions.create('border-bottom-color', {
              duration: o.transitions.duration.shorter,
            }),
            pointerEvents: 'none',
          },
          [`&:hover:not(.${inputClasses.disabled}, .${inputClasses.error}):before`]: {
            borderBottom: `2px solid ${(o.vars || o).palette.text.primary}`,
            '@media (hover: none)': { borderBottom: `1px solid ${$}` },
          },
          [`&.${inputClasses.disabled}:before`]: {
            borderBottomStyle: 'dotted',
          },
        }
      )
    )
  }),
  InputInput = styled(InputBaseComponent, {
    name: 'MuiInput',
    slot: 'Input',
    overridesResolver: inputOverridesResolver,
  })({}),
  Input = reactExports.forwardRef(function o(a, s) {
    var $, j, _e, et
    const tt = useDefaultProps({ props: a, name: 'MuiInput' }),
      {
        disableUnderline: rt,
        components: nt = {},
        componentsProps: it,
        fullWidth: ot = !1,
        inputComponent: at = 'input',
        multiline: st = !1,
        slotProps: ut,
        slots: ct = {},
        type: dt = 'text',
      } = tt,
      ft = _objectWithoutPropertiesLoose$3(tt, _excluded$z),
      mt = useUtilityClasses$v(tt),
      yt = { root: { ownerState: { disableUnderline: rt } } },
      pt = ut ?? it ? deepmerge$1(ut ?? it, yt) : yt,
      ht = ($ = (j = ct.root) != null ? j : nt.Root) != null ? $ : InputRoot,
      At =
        (_e = (et = ct.input) != null ? et : nt.Input) != null ? _e : InputInput
    return jsxRuntimeExports.jsx(
      InputBase$1,
      _extends$5(
        {
          slots: { root: ht, input: At },
          slotProps: pt,
          fullWidth: ot,
          inputComponent: at,
          multiline: st,
          ref: s,
          type: dt,
        },
        ft,
        { classes: mt }
      )
    )
  })
Input.muiName = 'Input'
function getFilledInputUtilityClass(o) {
  return generateUtilityClass('MuiFilledInput', o)
}
const filledInputClasses = _extends$5(
    {},
    inputBaseClasses,
    generateUtilityClasses('MuiFilledInput', ['root', 'underline', 'input'])
  ),
  _excluded$y = [
    'disableUnderline',
    'components',
    'componentsProps',
    'fullWidth',
    'hiddenLabel',
    'inputComponent',
    'multiline',
    'slotProps',
    'slots',
    'type',
  ],
  useUtilityClasses$u = o => {
    const { classes: a, disableUnderline: s } = o,
      j = composeClasses(
        { root: ['root', !s && 'underline'], input: ['input'] },
        getFilledInputUtilityClass,
        a
      )
    return _extends$5({}, a, j)
  },
  FilledInputRoot = styled(InputBaseRoot, {
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    name: 'MuiFilledInput',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        ...rootOverridesResolver(o, a),
        !s.disableUnderline && a.underline,
      ]
    },
  })(({ theme: o, ownerState: a }) => {
    var s
    const $ = o.palette.mode === 'light',
      j = $ ? 'rgba(0, 0, 0, 0.42)' : 'rgba(255, 255, 255, 0.7)',
      _e = $ ? 'rgba(0, 0, 0, 0.06)' : 'rgba(255, 255, 255, 0.09)',
      et = $ ? 'rgba(0, 0, 0, 0.09)' : 'rgba(255, 255, 255, 0.13)',
      tt = $ ? 'rgba(0, 0, 0, 0.12)' : 'rgba(255, 255, 255, 0.12)'
    return _extends$5(
      {
        position: 'relative',
        backgroundColor: o.vars ? o.vars.palette.FilledInput.bg : _e,
        borderTopLeftRadius: (o.vars || o).shape.borderRadius,
        borderTopRightRadius: (o.vars || o).shape.borderRadius,
        transition: o.transitions.create('background-color', {
          duration: o.transitions.duration.shorter,
          easing: o.transitions.easing.easeOut,
        }),
        '&:hover': {
          backgroundColor: o.vars ? o.vars.palette.FilledInput.hoverBg : et,
          '@media (hover: none)': {
            backgroundColor: o.vars ? o.vars.palette.FilledInput.bg : _e,
          },
        },
        [`&.${filledInputClasses.focused}`]: {
          backgroundColor: o.vars ? o.vars.palette.FilledInput.bg : _e,
        },
        [`&.${filledInputClasses.disabled}`]: {
          backgroundColor: o.vars ? o.vars.palette.FilledInput.disabledBg : tt,
        },
      },
      !a.disableUnderline && {
        '&::after': {
          borderBottom: `2px solid ${
            (s = (o.vars || o).palette[a.color || 'primary']) == null
              ? void 0
              : s.main
          }`,
          left: 0,
          bottom: 0,
          content: '""',
          position: 'absolute',
          right: 0,
          transform: 'scaleX(0)',
          transition: o.transitions.create('transform', {
            duration: o.transitions.duration.shorter,
            easing: o.transitions.easing.easeOut,
          }),
          pointerEvents: 'none',
        },
        [`&.${filledInputClasses.focused}:after`]: {
          transform: 'scaleX(1) translateX(0)',
        },
        [`&.${filledInputClasses.error}`]: {
          '&::before, &::after': {
            borderBottomColor: (o.vars || o).palette.error.main,
          },
        },
        '&::before': {
          borderBottom: `1px solid ${
            o.vars
              ? `rgba(${o.vars.palette.common.onBackgroundChannel} / ${o.vars.opacity.inputUnderline})`
              : j
          }`,
          left: 0,
          bottom: 0,
          content: '"\\00a0"',
          position: 'absolute',
          right: 0,
          transition: o.transitions.create('border-bottom-color', {
            duration: o.transitions.duration.shorter,
          }),
          pointerEvents: 'none',
        },
        [`&:hover:not(.${filledInputClasses.disabled}, .${filledInputClasses.error}):before`]: {
          borderBottom: `1px solid ${(o.vars || o).palette.text.primary}`,
        },
        [`&.${filledInputClasses.disabled}:before`]: {
          borderBottomStyle: 'dotted',
        },
      },
      a.startAdornment && { paddingLeft: 12 },
      a.endAdornment && { paddingRight: 12 },
      a.multiline &&
        _extends$5(
          { padding: '25px 12px 8px' },
          a.size === 'small' && { paddingTop: 21, paddingBottom: 4 },
          a.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
          a.hiddenLabel &&
            a.size === 'small' && { paddingTop: 8, paddingBottom: 9 }
        )
    )
  }),
  FilledInputInput = styled(InputBaseComponent, {
    name: 'MuiFilledInput',
    slot: 'Input',
    overridesResolver: inputOverridesResolver,
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      { paddingTop: 25, paddingRight: 12, paddingBottom: 8, paddingLeft: 12 },
      !o.vars && {
        '&:-webkit-autofill': {
          WebkitBoxShadow:
            o.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset',
          WebkitTextFillColor: o.palette.mode === 'light' ? null : '#fff',
          caretColor: o.palette.mode === 'light' ? null : '#fff',
          borderTopLeftRadius: 'inherit',
          borderTopRightRadius: 'inherit',
        },
      },
      o.vars && {
        '&:-webkit-autofill': {
          borderTopLeftRadius: 'inherit',
          borderTopRightRadius: 'inherit',
        },
        [o.getColorSchemeSelector('dark')]: {
          '&:-webkit-autofill': {
            WebkitBoxShadow: '0 0 0 100px #266798 inset',
            WebkitTextFillColor: '#fff',
            caretColor: '#fff',
          },
        },
      },
      a.size === 'small' && { paddingTop: 21, paddingBottom: 4 },
      a.hiddenLabel && { paddingTop: 16, paddingBottom: 17 },
      a.startAdornment && { paddingLeft: 0 },
      a.endAdornment && { paddingRight: 0 },
      a.hiddenLabel &&
        a.size === 'small' && { paddingTop: 8, paddingBottom: 9 },
      a.multiline && {
        paddingTop: 0,
        paddingBottom: 0,
        paddingLeft: 0,
        paddingRight: 0,
      }
    )
  ),
  FilledInput = reactExports.forwardRef(function o(a, s) {
    var $, j, _e, et
    const tt = useDefaultProps({ props: a, name: 'MuiFilledInput' }),
      {
        components: rt = {},
        componentsProps: nt,
        fullWidth: it = !1,
        inputComponent: ot = 'input',
        multiline: at = !1,
        slotProps: st,
        slots: ut = {},
        type: ct = 'text',
      } = tt,
      dt = _objectWithoutPropertiesLoose$3(tt, _excluded$y),
      ft = _extends$5({}, tt, {
        fullWidth: it,
        inputComponent: ot,
        multiline: at,
        type: ct,
      }),
      mt = useUtilityClasses$u(tt),
      vt = { root: { ownerState: ft }, input: { ownerState: ft } },
      yt = st ?? nt ? deepmerge$1(vt, st ?? nt) : vt,
      pt =
        ($ = (j = ut.root) != null ? j : rt.Root) != null ? $ : FilledInputRoot,
      ht =
        (_e = (et = ut.input) != null ? et : rt.Input) != null
          ? _e
          : FilledInputInput
    return jsxRuntimeExports.jsx(
      InputBase$1,
      _extends$5(
        {
          slots: { root: pt, input: ht },
          componentsProps: yt,
          fullWidth: it,
          inputComponent: ot,
          multiline: at,
          ref: s,
          type: ct,
        },
        dt,
        { classes: mt }
      )
    )
  })
FilledInput.muiName = 'Input'
var _span$1
const _excluded$x = ['children', 'classes', 'className', 'label', 'notched'],
  NotchedOutlineRoot$1 = styled('fieldset', {
    shouldForwardProp: rootShouldForwardProp,
  })({
    textAlign: 'left',
    position: 'absolute',
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: '0 8px',
    pointerEvents: 'none',
    borderRadius: 'inherit',
    borderStyle: 'solid',
    borderWidth: 1,
    overflow: 'hidden',
    minWidth: '0%',
  }),
  NotchedOutlineLegend = styled('legend', {
    shouldForwardProp: rootShouldForwardProp,
  })(({ ownerState: o, theme: a }) =>
    _extends$5(
      { float: 'unset', width: 'auto', overflow: 'hidden' },
      !o.withLabel && {
        padding: 0,
        lineHeight: '11px',
        transition: a.transitions.create('width', {
          duration: 150,
          easing: a.transitions.easing.easeOut,
        }),
      },
      o.withLabel &&
        _extends$5(
          {
            display: 'block',
            padding: 0,
            height: 11,
            fontSize: '0.75em',
            visibility: 'hidden',
            maxWidth: 0.01,
            transition: a.transitions.create('max-width', {
              duration: 50,
              easing: a.transitions.easing.easeOut,
            }),
            whiteSpace: 'nowrap',
            '& > span': {
              paddingLeft: 5,
              paddingRight: 5,
              display: 'inline-block',
              opacity: 0,
              visibility: 'visible',
            },
          },
          o.notched && {
            maxWidth: '100%',
            transition: a.transitions.create('max-width', {
              duration: 100,
              easing: a.transitions.easing.easeOut,
              delay: 50,
            }),
          }
        )
    )
  )
function NotchedOutline(o) {
  const { className: a, label: s, notched: $ } = o,
    j = _objectWithoutPropertiesLoose$3(o, _excluded$x),
    _e = s != null && s !== '',
    et = _extends$5({}, o, { notched: $, withLabel: _e })
  return jsxRuntimeExports.jsx(
    NotchedOutlineRoot$1,
    _extends$5({ 'aria-hidden': !0, className: a, ownerState: et }, j, {
      children: jsxRuntimeExports.jsx(NotchedOutlineLegend, {
        ownerState: et,
        children: _e
          ? jsxRuntimeExports.jsx('span', { children: s })
          : _span$1 ||
            (_span$1 = jsxRuntimeExports.jsx('span', {
              className: 'notranslate',
              children: '',
            })),
      }),
    })
  )
}
function getOutlinedInputUtilityClass(o) {
  return generateUtilityClass('MuiOutlinedInput', o)
}
const outlinedInputClasses = _extends$5(
    {},
    inputBaseClasses,
    generateUtilityClasses('MuiOutlinedInput', [
      'root',
      'notchedOutline',
      'input',
    ])
  ),
  _excluded$w = [
    'components',
    'fullWidth',
    'inputComponent',
    'label',
    'multiline',
    'notched',
    'slots',
    'type',
  ],
  useUtilityClasses$t = o => {
    const { classes: a } = o,
      $ = composeClasses(
        {
          root: ['root'],
          notchedOutline: ['notchedOutline'],
          input: ['input'],
        },
        getOutlinedInputUtilityClass,
        a
      )
    return _extends$5({}, a, $)
  },
  OutlinedInputRoot = styled(InputBaseRoot, {
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    name: 'MuiOutlinedInput',
    slot: 'Root',
    overridesResolver: rootOverridesResolver,
  })(({ theme: o, ownerState: a }) => {
    const s =
      o.palette.mode === 'light'
        ? 'rgba(0, 0, 0, 0.23)'
        : 'rgba(255, 255, 255, 0.23)'
    return _extends$5(
      {
        position: 'relative',
        borderRadius: (o.vars || o).shape.borderRadius,
        [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (o.vars || o).palette.text.primary,
        },
        '@media (hover: none)': {
          [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
            borderColor: o.vars
              ? `rgba(${o.vars.palette.common.onBackgroundChannel} / 0.23)`
              : s,
          },
        },
        [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (o.vars || o).palette[a.color].main,
          borderWidth: 2,
        },
        [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (o.vars || o).palette.error.main,
        },
        [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
          borderColor: (o.vars || o).palette.action.disabled,
        },
      },
      a.startAdornment && { paddingLeft: 14 },
      a.endAdornment && { paddingRight: 14 },
      a.multiline &&
        _extends$5(
          { padding: '16.5px 14px' },
          a.size === 'small' && { padding: '8.5px 14px' }
        )
    )
  }),
  NotchedOutlineRoot = styled(NotchedOutline, {
    name: 'MuiOutlinedInput',
    slot: 'NotchedOutline',
    overridesResolver: (o, a) => a.notchedOutline,
  })(({ theme: o }) => {
    const a =
      o.palette.mode === 'light'
        ? 'rgba(0, 0, 0, 0.23)'
        : 'rgba(255, 255, 255, 0.23)'
    return {
      borderColor: o.vars
        ? `rgba(${o.vars.palette.common.onBackgroundChannel} / 0.23)`
        : a,
    }
  }),
  OutlinedInputInput = styled(InputBaseComponent, {
    name: 'MuiOutlinedInput',
    slot: 'Input',
    overridesResolver: inputOverridesResolver,
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      { padding: '16.5px 14px' },
      !o.vars && {
        '&:-webkit-autofill': {
          WebkitBoxShadow:
            o.palette.mode === 'light' ? null : '0 0 0 100px #266798 inset',
          WebkitTextFillColor: o.palette.mode === 'light' ? null : '#fff',
          caretColor: o.palette.mode === 'light' ? null : '#fff',
          borderRadius: 'inherit',
        },
      },
      o.vars && {
        '&:-webkit-autofill': { borderRadius: 'inherit' },
        [o.getColorSchemeSelector('dark')]: {
          '&:-webkit-autofill': {
            WebkitBoxShadow: '0 0 0 100px #266798 inset',
            WebkitTextFillColor: '#fff',
            caretColor: '#fff',
          },
        },
      },
      a.size === 'small' && { padding: '8.5px 14px' },
      a.multiline && { padding: 0 },
      a.startAdornment && { paddingLeft: 0 },
      a.endAdornment && { paddingRight: 0 }
    )
  ),
  OutlinedInput = reactExports.forwardRef(function o(a, s) {
    var $, j, _e, et, tt
    const rt = useDefaultProps({ props: a, name: 'MuiOutlinedInput' }),
      {
        components: nt = {},
        fullWidth: it = !1,
        inputComponent: ot = 'input',
        label: at,
        multiline: st = !1,
        notched: ut,
        slots: ct = {},
        type: dt = 'text',
      } = rt,
      ft = _objectWithoutPropertiesLoose$3(rt, _excluded$w),
      mt = useUtilityClasses$t(rt),
      vt = useFormControl(),
      yt = formControlState({
        props: rt,
        muiFormControl: vt,
        states: [
          'color',
          'disabled',
          'error',
          'focused',
          'hiddenLabel',
          'size',
          'required',
        ],
      }),
      pt = _extends$5({}, rt, {
        color: yt.color || 'primary',
        disabled: yt.disabled,
        error: yt.error,
        focused: yt.focused,
        formControl: vt,
        fullWidth: it,
        hiddenLabel: yt.hiddenLabel,
        multiline: st,
        size: yt.size,
        type: dt,
      }),
      ht =
        ($ = (j = ct.root) != null ? j : nt.Root) != null
          ? $
          : OutlinedInputRoot,
      At =
        (_e = (et = ct.input) != null ? et : nt.Input) != null
          ? _e
          : OutlinedInputInput
    return jsxRuntimeExports.jsx(
      InputBase$1,
      _extends$5(
        {
          slots: { root: ht, input: At },
          renderSuffix: wt =>
            jsxRuntimeExports.jsx(NotchedOutlineRoot, {
              ownerState: pt,
              className: mt.notchedOutline,
              label:
                at != null && at !== '' && yt.required
                  ? tt ||
                    (tt = jsxRuntimeExports.jsxs(reactExports.Fragment, {
                      children: [at, '', '*'],
                    }))
                  : at,
              notched:
                typeof ut < 'u'
                  ? ut
                  : !!(wt.startAdornment || wt.filled || wt.focused),
            }),
          fullWidth: it,
          inputComponent: ot,
          multiline: st,
          ref: s,
          type: dt,
        },
        ft,
        { classes: _extends$5({}, mt, { notchedOutline: null }) }
      )
    )
  })
OutlinedInput.muiName = 'Input'
const _excluded$v = [
    'autoWidth',
    'children',
    'classes',
    'className',
    'defaultOpen',
    'displayEmpty',
    'IconComponent',
    'id',
    'input',
    'inputProps',
    'label',
    'labelId',
    'MenuProps',
    'multiple',
    'native',
    'onClose',
    'onOpen',
    'open',
    'renderValue',
    'SelectDisplayProps',
    'variant',
  ],
  _excluded2$1 = ['root'],
  useUtilityClasses$s = o => {
    const { classes: a } = o
    return a
  },
  styledRootConfig = {
    name: 'MuiSelect',
    overridesResolver: (o, a) => a.root,
    shouldForwardProp: o => rootShouldForwardProp(o) && o !== 'variant',
    slot: 'Root',
  },
  StyledInput = styled(Input, styledRootConfig)(''),
  StyledOutlinedInput = styled(OutlinedInput, styledRootConfig)(''),
  StyledFilledInput = styled(FilledInput, styledRootConfig)(''),
  Select = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ name: 'MuiSelect', props: a }),
      {
        autoWidth: j = !1,
        children: _e,
        classes: et = {},
        className: tt,
        defaultOpen: rt = !1,
        displayEmpty: nt = !1,
        IconComponent: it = ArrowDropDownIcon,
        id: ot,
        input: at,
        inputProps: st,
        label: ut,
        labelId: ct,
        MenuProps: dt,
        multiple: ft = !1,
        native: mt = !1,
        onClose: vt,
        onOpen: yt,
        open: pt,
        renderValue: ht,
        SelectDisplayProps: At,
        variant: wt = 'outlined',
      } = $,
      Ct = _objectWithoutPropertiesLoose$3($, _excluded$v),
      Dt = mt ? NativeSelectInput : SelectInput,
      jt = useFormControl(),
      Et = formControlState({
        props: $,
        muiFormControl: jt,
        states: ['variant', 'error'],
      }),
      St = Et.variant || wt,
      Bt = _extends$5({}, $, { variant: St, classes: et }),
      Mt = useUtilityClasses$s(Bt),
      Ut = _objectWithoutPropertiesLoose$3(Mt, _excluded2$1),
      Wt =
        at ||
        {
          standard: jsxRuntimeExports.jsx(StyledInput, { ownerState: Bt }),
          outlined: jsxRuntimeExports.jsx(StyledOutlinedInput, {
            label: ut,
            ownerState: Bt,
          }),
          filled: jsxRuntimeExports.jsx(StyledFilledInput, { ownerState: Bt }),
        }[St],
      Tt = useForkRef(s, Wt.ref)
    return jsxRuntimeExports.jsx(reactExports.Fragment, {
      children: reactExports.cloneElement(
        Wt,
        _extends$5(
          {
            inputComponent: Dt,
            inputProps: _extends$5(
              {
                children: _e,
                error: Et.error,
                IconComponent: it,
                variant: St,
                type: void 0,
                multiple: ft,
              },
              mt
                ? { id: ot }
                : {
                    autoWidth: j,
                    defaultOpen: rt,
                    displayEmpty: nt,
                    labelId: ct,
                    MenuProps: dt,
                    onClose: vt,
                    onOpen: yt,
                    open: pt,
                    renderValue: ht,
                    SelectDisplayProps: _extends$5({ id: ot }, At),
                  },
              st,
              { classes: st ? deepmerge$1(Ut, st.classes) : Ut },
              at ? at.props.inputProps : {}
            ),
          },
          ((ft && mt) || nt) && St === 'outlined' ? { notched: !0 } : {},
          { ref: Tt, className: clsx$1(Wt.props.className, tt, Mt.root) },
          !at && { variant: St },
          Ct
        )
      ),
    })
  })
Select.muiName = 'Select'
var Settings = {},
  _interopRequireDefault$8 = interopRequireDefaultExports
Object.defineProperty(Settings, '__esModule', { value: !0 })
var default_1$7 = (Settings.default = void 0),
  _createSvgIcon$7 = _interopRequireDefault$8(requireCreateSvgIcon()),
  _jsxRuntime$7 = jsxRuntimeExports
default_1$7 = Settings.default = (0, _createSvgIcon$7.default)(
  (0, _jsxRuntime$7.jsx)('path', {
    d:
      'M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6',
  }),
  'Settings'
)
function getFormLabelUtilityClasses(o) {
  return generateUtilityClass('MuiFormLabel', o)
}
const formLabelClasses = generateUtilityClasses('MuiFormLabel', [
    'root',
    'colorSecondary',
    'focused',
    'disabled',
    'error',
    'filled',
    'required',
    'asterisk',
  ]),
  _excluded$u = [
    'children',
    'className',
    'color',
    'component',
    'disabled',
    'error',
    'filled',
    'focused',
    'required',
  ],
  useUtilityClasses$r = o => {
    const {
        classes: a,
        color: s,
        focused: $,
        disabled: j,
        error: _e,
        filled: et,
        required: tt,
      } = o,
      rt = {
        root: [
          'root',
          `color${capitalize$2(s)}`,
          j && 'disabled',
          _e && 'error',
          et && 'filled',
          $ && 'focused',
          tt && 'required',
        ],
        asterisk: ['asterisk', _e && 'error'],
      }
    return composeClasses(rt, getFormLabelUtilityClasses, a)
  },
  FormLabelRoot = styled('label', {
    name: 'MuiFormLabel',
    slot: 'Root',
    overridesResolver: ({ ownerState: o }, a) =>
      _extends$5(
        {},
        a.root,
        o.color === 'secondary' && a.colorSecondary,
        o.filled && a.filled
      ),
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      { color: (o.vars || o).palette.text.secondary },
      o.typography.body1,
      {
        lineHeight: '1.4375em',
        padding: 0,
        position: 'relative',
        [`&.${formLabelClasses.focused}`]: {
          color: (o.vars || o).palette[a.color].main,
        },
        [`&.${formLabelClasses.disabled}`]: {
          color: (o.vars || o).palette.text.disabled,
        },
        [`&.${formLabelClasses.error}`]: {
          color: (o.vars || o).palette.error.main,
        },
      }
    )
  ),
  AsteriskComponent$1 = styled('span', {
    name: 'MuiFormLabel',
    slot: 'Asterisk',
    overridesResolver: (o, a) => a.asterisk,
  })(({ theme: o }) => ({
    [`&.${formLabelClasses.error}`]: {
      color: (o.vars || o).palette.error.main,
    },
  })),
  FormLabel = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiFormLabel' }),
      { children: j, className: _e, component: et = 'label' } = $,
      tt = _objectWithoutPropertiesLoose$3($, _excluded$u),
      rt = useFormControl(),
      nt = formControlState({
        props: $,
        muiFormControl: rt,
        states: ['color', 'required', 'focused', 'disabled', 'error', 'filled'],
      }),
      it = _extends$5({}, $, {
        color: nt.color || 'primary',
        component: et,
        disabled: nt.disabled,
        error: nt.error,
        filled: nt.filled,
        focused: nt.focused,
        required: nt.required,
      }),
      ot = useUtilityClasses$r(it)
    return jsxRuntimeExports.jsxs(
      FormLabelRoot,
      _extends$5(
        { as: et, ownerState: it, className: clsx$1(ot.root, _e), ref: s },
        tt,
        {
          children: [
            j,
            nt.required &&
              jsxRuntimeExports.jsxs(AsteriskComponent$1, {
                ownerState: it,
                'aria-hidden': !0,
                className: ot.asterisk,
                children: ['', '*'],
              }),
          ],
        }
      )
    )
  })
function getInputLabelUtilityClasses(o) {
  return generateUtilityClass('MuiInputLabel', o)
}
generateUtilityClasses('MuiInputLabel', [
  'root',
  'focused',
  'disabled',
  'error',
  'required',
  'asterisk',
  'formControl',
  'sizeSmall',
  'shrink',
  'animated',
  'standard',
  'filled',
  'outlined',
])
const _excluded$t = [
    'disableAnimation',
    'margin',
    'shrink',
    'variant',
    'className',
  ],
  useUtilityClasses$q = o => {
    const {
        classes: a,
        formControl: s,
        size: $,
        shrink: j,
        disableAnimation: _e,
        variant: et,
        required: tt,
      } = o,
      rt = {
        root: [
          'root',
          s && 'formControl',
          !_e && 'animated',
          j && 'shrink',
          $ && $ !== 'normal' && `size${capitalize$2($)}`,
          et,
        ],
        asterisk: [tt && 'asterisk'],
      },
      nt = composeClasses(rt, getInputLabelUtilityClasses, a)
    return _extends$5({}, a, nt)
  },
  InputLabelRoot = styled(FormLabel, {
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    name: 'MuiInputLabel',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        { [`& .${formLabelClasses.asterisk}`]: a.asterisk },
        a.root,
        s.formControl && a.formControl,
        s.size === 'small' && a.sizeSmall,
        s.shrink && a.shrink,
        !s.disableAnimation && a.animated,
        s.focused && a.focused,
        a[s.variant],
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        display: 'block',
        transformOrigin: 'top left',
        whiteSpace: 'nowrap',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        maxWidth: '100%',
      },
      a.formControl && {
        position: 'absolute',
        left: 0,
        top: 0,
        transform: 'translate(0, 20px) scale(1)',
      },
      a.size === 'small' && { transform: 'translate(0, 17px) scale(1)' },
      a.shrink && {
        transform: 'translate(0, -1.5px) scale(0.75)',
        transformOrigin: 'top left',
        maxWidth: '133%',
      },
      !a.disableAnimation && {
        transition: o.transitions.create(['color', 'transform', 'max-width'], {
          duration: o.transitions.duration.shorter,
          easing: o.transitions.easing.easeOut,
        }),
      },
      a.variant === 'filled' &&
        _extends$5(
          {
            zIndex: 1,
            pointerEvents: 'none',
            transform: 'translate(12px, 16px) scale(1)',
            maxWidth: 'calc(100% - 24px)',
          },
          a.size === 'small' && { transform: 'translate(12px, 13px) scale(1)' },
          a.shrink &&
            _extends$5(
              {
                userSelect: 'none',
                pointerEvents: 'auto',
                transform: 'translate(12px, 7px) scale(0.75)',
                maxWidth: 'calc(133% - 24px)',
              },
              a.size === 'small' && {
                transform: 'translate(12px, 4px) scale(0.75)',
              }
            )
        ),
      a.variant === 'outlined' &&
        _extends$5(
          {
            zIndex: 1,
            pointerEvents: 'none',
            transform: 'translate(14px, 16px) scale(1)',
            maxWidth: 'calc(100% - 24px)',
          },
          a.size === 'small' && { transform: 'translate(14px, 9px) scale(1)' },
          a.shrink && {
            userSelect: 'none',
            pointerEvents: 'auto',
            maxWidth: 'calc(133% - 32px)',
            transform: 'translate(14px, -9px) scale(0.75)',
          }
        )
    )
  ),
  InputLabel = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ name: 'MuiInputLabel', props: a }),
      { disableAnimation: j = !1, shrink: _e, className: et } = $,
      tt = _objectWithoutPropertiesLoose$3($, _excluded$t),
      rt = useFormControl()
    let nt = _e
    typeof nt > 'u' && rt && (nt = rt.filled || rt.focused || rt.adornedStart)
    const it = formControlState({
        props: $,
        muiFormControl: rt,
        states: ['size', 'variant', 'required', 'focused'],
      }),
      ot = _extends$5({}, $, {
        disableAnimation: j,
        formControl: rt,
        shrink: nt,
        size: it.size,
        variant: it.variant,
        required: it.required,
        focused: it.focused,
      }),
      at = useUtilityClasses$q(ot)
    return jsxRuntimeExports.jsx(
      InputLabelRoot,
      _extends$5(
        {
          'data-shrink': nt,
          ownerState: ot,
          ref: s,
          className: clsx$1(at.root, et),
        },
        tt,
        { classes: at }
      )
    )
  })
function getFormHelperTextUtilityClasses(o) {
  return generateUtilityClass('MuiFormHelperText', o)
}
const formHelperTextClasses = generateUtilityClasses('MuiFormHelperText', [
  'root',
  'error',
  'disabled',
  'sizeSmall',
  'sizeMedium',
  'contained',
  'focused',
  'filled',
  'required',
])
var _span
const _excluded$s = [
    'children',
    'className',
    'component',
    'disabled',
    'error',
    'filled',
    'focused',
    'margin',
    'required',
    'variant',
  ],
  useUtilityClasses$p = o => {
    const {
        classes: a,
        contained: s,
        size: $,
        disabled: j,
        error: _e,
        filled: et,
        focused: tt,
        required: rt,
      } = o,
      nt = {
        root: [
          'root',
          j && 'disabled',
          _e && 'error',
          $ && `size${capitalize$2($)}`,
          s && 'contained',
          tt && 'focused',
          et && 'filled',
          rt && 'required',
        ],
      }
    return composeClasses(nt, getFormHelperTextUtilityClasses, a)
  },
  FormHelperTextRoot = styled('p', {
    name: 'MuiFormHelperText',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        s.size && a[`size${capitalize$2(s.size)}`],
        s.contained && a.contained,
        s.filled && a.filled,
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      { color: (o.vars || o).palette.text.secondary },
      o.typography.caption,
      {
        textAlign: 'left',
        marginTop: 3,
        marginRight: 0,
        marginBottom: 0,
        marginLeft: 0,
        [`&.${formHelperTextClasses.disabled}`]: {
          color: (o.vars || o).palette.text.disabled,
        },
        [`&.${formHelperTextClasses.error}`]: {
          color: (o.vars || o).palette.error.main,
        },
      },
      a.size === 'small' && { marginTop: 4 },
      a.contained && { marginLeft: 14, marginRight: 14 }
    )
  ),
  FormHelperText = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiFormHelperText' }),
      { children: j, className: _e, component: et = 'p' } = $,
      tt = _objectWithoutPropertiesLoose$3($, _excluded$s),
      rt = useFormControl(),
      nt = formControlState({
        props: $,
        muiFormControl: rt,
        states: [
          'variant',
          'size',
          'disabled',
          'error',
          'filled',
          'focused',
          'required',
        ],
      }),
      it = _extends$5({}, $, {
        component: et,
        contained: nt.variant === 'filled' || nt.variant === 'outlined',
        variant: nt.variant,
        size: nt.size,
        disabled: nt.disabled,
        error: nt.error,
        filled: nt.filled,
        focused: nt.focused,
        required: nt.required,
      }),
      ot = useUtilityClasses$p(it)
    return jsxRuntimeExports.jsx(
      FormHelperTextRoot,
      _extends$5(
        { as: et, ownerState: it, className: clsx$1(ot.root, _e), ref: s },
        tt,
        {
          children:
            j === ' '
              ? _span ||
                (_span = jsxRuntimeExports.jsx('span', {
                  className: 'notranslate',
                  children: '',
                }))
              : j,
        }
      )
    )
  })
function getTextFieldUtilityClass(o) {
  return generateUtilityClass('MuiTextField', o)
}
generateUtilityClasses('MuiTextField', ['root'])
const _excluded$r = [
    'autoComplete',
    'autoFocus',
    'children',
    'className',
    'color',
    'defaultValue',
    'disabled',
    'error',
    'FormHelperTextProps',
    'fullWidth',
    'helperText',
    'id',
    'InputLabelProps',
    'inputProps',
    'InputProps',
    'inputRef',
    'label',
    'maxRows',
    'minRows',
    'multiline',
    'name',
    'onBlur',
    'onChange',
    'onFocus',
    'placeholder',
    'required',
    'rows',
    'select',
    'SelectProps',
    'type',
    'value',
    'variant',
  ],
  variantComponent = {
    standard: Input,
    filled: FilledInput,
    outlined: OutlinedInput,
  },
  useUtilityClasses$o = o => {
    const { classes: a } = o
    return composeClasses({ root: ['root'] }, getTextFieldUtilityClass, a)
  },
  TextFieldRoot = styled(FormControl, {
    name: 'MuiTextField',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({}),
  TextField = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTextField' }),
      {
        autoComplete: j,
        autoFocus: _e = !1,
        children: et,
        className: tt,
        color: rt = 'primary',
        defaultValue: nt,
        disabled: it = !1,
        error: ot = !1,
        FormHelperTextProps: at,
        fullWidth: st = !1,
        helperText: ut,
        id: ct,
        InputLabelProps: dt,
        inputProps: ft,
        InputProps: mt,
        inputRef: vt,
        label: yt,
        maxRows: pt,
        minRows: ht,
        multiline: At = !1,
        name: wt,
        onBlur: Ct,
        onChange: Dt,
        onFocus: jt,
        placeholder: Et,
        required: St = !1,
        rows: Bt,
        select: Mt = !1,
        SelectProps: Ut,
        type: Wt,
        value: Tt,
        variant: kt = 'outlined',
      } = $,
      Ot = _objectWithoutPropertiesLoose$3($, _excluded$r),
      Nt = _extends$5({}, $, {
        autoFocus: _e,
        color: rt,
        disabled: it,
        error: ot,
        fullWidth: st,
        multiline: At,
        required: St,
        select: Mt,
        variant: kt,
      }),
      $t = useUtilityClasses$o(Nt),
      Pt = {}
    kt === 'outlined' &&
      (dt && typeof dt.shrink < 'u' && (Pt.notched = dt.shrink),
      (Pt.label = yt)),
      Mt &&
        ((!Ut || !Ut.native) && (Pt.id = void 0),
        (Pt['aria-describedby'] = void 0))
    const Ft = useId(ct),
      Vt = ut && Ft ? `${Ft}-helper-text` : void 0,
      Xt = yt && Ft ? `${Ft}-label` : void 0,
      Yt = variantComponent[kt],
      xt = jsxRuntimeExports.jsx(
        Yt,
        _extends$5(
          {
            'aria-describedby': Vt,
            autoComplete: j,
            autoFocus: _e,
            defaultValue: nt,
            fullWidth: st,
            multiline: At,
            name: wt,
            rows: Bt,
            maxRows: pt,
            minRows: ht,
            type: Wt,
            value: Tt,
            id: Ft,
            inputRef: vt,
            onBlur: Ct,
            onChange: Dt,
            onFocus: jt,
            placeholder: Et,
            inputProps: ft,
          },
          Pt,
          mt
        )
      )
    return jsxRuntimeExports.jsxs(
      TextFieldRoot,
      _extends$5(
        {
          className: clsx$1($t.root, tt),
          disabled: it,
          error: ot,
          fullWidth: st,
          ref: s,
          required: St,
          color: rt,
          variant: kt,
          ownerState: Nt,
        },
        Ot,
        {
          children: [
            yt != null &&
              yt !== '' &&
              jsxRuntimeExports.jsx(
                InputLabel,
                _extends$5({ htmlFor: Ft, id: Xt }, dt, { children: yt })
              ),
            Mt
              ? jsxRuntimeExports.jsx(
                  Select,
                  _extends$5(
                    {
                      'aria-describedby': Vt,
                      id: Ft,
                      labelId: Xt,
                      value: Tt,
                      input: xt,
                    },
                    Ut,
                    { children: et }
                  )
                )
              : xt,
            ut &&
              jsxRuntimeExports.jsx(
                FormHelperText,
                _extends$5({ id: Vt }, at, { children: ut })
              ),
          ],
        }
      )
    )
  })
function getCardUtilityClass(o) {
  return generateUtilityClass('MuiCard', o)
}
generateUtilityClasses('MuiCard', ['root'])
const _excluded$q = ['className', 'raised'],
  useUtilityClasses$n = o => {
    const { classes: a } = o
    return composeClasses({ root: ['root'] }, getCardUtilityClass, a)
  },
  CardRoot = styled(Paper, {
    name: 'MuiCard',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })(() => ({ overflow: 'hidden' })),
  Card = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiCard' }),
      { className: j, raised: _e = !1 } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$q),
      tt = _extends$5({}, $, { raised: _e }),
      rt = useUtilityClasses$n(tt)
    return jsxRuntimeExports.jsx(
      CardRoot,
      _extends$5(
        {
          className: clsx$1(rt.root, j),
          elevation: _e ? 8 : void 0,
          ref: s,
          ownerState: tt,
        },
        et
      )
    )
  })
function getCardHeaderUtilityClass(o) {
  return generateUtilityClass('MuiCardHeader', o)
}
const cardHeaderClasses = generateUtilityClasses('MuiCardHeader', [
    'root',
    'avatar',
    'action',
    'content',
    'title',
    'subheader',
  ]),
  _excluded$p = [
    'action',
    'avatar',
    'className',
    'component',
    'disableTypography',
    'subheader',
    'subheaderTypographyProps',
    'title',
    'titleTypographyProps',
  ],
  useUtilityClasses$m = o => {
    const { classes: a } = o
    return composeClasses(
      {
        root: ['root'],
        avatar: ['avatar'],
        action: ['action'],
        content: ['content'],
        title: ['title'],
        subheader: ['subheader'],
      },
      getCardHeaderUtilityClass,
      a
    )
  },
  CardHeaderRoot = styled('div', {
    name: 'MuiCardHeader',
    slot: 'Root',
    overridesResolver: (o, a) =>
      _extends$5(
        {
          [`& .${cardHeaderClasses.title}`]: a.title,
          [`& .${cardHeaderClasses.subheader}`]: a.subheader,
        },
        a.root
      ),
  })({ display: 'flex', alignItems: 'center', padding: 16 }),
  CardHeaderAvatar = styled('div', {
    name: 'MuiCardHeader',
    slot: 'Avatar',
    overridesResolver: (o, a) => a.avatar,
  })({ display: 'flex', flex: '0 0 auto', marginRight: 16 }),
  CardHeaderAction = styled('div', {
    name: 'MuiCardHeader',
    slot: 'Action',
    overridesResolver: (o, a) => a.action,
  })({
    flex: '0 0 auto',
    alignSelf: 'flex-start',
    marginTop: -4,
    marginRight: -8,
    marginBottom: -4,
  }),
  CardHeaderContent = styled('div', {
    name: 'MuiCardHeader',
    slot: 'Content',
    overridesResolver: (o, a) => a.content,
  })({ flex: '1 1 auto' }),
  CardHeader = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiCardHeader' }),
      {
        action: j,
        avatar: _e,
        className: et,
        component: tt = 'div',
        disableTypography: rt = !1,
        subheader: nt,
        subheaderTypographyProps: it,
        title: ot,
        titleTypographyProps: at,
      } = $,
      st = _objectWithoutPropertiesLoose$3($, _excluded$p),
      ut = _extends$5({}, $, { component: tt, disableTypography: rt }),
      ct = useUtilityClasses$m(ut)
    let dt = ot
    dt != null &&
      dt.type !== Typography &&
      !rt &&
      (dt = jsxRuntimeExports.jsx(
        Typography,
        _extends$5(
          {
            variant: _e ? 'body2' : 'h5',
            className: ct.title,
            component: 'span',
            display: 'block',
          },
          at,
          { children: dt }
        )
      ))
    let ft = nt
    return (
      ft != null &&
        ft.type !== Typography &&
        !rt &&
        (ft = jsxRuntimeExports.jsx(
          Typography,
          _extends$5(
            {
              variant: _e ? 'body2' : 'body1',
              className: ct.subheader,
              color: 'text.secondary',
              component: 'span',
              display: 'block',
            },
            it,
            { children: ft }
          )
        )),
      jsxRuntimeExports.jsxs(
        CardHeaderRoot,
        _extends$5(
          { className: clsx$1(ct.root, et), as: tt, ref: s, ownerState: ut },
          st,
          {
            children: [
              _e &&
                jsxRuntimeExports.jsx(CardHeaderAvatar, {
                  className: ct.avatar,
                  ownerState: ut,
                  children: _e,
                }),
              jsxRuntimeExports.jsxs(CardHeaderContent, {
                className: ct.content,
                ownerState: ut,
                children: [dt, ft],
              }),
              j &&
                jsxRuntimeExports.jsx(CardHeaderAction, {
                  className: ct.action,
                  ownerState: ut,
                  children: j,
                }),
            ],
          }
        )
      )
    )
  })
function getCardContentUtilityClass(o) {
  return generateUtilityClass('MuiCardContent', o)
}
generateUtilityClasses('MuiCardContent', ['root'])
const _excluded$o = ['className', 'component'],
  useUtilityClasses$l = o => {
    const { classes: a } = o
    return composeClasses({ root: ['root'] }, getCardContentUtilityClass, a)
  },
  CardContentRoot = styled('div', {
    name: 'MuiCardContent',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })(() => ({ padding: 16, '&:last-child': { paddingBottom: 24 } })),
  CardContent = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiCardContent' }),
      { className: j, component: _e = 'div' } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$o),
      tt = _extends$5({}, $, { component: _e }),
      rt = useUtilityClasses$l(tt)
    return jsxRuntimeExports.jsx(
      CardContentRoot,
      _extends$5(
        { as: _e, className: clsx$1(rt.root, j), ownerState: tt, ref: s },
        et
      )
    )
  })
function noop$4() {}
function returnTrue() {
  return !0
}
function charIsNumber(o) {
  return !!(o || '').match(/\d/)
}
function isNil(o) {
  return o == null
}
function escapeRegExp(o) {
  return o.replace(/[-[\]/{}()*+?.\\^$|]/g, '\\$&')
}
function getThousandsGroupRegex(o) {
  switch (o) {
    case 'lakh':
      return /(\d+?)(?=(\d\d)+(\d)(?!\d))(\.\d+)?/g
    case 'wan':
      return /(\d)(?=(\d{4})+(?!\d))/g
    case 'thousand':
    default:
      return /(\d)(?=(\d{3})+(?!\d))/g
  }
}
function applyThousandSeparator(o, a, s) {
  var $ = getThousandsGroupRegex(s),
    j = o.search(/[1-9]/)
  return (
    (j = j === -1 ? o.length : j),
    o.substring(0, j) + o.substring(j, o.length).replace($, '$1' + a)
  )
}
function splitDecimal(o, a) {
  a === void 0 && (a = !0)
  var s = o[0] === '-',
    $ = s && a
  o = o.replace('-', '')
  var j = o.split('.'),
    _e = j[0],
    et = j[1] || ''
  return { beforeDecimal: _e, afterDecimal: et, hasNagation: s, addNegation: $ }
}
function fixLeadingZero(o) {
  if (!o) return o
  var a = o[0] === '-'
  a && (o = o.substring(1, o.length))
  var s = o.split('.'),
    $ = s[0].replace(/^0+/, '') || '0',
    j = s[1] || ''
  return (a ? '-' : '') + $ + (j ? '.' + j : '')
}
function limitToScale(o, a, s) {
  for (var $ = '', j = s ? '0' : '', _e = 0; _e <= a - 1; _e++) $ += o[_e] || j
  return $
}
function repeat(o, a) {
  return Array(a + 1).join(o)
}
function toNumericString(o) {
  o += ''
  var a = o[0] === '-' ? '-' : ''
  a && (o = o.substring(1))
  var s = o.split(/[eE]/g),
    $ = s[0],
    j = s[1]
  if (((j = Number(j)), !j)) return a + $
  $ = $.replace('.', '')
  var _e = 1 + j,
    et = $.length
  return (
    _e < 0
      ? ($ = '0.' + repeat('0', Math.abs(_e)) + $)
      : _e >= et
      ? ($ = $ + repeat('0', _e - et))
      : ($ = ($.substring(0, _e) || '0') + '.' + $.substring(_e)),
    a + $
  )
}
function roundToPrecision(o, a, s) {
  if (['', '-'].indexOf(o) !== -1) return o
  var $ = o.indexOf('.') !== -1 && a,
    j = splitDecimal(o),
    _e = j.beforeDecimal,
    et = j.afterDecimal,
    tt = j.hasNagation,
    rt = parseFloat('0.' + (et || '0')),
    nt = et.length <= a ? '0.' + et : rt.toFixed(a),
    it = nt.split('.'),
    ot = _e
      .split('')
      .reverse()
      .reduce(function(ct, dt, ft) {
        return ct.length > ft
          ? (Number(ct[0]) + Number(dt)).toString() + ct.substring(1, ct.length)
          : dt + ct
      }, it[0]),
    at = limitToScale(it[1] || '', Math.min(a, et.length), s),
    st = tt ? '-' : '',
    ut = $ ? '.' : ''
  return '' + st + ot + ut + at
}
function setCaretPosition(o, a) {
  if (((o.value = o.value), o !== null)) {
    if (o.createTextRange) {
      var s = o.createTextRange()
      return s.move('character', a), s.select(), !0
    }
    return o.selectionStart || o.selectionStart === 0
      ? (o.focus(), o.setSelectionRange(a, a), !0)
      : (o.focus(), !1)
  }
}
function findChangedIndex(o, a) {
  for (var s = 0, $ = 0, j = o.length, _e = a.length; o[s] === a[s] && s < j; )
    s++
  for (; o[j - 1 - $] === a[_e - 1 - $] && _e - $ > s && j - $ > s; ) $++
  return { start: s, end: j - $ }
}
function clamp(o, a, s) {
  return Math.min(Math.max(o, a), s)
}
function getCurrentCaretPosition(o) {
  return Math.max(o.selectionStart, o.selectionEnd)
}
function addInputMode(o) {
  return (
    o ||
    (typeof navigator < 'u' &&
      !(navigator.platform && /iPhone|iPod/.test(navigator.platform)))
  )
}
function objectWithoutProperties$1(o, a) {
  var s = {}
  for (var $ in o)
    Object.prototype.hasOwnProperty.call(o, $) &&
      a.indexOf($) === -1 &&
      (s[$] = o[$])
  return s
}
var defaultProps = {
    displayType: 'input',
    decimalSeparator: '.',
    thousandsGroupStyle: 'thousand',
    fixedDecimalScale: !1,
    prefix: '',
    suffix: '',
    allowNegative: !0,
    allowEmptyFormatting: !1,
    allowLeadingZeros: !1,
    isNumericString: !1,
    type: 'text',
    onValueChange: noop$4,
    onChange: noop$4,
    onKeyDown: noop$4,
    onMouseUp: noop$4,
    onFocus: noop$4,
    onBlur: noop$4,
    isAllowed: returnTrue,
  },
  NumberFormat = (function(o) {
    function a(s) {
      o.call(this, s)
      var $ = s.defaultValue
      this.validateProps()
      var j = this.formatValueProp($)
      ;(this.state = {
        value: j,
        numAsString: this.removeFormatting(j),
        mounted: !1,
      }),
        (this.selectionBeforeInput = { selectionStart: 0, selectionEnd: 0 }),
        (this.onChange = this.onChange.bind(this)),
        (this.onKeyDown = this.onKeyDown.bind(this)),
        (this.onMouseUp = this.onMouseUp.bind(this)),
        (this.onFocus = this.onFocus.bind(this)),
        (this.onBlur = this.onBlur.bind(this))
    }
    return (
      o && (a.__proto__ = o),
      (a.prototype = Object.create(o && o.prototype)),
      (a.prototype.constructor = a),
      (a.prototype.componentDidMount = function() {
        this.setState({ mounted: !0 })
      }),
      (a.prototype.componentDidUpdate = function($) {
        this.updateValueIfRequired($)
      }),
      (a.prototype.componentWillUnmount = function() {
        clearTimeout(this.focusTimeout), clearTimeout(this.caretPositionTimeout)
      }),
      (a.prototype.updateValueIfRequired = function($) {
        var j = this,
          _e = j.props,
          et = j.state,
          tt = j.focusedElm,
          rt = et.value,
          nt = et.numAsString
        if ((nt === void 0 && (nt = ''), $ !== _e)) {
          this.validateProps()
          var it = this.formatNumString(nt),
            ot = isNil(_e.value) ? it : this.formatValueProp(),
            at = this.removeFormatting(ot),
            st = parseFloat(at),
            ut = parseFloat(nt)
          ;(((!isNaN(st) || !isNaN(ut)) && st !== ut) ||
            it !== rt ||
            (tt === null && ot !== rt)) &&
            this.updateValue({
              formattedValue: ot,
              numAsString: at,
              input: tt,
              source: 'prop',
              event: null,
            })
        }
      }),
      (a.prototype.getFloatString = function($) {
        $ === void 0 && ($ = '')
        var j = this.props,
          _e = j.decimalScale,
          et = this.getSeparators(),
          tt = et.decimalSeparator,
          rt = this.getNumberRegex(!0),
          nt = $[0] === '-'
        nt && ($ = $.replace('-', '')),
          tt && _e === 0 && ($ = $.split(tt)[0]),
          ($ = ($.match(rt) || []).join('').replace(tt, '.'))
        var it = $.indexOf('.')
        return (
          it !== -1 &&
            ($ =
              $.substring(0, it) +
              '.' +
              $.substring(it + 1, $.length).replace(
                new RegExp(escapeRegExp(tt), 'g'),
                ''
              )),
          nt && ($ = '-' + $),
          $
        )
      }),
      (a.prototype.getNumberRegex = function($, j) {
        var _e = this.props,
          et = _e.format,
          tt = _e.decimalScale,
          rt = _e.customNumerals,
          nt = this.getSeparators(),
          it = nt.decimalSeparator
        return new RegExp(
          '[0-9' +
            (rt ? rt.join('') : '') +
            ']' +
            (it && tt !== 0 && !j && !et ? '|' + escapeRegExp(it) : ''),
          $ ? 'g' : void 0
        )
      }),
      (a.prototype.getSeparators = function() {
        var $ = this.props,
          j = $.decimalSeparator,
          _e = this.props,
          et = _e.thousandSeparator,
          tt = _e.allowedDecimalSeparators
        return (
          et === !0 && (et = ','),
          tt || (tt = [j, '.']),
          {
            decimalSeparator: j,
            thousandSeparator: et,
            allowedDecimalSeparators: tt,
          }
        )
      }),
      (a.prototype.getMaskAtIndex = function($) {
        var j = this.props,
          _e = j.mask
        return (
          _e === void 0 && (_e = ' '), typeof _e == 'string' ? _e : _e[$] || ' '
        )
      }),
      (a.prototype.getValueObject = function($, j) {
        var _e = parseFloat(j)
        return {
          formattedValue: $,
          value: j,
          floatValue: isNaN(_e) ? void 0 : _e,
        }
      }),
      (a.prototype.validateProps = function() {
        var $ = this.props,
          j = $.mask,
          _e = this.getSeparators(),
          et = _e.decimalSeparator,
          tt = _e.thousandSeparator
        if (et === tt)
          throw new Error(
            `
          Decimal separator can't be same as thousand separator.
          thousandSeparator: ` +
              tt +
              ` (thousandSeparator = {true} is same as thousandSeparator = ",")
          decimalSeparator: ` +
              et +
              ` (default value for decimalSeparator is .)
       `
          )
        if (j) {
          var rt = j === 'string' ? j : j.toString()
          if (rt.match(/\d/g))
            throw new Error(
              `
          Mask ` +
                j +
                ` should not contain numeric character;
        `
            )
        }
      }),
      (a.prototype.setPatchedCaretPosition = function($, j, _e) {
        setCaretPosition($, j),
          (this.caretPositionTimeout = setTimeout(function() {
            $.value === _e && setCaretPosition($, j)
          }, 0))
      }),
      (a.prototype.correctCaretPosition = function($, j, _e) {
        var et = this.props,
          tt = et.prefix,
          rt = et.suffix,
          nt = et.format
        if ($ === '') return 0
        if (((j = clamp(j, 0, $.length)), !nt)) {
          var it = $[0] === '-'
          return clamp(j, tt.length + (it ? 1 : 0), $.length - rt.length)
        }
        if (
          typeof nt == 'function' ||
          (nt[j] === '#' && charIsNumber($[j])) ||
          (nt[j - 1] === '#' && charIsNumber($[j - 1]))
        )
          return j
        var ot = nt.indexOf('#'),
          at = nt.lastIndexOf('#')
        j = clamp(j, ot, at + 1)
        for (
          var st = nt.substring(j, nt.length).indexOf('#'),
            ut = j,
            ct = j + (st === -1 ? 0 : st);
          ut > ot && (nt[ut] !== '#' || !charIsNumber($[ut]));

        )
          ut -= 1
        var dt =
          !charIsNumber($[ct]) || (_e === 'left' && j !== ot) || j - ut < ct - j
        return dt ? (charIsNumber($[ut]) ? ut + 1 : ut) : ct
      }),
      (a.prototype.getCaretPosition = function($, j, _e) {
        var et = this.props,
          tt = et.format,
          rt = this.state.value,
          nt = this.getNumberRegex(!0),
          it = ($.match(nt) || []).join(''),
          ot = (j.match(nt) || []).join(''),
          at,
          st
        for (at = 0, st = 0; st < _e; st++) {
          var ut = $[st] || '',
            ct = j[at] || ''
          if (
            !(!ut.match(nt) && ut !== ct) &&
            !(
              ut === '0' &&
              ct.match(nt) &&
              ct !== '0' &&
              it.length !== ot.length
            )
          ) {
            for (; ut !== j[at] && at < j.length; ) at++
            at++
          }
        }
        return (
          typeof tt == 'string' && !rt && (at = j.length),
          (at = this.correctCaretPosition(j, at)),
          at
        )
      }),
      (a.prototype.removePrefixAndSuffix = function($) {
        var j = this.props,
          _e = j.format,
          et = j.prefix,
          tt = j.suffix
        if (!_e && $) {
          var rt = $[0] === '-'
          rt && ($ = $.substring(1, $.length)),
            ($ =
              et && $.indexOf(et) === 0 ? $.substring(et.length, $.length) : $)
          var nt = $.lastIndexOf(tt)
          ;($ =
            tt && nt !== -1 && nt === $.length - tt.length
              ? $.substring(0, nt)
              : $),
            rt && ($ = '-' + $)
        }
        return $
      }),
      (a.prototype.removePatternFormatting = function($) {
        for (
          var j = this.props,
            _e = j.format,
            et = _e.split('#').filter(function(st) {
              return st !== ''
            }),
            tt = 0,
            rt = '',
            nt = 0,
            it = et.length;
          nt <= it;
          nt++
        ) {
          var ot = et[nt] || '',
            at = nt === it ? $.length : $.indexOf(ot, tt)
          if (at === -1) {
            rt = $
            break
          } else (rt += $.substring(tt, at)), (tt = at + ot.length)
        }
        return (rt.match(this.getNumberRegex(!0)) || []).join('')
      }),
      (a.prototype.removeFormatting = function($) {
        var j = this.props,
          _e = j.format,
          et = j.removeFormatting
        return (
          $ &&
          (_e
            ? typeof _e == 'string'
              ? ($ = this.removePatternFormatting($))
              : typeof et == 'function'
              ? ($ = et($))
              : ($ = ($.match(this.getNumberRegex(!0)) || []).join(''))
            : (($ = this.removePrefixAndSuffix($)),
              ($ = this.getFloatString($))),
          $)
        )
      }),
      (a.prototype.formatWithPattern = function($) {
        for (
          var j = this.props,
            _e = j.format,
            et = 0,
            tt = _e.split(''),
            rt = 0,
            nt = _e.length;
          rt < nt;
          rt++
        )
          _e[rt] === '#' &&
            ((tt[rt] = $[et] || this.getMaskAtIndex(et)), (et += 1))
        return tt.join('')
      }),
      (a.prototype.formatAsNumber = function($) {
        var j = this.props,
          _e = j.decimalScale,
          et = j.fixedDecimalScale,
          tt = j.prefix,
          rt = j.suffix,
          nt = j.allowNegative,
          it = j.thousandsGroupStyle,
          ot = this.getSeparators(),
          at = ot.thousandSeparator,
          st = ot.decimalSeparator,
          ut = $.indexOf('.') !== -1 || (_e && et),
          ct = splitDecimal($, nt),
          dt = ct.beforeDecimal,
          ft = ct.afterDecimal,
          mt = ct.addNegation
        return (
          _e !== void 0 && (ft = limitToScale(ft, _e, et)),
          at && (dt = applyThousandSeparator(dt, at, it)),
          tt && (dt = tt + dt),
          rt && (ft = ft + rt),
          mt && (dt = '-' + dt),
          ($ = dt + ((ut && st) || '') + ft),
          $
        )
      }),
      (a.prototype.formatNumString = function($) {
        $ === void 0 && ($ = '')
        var j = this.props,
          _e = j.format,
          et = j.allowEmptyFormatting,
          tt = j.customNumerals,
          rt = $
        if (tt && tt.length === 10) {
          var nt = new RegExp('[' + tt.join('') + ']', 'g')
          rt = $.replace(nt, function(it) {
            return tt.indexOf(it).toString()
          })
        }
        return (
          $ === '' && !et
            ? (rt = '')
            : $ === '-' && !_e
            ? (rt = '-')
            : typeof _e == 'string'
            ? (rt = this.formatWithPattern(rt))
            : typeof _e == 'function'
            ? (rt = _e(rt))
            : (rt = this.formatAsNumber(rt)),
          rt
        )
      }),
      (a.prototype.formatValueProp = function($) {
        var j = this.props,
          _e = j.format,
          et = j.decimalScale,
          tt = j.fixedDecimalScale,
          rt = j.allowEmptyFormatting,
          nt = this.props,
          it = nt.value,
          ot = nt.isNumericString
        it = isNil(it) ? $ : it
        var at = !it && it !== 0
        if ((at && rt && (it = ''), at && !rt)) return ''
        typeof it == 'number' && ((it = toNumericString(it)), (ot = !0)),
          it === 'Infinity' && ot && (it = ''),
          ot &&
            !_e &&
            typeof et == 'number' &&
            (it = roundToPrecision(it, et, tt))
        var st = ot ? this.formatNumString(it) : this.formatInput(it)
        return st
      }),
      (a.prototype.formatNegation = function($) {
        $ === void 0 && ($ = '')
        var j = this.props,
          _e = j.allowNegative,
          et = new RegExp('(-)'),
          tt = new RegExp('(-)(.)*(-)'),
          rt = et.test($),
          nt = tt.test($)
        return ($ = $.replace(/-/g, '')), rt && !nt && _e && ($ = '-' + $), $
      }),
      (a.prototype.formatInput = function($) {
        $ === void 0 && ($ = '')
        var j = this.props,
          _e = j.format
        return (
          _e ||
            (($ = this.removePrefixAndSuffix($)), ($ = this.formatNegation($))),
          ($ = this.removeFormatting($)),
          this.formatNumString($)
        )
      }),
      (a.prototype.isCharacterAFormat = function($, j) {
        var _e = this.props,
          et = _e.format,
          tt = _e.prefix,
          rt = _e.suffix,
          nt = _e.decimalScale,
          it = _e.fixedDecimalScale,
          ot = this.getSeparators(),
          at = ot.decimalSeparator
        return !!(
          (typeof et == 'string' && et[$] !== '#') ||
          (!et &&
            ($ < tt.length ||
              $ >= j.length - rt.length ||
              (nt && it && j[$] === at)))
        )
      }),
      (a.prototype.correctInputValue = function($, j, _e) {
        var et = this,
          tt = this.props,
          rt = tt.format,
          nt = tt.allowNegative,
          it = tt.prefix,
          ot = tt.suffix,
          at = tt.decimalScale,
          st = this.getSeparators(),
          ut = st.allowedDecimalSeparators,
          ct = st.decimalSeparator,
          dt = this.state.numAsString || '',
          ft = this.selectionBeforeInput,
          mt = ft.selectionStart,
          vt = ft.selectionEnd,
          yt = findChangedIndex(j, _e),
          pt = yt.start,
          ht = yt.end
        if (!rt && pt === ht && ut.indexOf(_e[mt]) !== -1) {
          var At = at === 0 ? '' : ct
          return _e.substr(0, mt) + At + _e.substr(mt + 1, _e.length)
        }
        var wt = rt ? 0 : it.length,
          Ct = j.length - (rt ? 0 : ot.length)
        if (
          _e.length > j.length ||
          !_e.length ||
          pt === ht ||
          (mt === 0 && vt === j.length) ||
          (pt === 0 && ht === j.length) ||
          (mt === wt && vt === Ct)
        )
          return _e
        var Dt = j.substr(pt, ht - pt),
          jt = !![].concat(Dt).find(function(Nt, $t) {
            return et.isCharacterAFormat($t + pt, j)
          })
        if (jt) {
          var Et = j.substr(pt),
            St = {},
            Bt = []
          ;[].concat(Et).forEach(function(Nt, $t) {
            et.isCharacterAFormat($t + pt, j)
              ? (St[$t] = Nt)
              : $t > Dt.length - 1 && Bt.push(Nt)
          }),
            Object.keys(St).forEach(function(Nt) {
              Bt.length > Nt ? Bt.splice(Nt, 0, St[Nt]) : Bt.push(St[Nt])
            }),
            (_e = j.substr(0, pt) + Bt.join(''))
        }
        if (!rt) {
          var Mt = this.removeFormatting(_e),
            Ut = splitDecimal(Mt, nt),
            Wt = Ut.beforeDecimal,
            Tt = Ut.afterDecimal,
            kt = Ut.addNegation,
            Ot = $ < _e.indexOf(ct) + 1
          if (Mt.length < dt.length && Ot && Wt === '' && !parseFloat(Tt))
            return kt ? '-' : ''
        }
        return _e
      }),
      (a.prototype.updateValue = function($) {
        var j = $.formattedValue,
          _e = $.input,
          et = $.setCaretPosition
        et === void 0 && (et = !0)
        var tt = $.source,
          rt = $.event,
          nt = $.numAsString,
          it = $.caretPos,
          ot = this.props,
          at = ot.onValueChange,
          st = this.state,
          ut = st.value
        if (_e) {
          if (it === void 0 && et) {
            var ct = $.inputValue || _e.value,
              dt = getCurrentCaretPosition(_e)
            ;(_e.value = j), (it = this.getCaretPosition(ct, j, dt))
          }
          ;(_e.value = j), et && this.setPatchedCaretPosition(_e, it, j)
        }
        nt === void 0 && (nt = this.removeFormatting(j)),
          j !== ut &&
            (this.setState({ value: j, numAsString: nt }),
            at(this.getValueObject(j, nt), { event: rt, source: tt }))
      }),
      (a.prototype.onChange = function($) {
        var j = $.target,
          _e = j.value,
          et = this,
          tt = et.state,
          rt = et.props,
          nt = rt.isAllowed,
          it = tt.value || '',
          ot = getCurrentCaretPosition(j)
        _e = this.correctInputValue(ot, it, _e)
        var at = this.formatInput(_e) || '',
          st = this.removeFormatting(at),
          ut = this.getValueObject(at, st),
          ct = nt(ut)
        ct || (at = it),
          this.updateValue({
            formattedValue: at,
            numAsString: st,
            inputValue: _e,
            input: j,
            event: $,
            source: 'event',
          }),
          ct && rt.onChange($)
      }),
      (a.prototype.onBlur = function($) {
        var j = this,
          _e = j.props,
          et = j.state,
          tt = _e.format,
          rt = _e.onBlur,
          nt = _e.allowLeadingZeros,
          it = et.numAsString,
          ot = et.value
        if (
          ((this.focusedElm = null),
          clearTimeout(this.focusTimeout),
          clearTimeout(this.caretPositionTimeout),
          !tt)
        ) {
          isNaN(parseFloat(it)) && (it = ''), nt || (it = fixLeadingZero(it))
          var at = this.formatNumString(it)
          if (at !== ot) {
            this.updateValue({
              formattedValue: at,
              numAsString: it,
              input: $.target,
              setCaretPosition: !1,
              event: $,
              source: 'event',
            }),
              rt($)
            return
          }
        }
        rt($)
      }),
      (a.prototype.onKeyDown = function($) {
        var j = $.target,
          _e = $.key,
          et = j.selectionStart,
          tt = j.selectionEnd,
          rt = j.value
        rt === void 0 && (rt = '')
        var nt,
          it = this.props,
          ot = it.decimalScale,
          at = it.fixedDecimalScale,
          st = it.prefix,
          ut = it.suffix,
          ct = it.format,
          dt = it.onKeyDown,
          ft = ot !== void 0 && at,
          mt = this.getNumberRegex(!1, ft),
          vt = new RegExp('-'),
          yt = typeof ct == 'string'
        if (
          ((this.selectionBeforeInput = {
            selectionStart: et,
            selectionEnd: tt,
          }),
          _e === 'ArrowLeft' || _e === 'Backspace'
            ? (nt = et - 1)
            : _e === 'ArrowRight'
            ? (nt = et + 1)
            : _e === 'Delete' && (nt = et),
          nt === void 0 || et !== tt)
        ) {
          dt($)
          return
        }
        var pt = nt,
          ht = yt ? ct.indexOf('#') : st.length,
          At = yt ? ct.lastIndexOf('#') + 1 : rt.length - ut.length
        if (_e === 'ArrowLeft' || _e === 'ArrowRight') {
          var wt = _e === 'ArrowLeft' ? 'left' : 'right'
          pt = this.correctCaretPosition(rt, nt, wt)
        } else if (_e === 'Delete' && !mt.test(rt[nt]) && !vt.test(rt[nt]))
          for (; !mt.test(rt[pt]) && pt < At; ) pt++
        else if (_e === 'Backspace' && !mt.test(rt[nt])) {
          if (et <= ht + 1 && rt[0] === '-' && typeof ct > 'u') {
            var Ct = rt.substring(1)
            this.updateValue({
              formattedValue: Ct,
              caretPos: pt,
              input: j,
              event: $,
              source: 'event',
            })
          } else if (!vt.test(rt[nt])) {
            for (; !mt.test(rt[pt - 1]) && pt > ht; ) pt--
            pt = this.correctCaretPosition(rt, pt, 'left')
          }
        }
        ;(pt !== nt || nt < ht || nt > At) &&
          ($.preventDefault(), this.setPatchedCaretPosition(j, pt, rt)),
          $.isUnitTestRun && this.setPatchedCaretPosition(j, pt, rt),
          dt($)
      }),
      (a.prototype.onMouseUp = function($) {
        var j = $.target,
          _e = j.selectionStart,
          et = j.selectionEnd,
          tt = j.value
        if ((tt === void 0 && (tt = ''), _e === et)) {
          var rt = this.correctCaretPosition(tt, _e)
          rt !== _e && this.setPatchedCaretPosition(j, rt, tt)
        }
        this.props.onMouseUp($)
      }),
      (a.prototype.onFocus = function($) {
        var j = this
        $.persist(),
          (this.focusedElm = $.target),
          (this.focusTimeout = setTimeout(function() {
            var _e = $.target,
              et = _e.selectionStart,
              tt = _e.selectionEnd,
              rt = _e.value
            rt === void 0 && (rt = '')
            var nt = j.correctCaretPosition(rt, et)
            nt !== et &&
              !(et === 0 && tt === rt.length) &&
              j.setPatchedCaretPosition(_e, nt, rt),
              j.props.onFocus($)
          }, 0))
      }),
      (a.prototype.render = function() {
        var $ = this.props,
          j = $.type,
          _e = $.displayType,
          et = $.customInput,
          tt = $.renderText,
          rt = $.getInputRef,
          nt = $.format
        $.thousandSeparator,
          $.decimalSeparator,
          $.allowedDecimalSeparators,
          $.thousandsGroupStyle,
          $.decimalScale,
          $.fixedDecimalScale,
          $.prefix,
          $.suffix,
          $.removeFormatting,
          $.mask,
          $.defaultValue,
          $.isNumericString,
          $.allowNegative,
          $.allowEmptyFormatting,
          $.allowLeadingZeros,
          $.onValueChange,
          $.isAllowed,
          $.customNumerals,
          $.onChange,
          $.onKeyDown,
          $.onMouseUp,
          $.onFocus,
          $.onBlur,
          $.value
        var it = objectWithoutProperties$1($, [
            'type',
            'displayType',
            'customInput',
            'renderText',
            'getInputRef',
            'format',
            'thousandSeparator',
            'decimalSeparator',
            'allowedDecimalSeparators',
            'thousandsGroupStyle',
            'decimalScale',
            'fixedDecimalScale',
            'prefix',
            'suffix',
            'removeFormatting',
            'mask',
            'defaultValue',
            'isNumericString',
            'allowNegative',
            'allowEmptyFormatting',
            'allowLeadingZeros',
            'onValueChange',
            'isAllowed',
            'customNumerals',
            'onChange',
            'onKeyDown',
            'onMouseUp',
            'onFocus',
            'onBlur',
            'value',
          ]),
          ot = it,
          at = this.state,
          st = at.value,
          ut = at.mounted,
          ct = ut && addInputMode(nt) ? 'numeric' : void 0,
          dt = Object.assign({ inputMode: ct }, ot, {
            type: j,
            value: st,
            onChange: this.onChange,
            onKeyDown: this.onKeyDown,
            onMouseUp: this.onMouseUp,
            onFocus: this.onFocus,
            onBlur: this.onBlur,
          })
        if (_e === 'text')
          return tt
            ? tt(st, ot) || null
            : React$5.createElement(
                'span',
                Object.assign({}, ot, { ref: rt }),
                st
              )
        if (et) {
          var ft = et
          return React$5.createElement(ft, Object.assign({}, dt, { ref: rt }))
        }
        return React$5.createElement(
          'input',
          Object.assign({}, dt, { ref: rt })
        )
      }),
      a
    )
  })(React$5.Component)
NumberFormat.defaultProps = defaultProps
const MoneyNumberFormat = reactExports.forwardRef(
    ({ max: o, min: a, onChange: s, setLoanInputValue: $, ...j }, _e) =>
      jsxRuntimeExports.jsx(NumberFormat, {
        fixedDecimalScale: !0,
        thousandSeparator: !0,
        getInputRef: _e,
        ...j,
        allowNegative: !1,
        decimalScale: 2,
        prefix: '$',
        isAllowed: ({ floatValue: et = 0 }) => a >= 0 && et <= o,
        onValueChange: ({ floatValue: et = 0 }) => s(et),
      })
  ),
  AccountingView = ({
    handleClickLoanPaydownButton: o,
    handleClickTakeOutLoanButton: a,
    loanBalance: s,
    money: $,
  }) => {
    const [j, _e] = reactExports.useState(Math.min(s, $))
    return (
      reactExports.useEffect(() => _e(Math.min(s, $)), [s, $]),
      jsxRuntimeExports.jsx('div', {
        className: 'AccountingView',
        children: jsxRuntimeExports.jsxs(Card, {
          children: [
            jsxRuntimeExports.jsx(CardHeader, {
              avatar: jsxRuntimeExports.jsx(default_1$a, {}),
              title: 'Loan Balance',
              subheader: jsxRuntimeExports.jsx('p', {
                children: moneyString(s),
              }),
            }),
            jsxRuntimeExports.jsxs(CardContent, {
              children: [
                jsxRuntimeExports.jsxs('div', {
                  className: 'loan-container',
                  children: [
                    jsxRuntimeExports.jsx(TextField, {
                      variant: 'standard',
                      value: j,
                      inputProps: { max: s, min: 0, pattern: '[0-9]*' },
                      onChange: et => {
                        _e(Number(et))
                      },
                      InputProps: { inputComponent: MoneyNumberFormat },
                    }),
                    jsxRuntimeExports.jsx(Button, {
                      color: 'primary',
                      disabled: s === 0,
                      variant: 'contained',
                      onClick: () => {
                        o(j), _e(s - j)
                      },
                      children: 'Pay into loan',
                    }),
                    jsxRuntimeExports.jsxs('p', {
                      children: [
                        'You may take out a Hardship Assistance Loan if your funds fall below ',
                        dollarString(STANDARD_LOAN_AMOUNT),
                        '. So long as you have an outstanding loan balance, all farm product sales are garnished by',
                        ' ',
                        LOAN_GARNISHMENT_RATE * 100,
                        '% until the loan is repaid. The loan interest rate is ',
                        LOAN_INTEREST_RATE * 100,
                        '% per day, compounded daily.',
                      ],
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(Button, {
                  color: 'error',
                  disabled: $ >= STANDARD_LOAN_AMOUNT,
                  onClick: () => {
                    a(STANDARD_LOAN_AMOUNT),
                      _e(
                        Math.min(
                          moneyTotal(j, STANDARD_LOAN_AMOUNT),
                          moneyTotal($, STANDARD_LOAN_AMOUNT)
                        )
                      )
                  },
                  variant: 'contained',
                  children: [
                    'Take out a ',
                    dollarString(STANDARD_LOAN_AMOUNT),
                    ' loan',
                  ],
                }),
              ],
            }),
          ],
        }),
      })
    )
  }
AccountingView.propTypes = {
  handleClickTakeOutLoanButton: propTypesExports.func.isRequired,
  handleClickLoanPaydownButton: propTypesExports.func.isRequired,
  loanBalance: propTypesExports.number.isRequired,
  money: propTypesExports.number.isRequired,
}
function Consumer$m(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(AccountingView, { ...a, ...s, ...o }),
  })
}
const _excluded$n = [
    'className',
    'elementType',
    'ownerState',
    'externalForwardedProps',
    'getSlotOwnerState',
    'internalForwardedProps',
  ],
  _excluded2 = ['component', 'slots', 'slotProps'],
  _excluded3 = ['component']
function useSlot(o, a) {
  const {
      className: s,
      elementType: $,
      ownerState: j,
      externalForwardedProps: _e,
      getSlotOwnerState: et,
      internalForwardedProps: tt,
    } = a,
    rt = _objectWithoutPropertiesLoose$3(a, _excluded$n),
    {
      component: nt,
      slots: it = { [o]: void 0 },
      slotProps: ot = { [o]: void 0 },
    } = _e,
    at = _objectWithoutPropertiesLoose$3(_e, _excluded2),
    st = it[o] || $,
    ut = resolveComponentProps(ot[o], j),
    ct = mergeSlotProps(
      _extends$5({ className: s }, rt, {
        externalForwardedProps: o === 'root' ? at : void 0,
        externalSlotProps: ut,
      })
    ),
    {
      props: { component: dt },
      internalRef: ft,
    } = ct,
    mt = _objectWithoutPropertiesLoose$3(ct.props, _excluded3),
    vt = useForkRef(ft, ut == null ? void 0 : ut.ref, a.ref),
    yt = et ? et(mt) : {},
    pt = _extends$5({}, j, yt),
    ht = o === 'root' ? dt || nt : dt,
    At = appendOwnerState(
      st,
      _extends$5(
        {},
        o === 'root' && !nt && !it[o] && tt,
        o !== 'root' && !it[o] && tt,
        mt,
        ht && { as: ht },
        { ref: vt }
      ),
      pt
    )
  return (
    Object.keys(yt).forEach(wt => {
      delete At[wt]
    }),
    [st, At]
  )
}
function getAlertUtilityClass(o) {
  return generateUtilityClass('MuiAlert', o)
}
const alertClasses = generateUtilityClasses('MuiAlert', [
  'root',
  'action',
  'icon',
  'message',
  'filled',
  'colorSuccess',
  'colorInfo',
  'colorWarning',
  'colorError',
  'filledSuccess',
  'filledInfo',
  'filledWarning',
  'filledError',
  'outlined',
  'outlinedSuccess',
  'outlinedInfo',
  'outlinedWarning',
  'outlinedError',
  'standard',
  'standardSuccess',
  'standardInfo',
  'standardWarning',
  'standardError',
])
function getIconButtonUtilityClass(o) {
  return generateUtilityClass('MuiIconButton', o)
}
const iconButtonClasses = generateUtilityClasses('MuiIconButton', [
    'root',
    'disabled',
    'colorInherit',
    'colorPrimary',
    'colorSecondary',
    'colorError',
    'colorInfo',
    'colorSuccess',
    'colorWarning',
    'edgeStart',
    'edgeEnd',
    'sizeSmall',
    'sizeMedium',
    'sizeLarge',
  ]),
  _excluded$m = [
    'edge',
    'children',
    'className',
    'color',
    'disabled',
    'disableFocusRipple',
    'size',
  ],
  useUtilityClasses$k = o => {
    const { classes: a, disabled: s, color: $, edge: j, size: _e } = o,
      et = {
        root: [
          'root',
          s && 'disabled',
          $ !== 'default' && `color${capitalize$2($)}`,
          j && `edge${capitalize$2(j)}`,
          `size${capitalize$2(_e)}`,
        ],
      }
    return composeClasses(et, getIconButtonUtilityClass, a)
  },
  IconButtonRoot = styled(ButtonBase, {
    name: 'MuiIconButton',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        s.color !== 'default' && a[`color${capitalize$2(s.color)}`],
        s.edge && a[`edge${capitalize$2(s.edge)}`],
        a[`size${capitalize$2(s.size)}`],
      ]
    },
  })(
    ({ theme: o, ownerState: a }) =>
      _extends$5(
        {
          textAlign: 'center',
          flex: '0 0 auto',
          fontSize: o.typography.pxToRem(24),
          padding: 8,
          borderRadius: '50%',
          overflow: 'visible',
          color: (o.vars || o).palette.action.active,
          transition: o.transitions.create('background-color', {
            duration: o.transitions.duration.shortest,
          }),
        },
        !a.disableRipple && {
          '&:hover': {
            backgroundColor: o.vars
              ? `rgba(${o.vars.palette.action.activeChannel} / ${o.vars.palette.action.hoverOpacity})`
              : alpha_1(o.palette.action.active, o.palette.action.hoverOpacity),
            '@media (hover: none)': { backgroundColor: 'transparent' },
          },
        },
        a.edge === 'start' && { marginLeft: a.size === 'small' ? -3 : -12 },
        a.edge === 'end' && { marginRight: a.size === 'small' ? -3 : -12 }
      ),
    ({ theme: o, ownerState: a }) => {
      var s
      const $ = (s = (o.vars || o).palette) == null ? void 0 : s[a.color]
      return _extends$5(
        {},
        a.color === 'inherit' && { color: 'inherit' },
        a.color !== 'inherit' &&
          a.color !== 'default' &&
          _extends$5(
            { color: $ == null ? void 0 : $.main },
            !a.disableRipple && {
              '&:hover': _extends$5(
                {},
                $ && {
                  backgroundColor: o.vars
                    ? `rgba(${$.mainChannel} / ${o.vars.palette.action.hoverOpacity})`
                    : alpha_1($.main, o.palette.action.hoverOpacity),
                },
                { '@media (hover: none)': { backgroundColor: 'transparent' } }
              ),
            }
          ),
        a.size === 'small' && {
          padding: 5,
          fontSize: o.typography.pxToRem(18),
        },
        a.size === 'large' && {
          padding: 12,
          fontSize: o.typography.pxToRem(28),
        },
        {
          [`&.${iconButtonClasses.disabled}`]: {
            backgroundColor: 'transparent',
            color: (o.vars || o).palette.action.disabled,
          },
        }
      )
    }
  ),
  IconButton = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiIconButton' }),
      {
        edge: j = !1,
        children: _e,
        className: et,
        color: tt = 'default',
        disabled: rt = !1,
        disableFocusRipple: nt = !1,
        size: it = 'medium',
      } = $,
      ot = _objectWithoutPropertiesLoose$3($, _excluded$m),
      at = _extends$5({}, $, {
        edge: j,
        color: tt,
        disabled: rt,
        disableFocusRipple: nt,
        size: it,
      }),
      st = useUtilityClasses$k(at)
    return jsxRuntimeExports.jsx(
      IconButtonRoot,
      _extends$5(
        {
          className: clsx$1(st.root, et),
          centerRipple: !0,
          focusRipple: !nt,
          disabled: rt,
          ref: s,
        },
        ot,
        { ownerState: at, children: _e }
      )
    )
  }),
  SuccessOutlinedIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M20,12A8,8 0 0,1 12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4C12.76,4 13.5,4.11 14.2, 4.31L15.77,2.74C14.61,2.26 13.34,2 12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0, 0 22,12M7.91,10.08L6.5,11.5L11,16L21,6L19.59,4.58L11,13.17L7.91,10.08Z',
    }),
    'SuccessOutlined'
  ),
  ReportProblemOutlinedIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M12 5.99L19.53 19H4.47L12 5.99M12 2L1 21h22L12 2zm1 14h-2v2h2v-2zm0-6h-2v4h2v-4z',
    }),
    'ReportProblemOutlined'
  ),
  ErrorOutlineIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z',
    }),
    'ErrorOutline'
  ),
  InfoOutlinedIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20, 12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10, 10 0 0,0 12,2M11,17H13V11H11V17Z',
    }),
    'InfoOutlined'
  ),
  CloseIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z',
    }),
    'Close'
  ),
  _excluded$l = [
    'action',
    'children',
    'className',
    'closeText',
    'color',
    'components',
    'componentsProps',
    'icon',
    'iconMapping',
    'onClose',
    'role',
    'severity',
    'slotProps',
    'slots',
    'variant',
  ],
  useUtilityClasses$j = o => {
    const { variant: a, color: s, severity: $, classes: j } = o,
      _e = {
        root: [
          'root',
          `color${capitalize$2(s || $)}`,
          `${a}${capitalize$2(s || $)}`,
          `${a}`,
        ],
        icon: ['icon'],
        message: ['message'],
        action: ['action'],
      }
    return composeClasses(_e, getAlertUtilityClass, j)
  },
  AlertRoot = styled(Paper, {
    name: 'MuiAlert',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        a[s.variant],
        a[`${s.variant}${capitalize$2(s.color || s.severity)}`],
      ]
    },
  })(({ theme: o }) => {
    const a = o.palette.mode === 'light' ? darken_1 : lighten_1,
      s = o.palette.mode === 'light' ? lighten_1 : darken_1
    return _extends$5({}, o.typography.body2, {
      backgroundColor: 'transparent',
      display: 'flex',
      padding: '6px 16px',
      variants: [
        ...Object.entries(o.palette)
          .filter(([, $]) => $.main && $.light)
          .map(([$]) => ({
            props: { colorSeverity: $, variant: 'standard' },
            style: {
              color: o.vars
                ? o.vars.palette.Alert[`${$}Color`]
                : a(o.palette[$].light, 0.6),
              backgroundColor: o.vars
                ? o.vars.palette.Alert[`${$}StandardBg`]
                : s(o.palette[$].light, 0.9),
              [`& .${alertClasses.icon}`]: o.vars
                ? { color: o.vars.palette.Alert[`${$}IconColor`] }
                : { color: o.palette[$].main },
            },
          })),
        ...Object.entries(o.palette)
          .filter(([, $]) => $.main && $.light)
          .map(([$]) => ({
            props: { colorSeverity: $, variant: 'outlined' },
            style: {
              color: o.vars
                ? o.vars.palette.Alert[`${$}Color`]
                : a(o.palette[$].light, 0.6),
              border: `1px solid ${(o.vars || o).palette[$].light}`,
              [`& .${alertClasses.icon}`]: o.vars
                ? { color: o.vars.palette.Alert[`${$}IconColor`] }
                : { color: o.palette[$].main },
            },
          })),
        ...Object.entries(o.palette)
          .filter(([, $]) => $.main && $.dark)
          .map(([$]) => ({
            props: { colorSeverity: $, variant: 'filled' },
            style: _extends$5(
              { fontWeight: o.typography.fontWeightMedium },
              o.vars
                ? {
                    color: o.vars.palette.Alert[`${$}FilledColor`],
                    backgroundColor: o.vars.palette.Alert[`${$}FilledBg`],
                  }
                : {
                    backgroundColor:
                      o.palette.mode === 'dark'
                        ? o.palette[$].dark
                        : o.palette[$].main,
                    color: o.palette.getContrastText(o.palette[$].main),
                  }
            ),
          })),
      ],
    })
  }),
  AlertIcon = styled('div', {
    name: 'MuiAlert',
    slot: 'Icon',
    overridesResolver: (o, a) => a.icon,
  })({
    marginRight: 12,
    padding: '7px 0',
    display: 'flex',
    fontSize: 22,
    opacity: 0.9,
  }),
  AlertMessage = styled('div', {
    name: 'MuiAlert',
    slot: 'Message',
    overridesResolver: (o, a) => a.message,
  })({ padding: '8px 0', minWidth: 0, overflow: 'auto' }),
  AlertAction = styled('div', {
    name: 'MuiAlert',
    slot: 'Action',
    overridesResolver: (o, a) => a.action,
  })({
    display: 'flex',
    alignItems: 'flex-start',
    padding: '4px 0 0 16px',
    marginLeft: 'auto',
    marginRight: -8,
  }),
  defaultIconMapping = {
    success: jsxRuntimeExports.jsx(SuccessOutlinedIcon, {
      fontSize: 'inherit',
    }),
    warning: jsxRuntimeExports.jsx(ReportProblemOutlinedIcon, {
      fontSize: 'inherit',
    }),
    error: jsxRuntimeExports.jsx(ErrorOutlineIcon, { fontSize: 'inherit' }),
    info: jsxRuntimeExports.jsx(InfoOutlinedIcon, { fontSize: 'inherit' }),
  },
  Alert = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiAlert' }),
      {
        action: j,
        children: _e,
        className: et,
        closeText: tt = 'Close',
        color: rt,
        components: nt = {},
        componentsProps: it = {},
        icon: ot,
        iconMapping: at = defaultIconMapping,
        onClose: st,
        role: ut = 'alert',
        severity: ct = 'success',
        slotProps: dt = {},
        slots: ft = {},
        variant: mt = 'standard',
      } = $,
      vt = _objectWithoutPropertiesLoose$3($, _excluded$l),
      yt = _extends$5({}, $, {
        color: rt,
        severity: ct,
        variant: mt,
        colorSeverity: rt || ct,
      }),
      pt = useUtilityClasses$j(yt),
      ht = {
        slots: _extends$5(
          { closeButton: nt.CloseButton, closeIcon: nt.CloseIcon },
          ft
        ),
        slotProps: _extends$5({}, it, dt),
      },
      [At, wt] = useSlot('closeButton', {
        elementType: IconButton,
        externalForwardedProps: ht,
        ownerState: yt,
      }),
      [Ct, Dt] = useSlot('closeIcon', {
        elementType: CloseIcon,
        externalForwardedProps: ht,
        ownerState: yt,
      })
    return jsxRuntimeExports.jsxs(
      AlertRoot,
      _extends$5(
        {
          role: ut,
          elevation: 0,
          ownerState: yt,
          className: clsx$1(pt.root, et),
          ref: s,
        },
        vt,
        {
          children: [
            ot !== !1
              ? jsxRuntimeExports.jsx(AlertIcon, {
                  ownerState: yt,
                  className: pt.icon,
                  children: ot || at[ct] || defaultIconMapping[ct],
                })
              : null,
            jsxRuntimeExports.jsx(AlertMessage, {
              ownerState: yt,
              className: pt.message,
              children: _e,
            }),
            j != null
              ? jsxRuntimeExports.jsx(AlertAction, {
                  ownerState: yt,
                  className: pt.action,
                  children: j,
                })
              : null,
            j == null && st
              ? jsxRuntimeExports.jsx(AlertAction, {
                  ownerState: yt,
                  className: pt.action,
                  children: jsxRuntimeExports.jsx(
                    At,
                    _extends$5(
                      {
                        size: 'small',
                        'aria-label': tt,
                        title: tt,
                        color: 'inherit',
                        onClick: st,
                      },
                      wt,
                      {
                        children: jsxRuntimeExports.jsx(
                          Ct,
                          _extends$5({ fontSize: 'small' }, Dt)
                        ),
                      }
                    )
                  ),
                })
              : null,
          ],
        }
      )
    )
  })
var immutable$2 = extend$4,
  hasOwnProperty$2 = Object.prototype.hasOwnProperty
function extend$4() {
  for (var o = {}, a = 0; a < arguments.length; a++) {
    var s = arguments[a]
    for (var $ in s) hasOwnProperty$2.call(s, $) && (o[$] = s[$])
  }
  return o
}
var hasOwn = Object.prototype.hasOwnProperty,
  toStr = Object.prototype.toString,
  defineProperty = Object.defineProperty,
  gOPD = Object.getOwnPropertyDescriptor,
  isArray = function o(a) {
    return typeof Array.isArray == 'function'
      ? Array.isArray(a)
      : toStr.call(a) === '[object Array]'
  },
  isPlainObject = function o(a) {
    if (!a || toStr.call(a) !== '[object Object]') return !1
    var s = hasOwn.call(a, 'constructor'),
      $ =
        a.constructor &&
        a.constructor.prototype &&
        hasOwn.call(a.constructor.prototype, 'isPrototypeOf')
    if (a.constructor && !s && !$) return !1
    var j
    for (j in a);
    return typeof j > 'u' || hasOwn.call(a, j)
  },
  setProperty = function o(a, s) {
    defineProperty && s.name === '__proto__'
      ? defineProperty(a, s.name, {
          enumerable: !0,
          configurable: !0,
          value: s.newValue,
          writable: !0,
        })
      : (a[s.name] = s.newValue)
  },
  getProperty = function o(a, s) {
    if (s === '__proto__')
      if (hasOwn.call(a, s)) {
        if (gOPD) return gOPD(a, s).value
      } else return
    return a[s]
  },
  extend$3 = function o() {
    var a,
      s,
      $,
      j,
      _e,
      et,
      tt = arguments[0],
      rt = 1,
      nt = arguments.length,
      it = !1
    for (
      typeof tt == 'boolean' &&
        ((it = tt), (tt = arguments[1] || {}), (rt = 2)),
        (tt == null || (typeof tt != 'object' && typeof tt != 'function')) &&
          (tt = {});
      rt < nt;
      ++rt
    )
      if (((a = arguments[rt]), a != null))
        for (s in a)
          ($ = getProperty(tt, s)),
            (j = getProperty(a, s)),
            tt !== j &&
              (it && j && (isPlainObject(j) || (_e = isArray(j)))
                ? (_e
                    ? ((_e = !1), (et = $ && isArray($) ? $ : []))
                    : (et = $ && isPlainObject($) ? $ : {}),
                  setProperty(tt, { name: s, newValue: o(it, et, j) }))
                : typeof j < 'u' && setProperty(tt, { name: s, newValue: j }))
    return tt
  },
  bail_1 = bail$1
function bail$1(o) {
  if (o) throw o
}
var own$3 = {}.hasOwnProperty,
  unistUtilStringifyPosition = stringify$1
function stringify$1(o) {
  return !o || typeof o != 'object'
    ? null
    : own$3.call(o, 'position') || own$3.call(o, 'type')
    ? position(o.position)
    : own$3.call(o, 'start') || own$3.call(o, 'end')
    ? position(o)
    : own$3.call(o, 'line') || own$3.call(o, 'column')
    ? point(o)
    : null
}
function point(o) {
  return (
    (!o || typeof o != 'object') && (o = {}),
    index(o.line) + ':' + index(o.column)
  )
}
function position(o) {
  return (
    (!o || typeof o != 'object') && (o = {}),
    point(o.start) + '-' + point(o.end)
  )
}
function index(o) {
  return o && typeof o == 'number' ? o : 1
}
var stringify = unistUtilStringifyPosition,
  vfileMessage = VMessage$1
function VMessagePrototype() {}
VMessagePrototype.prototype = Error.prototype
VMessage$1.prototype = new VMessagePrototype()
var proto$3 = VMessage$1.prototype
proto$3.file = ''
proto$3.name = ''
proto$3.reason = ''
proto$3.message = ''
proto$3.stack = ''
proto$3.fatal = null
proto$3.column = null
proto$3.line = null
function VMessage$1(o, a, s) {
  var $, j, _e
  typeof a == 'string' && ((s = a), (a = null)),
    ($ = parseOrigin(s)),
    (j = stringify(a) || '1:1'),
    (_e = {
      start: { line: null, column: null },
      end: { line: null, column: null },
    }),
    a && a.position && (a = a.position),
    a && (a.start ? ((_e = a), (a = a.start)) : (_e.start = a)),
    o.stack && ((this.stack = o.stack), (o = o.message)),
    (this.message = o),
    (this.name = j),
    (this.reason = o),
    (this.line = a ? a.line : null),
    (this.column = a ? a.column : null),
    (this.location = _e),
    (this.source = $[0]),
    (this.ruleId = $[1])
}
function parseOrigin(o) {
  var a = [null, null],
    s
  return (
    typeof o == 'string' &&
      ((s = o.indexOf(':')),
      s === -1
        ? (a[1] = o)
        : ((a[0] = o.slice(0, s)), (a[1] = o.slice(s + 1)))),
    a
  )
}
var path$1 = path$3
function replaceExt(o, a) {
  if (typeof o != 'string' || o.length === 0) return o
  var s = path$1.basename(o, path$1.extname(o)) + a
  return path$1.join(path$1.dirname(o), s)
}
var replaceExt_1 = replaceExt
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var isBuffer_1 = function(o) {
  return o != null && (isBuffer(o) || isSlowBuffer(o) || !!o._isBuffer)
}
function isBuffer(o) {
  return (
    !!o.constructor &&
    typeof o.constructor.isBuffer == 'function' &&
    o.constructor.isBuffer(o)
  )
}
function isSlowBuffer(o) {
  return (
    typeof o.readFloatLE == 'function' &&
    typeof o.slice == 'function' &&
    isBuffer(o.slice(0, 0))
  )
}
var path = path$3,
  replace = replaceExt_1,
  buffer = isBuffer_1,
  core = VFile$1,
  own$2 = {}.hasOwnProperty,
  proto$2 = VFile$1.prototype
proto$2.toString = toString$2
var order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname']
function VFile$1(o) {
  var a, s, $
  if (!o) o = {}
  else if (typeof o == 'string' || buffer(o)) o = { contents: o }
  else if ('message' in o && 'messages' in o) return o
  if (!(this instanceof VFile$1)) return new VFile$1(o)
  for (
    this.data = {},
      this.messages = [],
      this.history = [],
      this.cwd = process.cwd(),
      s = -1,
      $ = order.length;
    ++s < $;

  )
    (a = order[s]), own$2.call(o, a) && (this[a] = o[a])
  for (a in o) order.indexOf(a) === -1 && (this[a] = o[a])
}
Object.defineProperty(proto$2, 'path', {
  get: function() {
    return this.history[this.history.length - 1]
  },
  set: function(o) {
    assertNonEmpty(o, 'path'), o !== this.path && this.history.push(o)
  },
})
Object.defineProperty(proto$2, 'dirname', {
  get: function() {
    return typeof this.path == 'string' ? path.dirname(this.path) : void 0
  },
  set: function(o) {
    assertPath(this.path, 'dirname'),
      (this.path = path.join(o || '', this.basename))
  },
})
Object.defineProperty(proto$2, 'basename', {
  get: function() {
    return typeof this.path == 'string' ? path.basename(this.path) : void 0
  },
  set: function(o) {
    assertNonEmpty(o, 'basename'),
      assertPart(o, 'basename'),
      (this.path = path.join(this.dirname || '', o))
  },
})
Object.defineProperty(proto$2, 'extname', {
  get: function() {
    return typeof this.path == 'string' ? path.extname(this.path) : void 0
  },
  set: function(o) {
    var a = o || ''
    if ((assertPart(a, 'extname'), assertPath(this.path, 'extname'), a)) {
      if (a.charAt(0) !== '.') throw new Error('`extname` must start with `.`')
      if (a.indexOf('.', 1) !== -1)
        throw new Error('`extname` cannot contain multiple dots')
    }
    this.path = replace(this.path, a)
  },
})
Object.defineProperty(proto$2, 'stem', {
  get: function() {
    return typeof this.path == 'string'
      ? path.basename(this.path, this.extname)
      : void 0
  },
  set: function(o) {
    assertNonEmpty(o, 'stem'),
      assertPart(o, 'stem'),
      (this.path = path.join(this.dirname || '', o + (this.extname || '')))
  },
})
function toString$2(o) {
  var a = this.contents || ''
  return buffer(a) ? a.toString(o) : String(a)
}
function assertPart(o, a) {
  if (o.indexOf(path.sep) !== -1)
    throw new Error(
      '`' + a + '` cannot be a path: did not expect `' + path.sep + '`'
    )
}
function assertNonEmpty(o, a) {
  if (!o) throw new Error('`' + a + '` cannot be empty')
}
function assertPath(o, a) {
  if (!o) throw new Error('Setting `' + a + '` requires `path` to be set too')
}
var VMessage = vfileMessage,
  VFile = core,
  vfile$1 = VFile,
  proto$1 = VFile.prototype
proto$1.message = message
proto$1.info = info
proto$1.fail = fail
proto$1.warn = message
function message(o, a, s) {
  var $ = this.path,
    j = new VMessage(o, a, s)
  return (
    $ && ((j.name = $ + ':' + j.name), (j.file = $)),
    (j.fatal = !1),
    this.messages.push(j),
    j
  )
}
function fail() {
  var o = this.message.apply(this, arguments)
  throw ((o.fatal = !0), o)
}
function info() {
  var o = this.message.apply(this, arguments)
  return (o.fatal = null), o
}
var slice$2 = [].slice,
  wrap_1 = wrap$2
function wrap$2(o, a) {
  var s
  return $
  function $() {
    var et = slice$2.call(arguments, 0),
      tt = o.length > et.length,
      rt
    tt && et.push(j)
    try {
      rt = o.apply(null, et)
    } catch (nt) {
      if (tt && s) throw nt
      return j(nt)
    }
    tt ||
      (rt && typeof rt.then == 'function'
        ? rt.then(_e, j)
        : rt instanceof Error
        ? j(rt)
        : _e(rt))
  }
  function j() {
    s || ((s = !0), a.apply(null, arguments))
  }
  function _e(et) {
    j(null, et)
  }
}
var wrap$1 = wrap_1,
  trough_1 = trough$1
trough$1.wrap = wrap$1
var slice$1 = [].slice
function trough$1() {
  var o = [],
    a = {}
  return (a.run = s), (a.use = $), a
  function s() {
    var j = -1,
      _e = slice$1.call(arguments, 0, -1),
      et = arguments[arguments.length - 1]
    if (typeof et != 'function')
      throw new Error('Expected function as last argument, not ' + et)
    tt.apply(null, [null].concat(_e))
    function tt(rt) {
      var nt = o[++j],
        it = slice$1.call(arguments, 0),
        ot = it.slice(1),
        at = _e.length,
        st = -1
      if (rt) {
        et(rt)
        return
      }
      for (; ++st < at; )
        (ot[st] === null || ot[st] === void 0) && (ot[st] = _e[st])
      ;(_e = ot),
        nt ? wrap$1(nt, tt).apply(null, _e) : et.apply(null, [null].concat(_e))
    }
  }
  function $(j) {
    if (typeof j != 'function')
      throw new Error('Expected `fn` to be a function, not ' + j)
    return o.push(j), a
  }
}
var toString$1 = Object.prototype.toString,
  xIsString = isString
function isString(o) {
  return toString$1.call(o) === '[object String]'
}
var toString = Object.prototype.toString,
  isPlainObj = function(o) {
    var a
    return (
      toString.call(o) === '[object Object]' &&
      ((a = Object.getPrototypeOf(o)),
      a === null || a === Object.getPrototypeOf({}))
    )
  },
  extend$2 = extend$3,
  bail = bail_1,
  vfile = vfile$1,
  trough = trough_1,
  string = xIsString,
  plain = isPlainObj,
  unified_1 = unified$1().freeze(),
  slice = [].slice,
  own$1 = {}.hasOwnProperty,
  pipeline = trough()
    .use(pipelineParse)
    .use(pipelineRun)
    .use(pipelineStringify)
function pipelineParse(o, a) {
  a.tree = o.parse(a.file)
}
function pipelineRun(o, a, s) {
  o.run(a.tree, a.file, $)
  function $(j, _e, et) {
    j ? s(j) : ((a.tree = _e), (a.file = et), s())
  }
}
function pipelineStringify(o, a) {
  a.file.contents = o.stringify(a.tree, a.file)
}
function unified$1() {
  var o = [],
    a = trough(),
    s = {},
    $ = !1,
    j = -1
  return (
    (_e.data = tt),
    (_e.freeze = et),
    (_e.attachers = o),
    (_e.use = rt),
    (_e.parse = it),
    (_e.stringify = st),
    (_e.run = ot),
    (_e.runSync = at),
    (_e.process = ut),
    (_e.processSync = ct),
    _e
  )
  function _e() {
    for (var dt = unified$1(), ft = o.length, mt = -1; ++mt < ft; )
      dt.use.apply(null, o[mt])
    return dt.data(extend$2(!0, {}, s)), dt
  }
  function et() {
    var dt, ft, mt, vt
    if ($) return _e
    for (; ++j < o.length; )
      (dt = o[j]),
        (ft = dt[0]),
        (mt = dt[1]),
        (vt = null),
        mt !== !1 &&
          (mt === !0 && (dt[1] = void 0),
          (vt = ft.apply(_e, dt.slice(1))),
          typeof vt == 'function' && a.use(vt))
    return ($ = !0), (j = 1 / 0), _e
  }
  function tt(dt, ft) {
    return string(dt)
      ? arguments.length === 2
        ? (assertUnfrozen('data', $), (s[dt] = ft), _e)
        : (own$1.call(s, dt) && s[dt]) || null
      : dt
      ? (assertUnfrozen('data', $), (s = dt), _e)
      : s
  }
  function rt(dt) {
    var ft
    if ((assertUnfrozen('use', $), dt != null))
      if (typeof dt == 'function') pt.apply(null, arguments)
      else if (typeof dt == 'object') 'length' in dt ? yt(dt) : mt(dt)
      else throw new Error('Expected usable value, not `' + dt + '`')
    return ft && (s.settings = extend$2(s.settings || {}, ft)), _e
    function mt(ht) {
      yt(ht.plugins), ht.settings && (ft = extend$2(ft || {}, ht.settings))
    }
    function vt(ht) {
      if (typeof ht == 'function') pt(ht)
      else if (typeof ht == 'object')
        'length' in ht ? pt.apply(null, ht) : mt(ht)
      else throw new Error('Expected usable value, not `' + ht + '`')
    }
    function yt(ht) {
      var At, wt
      if (ht != null)
        if (typeof ht == 'object' && 'length' in ht)
          for (At = ht.length, wt = -1; ++wt < At; ) vt(ht[wt])
        else throw new Error('Expected a list of plugins, not `' + ht + '`')
    }
    function pt(ht, At) {
      var wt = nt(ht)
      wt
        ? (plain(wt[1]) && plain(At) && (At = extend$2(wt[1], At)),
          (wt[1] = At))
        : o.push(slice.call(arguments))
    }
  }
  function nt(dt) {
    for (var ft = o.length, mt = -1, vt; ++mt < ft; )
      if (((vt = o[mt]), vt[0] === dt)) return vt
  }
  function it(dt) {
    var ft = vfile(dt),
      mt
    return (
      et(),
      (mt = _e.Parser),
      assertParser('parse', mt),
      newable(mt) ? new mt(String(ft), ft).parse() : mt(String(ft), ft)
    )
  }
  function ot(dt, ft, mt) {
    if (
      (assertNode(dt),
      et(),
      !mt && typeof ft == 'function' && ((mt = ft), (ft = null)),
      !mt)
    )
      return new Promise(vt)
    vt(null, mt)
    function vt(yt, pt) {
      a.run(dt, vfile(ft), ht)
      function ht(At, wt, Ct) {
        ;(wt = wt || dt), At ? pt(At) : yt ? yt(wt) : mt(null, wt, Ct)
      }
    }
  }
  function at(dt, ft) {
    var mt = !1,
      vt
    return ot(dt, ft, yt), assertDone('runSync', 'run', mt), vt
    function yt(pt, ht) {
      ;(mt = !0), bail(pt), (vt = ht)
    }
  }
  function st(dt, ft) {
    var mt = vfile(ft),
      vt
    return (
      et(),
      (vt = _e.Compiler),
      assertCompiler('stringify', vt),
      assertNode(dt),
      newable(vt) ? new vt(dt, mt).compile() : vt(dt, mt)
    )
  }
  function ut(dt, ft) {
    if (
      (et(),
      assertParser('process', _e.Parser),
      assertCompiler('process', _e.Compiler),
      !ft)
    )
      return new Promise(mt)
    mt(null, ft)
    function mt(vt, yt) {
      var pt = vfile(dt)
      pipeline.run(_e, { file: pt }, ht)
      function ht(At) {
        At ? yt(At) : vt ? vt(pt) : ft(null, pt)
      }
    }
  }
  function ct(dt) {
    var ft = !1,
      mt
    return (
      et(),
      assertParser('processSync', _e.Parser),
      assertCompiler('processSync', _e.Compiler),
      (mt = vfile(dt)),
      ut(mt, vt),
      assertDone('processSync', 'process', ft),
      mt
    )
    function vt(yt) {
      ;(ft = !0), bail(yt)
    }
  }
}
function newable(o) {
  return typeof o == 'function' && keys$1(o.prototype)
}
function keys$1(o) {
  var a
  for (a in o) return !0
  return !1
}
function assertParser(o, a) {
  if (typeof a != 'function')
    throw new Error('Cannot `' + o + '` without `Parser`')
}
function assertCompiler(o, a) {
  if (typeof a != 'function')
    throw new Error('Cannot `' + o + '` without `Compiler`')
}
function assertUnfrozen(o, a) {
  if (a)
    throw new Error(
      [
        'Cannot invoke `' + o + '` on a frozen processor.\nCreate a new ',
        'processor first, by invoking it: use `processor()` instead of ',
        '`processor`.',
      ].join('')
    )
}
function assertNode(o) {
  if (!o || !string(o.type)) throw new Error('Expected node, got `' + o + '`')
}
function assertDone(o, a, s) {
  if (!s) throw new Error('`' + o + '` finished async. Use `' + a + '` instead')
}
var immutable$1 = extend$1,
  hasOwnProperty$1 = Object.prototype.hasOwnProperty
function extend$1() {
  for (var o = {}, a = 0; a < arguments.length; a++) {
    var s = arguments[a]
    for (var $ in s) hasOwnProperty$1.call(s, $) && (o[$] = s[$])
  }
  return o
}
var xtend$6 = immutable$1,
  inherits$1 = inherits_browserExports,
  unherit_1 = unherit$1
function unherit$1(o) {
  var a, s, $
  inherits$1(_e, o), inherits$1(j, _e), (a = _e.prototype)
  for (s in a)
    ($ = a[s]),
      $ &&
        typeof $ == 'object' &&
        (a[s] = 'concat' in $ ? $.concat() : xtend$6($))
  return _e
  function j(et) {
    return o.apply(this, et)
  }
  function _e() {
    return this instanceof _e ? o.apply(this, arguments) : new j(arguments)
  }
}
var immutable = extend,
  hasOwnProperty = Object.prototype.hasOwnProperty
function extend() {
  for (var o = {}, a = 0; a < arguments.length; a++) {
    var s = arguments[a]
    for (var $ in s) hasOwnProperty.call(s, $) && (o[$] = s[$])
  }
  return o
}
var stateToggle = factory$4
function factory$4(o, a, s) {
  return $
  function $() {
    var j = s || this,
      _e = j[o]
    return (j[o] = !a), et
    function et() {
      j[o] = _e
    }
  }
}
var vfileLocation$1 = factory$3
function factory$3(o) {
  var a = indices(String(o))
  return {
    toPosition: offsetToPositionFactory(a),
    toOffset: positionToOffsetFactory(a),
  }
}
function offsetToPositionFactory(o) {
  return a
  function a(s) {
    var $ = -1,
      j = o.length
    if (s < 0) return {}
    for (; ++$ < j; )
      if (o[$] > s)
        return { line: $ + 1, column: s - (o[$ - 1] || 0) + 1, offset: s }
    return {}
  }
}
function positionToOffsetFactory(o) {
  return a
  function a(s) {
    var $ = s && s.line,
      j = s && s.column
    return !isNaN($) && !isNaN(j) && $ - 1 in o
      ? (o[$ - 2] || 0) + j - 1 || 0
      : -1
  }
}
function indices(o) {
  for (
    var a = [],
      s = o.indexOf(`
`);
    s !== -1;

  )
    a.push(s + 1),
      (s = o.indexOf(
        `
`,
        s + 1
      ))
  return a.push(o.length + 1), a
}
var _unescape = factory$2
function factory$2(o, a) {
  return s
  function s($) {
    for (var j = 0, _e = $.indexOf('\\'), et = o[a], tt = [], rt; _e !== -1; )
      tt.push($.slice(j, _e)),
        (j = _e + 1),
        (rt = $.charAt(j)),
        (!rt || et.indexOf(rt) === -1) && tt.push('\\'),
        (_e = $.indexOf('\\', j))
    return tt.push($.slice(j)), tt.join('')
  }
}
const AElig = '',
  AMP = '&',
  Aacute = '',
  Acirc = '',
  Agrave = '',
  Aring = '',
  Atilde = '',
  Auml = '',
  COPY = '',
  Ccedil = '',
  ETH = '',
  Eacute = '',
  Ecirc = '',
  Egrave = '',
  Euml = '',
  GT = '>',
  Iacute = '',
  Icirc = '',
  Igrave = '',
  Iuml = '',
  LT = '<',
  Ntilde = '',
  Oacute = '',
  Ocirc = '',
  Ograve = '',
  Oslash = '',
  Otilde = '',
  Ouml = '',
  QUOT = '"',
  REG = '',
  THORN = '',
  Uacute = '',
  Ucirc = '',
  Ugrave = '',
  Uuml = '',
  Yacute = '',
  aacute = '',
  acirc = '',
  acute = '',
  aelig = '',
  agrave = '',
  amp = '&',
  aring = '',
  atilde = '',
  auml = '',
  brvbar = '',
  ccedil = '',
  cedil = '',
  cent = '',
  copy = '',
  curren = '',
  deg = '',
  divide = '',
  eacute = '',
  ecirc = '',
  egrave = '',
  eth = '',
  euml = '',
  frac12 = '',
  frac14 = '',
  frac34 = '',
  gt = '>',
  iacute = '',
  icirc = '',
  iexcl = '',
  igrave = '',
  iquest = '',
  iuml = '',
  laquo = '',
  lt = '<',
  macr = '',
  micro = '',
  middot = '',
  nbsp = '',
  not = '',
  ntilde = '',
  oacute = '',
  ocirc = '',
  ograve = '',
  ordf = '',
  ordm = '',
  oslash = '',
  otilde = '',
  ouml = '',
  para = '',
  plusmn = '',
  pound = '',
  quot = '"',
  raquo = '',
  reg = '',
  sect = '',
  shy = '',
  sup1 = '',
  sup2 = '',
  sup3 = '',
  szlig = '',
  thorn = '',
  times = '',
  uacute = '',
  ucirc = '',
  ugrave = '',
  uml = '',
  uuml = '',
  yacute = '',
  yen = '',
  yuml = '',
  require$$0$2 = {
    AElig,
    AMP,
    Aacute,
    Acirc,
    Agrave,
    Aring,
    Atilde,
    Auml,
    COPY,
    Ccedil,
    ETH,
    Eacute,
    Ecirc,
    Egrave,
    Euml,
    GT,
    Iacute,
    Icirc,
    Igrave,
    Iuml,
    LT,
    Ntilde,
    Oacute,
    Ocirc,
    Ograve,
    Oslash,
    Otilde,
    Ouml,
    QUOT,
    REG,
    THORN,
    Uacute,
    Ucirc,
    Ugrave,
    Uuml,
    Yacute,
    aacute,
    acirc,
    acute,
    aelig,
    agrave,
    amp,
    aring,
    atilde,
    auml,
    brvbar,
    ccedil,
    cedil,
    cent,
    copy,
    curren,
    deg,
    divide,
    eacute,
    ecirc,
    egrave,
    eth,
    euml,
    frac12,
    frac14,
    frac34,
    gt,
    iacute,
    icirc,
    iexcl,
    igrave,
    iquest,
    iuml,
    laquo,
    lt,
    macr,
    micro,
    middot,
    nbsp,
    not,
    ntilde,
    oacute,
    ocirc,
    ograve,
    ordf,
    ordm,
    oslash,
    otilde,
    ouml,
    para,
    plusmn,
    pound,
    quot,
    raquo,
    reg,
    sect,
    shy,
    sup1,
    sup2,
    sup3,
    szlig,
    thorn,
    times,
    uacute,
    ucirc,
    ugrave,
    uml,
    uuml,
    yacute,
    yen,
    yuml,
  },
  require$$1 = {
    0: '',
    128: '',
    130: '',
    131: '',
    132: '',
    133: '',
    134: '',
    135: '',
    136: '',
    137: '',
    138: '',
    139: '',
    140: '',
    142: '',
    145: '',
    146: '',
    147: '',
    148: '',
    149: '',
    150: '',
    151: '',
    152: '',
    153: '',
    154: '',
    155: '',
    156: '',
    158: '',
    159: '',
  }
var isDecimal = decimal$2
function decimal$2(o) {
  var a = typeof o == 'string' ? o.charCodeAt(0) : o
  return a >= 48 && a <= 57
}
var isHexadecimal = hexadecimal$1
function hexadecimal$1(o) {
  var a = typeof o == 'string' ? o.charCodeAt(0) : o
  return (a >= 97 && a <= 102) || (a >= 65 && a <= 70) || (a >= 48 && a <= 57)
}
var isAlphabetical, hasRequiredIsAlphabetical
function requireIsAlphabetical() {
  if (hasRequiredIsAlphabetical) return isAlphabetical
  ;(hasRequiredIsAlphabetical = 1), (isAlphabetical = o)
  function o(a) {
    var s = typeof a == 'string' ? a.charCodeAt(0) : a
    return (s >= 97 && s <= 122) || (s >= 65 && s <= 90)
  }
  return isAlphabetical
}
var alphabetical = requireIsAlphabetical(),
  decimal$1 = isDecimal,
  isAlphanumerical = alphanumerical$1
function alphanumerical$1(o) {
  return alphabetical(o) || decimal$1(o)
}
var el,
  semicolon$1 = 59,
  decodeEntity_browser = decodeEntity$1
function decodeEntity$1(o) {
  var a = '&' + o + ';',
    s
  return (
    (el = el || document.createElement('i')),
    (el.innerHTML = a),
    (s = el.textContent),
    (s.charCodeAt(s.length - 1) === semicolon$1 && o !== 'semi') || s === a
      ? !1
      : s
  )
}
var legacy = require$$0$2,
  invalid = require$$1,
  decimal = isDecimal,
  hexadecimal = isHexadecimal,
  alphanumerical = isAlphanumerical,
  decodeEntity = decodeEntity_browser,
  parseEntities_1 = parseEntities,
  own = {}.hasOwnProperty,
  fromCharCode = String.fromCharCode,
  noop$3 = Function.prototype,
  defaults$1 = {
    warning: null,
    reference: null,
    text: null,
    warningContext: null,
    referenceContext: null,
    textContext: null,
    position: {},
    additional: null,
    attribute: !1,
    nonTerminated: !0,
  },
  tab = 9,
  lineFeed = 10,
  formFeed = 12,
  space = 32,
  ampersand = 38,
  semicolon = 59,
  lessThan = 60,
  equalsTo = 61,
  numberSign = 35,
  uppercaseX = 88,
  lowercaseX = 120,
  replacementCharacter = 65533,
  name = 'named',
  hexa = 'hexadecimal',
  deci = 'decimal',
  bases = {}
bases[hexa] = 16
bases[deci] = 10
var tests = {}
tests[name] = alphanumerical
tests[deci] = decimal
tests[hexa] = hexadecimal
var namedNotTerminated = 1,
  numericNotTerminated = 2,
  namedEmpty = 3,
  numericEmpty = 4,
  namedUnknown = 5,
  numericDisallowed = 6,
  numericProhibited = 7,
  messages = {}
messages[namedNotTerminated] =
  'Named character references must be terminated by a semicolon'
messages[numericNotTerminated] =
  'Numeric character references must be terminated by a semicolon'
messages[namedEmpty] = 'Named character references cannot be empty'
messages[numericEmpty] = 'Numeric character references cannot be empty'
messages[namedUnknown] = 'Named character references must be known'
messages[numericDisallowed] =
  'Numeric character references cannot be disallowed'
messages[numericProhibited] =
  'Numeric character references cannot be outside the permissible Unicode range'
function parseEntities(o, a) {
  var s = {},
    $,
    j
  a || (a = {})
  for (j in defaults$1) ($ = a[j]), (s[j] = $ ?? defaults$1[j])
  return (
    (s.position.indent || s.position.start) &&
      ((s.indent = s.position.indent || []), (s.position = s.position.start)),
    parse$3(o, s)
  )
}
function parse$3(o, a) {
  var s = a.additional,
    $ = a.nonTerminated,
    j = a.text,
    _e = a.reference,
    et = a.warning,
    tt = a.textContext,
    rt = a.referenceContext,
    nt = a.warningContext,
    it = a.position,
    ot = a.indent || [],
    at = o.length,
    st = 0,
    ut = -1,
    ct = it.column || 1,
    dt = it.line || 1,
    ft = '',
    mt = [],
    vt,
    yt,
    pt,
    ht,
    At,
    wt,
    Ct,
    Dt,
    jt,
    Et,
    St,
    Bt,
    Mt,
    Ut,
    Wt,
    Tt,
    kt,
    Ot,
    Nt
  for (
    typeof s == 'string' && (s = s.charCodeAt(0)),
      Tt = $t(),
      Dt = et ? Pt : noop$3,
      st--,
      at++;
    ++st < at;

  )
    if (
      (At === lineFeed && (ct = ot[ut] || 1),
      (At = o.charCodeAt(st)),
      At === ampersand)
    ) {
      if (
        ((Ct = o.charCodeAt(st + 1)),
        Ct === tab ||
          Ct === lineFeed ||
          Ct === formFeed ||
          Ct === space ||
          Ct === ampersand ||
          Ct === lessThan ||
          Ct !== Ct ||
          (s && Ct === s))
      ) {
        ;(ft += fromCharCode(At)), ct++
        continue
      }
      for (
        Mt = st + 1,
          Bt = Mt,
          Nt = Mt,
          Ct === numberSign
            ? ((Nt = ++Bt),
              (Ct = o.charCodeAt(Nt)),
              Ct === uppercaseX || Ct === lowercaseX
                ? ((Ut = hexa), (Nt = ++Bt))
                : (Ut = deci))
            : (Ut = name),
          vt = '',
          St = '',
          ht = '',
          Wt = tests[Ut],
          Nt--;
        ++Nt < at && ((Ct = o.charCodeAt(Nt)), !!Wt(Ct));

      )
        (ht += fromCharCode(Ct)),
          Ut === name && own.call(legacy, ht) && ((vt = ht), (St = legacy[ht]))
      ;(pt = o.charCodeAt(Nt) === semicolon),
        pt &&
          (Nt++,
          (yt = Ut === name ? decodeEntity(ht) : !1),
          yt && ((vt = ht), (St = yt))),
        (Ot = 1 + Nt - Mt),
        (!pt && !$) ||
          (ht
            ? Ut === name
              ? (pt && !St
                  ? Dt(namedUnknown, 1)
                  : (vt !== ht &&
                      ((Nt = Bt + vt.length), (Ot = 1 + Nt - Bt), (pt = !1)),
                    pt ||
                      ((jt = vt ? namedNotTerminated : namedEmpty),
                      a.attribute
                        ? ((Ct = o.charCodeAt(Nt)),
                          Ct === equalsTo
                            ? (Dt(jt, Ot), (St = null))
                            : alphanumerical(Ct)
                            ? (St = null)
                            : Dt(jt, Ot))
                        : Dt(jt, Ot))),
                (wt = St))
              : (pt || Dt(numericNotTerminated, Ot),
                (wt = parseInt(ht, bases[Ut])),
                prohibited(wt)
                  ? (Dt(numericProhibited, Ot),
                    (wt = fromCharCode(replacementCharacter)))
                  : wt in invalid
                  ? (Dt(numericDisallowed, Ot), (wt = invalid[wt]))
                  : ((Et = ''),
                    disallowed(wt) && Dt(numericDisallowed, Ot),
                    wt > 65535 &&
                      ((wt -= 65536),
                      (Et += fromCharCode((wt >>> 10) | 55296)),
                      (wt = 56320 | (wt & 1023))),
                    (wt = Et + fromCharCode(wt))))
            : Ut !== name && Dt(numericEmpty, Ot)),
        wt
          ? (Ft(),
            (Tt = $t()),
            (st = Nt - 1),
            (ct += Nt - Mt + 1),
            mt.push(wt),
            (kt = $t()),
            kt.offset++,
            _e && _e.call(rt, wt, { start: Tt, end: kt }, o.slice(Mt - 1, Nt)),
            (Tt = kt))
          : ((ht = o.slice(Mt - 1, Nt)),
            (ft += ht),
            (ct += ht.length),
            (st = Nt - 1))
    } else
      At === 10 && (dt++, ut++, (ct = 0)),
        At === At ? ((ft += fromCharCode(At)), ct++) : Ft()
  return mt.join('')
  function $t() {
    return { line: dt, column: ct, offset: st + (it.offset || 0) }
  }
  function Pt(Vt, Xt) {
    var Yt = $t()
    ;(Yt.column += Xt), (Yt.offset += Xt), et.call(nt, messages[Vt], Yt, Vt)
  }
  function Ft() {
    ft &&
      (mt.push(ft), j && j.call(tt, ft, { start: Tt, end: $t() }), (ft = ''))
  }
}
function prohibited(o) {
  return (o >= 55296 && o <= 57343) || o > 1114111
}
function disallowed(o) {
  return (
    (o >= 1 && o <= 8) ||
    o === 11 ||
    (o >= 13 && o <= 31) ||
    (o >= 127 && o <= 159) ||
    (o >= 64976 && o <= 65007) ||
    (o & 65535) === 65535 ||
    (o & 65535) === 65534
  )
}
var xtend$5 = immutable,
  entities = parseEntities_1,
  decode$1 = factory$1
function factory$1(o) {
  return ($.raw = j), $
  function a(_e) {
    for (var et = o.offset, tt = _e.line, rt = []; ++tt && tt in et; )
      rt.push((et[tt] || 0) + 1)
    return { start: _e, indent: rt }
  }
  function s(_e, et, tt) {
    tt !== 3 && o.file.message(_e, et)
  }
  function $(_e, et, tt) {
    entities(_e, {
      position: a(et),
      warning: s,
      text: tt,
      reference: tt,
      textContext: o,
      referenceContext: o,
    })
  }
  function j(_e, et, tt) {
    return entities(_e, xtend$5(tt, { position: a(et), warning: s }))
  }
}
var tokenizer$1 = factory,
  MERGEABLE_NODES = { text: mergeText, blockquote: mergeBlockquote }
function mergeable(o) {
  var a, s
  return o.type !== 'text' || !o.position
    ? !0
    : ((a = o.position.start),
      (s = o.position.end),
      a.line !== s.line || s.column - a.column === o.value.length)
}
function mergeText(o, a) {
  return (o.value += a.value), o
}
function mergeBlockquote(o, a) {
  return this.options.commonmark
    ? a
    : ((o.children = o.children.concat(a.children)), o)
}
function factory(o) {
  return a
  function a(s, $) {
    var j = this,
      _e = j.offset,
      et = [],
      tt = j[o + 'Methods'],
      rt = j[o + 'Tokenizers'],
      nt = $.line,
      it = $.column,
      ot,
      at,
      st,
      ut,
      ct,
      dt
    if (!s) return et
    for (wt.now = vt, wt.file = j.file, ft(''); s; ) {
      for (
        ot = -1, at = tt.length, ct = !1;
        ++ot < at &&
        ((ut = tt[ot]),
        (st = rt[ut]),
        !(
          st &&
          (!st.onlyAtStart || j.atStart) &&
          (!st.notInList || !j.inList) &&
          (!st.notInBlock || !j.inBlock) &&
          (!st.notInLink || !j.inLink) &&
          ((dt = s.length), st.apply(j, [wt, s]), (ct = dt !== s.length), ct)
        ));

      );
      ct || j.file.fail(new Error('Infinite loop'), wt.now())
    }
    return (j.eof = vt()), et
    function ft(Ct) {
      for (
        var Dt = -1,
          jt = Ct.indexOf(`
`);
        jt !== -1;

      )
        nt++,
          (Dt = jt),
          (jt = Ct.indexOf(
            `
`,
            jt + 1
          ))
      Dt === -1 ? (it += Ct.length) : (it = Ct.length - Dt),
        nt in _e &&
          (Dt !== -1 ? (it += _e[nt]) : it <= _e[nt] && (it = _e[nt] + 1))
    }
    function mt() {
      var Ct = [],
        Dt = nt + 1
      return function() {
        for (var jt = nt + 1; Dt < jt; ) Ct.push((_e[Dt] || 0) + 1), Dt++
        return Ct
      }
    }
    function vt() {
      var Ct = { line: nt, column: it }
      return (Ct.offset = j.toOffset(Ct)), Ct
    }
    function yt(Ct) {
      ;(this.start = Ct), (this.end = vt())
    }
    function pt(Ct) {
      s.substring(0, Ct.length) !== Ct &&
        j.file.fail(
          new Error(
            'Incorrectly eaten value: please report this warning on http://git.io/vg5Ft'
          ),
          vt()
        )
    }
    function ht() {
      var Ct = vt()
      return Dt
      function Dt(jt, Et) {
        var St = jt.position,
          Bt = St ? St.start : Ct,
          Mt = [],
          Ut = St && St.end.line,
          Wt = Ct.line
        if (((jt.position = new yt(Bt)), St && Et && St.indent)) {
          if (((Mt = St.indent), Ut < Wt)) {
            for (; ++Ut < Wt; ) Mt.push((_e[Ut] || 0) + 1)
            Mt.push(Ct.column)
          }
          Et = Mt.concat(Et)
        }
        return (jt.position.indent = Et || []), jt
      }
    }
    function At(Ct, Dt) {
      var jt = Dt ? Dt.children : et,
        Et = jt[jt.length - 1]
      return (
        Et &&
          Ct.type === Et.type &&
          Ct.type in MERGEABLE_NODES &&
          mergeable(Et) &&
          mergeable(Ct) &&
          (Ct = MERGEABLE_NODES[Ct.type].call(j, Et, Ct)),
        Ct !== Et && jt.push(Ct),
        j.atStart && et.length !== 0 && j.exitStart(),
        Ct
      )
    }
    function wt(Ct) {
      var Dt = mt(),
        jt = ht(),
        Et = vt()
      return (
        pt(Ct),
        (St.reset = Bt),
        (Bt.test = Mt),
        (St.test = Mt),
        (s = s.substring(Ct.length)),
        ft(Ct),
        (Dt = Dt()),
        St
      )
      function St(Ut, Wt) {
        return jt(At(jt(Ut), Wt), Dt)
      }
      function Bt() {
        var Ut = St.apply(null, arguments)
        return (nt = Et.line), (it = Et.column), (s = Ct + s), Ut
      }
      function Mt() {
        var Ut = jt({})
        return (nt = Et.line), (it = Et.column), (s = Ct + s), Ut.position
      }
    }
  }
}
var markdownEscapes, hasRequiredMarkdownEscapes
function requireMarkdownEscapes() {
  if (hasRequiredMarkdownEscapes) return markdownEscapes
  ;(hasRequiredMarkdownEscapes = 1), (markdownEscapes = $)
  var o = [
      '\\',
      '`',
      '*',
      '{',
      '}',
      '[',
      ']',
      '(',
      ')',
      '#',
      '+',
      '-',
      '.',
      '!',
      '_',
      '>',
    ],
    a = o.concat(['~', '|']),
    s = a.concat([
      `
`,
      '"',
      '$',
      '%',
      '&',
      "'",
      ',',
      '/',
      ':',
      ';',
      '<',
      '=',
      '?',
      '@',
      '^',
    ])
  ;($.default = o), ($.gfm = a), ($.commonmark = s)
  function $(j) {
    var _e = j || {}
    return _e.commonmark ? s : _e.gfm ? a : o
  }
  return markdownEscapes
}
const require$$0$1 = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hgroup',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'meta',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'pre',
  'section',
  'source',
  'title',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul',
]
var defaults, hasRequiredDefaults
function requireDefaults() {
  return (
    hasRequiredDefaults ||
      ((hasRequiredDefaults = 1),
      (defaults = {
        position: !0,
        gfm: !0,
        commonmark: !1,
        footnotes: !1,
        pedantic: !1,
        blocks: require$$0$1,
      })),
    defaults
  )
}
var setOptions_1, hasRequiredSetOptions
function requireSetOptions() {
  if (hasRequiredSetOptions) return setOptions_1
  hasRequiredSetOptions = 1
  var o = immutable,
    a = requireMarkdownEscapes(),
    s = requireDefaults()
  setOptions_1 = $
  function $(j) {
    var _e = this,
      et = _e.options,
      tt,
      rt
    if (j == null) j = {}
    else if (typeof j == 'object') j = o(j)
    else throw new Error('Invalid value `' + j + '` for setting `options`')
    for (tt in s) {
      if (
        ((rt = j[tt]),
        rt == null && (rt = et[tt]),
        (tt !== 'blocks' && typeof rt != 'boolean') ||
          (tt === 'blocks' && typeof rt != 'object'))
      )
        throw new Error(
          'Invalid value `' + rt + '` for setting `options.' + tt + '`'
        )
      j[tt] = rt
    }
    return (_e.options = j), (_e.escape = a(j)), _e
  }
  return setOptions_1
}
var convert_1 = convert$2
function convert$2(o) {
  if (typeof o == 'string') return typeFactory(o)
  if (o == null) return ok
  if (typeof o == 'object')
    return ('length' in o ? anyFactory : matchesFactory)(o)
  if (typeof o == 'function') return o
  throw new Error('Expected function, string, or object as test')
}
function convertAll(o) {
  for (var a = [], s = o.length, $ = -1; ++$ < s; ) a[$] = convert$2(o[$])
  return a
}
function matchesFactory(o) {
  return a
  function a(s) {
    var $
    for ($ in o) if (s[$] !== o[$]) return !1
    return !0
  }
}
function anyFactory(o) {
  var a = convertAll(o),
    s = a.length
  return $
  function $() {
    for (var j = -1; ++j < s; ) if (a[j].apply(this, arguments)) return !0
    return !1
  }
}
function typeFactory(o) {
  return a
  function a(s) {
    return !!(s && s.type === o)
  }
}
function ok() {
  return !0
}
var unistUtilVisitParents$1 = visitParents$2,
  convert$1 = convert_1,
  CONTINUE$1 = !0,
  SKIP$1 = 'skip',
  EXIT$1 = !1
visitParents$2.CONTINUE = CONTINUE$1
visitParents$2.SKIP = SKIP$1
visitParents$2.EXIT = EXIT$1
function visitParents$2(o, a, s, $) {
  var j
  typeof a == 'function' &&
    typeof s != 'function' &&
    (($ = s), (s = a), (a = null)),
    (j = convert$1(a)),
    _e(o, null, [])
  function _e(tt, rt, nt) {
    var it = [],
      ot
    return (!a || j(tt, rt, nt[nt.length - 1] || null)) &&
      ((it = toResult(s(tt, nt))), it[0] === EXIT$1)
      ? it
      : tt.children && it[0] !== SKIP$1
      ? ((ot = toResult(et(tt.children, nt.concat(tt)))),
        ot[0] === EXIT$1 ? ot : it)
      : it
  }
  function et(tt, rt) {
    for (
      var nt = -1, it = $ ? -1 : 1, ot = ($ ? tt.length : nt) + it, at;
      ot > nt && ot < tt.length;

    ) {
      if (((at = _e(tt[ot], ot, rt)), at[0] === EXIT$1)) return at
      ot = typeof at[1] == 'number' ? at[1] : ot + it
    }
  }
}
function toResult(o) {
  return o !== null && typeof o == 'object' && 'length' in o
    ? o
    : typeof o == 'number'
    ? [CONTINUE$1, o]
    : [o]
}
var unistUtilVisit = visit$3,
  visitParents$1 = unistUtilVisitParents$1,
  CONTINUE = visitParents$1.CONTINUE,
  SKIP = visitParents$1.SKIP,
  EXIT = visitParents$1.EXIT
visit$3.CONTINUE = CONTINUE
visit$3.SKIP = SKIP
visit$3.EXIT = EXIT
function visit$3(o, a, s, $) {
  typeof a == 'function' &&
    typeof s != 'function' &&
    (($ = s), (s = a), (a = null)),
    visitParents$1(o, a, j, $)
  function j(_e, et) {
    var tt = et[et.length - 1],
      rt = tt ? tt.children.indexOf(_e) : null
    return s(_e, rt, tt)
  }
}
var unistUtilRemovePosition, hasRequiredUnistUtilRemovePosition
function requireUnistUtilRemovePosition() {
  if (hasRequiredUnistUtilRemovePosition) return unistUtilRemovePosition
  hasRequiredUnistUtilRemovePosition = 1
  var o = unistUtilVisit
  unistUtilRemovePosition = a
  function a(j, _e) {
    return o(j, _e ? s : $), j
  }
  function s(j) {
    delete j.position
  }
  function $(j) {
    j.position = void 0
  }
  return unistUtilRemovePosition
}
var parse_1, hasRequiredParse
function requireParse() {
  if (hasRequiredParse) return parse_1
  hasRequiredParse = 1
  var o = immutable,
    a = requireUnistUtilRemovePosition()
  parse_1 = j
  var s = `
`,
    $ = /\r\n|\r/g
  function j() {
    var _e = this,
      et = String(_e.file),
      tt = { line: 1, column: 1, offset: 0 },
      rt = o(tt),
      nt
    return (
      (et = et.replace($, s)),
      et.charCodeAt(0) === 65279 &&
        ((et = et.slice(1)), rt.column++, rt.offset++),
      (nt = {
        type: 'root',
        children: _e.tokenizeBlock(et, rt),
        position: { start: tt, end: _e.eof || o(tt) },
      }),
      _e.options.position || a(nt, !0),
      nt
    )
  }
  return parse_1
}
var isWhitespaceCharacter, hasRequiredIsWhitespaceCharacter
function requireIsWhitespaceCharacter() {
  if (hasRequiredIsWhitespaceCharacter) return isWhitespaceCharacter
  ;(hasRequiredIsWhitespaceCharacter = 1), (isWhitespaceCharacter = s)
  var o = String.fromCharCode,
    a = /\s/
  function s($) {
    return a.test(typeof $ == 'number' ? o($) : $.charAt(0))
  }
  return isWhitespaceCharacter
}
var newline_1, hasRequiredNewline
function requireNewline() {
  if (hasRequiredNewline) return newline_1
  hasRequiredNewline = 1
  var o = requireIsWhitespaceCharacter()
  newline_1 = a
  function a(s, $, j) {
    var _e = $.charAt(0),
      et,
      tt,
      rt,
      nt
    if (
      _e ===
      `
`
    ) {
      if (j) return !0
      for (
        nt = 1, et = $.length, tt = _e, rt = '';
        nt < et && ((_e = $.charAt(nt)), !!o(_e));

      )
        (rt += _e),
          _e ===
            `
` && ((tt += rt), (rt = '')),
          nt++
      s(tt)
    }
  }
  return newline_1
}
/*!
 * repeat-string <https://github.com/jonschlinkert/repeat-string>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */ var repeatString, hasRequiredRepeatString
function requireRepeatString() {
  if (hasRequiredRepeatString) return repeatString
  hasRequiredRepeatString = 1
  var o = '',
    a
  repeatString = s
  function s($, j) {
    if (typeof $ != 'string') throw new TypeError('expected a string')
    if (j === 1) return $
    if (j === 2) return $ + $
    var _e = $.length * j
    if (a !== $ || typeof a > 'u') (a = $), (o = '')
    else if (o.length >= _e) return o.substr(0, _e)
    for (; _e > o.length && j > 1; ) j & 1 && (o += $), (j >>= 1), ($ += $)
    return (o += $), (o = o.substr(0, _e)), o
  }
  return repeatString
}
var trimTrailingLines_1, hasRequiredTrimTrailingLines
function requireTrimTrailingLines() {
  if (hasRequiredTrimTrailingLines) return trimTrailingLines_1
  ;(hasRequiredTrimTrailingLines = 1), (trimTrailingLines_1 = o)
  function o(a) {
    return String(a).replace(/\n+$/, '')
  }
  return trimTrailingLines_1
}
var codeIndented, hasRequiredCodeIndented
function requireCodeIndented() {
  if (hasRequiredCodeIndented) return codeIndented
  hasRequiredCodeIndented = 1
  var o = requireRepeatString(),
    a = requireTrimTrailingLines()
  codeIndented = tt
  var s = `
`,
    $ = '	',
    j = ' ',
    _e = 4,
    et = o(j, _e)
  function tt(rt, nt, it) {
    for (
      var ot = -1,
        at = nt.length,
        st = '',
        ut = '',
        ct = '',
        dt = '',
        ft,
        mt,
        vt;
      ++ot < at;

    )
      if (((ft = nt.charAt(ot)), vt))
        if (((vt = !1), (st += ct), (ut += dt), (ct = ''), (dt = ''), ft === s))
          (ct = ft), (dt = ft)
        else
          for (st += ft, ut += ft; ++ot < at; ) {
            if (((ft = nt.charAt(ot)), !ft || ft === s)) {
              ;(dt = ft), (ct = ft)
              break
            }
            ;(st += ft), (ut += ft)
          }
      else if (
        ft === j &&
        nt.charAt(ot + 1) === ft &&
        nt.charAt(ot + 2) === ft &&
        nt.charAt(ot + 3) === ft
      )
        (ct += et), (ot += 3), (vt = !0)
      else if (ft === $) (ct += ft), (vt = !0)
      else {
        for (mt = ''; ft === $ || ft === j; ) (mt += ft), (ft = nt.charAt(++ot))
        if (ft !== s) break
        ;(ct += mt + ft), (dt += ft)
      }
    if (ut) return it ? !0 : rt(st)({ type: 'code', lang: null, value: a(ut) })
  }
  return codeIndented
}
var codeFenced, hasRequiredCodeFenced
function requireCodeFenced() {
  if (hasRequiredCodeFenced) return codeFenced
  hasRequiredCodeFenced = 1
  var o = requireTrimTrailingLines()
  codeFenced = rt
  var a = `
`,
    s = '	',
    $ = ' ',
    j = '~',
    _e = '`',
    et = 3,
    tt = 4
  function rt(nt, it, ot) {
    var at = this,
      st = at.options,
      ut = it.length + 1,
      ct = 0,
      dt = '',
      ft,
      mt,
      vt,
      yt,
      pt,
      ht,
      At,
      wt,
      Ct,
      Dt,
      jt
    if (st.gfm) {
      for (; ct < ut && ((vt = it.charAt(ct)), !(vt !== $ && vt !== s)); )
        (dt += vt), ct++
      if (((Dt = ct), (vt = it.charAt(ct)), !(vt !== j && vt !== _e))) {
        for (
          ct++, mt = vt, ft = 1, dt += vt;
          ct < ut && ((vt = it.charAt(ct)), vt === mt);

        )
          (dt += vt), ft++, ct++
        if (!(ft < et)) {
          for (; ct < ut && ((vt = it.charAt(ct)), !(vt !== $ && vt !== s)); )
            (dt += vt), ct++
          for (
            yt = '', pt = '';
            ct < ut &&
            ((vt = it.charAt(ct)), !(vt === a || vt === j || vt === _e));

          )
            vt === $ || vt === s ? (pt += vt) : ((yt += pt + vt), (pt = '')),
              ct++
          if (((vt = it.charAt(ct)), !(vt && vt !== a))) {
            if (ot) return !0
            for (
              jt = nt.now(),
                jt.column += dt.length,
                jt.offset += dt.length,
                dt += yt,
                yt = at.decode.raw(at.unescape(yt), jt),
                pt && (dt += pt),
                pt = '',
                wt = '',
                Ct = '',
                ht = '',
                At = '';
              ct < ut;

            ) {
              if (
                ((vt = it.charAt(ct)),
                (ht += wt),
                (At += Ct),
                (wt = ''),
                (Ct = ''),
                vt !== a)
              ) {
                ;(ht += vt), (Ct += vt), ct++
                continue
              }
              for (
                ht ? ((wt += vt), (Ct += vt)) : (dt += vt), pt = '', ct++;
                ct < ut && ((vt = it.charAt(ct)), vt === $);

              )
                (pt += vt), ct++
              if (((wt += pt), (Ct += pt.slice(Dt)), !(pt.length >= tt))) {
                for (pt = ''; ct < ut && ((vt = it.charAt(ct)), vt === mt); )
                  (pt += vt), ct++
                if (((wt += pt), (Ct += pt), !(pt.length < ft))) {
                  for (
                    pt = '';
                    ct < ut && ((vt = it.charAt(ct)), !(vt !== $ && vt !== s));

                  )
                    (wt += vt), (Ct += vt), ct++
                  if (!vt || vt === a) break
                }
              }
            }
            return (
              (dt += ht + wt),
              nt(dt)({ type: 'code', lang: yt || null, value: o(At) })
            )
          }
        }
      }
    }
  }
  return codeFenced
}
var trim = { exports: {} },
  hasRequiredTrim
function requireTrim() {
  return (
    hasRequiredTrim ||
      ((hasRequiredTrim = 1),
      (function(o, a) {
        a = o.exports = s
        function s($) {
          return $.replace(/^\s*|\s*$/g, '')
        }
        ;(a.left = function($) {
          return $.replace(/^\s*/, '')
        }),
          (a.right = function($) {
            return $.replace(/\s*$/, '')
          })
      })(trim, trim.exports)),
    trim.exports
  )
}
var interrupt_1, hasRequiredInterrupt
function requireInterrupt() {
  if (hasRequiredInterrupt) return interrupt_1
  ;(hasRequiredInterrupt = 1), (interrupt_1 = o)
  function o(a, s, $, j) {
    for (
      var _e = ['pedantic', 'commonmark'],
        et = _e.length,
        tt = a.length,
        rt = -1,
        nt,
        it,
        ot,
        at,
        st,
        ut;
      ++rt < tt;

    ) {
      for (
        nt = a[rt], it = nt[1] || {}, ot = nt[0], at = -1, ut = !1;
        ++at < et;

      )
        if (((st = _e[at]), it[st] !== void 0 && it[st] !== $.options[st])) {
          ut = !0
          break
        }
      if (!ut && s[ot].apply($, j)) return !0
    }
    return !1
  }
  return interrupt_1
}
var blockquote_1, hasRequiredBlockquote
function requireBlockquote() {
  if (hasRequiredBlockquote) return blockquote_1
  hasRequiredBlockquote = 1
  var o = requireTrim(),
    a = requireInterrupt()
  blockquote_1 = et
  var s = `
`,
    $ = '	',
    j = ' ',
    _e = '>'
  function et(tt, rt, nt) {
    for (
      var it = this,
        ot = it.offset,
        at = it.blockTokenizers,
        st = it.interruptBlockquote,
        ut = tt.now(),
        ct = ut.line,
        dt = rt.length,
        ft = [],
        mt = [],
        vt = [],
        yt,
        pt = 0,
        ht,
        At,
        wt,
        Ct,
        Dt,
        jt,
        Et,
        St;
      pt < dt && ((ht = rt.charAt(pt)), !(ht !== j && ht !== $));

    )
      pt++
    if (rt.charAt(pt) === _e) {
      if (nt) return !0
      for (pt = 0; pt < dt; ) {
        for (
          wt = rt.indexOf(s, pt), jt = pt, Et = !1, wt === -1 && (wt = dt);
          pt < dt && ((ht = rt.charAt(pt)), !(ht !== j && ht !== $));

        )
          pt++
        if (
          (rt.charAt(pt) === _e
            ? (pt++, (Et = !0), rt.charAt(pt) === j && pt++)
            : (pt = jt),
          (Ct = rt.slice(pt, wt)),
          !Et && !o(Ct))
        ) {
          pt = jt
          break
        }
        if (!Et && ((At = rt.slice(pt)), a(st, at, it, [tt, At, !0]))) break
        ;(Dt = jt === pt ? Ct : rt.slice(jt, wt)),
          vt.push(pt - jt),
          ft.push(Dt),
          mt.push(Ct),
          (pt = wt + 1)
      }
      for (pt = -1, dt = vt.length, yt = tt(ft.join(s)); ++pt < dt; )
        (ot[ct] = (ot[ct] || 0) + vt[pt]), ct++
      return (
        (St = it.enterBlock()),
        (mt = it.tokenizeBlock(mt.join(s), ut)),
        St(),
        yt({ type: 'blockquote', children: mt })
      )
    }
  }
  return blockquote_1
}
var headingAtx, hasRequiredHeadingAtx
function requireHeadingAtx() {
  if (hasRequiredHeadingAtx) return headingAtx
  ;(hasRequiredHeadingAtx = 1), (headingAtx = _e)
  var o = `
`,
    a = '	',
    s = ' ',
    $ = '#',
    j = 6
  function _e(et, tt, rt) {
    for (
      var nt = this,
        it = nt.options,
        ot = tt.length + 1,
        at = -1,
        st = et.now(),
        ut = '',
        ct = '',
        dt,
        ft,
        mt;
      ++at < ot;

    ) {
      if (((dt = tt.charAt(at)), dt !== s && dt !== a)) {
        at--
        break
      }
      ut += dt
    }
    for (mt = 0; ++at <= ot; ) {
      if (((dt = tt.charAt(at)), dt !== $)) {
        at--
        break
      }
      ;(ut += dt), mt++
    }
    if (!(mt > j) && !(!mt || (!it.pedantic && tt.charAt(at + 1) === $))) {
      for (ot = tt.length + 1, ft = ''; ++at < ot; ) {
        if (((dt = tt.charAt(at)), dt !== s && dt !== a)) {
          at--
          break
        }
        ft += dt
      }
      if (!(!it.pedantic && ft.length === 0 && dt && dt !== o)) {
        if (rt) return !0
        for (
          ut += ft, ft = '', ct = '';
          ++at < ot && ((dt = tt.charAt(at)), !(!dt || dt === o));

        ) {
          if (dt !== s && dt !== a && dt !== $) {
            ;(ct += ft + dt), (ft = '')
            continue
          }
          for (; dt === s || dt === a; ) (ft += dt), (dt = tt.charAt(++at))
          for (; dt === $; ) (ft += dt), (dt = tt.charAt(++at))
          for (; dt === s || dt === a; ) (ft += dt), (dt = tt.charAt(++at))
          at--
        }
        return (
          (st.column += ut.length),
          (st.offset += ut.length),
          (ut += ct + ft),
          et(ut)({
            type: 'heading',
            depth: mt,
            children: nt.tokenizeInline(ct, st),
          })
        )
      }
    }
  }
  return headingAtx
}
var thematicBreak_1, hasRequiredThematicBreak
function requireThematicBreak() {
  if (hasRequiredThematicBreak) return thematicBreak_1
  ;(hasRequiredThematicBreak = 1), (thematicBreak_1 = tt)
  var o = `
`,
    a = '	',
    s = ' ',
    $ = '*',
    j = '_',
    _e = '-',
    et = 3
  function tt(rt, nt, it) {
    for (
      var ot = -1, at = nt.length + 1, st = '', ut, ct, dt, ft;
      ++ot < at && ((ut = nt.charAt(ot)), !(ut !== a && ut !== s));

    )
      st += ut
    if (!(ut !== $ && ut !== _e && ut !== j))
      for (ct = ut, st += ut, dt = 1, ft = ''; ++ot < at; )
        if (((ut = nt.charAt(ot)), ut === ct)) dt++, (st += ft + ct), (ft = '')
        else if (ut === s) ft += ut
        else
          return dt >= et && (!ut || ut === o)
            ? ((st += ft), it ? !0 : rt(st)({ type: 'thematicBreak' }))
            : void 0
  }
  return thematicBreak_1
}
var getIndentation, hasRequiredGetIndentation
function requireGetIndentation() {
  if (hasRequiredGetIndentation) return getIndentation
  ;(hasRequiredGetIndentation = 1), (getIndentation = a)
  var o = { ' ': 1, '	': 4 }
  function a(s) {
    for (var $ = 0, j = 0, _e = s.charAt($), et = {}, tt; _e in o; )
      (tt = o[_e]),
        (j += tt),
        tt > 1 && (j = Math.floor(j / tt) * tt),
        (et[j] = $),
        (_e = s.charAt(++$))
    return { indent: j, stops: et }
  }
  return getIndentation
}
var removeIndentation, hasRequiredRemoveIndentation
function requireRemoveIndentation() {
  if (hasRequiredRemoveIndentation) return removeIndentation
  hasRequiredRemoveIndentation = 1
  var o = requireTrim(),
    a = requireRepeatString(),
    s = requireGetIndentation()
  removeIndentation = et
  var $ = ' ',
    j = `
`,
    _e = '	'
  function et(tt, rt) {
    var nt = tt.split(j),
      it = nt.length + 1,
      ot = 1 / 0,
      at = [],
      st,
      ut,
      ct,
      dt
    for (nt.unshift(a($, rt) + '!'); it--; )
      if (((ut = s(nt[it])), (at[it] = ut.stops), o(nt[it]).length !== 0))
        if (ut.indent) ut.indent > 0 && ut.indent < ot && (ot = ut.indent)
        else {
          ot = 1 / 0
          break
        }
    if (ot !== 1 / 0)
      for (it = nt.length; it--; ) {
        for (ct = at[it], st = ot; st && !(st in ct); ) st--
        o(nt[it]).length !== 0 && ot && st !== ot ? (dt = _e) : (dt = ''),
          (nt[it] = dt + nt[it].slice(st in ct ? ct[st] + 1 : 0))
      }
    return nt.shift(), nt.join(j)
  }
  return removeIndentation
}
var list_1, hasRequiredList
function requireList() {
  if (hasRequiredList) return list_1
  hasRequiredList = 1
  var o = requireTrim(),
    a = requireRepeatString(),
    s = isDecimal,
    $ = requireGetIndentation(),
    j = requireRemoveIndentation(),
    _e = requireInterrupt()
  list_1 = Ct
  var et = '*',
    tt = '_',
    rt = '+',
    nt = '-',
    it = '.',
    ot = ' ',
    at = `
`,
    st = '	',
    ut = ')',
    ct = 'x',
    dt = 4,
    ft = /\n\n(?!\s*$)/,
    mt = /^\[([ \t]|x|X)][ \t]/,
    vt = /^([ \t]*)([*+-]|\d+[.)])( {1,4}(?! )| |\t|$|(?=\n))([^\n]*)/,
    yt = /^([ \t]*)([*+-]|\d+[.)])([ \t]+)/,
    pt = /^( {1,4}|\t)?/gm,
    ht = {}
  ;(ht[et] = !0), (ht[rt] = !0), (ht[nt] = !0)
  var At = {}
  At[it] = !0
  var wt = {}
  ;(wt[it] = !0), (wt[ut] = !0)
  function Ct(St, Bt, Mt) {
    for (
      var Ut = this,
        Wt = Ut.options.commonmark,
        Tt = Ut.options.pedantic,
        kt = Ut.blockTokenizers,
        Ot = Ut.interruptList,
        Nt,
        $t = 0,
        Pt = Bt.length,
        Ft = null,
        Vt = 0,
        Xt,
        Yt,
        xt,
        It,
        Kt,
        Qt,
        Ht,
        Lt,
        tr,
        lr,
        yr,
        mr,
        Er,
        ur,
        _r,
        Rr,
        nr,
        fr,
        gr,
        br,
        Sr,
        zt,
        bt;
      $t < Pt;

    ) {
      if (((xt = Bt.charAt($t)), xt === st)) Vt += dt - (Vt % dt)
      else if (xt === ot) Vt++
      else break
      $t++
    }
    if (!(Vt >= dt)) {
      if (((xt = Bt.charAt($t)), (Nt = Wt ? wt : At), ht[xt] === !0))
        (It = xt), (Yt = !1)
      else {
        for (Yt = !0, Xt = ''; $t < Pt && ((xt = Bt.charAt($t)), !!s(xt)); )
          (Xt += xt), $t++
        if (((xt = Bt.charAt($t)), !Xt || Nt[xt] !== !0)) return
        ;(Ft = parseInt(Xt, 10)), (It = xt)
      }
      if (((xt = Bt.charAt(++$t)), !(xt !== ot && xt !== st))) {
        if (Mt) return !0
        for ($t = 0, Er = [], ur = [], _r = []; $t < Pt; ) {
          for (
            Kt = Bt.indexOf(at, $t),
              Qt = $t,
              Ht = !1,
              bt = !1,
              Kt === -1 && (Kt = Pt),
              zt = $t + dt,
              Vt = 0;
            $t < Pt;

          ) {
            if (((xt = Bt.charAt($t)), xt === st)) Vt += dt - (Vt % dt)
            else if (xt === ot) Vt++
            else break
            $t++
          }
          if (
            (Vt >= dt && (bt = !0),
            Rr && Vt >= Rr.indent && (bt = !0),
            (xt = Bt.charAt($t)),
            (Lt = null),
            !bt)
          ) {
            if (ht[xt] === !0) (Lt = xt), $t++, Vt++
            else {
              for (Xt = ''; $t < Pt && ((xt = Bt.charAt($t)), !!s(xt)); )
                (Xt += xt), $t++
              ;(xt = Bt.charAt($t)),
                $t++,
                Xt && Nt[xt] === !0 && ((Lt = xt), (Vt += Xt.length + 1))
            }
            if (Lt)
              if (((xt = Bt.charAt($t)), xt === st))
                (Vt += dt - (Vt % dt)), $t++
              else if (xt === ot) {
                for (zt = $t + dt; $t < zt && Bt.charAt($t) === ot; ) $t++, Vt++
                $t === zt &&
                  Bt.charAt($t) === ot &&
                  (($t -= dt - 1), (Vt -= dt - 1))
              } else xt !== at && xt !== '' && (Lt = null)
          }
          if (Lt) {
            if (!Tt && It !== Lt) break
            Ht = !0
          } else
            !Wt && !bt && Bt.charAt(Qt) === ot
              ? (bt = !0)
              : Wt && Rr && (bt = Vt >= Rr.indent || Vt > dt),
              (Ht = !1),
              ($t = Qt)
          if (
            ((lr = Bt.slice(Qt, Kt)),
            (tr = Qt === $t ? lr : Bt.slice($t, Kt)),
            (Lt === et || Lt === tt || Lt === nt) &&
              kt.thematicBreak.call(Ut, St, lr, !0))
          )
            break
          if (((yr = mr), (mr = !o(tr).length), bt && Rr))
            (Rr.value = Rr.value.concat(_r, lr)),
              (ur = ur.concat(_r, lr)),
              (_r = [])
          else if (Ht)
            _r.length !== 0 && (Rr.value.push(''), (Rr.trail = _r.concat())),
              (Rr = { value: [lr], indent: Vt, trail: [] }),
              Er.push(Rr),
              (ur = ur.concat(_r, lr)),
              (_r = [])
          else if (mr) {
            if (yr) break
            _r.push(lr)
          } else {
            if (yr || _e(Ot, kt, Ut, [St, lr, !0])) break
            ;(Rr.value = Rr.value.concat(_r, lr)),
              (ur = ur.concat(_r, lr)),
              (_r = [])
          }
          $t = Kt + 1
        }
        for (
          br = St(ur.join(at)).reset({
            type: 'list',
            ordered: Yt,
            start: Ft,
            loose: null,
            children: [],
          }),
            nr = Ut.enterList(),
            fr = Ut.enterBlock(),
            gr = !1,
            $t = -1,
            Pt = Er.length;
          ++$t < Pt;

        )
          (Rr = Er[$t].value.join(at)),
            (Sr = St.now()),
            (Rr = St(Rr)(Dt(Ut, Rr, Sr), br)),
            Rr.loose && (gr = !0),
            (Rr = Er[$t].trail.join(at)),
            $t !== Pt - 1 && (Rr += at),
            St(Rr)
        return nr(), fr(), (br.loose = gr), br
      }
    }
  }
  function Dt(St, Bt, Mt) {
    var Ut = St.offset,
      Wt = St.options.pedantic ? jt : Et,
      Tt = null,
      kt,
      Ot
    return (
      (Bt = Wt.apply(null, arguments)),
      St.options.gfm &&
        ((kt = Bt.match(mt)),
        kt &&
          ((Ot = kt[0].length),
          (Tt = kt[1].toLowerCase() === ct),
          (Ut[Mt.line] += Ot),
          (Bt = Bt.slice(Ot)))),
      {
        type: 'listItem',
        loose: ft.test(Bt) || Bt.charAt(Bt.length - 1) === at,
        checked: Tt,
        children: St.tokenizeBlock(Bt, Mt),
      }
    )
  }
  function jt(St, Bt, Mt) {
    var Ut = St.offset,
      Wt = Mt.line
    return (Bt = Bt.replace(yt, Tt)), (Wt = Mt.line), Bt.replace(pt, Tt)
    function Tt(kt) {
      return (Ut[Wt] = (Ut[Wt] || 0) + kt.length), Wt++, ''
    }
  }
  function Et(St, Bt, Mt) {
    var Ut = St.offset,
      Wt = Mt.line,
      Tt,
      kt,
      Ot,
      Nt,
      $t,
      Pt,
      Ft
    for (
      Bt = Bt.replace(vt, Vt),
        Nt = Bt.split(at),
        $t = j(Bt, $(Tt).indent).split(at),
        $t[0] = Ot,
        Ut[Wt] = (Ut[Wt] || 0) + kt.length,
        Wt++,
        Pt = 0,
        Ft = Nt.length;
      ++Pt < Ft;

    )
      (Ut[Wt] = (Ut[Wt] || 0) + Nt[Pt].length - $t[Pt].length), Wt++
    return $t.join(at)
    function Vt(Xt, Yt, xt, It, Kt) {
      return (
        (kt = Yt + xt + It),
        (Ot = Kt),
        Number(xt) < 10 && kt.length % 2 === 1 && (xt = ot + xt),
        (Tt = Yt + a(ot, xt.length) + It),
        Tt + Ot
      )
    }
  }
  return list_1
}
var headingSetext, hasRequiredHeadingSetext
function requireHeadingSetext() {
  if (hasRequiredHeadingSetext) return headingSetext
  ;(hasRequiredHeadingSetext = 1), (headingSetext = tt)
  var o = `
`,
    a = '	',
    s = ' ',
    $ = '=',
    j = '-',
    _e = 3,
    et = {}
  ;(et[$] = 1), (et[j] = 2)
  function tt(rt, nt, it) {
    for (
      var ot = this,
        at = rt.now(),
        st = nt.length,
        ut = -1,
        ct = '',
        dt,
        ft,
        mt,
        vt,
        yt;
      ++ut < st;

    ) {
      if (((mt = nt.charAt(ut)), mt !== s || ut >= _e)) {
        ut--
        break
      }
      ct += mt
    }
    for (dt = '', ft = ''; ++ut < st; ) {
      if (((mt = nt.charAt(ut)), mt === o)) {
        ut--
        break
      }
      mt === s || mt === a ? (ft += mt) : ((dt += ft + mt), (ft = ''))
    }
    if (
      ((at.column += ct.length),
      (at.offset += ct.length),
      (ct += dt + ft),
      (mt = nt.charAt(++ut)),
      (vt = nt.charAt(++ut)),
      !(mt !== o || !et[vt]))
    ) {
      for (ct += mt, ft = vt, yt = et[vt]; ++ut < st; ) {
        if (((mt = nt.charAt(ut)), mt !== vt)) {
          if (mt !== o) return
          ut--
          break
        }
        ft += mt
      }
      return it
        ? !0
        : rt(ct + ft)({
            type: 'heading',
            depth: yt,
            children: ot.tokenizeInline(dt, at),
          })
    }
  }
  return headingSetext
}
var html = {},
  hasRequiredHtml
function requireHtml() {
  if (hasRequiredHtml) return html
  hasRequiredHtml = 1
  var o = '[a-zA-Z_:][a-zA-Z0-9:._-]*',
    a = '[^"\'=<>`\\u0000-\\u0020]+',
    s = "'[^']*'",
    $ = '"[^"]*"',
    j = '(?:' + a + '|' + s + '|' + $ + ')',
    _e = '(?:\\s+' + o + '(?:\\s*=\\s*' + j + ')?)',
    et = '<[A-Za-z][A-Za-z0-9\\-]*' + _e + '*\\s*\\/?>',
    tt = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>',
    rt = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->',
    nt = '<[?].*?[?]>',
    it = '<![A-Za-z]+\\s+[^>]*>',
    ot = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>'
  return (
    (html.openCloseTag = new RegExp('^(?:' + et + '|' + tt + ')')),
    (html.tag = new RegExp(
      '^(?:' + et + '|' + tt + '|' + rt + '|' + nt + '|' + it + '|' + ot + ')'
    )),
    html
  )
}
var htmlBlock, hasRequiredHtmlBlock
function requireHtmlBlock() {
  if (hasRequiredHtmlBlock) return htmlBlock
  hasRequiredHtmlBlock = 1
  var o = requireHtml().openCloseTag
  htmlBlock = _e
  var a = '	',
    s = ' ',
    $ = `
`,
    j = '<'
  function _e(et, tt, rt) {
    for (
      var nt = this,
        it = nt.options.blocks,
        ot = tt.length,
        at = 0,
        st,
        ut,
        ct,
        dt,
        ft,
        mt,
        vt,
        yt = [
          [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, !0],
          [/^<!--/, /-->/, !0],
          [/^<\?/, /\?>/, !0],
          [/^<![A-Za-z]/, />/, !0],
          [/^<!\[CDATA\[/, /\]\]>/, !0],
          [
            new RegExp('^</?(' + it.join('|') + ')(?=(\\s|/?>|$))', 'i'),
            /^$/,
            !0,
          ],
          [new RegExp(o.source + '\\s*$'), /^$/, !1],
        ];
      at < ot && ((dt = tt.charAt(at)), !(dt !== a && dt !== s));

    )
      at++
    if (tt.charAt(at) === j) {
      for (
        st = tt.indexOf($, at + 1),
          st = st === -1 ? ot : st,
          ut = tt.slice(at, st),
          ct = -1,
          ft = yt.length;
        ++ct < ft;

      )
        if (yt[ct][0].test(ut)) {
          mt = yt[ct]
          break
        }
      if (mt) {
        if (rt) return mt[2]
        if (((at = st), !mt[1].test(ut)))
          for (; at < ot; ) {
            if (
              ((st = tt.indexOf($, at + 1)),
              (st = st === -1 ? ot : st),
              (ut = tt.slice(at + 1, st)),
              mt[1].test(ut))
            ) {
              ut && (at = st)
              break
            }
            at = st
          }
        return (vt = tt.slice(0, at)), et(vt)({ type: 'html', value: vt })
      }
    }
  }
  return htmlBlock
}
var collapseWhiteSpace, hasRequiredCollapseWhiteSpace
function requireCollapseWhiteSpace() {
  if (hasRequiredCollapseWhiteSpace) return collapseWhiteSpace
  ;(hasRequiredCollapseWhiteSpace = 1), (collapseWhiteSpace = o)
  function o(a) {
    return String(a).replace(/\s+/g, ' ')
  }
  return collapseWhiteSpace
}
var normalize_1, hasRequiredNormalize
function requireNormalize() {
  if (hasRequiredNormalize) return normalize_1
  hasRequiredNormalize = 1
  var o = requireCollapseWhiteSpace()
  normalize_1 = a
  function a(s) {
    return o(s).toLowerCase()
  }
  return normalize_1
}
var footnoteDefinition_1, hasRequiredFootnoteDefinition
function requireFootnoteDefinition() {
  if (hasRequiredFootnoteDefinition) return footnoteDefinition_1
  hasRequiredFootnoteDefinition = 1
  var o = requireIsWhitespaceCharacter(),
    a = requireNormalize()
  ;(footnoteDefinition_1 = ot), (ot.notInList = !0), (ot.notInBlock = !0)
  var s = '\\',
    $ = `
`,
    j = '	',
    _e = ' ',
    et = '[',
    tt = ']',
    rt = '^',
    nt = ':',
    it = /^( {4}|\t)?/gm
  function ot(at, st, ut) {
    var ct = this,
      dt = ct.offset,
      ft,
      mt,
      vt,
      yt,
      pt,
      ht,
      At,
      wt,
      Ct,
      Dt,
      jt,
      Et
    if (ct.options.footnotes) {
      for (
        ft = 0, mt = st.length, vt = '', yt = at.now(), pt = yt.line;
        ft < mt && ((Ct = st.charAt(ft)), !!o(Ct));

      )
        (vt += Ct), ft++
      if (!(st.charAt(ft) !== et || st.charAt(ft + 1) !== rt)) {
        for (
          vt += et + rt, ft = vt.length, At = '';
          ft < mt && ((Ct = st.charAt(ft)), Ct !== tt);

        )
          Ct === s && ((At += Ct), ft++, (Ct = st.charAt(ft))), (At += Ct), ft++
        if (!(!At || st.charAt(ft) !== tt || st.charAt(ft + 1) !== nt)) {
          if (ut) return !0
          for (
            Dt = a(At), vt += At + tt + nt, ft = vt.length;
            ft < mt && ((Ct = st.charAt(ft)), !(Ct !== j && Ct !== _e));

          )
            (vt += Ct), ft++
          for (
            yt.column += vt.length,
              yt.offset += vt.length,
              At = '',
              ht = '',
              wt = '';
            ft < mt;

          ) {
            if (((Ct = st.charAt(ft)), Ct === $)) {
              for (wt = Ct, ft++; ft < mt && ((Ct = st.charAt(ft)), Ct === $); )
                (wt += Ct), ft++
              for (
                At += wt, wt = '';
                ft < mt && ((Ct = st.charAt(ft)), Ct === _e);

              )
                (wt += Ct), ft++
              if (wt.length === 0) break
              At += wt
            }
            At && ((ht += At), (At = '')), (ht += Ct), ft++
          }
          return (
            (vt += ht),
            (ht = ht.replace(it, function(St) {
              return (dt[pt] = (dt[pt] || 0) + St.length), pt++, ''
            })),
            (jt = at(vt)),
            (Et = ct.enterBlock()),
            (ht = ct.tokenizeBlock(ht, yt)),
            Et(),
            jt({ type: 'footnoteDefinition', identifier: Dt, children: ht })
          )
        }
      }
    }
  }
  return footnoteDefinition_1
}
var definition_1, hasRequiredDefinition
function requireDefinition() {
  if (hasRequiredDefinition) return definition_1
  hasRequiredDefinition = 1
  var o = requireIsWhitespaceCharacter(),
    a = requireNormalize()
  ;(definition_1 = ct), (ct.notInList = !0), (ct.notInBlock = !0)
  var s = '"',
    $ = "'",
    j = '\\',
    _e = `
`,
    et = '	',
    tt = ' ',
    rt = '[',
    nt = ']',
    it = '(',
    ot = ')',
    at = ':',
    st = '<',
    ut = '>'
  function ct(mt, vt, yt) {
    for (
      var pt = this,
        ht = pt.options.commonmark,
        At = 0,
        wt = vt.length,
        Ct = '',
        Dt,
        jt,
        Et,
        St,
        Bt,
        Mt,
        Ut,
        Wt;
      At < wt && ((St = vt.charAt(At)), !(St !== tt && St !== et));

    )
      (Ct += St), At++
    if (((St = vt.charAt(At)), St === rt)) {
      for (
        At++, Ct += St, Et = '';
        At < wt && ((St = vt.charAt(At)), St !== nt);

      )
        St === j && ((Et += St), At++, (St = vt.charAt(At))), (Et += St), At++
      if (!(!Et || vt.charAt(At) !== nt || vt.charAt(At + 1) !== at)) {
        for (
          Mt = Et, Ct += Et + nt + at, At = Ct.length, Et = '';
          At < wt &&
          ((St = vt.charAt(At)), !(St !== et && St !== tt && St !== _e));

        )
          (Ct += St), At++
        if (((St = vt.charAt(At)), (Et = ''), (Dt = Ct), St === st)) {
          for (At++; At < wt && ((St = vt.charAt(At)), !!dt(St)); )
            (Et += St), At++
          if (((St = vt.charAt(At)), St === dt.delimiter))
            (Ct += st + Et + St), At++
          else {
            if (ht) return
            ;(At -= Et.length + 1), (Et = '')
          }
        }
        if (!Et) {
          for (; At < wt && ((St = vt.charAt(At)), !!ft(St)); ) (Et += St), At++
          Ct += Et
        }
        if (Et) {
          for (
            Ut = Et, Et = '';
            At < wt &&
            ((St = vt.charAt(At)), !(St !== et && St !== tt && St !== _e));

          )
            (Et += St), At++
          if (
            ((St = vt.charAt(At)),
            (Bt = null),
            St === s ? (Bt = s) : St === $ ? (Bt = $) : St === it && (Bt = ot),
            !Bt)
          )
            (Et = ''), (At = Ct.length)
          else if (Et) {
            for (
              Ct += Et + St, At = Ct.length, Et = '';
              At < wt && ((St = vt.charAt(At)), St !== Bt);

            ) {
              if (St === _e) {
                if ((At++, (St = vt.charAt(At)), St === _e || St === Bt)) return
                Et += _e
              }
              ;(Et += St), At++
            }
            if (((St = vt.charAt(At)), St !== Bt)) return
            ;(jt = Ct), (Ct += Et + St), At++, (Wt = Et), (Et = '')
          } else return
          for (; At < wt && ((St = vt.charAt(At)), !(St !== et && St !== tt)); )
            (Ct += St), At++
          if (((St = vt.charAt(At)), !St || St === _e))
            return yt
              ? !0
              : ((Dt = mt(Dt).test().end),
                (Ut = pt.decode.raw(pt.unescape(Ut), Dt, {
                  nonTerminated: !1,
                })),
                Wt &&
                  ((jt = mt(jt).test().end),
                  (Wt = pt.decode.raw(pt.unescape(Wt), jt))),
                mt(Ct)({
                  type: 'definition',
                  identifier: a(Mt),
                  title: Wt || null,
                  url: Ut,
                }))
        }
      }
    }
  }
  function dt(mt) {
    return mt !== ut && mt !== rt && mt !== nt
  }
  dt.delimiter = ut
  function ft(mt) {
    return mt !== rt && mt !== nt && !o(mt)
  }
  return definition_1
}
var table_1, hasRequiredTable
function requireTable() {
  if (hasRequiredTable) return table_1
  hasRequiredTable = 1
  var o = requireIsWhitespaceCharacter()
  table_1 = ct
  var a = '\\',
    s = '`',
    $ = '-',
    j = '|',
    _e = ':',
    et = ' ',
    tt = `
`,
    rt = '	',
    nt = 1,
    it = 2,
    ot = 'left',
    at = 'center',
    st = 'right',
    ut = null
  function ct(dt, ft, mt) {
    var vt = this,
      yt,
      pt,
      ht,
      At,
      wt,
      Ct,
      Dt,
      jt,
      Et,
      St,
      Bt,
      Mt,
      Ut,
      Wt,
      Tt,
      kt,
      Ot,
      Nt,
      $t,
      Pt,
      Ft,
      Vt,
      Xt,
      Yt
    if (vt.options.gfm) {
      for (yt = 0, Nt = 0, Ct = ft.length + 1, Dt = []; yt < Ct; ) {
        if (
          ((Vt = ft.indexOf(tt, yt)),
          (Xt = ft.indexOf(j, yt + 1)),
          Vt === -1 && (Vt = ft.length),
          Xt === -1 || Xt > Vt)
        ) {
          if (Nt < it) return
          break
        }
        Dt.push(ft.slice(yt, Vt)), Nt++, (yt = Vt + 1)
      }
      for (
        At = Dt.join(tt),
          pt = Dt.splice(1, 1)[0] || [],
          yt = 0,
          Ct = pt.length,
          Nt--,
          ht = !1,
          Bt = [];
        yt < Ct;

      ) {
        if (((Et = pt.charAt(yt)), Et === j)) {
          if (((St = null), ht === !1)) {
            if (Yt === !1) return
          } else Bt.push(ht), (ht = !1)
          Yt = !1
        } else if (Et === $) (St = !0), (ht = ht || ut)
        else if (Et === _e)
          ht === ot ? (ht = at) : St && ht === ut ? (ht = st) : (ht = ot)
        else if (!o(Et)) return
        yt++
      }
      if ((ht !== !1 && Bt.push(ht), !(Bt.length < nt))) {
        if (mt) return !0
        for (
          Ot = -1,
            Pt = [],
            Ft = dt(At).reset({ type: 'table', align: Bt, children: Pt });
          ++Ot < Nt;

        ) {
          for (
            $t = Dt[Ot],
              wt = { type: 'tableRow', children: [] },
              Ot && dt(tt),
              dt($t).reset(wt, Ft),
              Ct = $t.length + 1,
              yt = 0,
              jt = '',
              Mt = '',
              Ut = !0,
              Wt = null,
              Tt = null;
            yt < Ct;

          ) {
            if (((Et = $t.charAt(yt)), Et === rt || Et === et)) {
              Mt ? (jt += Et) : dt(Et), yt++
              continue
            }
            if (Et === '' || Et === j)
              if (Ut) dt(Et)
              else {
                if (Et && Tt) {
                  ;(jt += Et), yt++
                  continue
                }
                ;(Mt || Et) &&
                  !Ut &&
                  ((At = Mt),
                  jt.length > 1 &&
                    (Et
                      ? ((At += jt.slice(0, jt.length - 1)),
                        (jt = jt.charAt(jt.length - 1)))
                      : ((At += jt), (jt = ''))),
                  (kt = dt.now()),
                  dt(At)(
                    { type: 'tableCell', children: vt.tokenizeInline(Mt, kt) },
                    wt
                  )),
                  dt(jt + Et),
                  (jt = ''),
                  (Mt = '')
              }
            else if (
              (jt && ((Mt += jt), (jt = '')),
              (Mt += Et),
              Et === a && yt !== Ct - 2 && ((Mt += $t.charAt(yt + 1)), yt++),
              Et === s)
            ) {
              for (Wt = 1; $t.charAt(yt + 1) === Et; ) (Mt += Et), yt++, Wt++
              Tt ? Wt >= Tt && (Tt = 0) : (Tt = Wt)
            }
            ;(Ut = !1), yt++
          }
          Ot || dt(tt + pt)
        }
        return Ft
      }
    }
  }
  return table_1
}
var paragraph_1, hasRequiredParagraph
function requireParagraph() {
  if (hasRequiredParagraph) return paragraph_1
  hasRequiredParagraph = 1
  var o = requireTrim(),
    a = isDecimal,
    s = requireTrimTrailingLines(),
    $ = requireInterrupt()
  paragraph_1 = rt
  var j = `
`,
    _e = '	',
    et = ' ',
    tt = 4
  function rt(nt, it, ot) {
    for (
      var at = this,
        st = at.options,
        ut = st.commonmark,
        ct = st.gfm,
        dt = at.blockTokenizers,
        ft = at.interruptParagraph,
        mt = it.indexOf(j),
        vt = it.length,
        yt,
        pt,
        ht,
        At,
        wt;
      mt < vt;

    ) {
      if (mt === -1) {
        mt = vt
        break
      }
      if (it.charAt(mt + 1) === j) break
      if (ut) {
        for (At = 0, yt = mt + 1; yt < vt; ) {
          if (((ht = it.charAt(yt)), ht === _e)) {
            At = tt
            break
          } else if (ht === et) At++
          else break
          yt++
        }
        if (At >= tt) {
          mt = it.indexOf(j, mt + 1)
          continue
        }
      }
      if (
        ((pt = it.slice(mt + 1)),
        $(ft, dt, at, [nt, pt, !0]) ||
          (dt.list.call(at, nt, pt, !0) &&
            (at.inList || ut || (ct && !a(o.left(pt).charAt(0))))))
      )
        break
      if (
        ((yt = mt),
        (mt = it.indexOf(j, mt + 1)),
        mt !== -1 && o(it.slice(yt, mt)) === '')
      ) {
        mt = yt
        break
      }
    }
    return (
      (pt = it.slice(0, mt)),
      o(pt) === ''
        ? (nt(pt), null)
        : ot
        ? !0
        : ((wt = nt.now()),
          (pt = s(pt)),
          nt(pt)({ type: 'paragraph', children: at.tokenizeInline(pt, wt) }))
    )
  }
  return paragraph_1
}
var _escape$1, hasRequired_escape$1
function require_escape$1() {
  if (hasRequired_escape$1) return _escape$1
  ;(hasRequired_escape$1 = 1), (_escape$1 = o)
  function o(a, s) {
    return a.indexOf('\\', s)
  }
  return _escape$1
}
var _escape, hasRequired_escape
function require_escape() {
  if (hasRequired_escape) return _escape
  hasRequired_escape = 1
  var o = require_escape$1()
  ;(_escape = a), (a.locator = o)
  function a(s, $, j) {
    var _e = this,
      et,
      tt
    if (
      $.charAt(0) === '\\' &&
      ((et = $.charAt(1)), _e.escape.indexOf(et) !== -1)
    )
      return j
        ? !0
        : (et ===
          `
`
            ? (tt = { type: 'break' })
            : (tt = { type: 'text', value: et }),
          s('\\' + et)(tt))
  }
  return _escape
}
var tag, hasRequiredTag
function requireTag() {
  if (hasRequiredTag) return tag
  ;(hasRequiredTag = 1), (tag = o)
  function o(a, s) {
    return a.indexOf('<', s)
  }
  return tag
}
var autoLink_1, hasRequiredAutoLink
function requireAutoLink() {
  if (hasRequiredAutoLink) return autoLink_1
  hasRequiredAutoLink = 1
  var o = requireIsWhitespaceCharacter(),
    a = parseEntities_1,
    s = requireTag()
  ;(autoLink_1 = nt), (nt.locator = s), (nt.notInLink = !0)
  var $ = '<',
    j = '>',
    _e = '@',
    et = '/',
    tt = 'mailto:',
    rt = tt.length
  function nt(it, ot, at) {
    var st, ut, ct, dt, ft, mt, vt, yt, pt, ht, At, wt
    if (ot.charAt(0) === $) {
      for (
        st = this,
          ut = '',
          ct = ot.length,
          dt = 0,
          ft = '',
          vt = !1,
          yt = '',
          dt++,
          ut = $;
        dt < ct &&
        ((mt = ot.charAt(dt)),
        !(
          o(mt) ||
          mt === j ||
          mt === _e ||
          (mt === ':' && ot.charAt(dt + 1) === et)
        ));

      )
        (ft += mt), dt++
      if (ft) {
        if (
          ((yt += ft),
          (ft = ''),
          (mt = ot.charAt(dt)),
          (yt += mt),
          dt++,
          mt === _e)
        )
          vt = !0
        else {
          if (mt !== ':' || ot.charAt(dt + 1) !== et) return
          ;(yt += et), dt++
        }
        for (; dt < ct && ((mt = ot.charAt(dt)), !(o(mt) || mt === j)); )
          (ft += mt), dt++
        if (((mt = ot.charAt(dt)), !(!ft || mt !== j)))
          return at
            ? !0
            : ((yt += ft),
              (ht = yt),
              (ut += yt + mt),
              (pt = it.now()),
              pt.column++,
              pt.offset++,
              vt &&
                (yt.slice(0, rt).toLowerCase() === tt
                  ? ((ht = ht.substr(rt)), (pt.column += rt), (pt.offset += rt))
                  : (yt = tt + yt)),
              (At = st.inlineTokenizers),
              (st.inlineTokenizers = { text: At.text }),
              (wt = st.enterLink()),
              (ht = st.tokenizeInline(ht, pt)),
              (st.inlineTokenizers = At),
              wt(),
              it(ut)({
                type: 'link',
                title: null,
                url: a(yt, { nonTerminated: !1 }),
                children: ht,
              }))
      }
    }
  }
  return autoLink_1
}
var url, hasRequiredUrl$1
function requireUrl$1() {
  if (hasRequiredUrl$1) return url
  ;(hasRequiredUrl$1 = 1), (url = a)
  var o = ['https://', 'http://', 'mailto:']
  function a(s, $) {
    var j = o.length,
      _e = -1,
      et = -1,
      tt
    if (!this.options.gfm) return -1
    for (; ++_e < j; )
      (tt = s.indexOf(o[_e], $)),
        tt !== -1 && (tt < et || et === -1) && (et = tt)
    return et
  }
  return url
}
var url_1, hasRequiredUrl
function requireUrl() {
  if (hasRequiredUrl) return url_1
  hasRequiredUrl = 1
  var o = parseEntities_1,
    a = requireIsWhitespaceCharacter(),
    s = requireUrl$1()
  ;(url_1 = ut), (ut.locator = s), (ut.notInLink = !0)
  var $ = '[',
    j = ']',
    _e = '(',
    et = ')',
    tt = '<',
    rt = '@',
    nt = 'http://',
    it = 'https://',
    ot = 'mailto:',
    at = [nt, it, ot],
    st = at.length
  function ut(ct, dt, ft) {
    var mt = this,
      vt,
      yt,
      pt,
      ht,
      At,
      wt,
      Ct,
      Dt,
      jt,
      Et,
      St,
      Bt
    if (mt.options.gfm) {
      for (vt = '', ht = -1, Dt = st; ++ht < Dt; )
        if (
          ((wt = at[ht]),
          (Ct = dt.slice(0, wt.length)),
          Ct.toLowerCase() === wt)
        ) {
          vt = Ct
          break
        }
      if (vt) {
        for (
          ht = vt.length, Dt = dt.length, jt = '', Et = 0;
          ht < Dt &&
          ((pt = dt.charAt(ht)),
          !(
            a(pt) ||
            pt === tt ||
            ((pt === '.' ||
              pt === ',' ||
              pt === ':' ||
              pt === ';' ||
              pt === '"' ||
              pt === "'" ||
              pt === ')' ||
              pt === ']') &&
              ((St = dt.charAt(ht + 1)), !St || a(St))) ||
            ((pt === _e || pt === $) && Et++,
            (pt === et || pt === j) && (Et--, Et < 0))
          ));

        )
          (jt += pt), ht++
        if (jt) {
          if (((vt += jt), (yt = vt), wt === ot)) {
            if (((At = jt.indexOf(rt)), At === -1 || At === Dt - 1)) return
            yt = yt.substr(ot.length)
          }
          return ft
            ? !0
            : ((Bt = mt.enterLink()),
              (yt = mt.tokenizeInline(yt, ct.now())),
              Bt(),
              ct(vt)({
                type: 'link',
                title: null,
                url: o(vt, { nonTerminated: !1 }),
                children: yt,
              }))
        }
      }
    }
  }
  return url_1
}
var htmlInline, hasRequiredHtmlInline
function requireHtmlInline() {
  if (hasRequiredHtmlInline) return htmlInline
  hasRequiredHtmlInline = 1
  var o = requireIsAlphabetical(),
    a = requireTag(),
    s = requireHtml().tag
  ;(htmlInline = _e), (_e.locator = a)
  var $ = /^<a /i,
    j = /^<\/a>/i
  function _e(et, tt, rt) {
    var nt = this,
      it = tt.length,
      ot,
      at
    if (
      !(tt.charAt(0) !== '<' || it < 3) &&
      ((ot = tt.charAt(1)),
      !(!o(ot) && ot !== '?' && ot !== '!' && ot !== '/') &&
        ((at = tt.match(s)), !!at))
    )
      return rt
        ? !0
        : ((at = at[0]),
          !nt.inLink && $.test(at)
            ? (nt.inLink = !0)
            : nt.inLink && j.test(at) && (nt.inLink = !1),
          et(at)({ type: 'html', value: at }))
  }
  return htmlInline
}
var link, hasRequiredLink$1
function requireLink$1() {
  if (hasRequiredLink$1) return link
  ;(hasRequiredLink$1 = 1), (link = o)
  function o(a, s) {
    var $ = a.indexOf('[', s),
      j = a.indexOf('![', s)
    return j === -1 || $ < j ? $ : j
  }
  return link
}
var link_1, hasRequiredLink
function requireLink() {
  if (hasRequiredLink) return link_1
  hasRequiredLink = 1
  var o = requireIsWhitespaceCharacter(),
    a = requireLink$1()
  ;(link_1 = ct), (ct.locator = a)
  var s = {}.hasOwnProperty,
    $ = '\\',
    j = '[',
    _e = ']',
    et = '(',
    tt = ')',
    rt = '<',
    nt = '>',
    it = '`',
    ot = '"',
    at = "'",
    st = {}
  ;(st[ot] = ot), (st[at] = at)
  var ut = {}
  ;(ut[ot] = ot), (ut[at] = at), (ut[et] = tt)
  function ct(dt, ft, mt) {
    var vt = this,
      yt = '',
      pt = 0,
      ht = ft.charAt(0),
      At = vt.options.pedantic,
      wt = vt.options.commonmark,
      Ct = vt.options.gfm,
      Dt,
      jt,
      Et,
      St,
      Bt,
      Mt,
      Ut,
      Wt,
      Tt,
      kt,
      Ot,
      Nt,
      $t,
      Pt,
      Ft,
      Vt,
      Xt,
      Yt,
      xt
    if (
      (ht === '!' && ((Tt = !0), (yt = ht), (ht = ft.charAt(++pt))),
      ht === j && !(!Tt && vt.inLink))
    ) {
      for (
        yt += ht,
          Ft = '',
          pt++,
          Nt = ft.length,
          Xt = dt.now(),
          Pt = 0,
          Xt.column += pt,
          Xt.offset += pt;
        pt < Nt;

      ) {
        if (((ht = ft.charAt(pt)), (Mt = ht), ht === it)) {
          for (jt = 1; ft.charAt(pt + 1) === it; ) (Mt += ht), pt++, jt++
          Et ? jt >= Et && (Et = 0) : (Et = jt)
        } else if (ht === $) pt++, (Mt += ft.charAt(pt))
        else if ((!Et || Ct) && ht === j) Pt++
        else if ((!Et || Ct) && ht === _e)
          if (Pt) Pt--
          else {
            if (!At)
              for (; pt < Nt && ((ht = ft.charAt(pt + 1)), !!o(ht)); )
                (Mt += ht), pt++
            if (ft.charAt(pt + 1) !== et) return
            ;(Mt += et), (Dt = !0), pt++
            break
          }
        ;(Ft += Mt), (Mt = ''), pt++
      }
      if (Dt) {
        for (
          kt = Ft, yt += Ft + Mt, pt++;
          pt < Nt && ((ht = ft.charAt(pt)), !!o(ht));

        )
          (yt += ht), pt++
        if (
          ((ht = ft.charAt(pt)),
          (Wt = wt ? ut : st),
          (Ft = ''),
          (St = yt),
          ht === rt)
        ) {
          for (pt++, St += rt; pt < Nt && ((ht = ft.charAt(pt)), ht !== nt); ) {
            if (
              wt &&
              ht ===
                `
`
            )
              return
            ;(Ft += ht), pt++
          }
          if (ft.charAt(pt) !== nt) return
          ;(yt += rt + Ft + nt), (Vt = Ft), pt++
        } else {
          for (
            ht = null, Mt = '';
            pt < Nt && ((ht = ft.charAt(pt)), !(Mt && s.call(Wt, ht)));

          ) {
            if (o(ht)) {
              if (!At) break
              Mt += ht
            } else {
              if (ht === et) Pt++
              else if (ht === tt) {
                if (Pt === 0) break
                Pt--
              }
              ;(Ft += Mt),
                (Mt = ''),
                ht === $ && ((Ft += $), (ht = ft.charAt(++pt))),
                (Ft += ht)
            }
            pt++
          }
          ;(yt += Ft), (Vt = Ft), (pt = yt.length)
        }
        for (Ft = ''; pt < Nt && ((ht = ft.charAt(pt)), !!o(ht)); )
          (Ft += ht), pt++
        if (((ht = ft.charAt(pt)), (yt += Ft), Ft && s.call(Wt, ht)))
          if ((pt++, (yt += ht), (Ft = ''), (Ot = Wt[ht]), (Bt = yt), wt)) {
            for (; pt < Nt && ((ht = ft.charAt(pt)), ht !== Ot); )
              ht === $ && ((Ft += $), (ht = ft.charAt(++pt))), pt++, (Ft += ht)
            if (((ht = ft.charAt(pt)), ht !== Ot)) return
            for (
              $t = Ft, yt += Ft + ht, pt++;
              pt < Nt && ((ht = ft.charAt(pt)), !!o(ht));

            )
              (yt += ht), pt++
          } else
            for (Mt = ''; pt < Nt; ) {
              if (((ht = ft.charAt(pt)), ht === Ot))
                Ut && ((Ft += Ot + Mt), (Mt = '')), (Ut = !0)
              else if (!Ut) Ft += ht
              else if (ht === tt) {
                ;(yt += Ft + Ot + Mt), ($t = Ft)
                break
              } else
                o(ht)
                  ? (Mt += ht)
                  : ((Ft += Ot + Mt + ht), (Mt = ''), (Ut = !1))
              pt++
            }
        if (ft.charAt(pt) === tt)
          return mt
            ? !0
            : ((yt += tt),
              (Vt = vt.decode.raw(vt.unescape(Vt), dt(St).test().end, {
                nonTerminated: !1,
              })),
              $t &&
                ((Bt = dt(Bt).test().end),
                ($t = vt.decode.raw(vt.unescape($t), Bt))),
              (xt = {
                type: Tt ? 'image' : 'link',
                title: $t || null,
                url: Vt,
              }),
              Tt
                ? (xt.alt = vt.decode.raw(vt.unescape(kt), Xt) || null)
                : ((Yt = vt.enterLink()),
                  (xt.children = vt.tokenizeInline(kt, Xt)),
                  Yt()),
              dt(yt)(xt))
      }
    }
  }
  return link_1
}
var reference_1, hasRequiredReference
function requireReference() {
  if (hasRequiredReference) return reference_1
  hasRequiredReference = 1
  var o = requireIsWhitespaceCharacter(),
    a = requireLink$1(),
    s = requireNormalize()
  ;(reference_1 = st), (st.locator = a)
  var $ = 'link',
    j = 'image',
    _e = 'footnote',
    et = 'shortcut',
    tt = 'collapsed',
    rt = 'full',
    nt = '^',
    it = '\\',
    ot = '[',
    at = ']'
  function st(ut, ct, dt) {
    var ft = this,
      mt = ct.charAt(0),
      vt = 0,
      yt = ct.length,
      pt = '',
      ht = '',
      At = $,
      wt = et,
      Ct,
      Dt,
      jt,
      Et,
      St,
      Bt,
      Mt,
      Ut
    if (
      (mt === '!' && ((At = j), (ht = mt), (mt = ct.charAt(++vt))), mt === ot)
    ) {
      if (
        (vt++,
        (ht += mt),
        (Bt = ''),
        ft.options.footnotes && ct.charAt(vt) === nt)
      ) {
        if (At === j) return
        ;(ht += nt), vt++, (At = _e)
      }
      for (Ut = 0; vt < yt; ) {
        if (((mt = ct.charAt(vt)), mt === ot)) (Mt = !0), Ut++
        else if (mt === at) {
          if (!Ut) break
          Ut--
        }
        mt === it && ((Bt += it), (mt = ct.charAt(++vt))), (Bt += mt), vt++
      }
      if (((pt = Bt), (Ct = Bt), (mt = ct.charAt(vt)), mt === at)) {
        for (
          vt++, pt += mt, Bt = '';
          vt < yt && ((mt = ct.charAt(vt)), !!o(mt));

        )
          (Bt += mt), vt++
        if (((mt = ct.charAt(vt)), At !== _e && mt === ot)) {
          for (
            Dt = '', Bt += mt, vt++;
            vt < yt && ((mt = ct.charAt(vt)), !(mt === ot || mt === at));

          )
            mt === it && ((Dt += it), (mt = ct.charAt(++vt))), (Dt += mt), vt++
          ;(mt = ct.charAt(vt)),
            mt === at
              ? ((wt = Dt ? rt : tt), (Bt += Dt + mt), vt++)
              : (Dt = ''),
            (pt += Bt),
            (Bt = '')
        } else {
          if (!Ct) return
          Dt = Ct
        }
        if (!(wt !== rt && Mt))
          return (
            (pt = ht + pt),
            At === $ && ft.inLink
              ? null
              : dt
              ? !0
              : At === _e && Ct.indexOf(' ') !== -1
              ? ut(pt)({
                  type: 'footnote',
                  children: this.tokenizeInline(Ct, ut.now()),
                })
              : ((jt = ut.now()),
                (jt.column += ht.length),
                (jt.offset += ht.length),
                (Dt = wt === rt ? Dt : Ct),
                (Et = { type: At + 'Reference', identifier: s(Dt) }),
                (At === $ || At === j) && (Et.referenceType = wt),
                At === $
                  ? ((St = ft.enterLink()),
                    (Et.children = ft.tokenizeInline(Ct, jt)),
                    St())
                  : At === j &&
                    (Et.alt = ft.decode.raw(ft.unescape(Ct), jt) || null),
                ut(pt)(Et))
          )
      }
    }
  }
  return reference_1
}
var strong, hasRequiredStrong$1
function requireStrong$1() {
  if (hasRequiredStrong$1) return strong
  ;(hasRequiredStrong$1 = 1), (strong = o)
  function o(a, s) {
    var $ = a.indexOf('**', s),
      j = a.indexOf('__', s)
    return j === -1 ? $ : $ === -1 || j < $ ? j : $
  }
  return strong
}
var strong_1, hasRequiredStrong
function requireStrong() {
  if (hasRequiredStrong) return strong_1
  hasRequiredStrong = 1
  var o = requireTrim(),
    a = requireIsWhitespaceCharacter(),
    s = requireStrong$1()
  ;(strong_1 = _e), (_e.locator = s)
  var $ = '*',
    j = '_'
  function _e(et, tt, rt) {
    var nt = this,
      it = 0,
      ot = tt.charAt(it),
      at,
      st,
      ut,
      ct,
      dt,
      ft,
      mt
    if (
      !((ot !== $ && ot !== j) || tt.charAt(++it) !== ot) &&
      ((st = nt.options.pedantic),
      (ut = ot),
      (dt = ut + ut),
      (ft = tt.length),
      it++,
      (ct = ''),
      (ot = ''),
      !(st && a(tt.charAt(it))))
    )
      for (; it < ft; ) {
        if (
          ((mt = ot),
          (ot = tt.charAt(it)),
          ot === ut &&
            tt.charAt(it + 1) === ut &&
            (!st || !a(mt)) &&
            ((ot = tt.charAt(it + 2)), ot !== ut))
        )
          return o(ct)
            ? rt
              ? !0
              : ((at = et.now()),
                (at.column += 2),
                (at.offset += 2),
                et(dt + ct + dt)({
                  type: 'strong',
                  children: nt.tokenizeInline(ct, at),
                }))
            : void 0
        !st && ot === '\\' && ((ct += ot), (ot = tt.charAt(++it))),
          (ct += ot),
          it++
      }
  }
  return strong_1
}
var isWordCharacter, hasRequiredIsWordCharacter
function requireIsWordCharacter() {
  if (hasRequiredIsWordCharacter) return isWordCharacter
  ;(hasRequiredIsWordCharacter = 1), (isWordCharacter = s)
  var o = String.fromCharCode,
    a = /\w/
  function s($) {
    return a.test(typeof $ == 'number' ? o($) : $.charAt(0))
  }
  return isWordCharacter
}
var emphasis, hasRequiredEmphasis$1
function requireEmphasis$1() {
  if (hasRequiredEmphasis$1) return emphasis
  ;(hasRequiredEmphasis$1 = 1), (emphasis = o)
  function o(a, s) {
    var $ = a.indexOf('*', s),
      j = a.indexOf('_', s)
    return j === -1 ? $ : $ === -1 || j < $ ? j : $
  }
  return emphasis
}
var emphasis_1, hasRequiredEmphasis
function requireEmphasis() {
  if (hasRequiredEmphasis) return emphasis_1
  hasRequiredEmphasis = 1
  var o = requireTrim(),
    a = requireIsWordCharacter(),
    s = requireIsWhitespaceCharacter(),
    $ = requireEmphasis$1()
  ;(emphasis_1 = et), (et.locator = $)
  var j = '*',
    _e = '_'
  function et(tt, rt, nt) {
    var it = this,
      ot = 0,
      at = rt.charAt(ot),
      st,
      ut,
      ct,
      dt,
      ft,
      mt,
      vt
    if (
      !(at !== j && at !== _e) &&
      ((ut = it.options.pedantic),
      (ft = at),
      (ct = at),
      (mt = rt.length),
      ot++,
      (dt = ''),
      (at = ''),
      !(ut && s(rt.charAt(ot))))
    )
      for (; ot < mt; ) {
        if (((vt = at), (at = rt.charAt(ot)), at === ct && (!ut || !s(vt)))) {
          if (((at = rt.charAt(++ot)), at !== ct)) {
            if (!o(dt) || vt === ct) return
            if (!ut && ct === _e && a(at)) {
              dt += ct
              continue
            }
            return nt
              ? !0
              : ((st = tt.now()),
                st.column++,
                st.offset++,
                tt(ft + dt + ct)({
                  type: 'emphasis',
                  children: it.tokenizeInline(dt, st),
                }))
          }
          dt += ct
        }
        !ut && at === '\\' && ((dt += at), (at = rt.charAt(++ot))),
          (dt += at),
          ot++
      }
  }
  return emphasis_1
}
var _delete$1, hasRequired_delete$1
function require_delete$1() {
  if (hasRequired_delete$1) return _delete$1
  ;(hasRequired_delete$1 = 1), (_delete$1 = o)
  function o(a, s) {
    return a.indexOf('~~', s)
  }
  return _delete$1
}
var _delete, hasRequired_delete
function require_delete() {
  if (hasRequired_delete) return _delete
  hasRequired_delete = 1
  var o = requireIsWhitespaceCharacter(),
    a = require_delete$1()
  ;(_delete = j), (j.locator = a)
  var s = '~',
    $ = '~~'
  function j(_e, et, tt) {
    var rt = this,
      nt = '',
      it = '',
      ot = '',
      at = '',
      st,
      ut,
      ct
    if (
      !(
        !rt.options.gfm ||
        et.charAt(0) !== s ||
        et.charAt(1) !== s ||
        o(et.charAt(2))
      )
    )
      for (
        st = 1, ut = et.length, ct = _e.now(), ct.column += 2, ct.offset += 2;
        ++st < ut;

      ) {
        if (((nt = et.charAt(st)), nt === s && it === s && (!ot || !o(ot))))
          return tt
            ? !0
            : _e($ + at + $)({
                type: 'delete',
                children: rt.tokenizeInline(at, ct),
              })
        ;(at += it), (ot = it), (it = nt)
      }
  }
  return _delete
}
var codeInline$1, hasRequiredCodeInline$1
function requireCodeInline$1() {
  if (hasRequiredCodeInline$1) return codeInline$1
  ;(hasRequiredCodeInline$1 = 1), (codeInline$1 = o)
  function o(a, s) {
    return a.indexOf('`', s)
  }
  return codeInline$1
}
var codeInline, hasRequiredCodeInline
function requireCodeInline() {
  if (hasRequiredCodeInline) return codeInline
  hasRequiredCodeInline = 1
  var o = requireIsWhitespaceCharacter(),
    a = requireCodeInline$1()
  ;(codeInline = $), ($.locator = a)
  var s = '`'
  function $(j, _e, et) {
    for (
      var tt = _e.length,
        rt = 0,
        nt = '',
        it = '',
        ot,
        at,
        st,
        ut,
        ct,
        dt,
        ft,
        mt;
      rt < tt && _e.charAt(rt) === s;

    )
      (nt += s), rt++
    if (nt) {
      for (ct = nt, ut = rt, nt = '', mt = _e.charAt(rt), st = 0; rt < tt; ) {
        if (
          ((dt = mt),
          (mt = _e.charAt(rt + 1)),
          dt === s ? (st++, (it += dt)) : ((st = 0), (nt += dt)),
          st && mt !== s)
        ) {
          if (st === ut) {
            ;(ct += nt + it), (ft = !0)
            break
          }
          ;(nt += it), (it = '')
        }
        rt++
      }
      if (!ft) {
        if (ut % 2 !== 0) return
        nt = ''
      }
      if (et) return !0
      for (ot = '', at = '', tt = nt.length, rt = -1; ++rt < tt; ) {
        if (((dt = nt.charAt(rt)), o(dt))) {
          at += dt
          continue
        }
        at && (ot && (ot += at), (at = '')), (ot += dt)
      }
      return j(ct)({ type: 'inlineCode', value: ot })
    }
  }
  return codeInline
}
var _break$1, hasRequired_break$1
function require_break$1() {
  if (hasRequired_break$1) return _break$1
  ;(hasRequired_break$1 = 1), (_break$1 = o)
  function o(a, s) {
    for (
      var $ = a.indexOf(
        `
`,
        s
      );
      $ > s && a.charAt($ - 1) === ' ';

    )
      $--
    return $
  }
  return _break$1
}
var _break, hasRequired_break
function require_break() {
  if (hasRequired_break) return _break
  hasRequired_break = 1
  var o = require_break$1()
  ;(_break = s), (s.locator = o)
  var a = 2
  function s($, j, _e) {
    for (var et = j.length, tt = -1, rt = '', nt; ++tt < et; ) {
      if (
        ((nt = j.charAt(tt)),
        nt ===
          `
`)
      )
        return tt < a
          ? void 0
          : _e
          ? !0
          : ((rt += nt), $(rt)({ type: 'break' }))
      if (nt !== ' ') return
      rt += nt
    }
  }
  return _break
}
var text_1, hasRequiredText
function requireText() {
  if (hasRequiredText) return text_1
  ;(hasRequiredText = 1), (text_1 = o)
  function o(a, s, $) {
    var j = this,
      _e,
      et,
      tt,
      rt,
      nt,
      it,
      ot,
      at,
      st,
      ut
    if ($) return !0
    for (
      _e = j.inlineMethods,
        rt = _e.length,
        et = j.inlineTokenizers,
        tt = -1,
        st = s.length;
      ++tt < rt;

    )
      (at = _e[tt]),
        !(at === 'text' || !et[at]) &&
          ((ot = et[at].locator),
          ot || a.file.fail('Missing locator: `' + at + '`'),
          (it = ot.call(j, s, 1)),
          it !== -1 && it < st && (st = it))
    ;(nt = s.slice(0, st)),
      (ut = a.now()),
      j.decode(nt, ut, function(ct, dt, ft) {
        a(ft || ct)({ type: 'text', value: ct })
      })
  }
  return text_1
}
var xtend$4 = immutable,
  toggle = stateToggle,
  vfileLocation = vfileLocation$1,
  unescape = _unescape,
  decode = decode$1,
  tokenizer = tokenizer$1,
  parser = Parser$1
function Parser$1(o, a) {
  ;(this.file = a),
    (this.offset = {}),
    (this.options = xtend$4(this.options)),
    this.setOptions({}),
    (this.inList = !1),
    (this.inBlock = !1),
    (this.inLink = !1),
    (this.atStart = !0),
    (this.toOffset = vfileLocation(a).toOffset),
    (this.unescape = unescape(this, 'escape')),
    (this.decode = decode(this))
}
var proto = Parser$1.prototype
proto.setOptions = requireSetOptions()
proto.parse = requireParse()
proto.options = requireDefaults()
proto.exitStart = toggle('atStart', !0)
proto.enterList = toggle('inList', !1)
proto.enterLink = toggle('inLink', !1)
proto.enterBlock = toggle('inBlock', !1)
proto.interruptParagraph = [
  ['thematicBreak'],
  ['atxHeading'],
  ['fencedCode'],
  ['blockquote'],
  ['html'],
  ['setextHeading', { commonmark: !1 }],
  ['definition', { commonmark: !1 }],
  ['footnote', { commonmark: !1 }],
]
proto.interruptList = [
  ['atxHeading', { pedantic: !1 }],
  ['fencedCode', { pedantic: !1 }],
  ['thematicBreak', { pedantic: !1 }],
  ['definition', { commonmark: !1 }],
  ['footnote', { commonmark: !1 }],
]
proto.interruptBlockquote = [
  ['indentedCode', { commonmark: !0 }],
  ['fencedCode', { commonmark: !0 }],
  ['atxHeading', { commonmark: !0 }],
  ['setextHeading', { commonmark: !0 }],
  ['thematicBreak', { commonmark: !0 }],
  ['html', { commonmark: !0 }],
  ['list', { commonmark: !0 }],
  ['definition', { commonmark: !1 }],
  ['footnote', { commonmark: !1 }],
]
proto.blockTokenizers = {
  newline: requireNewline(),
  indentedCode: requireCodeIndented(),
  fencedCode: requireCodeFenced(),
  blockquote: requireBlockquote(),
  atxHeading: requireHeadingAtx(),
  thematicBreak: requireThematicBreak(),
  list: requireList(),
  setextHeading: requireHeadingSetext(),
  html: requireHtmlBlock(),
  footnote: requireFootnoteDefinition(),
  definition: requireDefinition(),
  table: requireTable(),
  paragraph: requireParagraph(),
}
proto.inlineTokenizers = {
  escape: require_escape(),
  autoLink: requireAutoLink(),
  url: requireUrl(),
  html: requireHtmlInline(),
  link: requireLink(),
  reference: requireReference(),
  strong: requireStrong(),
  emphasis: requireEmphasis(),
  deletion: require_delete(),
  code: requireCodeInline(),
  break: require_break(),
  text: requireText(),
}
proto.blockMethods = keys(proto.blockTokenizers)
proto.inlineMethods = keys(proto.inlineTokenizers)
proto.tokenizeBlock = tokenizer('block')
proto.tokenizeInline = tokenizer('inline')
proto.tokenizeFactory = tokenizer
function keys(o) {
  var a = [],
    s
  for (s in o) a.push(s)
  return a
}
var unherit = unherit_1,
  xtend$3 = immutable,
  Parser = parser,
  remarkParse = parse$2
parse$2.Parser = Parser
function parse$2(o) {
  var a = unherit(Parser)
  ;(a.prototype.options = xtend$3(
    a.prototype.options,
    this.data('settings'),
    o
  )),
    (this.Parser = a)
}
var unistUtilVisitParents = visitParents
function visitParents(o, a, s) {
  var $ = []
  typeof a == 'function' && ((s = a), (a = null)), j(o)
  function j(et) {
    var tt
    return (
      (!a || et.type === a) && (tt = s(et, $.concat())),
      et.children && tt !== !1 ? _e(et.children, et) : tt
    )
  }
  function _e(et, tt) {
    var rt = et.length,
      nt = -1,
      it
    for ($.push(tt); ++nt < rt; )
      if (((it = et[nt]), it && j(it) === !1)) return !1
    return $.pop(), !0
  }
}
var visitWithParents = unistUtilVisitParents
function addListMetadata$1() {
  return function(o) {
    return (
      visitWithParents(o, 'list', function(a, s) {
        var $ = 0,
          j,
          _e
        for (j = 0, _e = s.length; j < _e; j++) s[j].type === 'list' && ($ += 1)
        for (j = 0, _e = a.children.length; j < _e; j++) {
          var et = a.children[j]
          ;(et.index = j), (et.ordered = a.ordered)
        }
        a.depth = $
      }),
      o
    )
  }
}
var mdastAddListMetadata = addListMetadata$1,
  visit$2 = unistUtilVisit,
  type = 'virtualHtml',
  selfClosingRe = /^<(area|base|br|col|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)\s*\/?>$/i,
  simpleTagRe = /^<(\/?)([a-z]+)\s*>$/,
  naiveHtml$1 = function(o) {
    var a, s
    return (
      visit$2(
        o,
        'html',
        function($, j, _e) {
          s !== _e && ((a = []), (s = _e))
          var et = getSelfClosing($)
          if (et)
            return (
              _e.children.splice(j, 1, { type, tag: et, position: $.position }),
              !0
            )
          var tt = getSimpleTag($)
          if (!tt) return !0
          var rt = findAndPull(a, tt.tag)
          return (
            rt
              ? _e.children.splice(j, 0, virtual(tt, rt, _e))
              : tt.opening || a.push(tt),
            !0
          )
        },
        !0
      ),
      o
    )
  }
function findAndPull(o, a) {
  for (var s = o.length; s--; ) if (o[s].tag === a) return o.splice(s, 1)[0]
  return !1
}
function getSimpleTag(o, a) {
  var s = o.value.match(simpleTagRe)
  return s ? { tag: s[2], opening: !s[1], node: o } : !1
}
function getSelfClosing(o) {
  var a = o.value.match(selfClosingRe)
  return a ? a[1] : !1
}
function virtual(o, a, s) {
  var $ = s.children.indexOf(o.node),
    j = s.children.indexOf(a.node),
    _e = s.children.splice($, j - $ + 1),
    et = _e.slice(1, -1)
  return {
    type,
    children: et,
    tag: o.tag,
    position: {
      start: o.node.position.start,
      end: a.node.position.end,
      indent: [],
    },
  }
}
var disallowNode$1 = {},
  visit$1 = unistUtilVisit
disallowNode$1.ofType = function(o, a) {
  return function($) {
    return (
      o.forEach(function(j) {
        return visit$1($, j, s, !0)
      }),
      $
    )
  }
  function s($, j, _e) {
    _e && untangle($, j, _e, a)
  }
}
disallowNode$1.ifNotMatch = function(o, a) {
  return function($) {
    return visit$1($, s, !0), $
  }
  function s($, j, _e) {
    _e && !o($, j, _e) && untangle($, j, _e, a)
  }
}
function untangle(o, a, s, $) {
  if ($ === 'remove') s.children.splice(a, 1)
  else if ($ === 'unwrap') {
    var j = [a, 1]
    o.children && (j = j.concat(o.children)),
      Array.prototype.splice.apply(s.children, j)
  }
}
var reactIs = { exports: {} },
  reactIs_production_min = {}
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var b = typeof Symbol == 'function' && Symbol.for,
  c = b ? Symbol.for('react.element') : 60103,
  d = b ? Symbol.for('react.portal') : 60106,
  e = b ? Symbol.for('react.fragment') : 60107,
  f = b ? Symbol.for('react.strict_mode') : 60108,
  g = b ? Symbol.for('react.profiler') : 60114,
  h = b ? Symbol.for('react.provider') : 60109,
  k = b ? Symbol.for('react.context') : 60110,
  l = b ? Symbol.for('react.async_mode') : 60111,
  m = b ? Symbol.for('react.concurrent_mode') : 60111,
  n = b ? Symbol.for('react.forward_ref') : 60112,
  p = b ? Symbol.for('react.suspense') : 60113,
  q = b ? Symbol.for('react.suspense_list') : 60120,
  r = b ? Symbol.for('react.memo') : 60115,
  t = b ? Symbol.for('react.lazy') : 60116,
  v = b ? Symbol.for('react.block') : 60121,
  w$1 = b ? Symbol.for('react.fundamental') : 60117,
  x = b ? Symbol.for('react.responder') : 60118,
  y = b ? Symbol.for('react.scope') : 60119
function z(o) {
  if (typeof o == 'object' && o !== null) {
    var a = o.$$typeof
    switch (a) {
      case c:
        switch (((o = o.type), o)) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return o
          default:
            switch (((o = o && o.$$typeof), o)) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return o
              default:
                return a
            }
        }
      case d:
        return a
    }
  }
}
function A(o) {
  return z(o) === m
}
reactIs_production_min.AsyncMode = l
reactIs_production_min.ConcurrentMode = m
reactIs_production_min.ContextConsumer = k
reactIs_production_min.ContextProvider = h
reactIs_production_min.Element = c
reactIs_production_min.ForwardRef = n
reactIs_production_min.Fragment = e
reactIs_production_min.Lazy = t
reactIs_production_min.Memo = r
reactIs_production_min.Portal = d
reactIs_production_min.Profiler = g
reactIs_production_min.StrictMode = f
reactIs_production_min.Suspense = p
reactIs_production_min.isAsyncMode = function(o) {
  return A(o) || z(o) === l
}
reactIs_production_min.isConcurrentMode = A
reactIs_production_min.isContextConsumer = function(o) {
  return z(o) === k
}
reactIs_production_min.isContextProvider = function(o) {
  return z(o) === h
}
reactIs_production_min.isElement = function(o) {
  return typeof o == 'object' && o !== null && o.$$typeof === c
}
reactIs_production_min.isForwardRef = function(o) {
  return z(o) === n
}
reactIs_production_min.isFragment = function(o) {
  return z(o) === e
}
reactIs_production_min.isLazy = function(o) {
  return z(o) === t
}
reactIs_production_min.isMemo = function(o) {
  return z(o) === r
}
reactIs_production_min.isPortal = function(o) {
  return z(o) === d
}
reactIs_production_min.isProfiler = function(o) {
  return z(o) === g
}
reactIs_production_min.isStrictMode = function(o) {
  return z(o) === f
}
reactIs_production_min.isSuspense = function(o) {
  return z(o) === p
}
reactIs_production_min.isValidElementType = function(o) {
  return (
    typeof o == 'string' ||
    typeof o == 'function' ||
    o === e ||
    o === m ||
    o === g ||
    o === f ||
    o === p ||
    o === q ||
    (typeof o == 'object' &&
      o !== null &&
      (o.$$typeof === t ||
        o.$$typeof === r ||
        o.$$typeof === h ||
        o.$$typeof === k ||
        o.$$typeof === n ||
        o.$$typeof === w$1 ||
        o.$$typeof === x ||
        o.$$typeof === y ||
        o.$$typeof === v))
  )
}
reactIs_production_min.typeOf = z
reactIs.exports = reactIs_production_min
var reactIsExports = reactIs.exports,
  React$3 = reactExports,
  xtend$2 = immutable$2,
  ReactIs = reactIsExports,
  defaultNodePosition = {
    start: { line: 1, column: 1, offset: 0 },
    end: { line: 1, column: 1, offset: 0 },
  }
function astToReact$1(o, a) {
  var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    $ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
    j = a.renderers[o.type]
  o.position === void 0 &&
    (o.position = (s.node && s.node.position) || defaultNodePosition)
  var _e = o.position.start,
    et = [o.type, _e.line, _e.column, $].join('-')
  if (!ReactIs.isValidElementType(j))
    throw new Error(
      'Renderer for type `'.concat(o.type, '` not defined or is not renderable')
    )
  var tt = getNodeProps(o, et, a, j, s, $)
  return React$3.createElement(j, tt, tt.children || rt() || void 0)
  function rt() {
    return (
      o.children &&
      o.children.map(function(nt, it) {
        return astToReact$1(nt, a, { node: o, props: tt }, it)
      })
    )
  }
}
function getNodeProps(o, a, s, $, j, _e) {
  var et = { key: a },
    tt = typeof $ == 'string'
  s.sourcePos &&
    o.position &&
    (et['data-sourcepos'] = flattenPosition(o.position)),
    s.rawSourcePos && !tt && (et.sourcePosition = o.position),
    s.includeNodeIndex &&
      j.node &&
      j.node.children &&
      !tt &&
      ((et.index = j.node.children.indexOf(o)),
      (et.parentChildCount = j.node.children.length))
  var rt =
    o.identifier !== null && o.identifier !== void 0
      ? s.definitions[o.identifier] || {}
      : null
  switch (o.type) {
    case 'root':
      assignDefined(et, { className: s.className })
      break
    case 'text':
      ;(et.nodeKey = a), (et.children = o.value)
      break
    case 'heading':
      et.level = o.depth
      break
    case 'list':
      ;(et.start = o.start),
        (et.ordered = o.ordered),
        (et.tight = !o.loose),
        (et.depth = o.depth)
      break
    case 'listItem':
      ;(et.checked = o.checked),
        (et.tight = !o.loose),
        (et.ordered = o.ordered),
        (et.index = o.index),
        (et.children = getListItemChildren(o, j).map(function(it, ot) {
          return astToReact$1(it, s, { node: o, props: et }, ot)
        }))
      break
    case 'definition':
      assignDefined(et, {
        identifier: o.identifier,
        title: o.title,
        url: o.url,
      })
      break
    case 'code':
      assignDefined(et, { language: o.lang && o.lang.split(/\s/, 1)[0] })
      break
    case 'inlineCode':
      ;(et.children = o.value), (et.inline = !0)
      break
    case 'link':
      assignDefined(et, {
        title: o.title || void 0,
        target:
          typeof s.linkTarget == 'function'
            ? s.linkTarget(o.url, o.children, o.title)
            : s.linkTarget,
        href: s.transformLinkUri
          ? s.transformLinkUri(o.url, o.children, o.title)
          : o.url,
      })
      break
    case 'image':
      assignDefined(et, {
        alt: o.alt || void 0,
        title: o.title || void 0,
        src: s.transformImageUri
          ? s.transformImageUri(o.url, o.children, o.title, o.alt)
          : o.url,
      })
      break
    case 'linkReference':
      assignDefined(
        et,
        xtend$2(rt, {
          href: s.transformLinkUri ? s.transformLinkUri(rt.href) : rt.href,
        })
      )
      break
    case 'imageReference':
      assignDefined(et, {
        src:
          s.transformImageUri && rt.href
            ? s.transformImageUri(rt.href, o.children, rt.title, o.alt)
            : rt.href,
        title: rt.title || void 0,
        alt: o.alt || void 0,
      })
      break
    case 'table':
    case 'tableHead':
    case 'tableBody':
      et.columnAlignment = o.align
      break
    case 'tableRow':
      ;(et.isHeader = j.node.type === 'tableHead'),
        (et.columnAlignment = j.props.columnAlignment)
      break
    case 'tableCell':
      assignDefined(et, {
        isHeader: j.props.isHeader,
        align: j.props.columnAlignment[_e],
      })
      break
    case 'virtualHtml':
      et.tag = o.tag
      break
    case 'html':
      ;(et.isBlock = o.position.start.line !== o.position.end.line),
        (et.escapeHtml = s.escapeHtml),
        (et.skipHtml = s.skipHtml)
      break
    case 'parsedHtml': {
      var nt
      o.children &&
        (nt = o.children.map(function(it, ot) {
          return astToReact$1(it, s, { node: o, props: et }, ot)
        })),
        (et.escapeHtml = s.escapeHtml),
        (et.skipHtml = s.skipHtml),
        (et.element = mergeNodeChildren(o, nt))
      break
    }
    default:
      assignDefined(
        et,
        xtend$2(o, { type: void 0, position: void 0, children: void 0 })
      )
  }
  return !tt && o.value && (et.value = o.value), et
}
function assignDefined(o, a) {
  for (var s in a) typeof a[s] < 'u' && (o[s] = a[s])
}
function mergeNodeChildren(o, a) {
  var s = o.element
  if (Array.isArray(s)) {
    var $ = React$3.Fragment || 'div'
    return React$3.createElement($, null, s)
  }
  if (s.props.children || a) {
    var j = React$3.Children.toArray(s.props.children).concat(a)
    return React$3.cloneElement(s, null, j)
  }
  return React$3.cloneElement(s, null)
}
function flattenPosition(o) {
  return [o.start.line, ':', o.start.column, '-', o.end.line, ':', o.end.column]
    .map(String)
    .join('')
}
function getListItemChildren(o, a) {
  return o.loose ||
    (a.node && o.index > 0 && a.node.children[o.index - 1].loose)
    ? o.children
    : unwrapParagraphs(o)
}
function unwrapParagraphs(o) {
  return o.children.reduce(function(a, s) {
    return a.concat(s.type === 'paragraph' ? s.children || [] : [s])
  }, [])
}
var astToReact_1 = astToReact$1,
  visit = unistUtilVisit,
  wrapTableRows$1 = function(o) {
    return visit(o, 'table', wrap), o
  }
function wrap(o) {
  var a = o.children
  ;(o.children = [
    {
      type: 'tableHead',
      align: o.align,
      children: [a[0]],
      position: a[0].position,
    },
  ]),
    a.length > 1 &&
      o.children.push({
        type: 'tableBody',
        align: o.align,
        children: a.slice(1),
        position: {
          start: a[1].position.start,
          end: a[a.length - 1].position.end,
        },
      })
}
var getDefinitions$1 = function o(a) {
    var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    return (a.children || []).reduce(function($, j) {
      return (
        j.type === 'definition' &&
          ($[j.identifier] = { href: j.url, title: j.title }),
        o(j, $)
      )
    }, s)
  },
  protocols = ['http', 'https', 'mailto', 'tel'],
  uriTransformer$1 = function o(a) {
    var s = (a || '').trim(),
      $ = s.charAt(0)
    if ($ === '#' || $ === '/') return s
    var j = s.indexOf(':')
    if (j === -1) return s
    for (var _e = protocols.length, et = -1; ++et < _e; ) {
      var tt = protocols[et]
      if (j === tt.length && s.slice(0, tt.length).toLowerCase() === tt)
        return s
    }
    return (
      (et = s.indexOf('?')),
      (et !== -1 && j > et) || ((et = s.indexOf('#')), et !== -1 && j > et)
        ? s
        : 'javascript:void(0)'
    )
  },
  xtend$1 = immutable$2,
  React$2 = reactExports,
  supportsStringRender =
    parseInt((React$2.version || '16').slice(0, 2), 10) >= 16,
  createElement = React$2.createElement,
  renderers = {
    break: 'br',
    paragraph: 'p',
    emphasis: 'em',
    strong: 'strong',
    thematicBreak: 'hr',
    blockquote: 'blockquote',
    delete: 'del',
    link: 'a',
    image: 'img',
    linkReference: 'a',
    imageReference: 'img',
    table: SimpleRenderer.bind(null, 'table'),
    tableHead: SimpleRenderer.bind(null, 'thead'),
    tableBody: SimpleRenderer.bind(null, 'tbody'),
    tableRow: SimpleRenderer.bind(null, 'tr'),
    tableCell: TableCell$1,
    root: Root,
    text: TextRenderer,
    list: List,
    listItem: ListItem,
    definition: NullRenderer,
    heading: Heading,
    inlineCode: InlineCode,
    code: CodeBlock,
    html: Html,
    virtualHtml: VirtualHtml,
    parsedHtml: ParsedHtml,
  }
function TextRenderer(o) {
  return supportsStringRender
    ? o.children
    : createElement('span', null, o.children)
}
function Root(o) {
  var a = !o.className,
    s = (a && React$2.Fragment) || 'div'
  return createElement(s, a ? null : o, o.children)
}
function SimpleRenderer(o, a) {
  return createElement(o, getCoreProps(a), a.children)
}
function TableCell$1(o) {
  var a = o.align ? { textAlign: o.align } : void 0,
    s = getCoreProps(o)
  return createElement(
    o.isHeader ? 'th' : 'td',
    a ? xtend$1({ style: a }, s) : s,
    o.children
  )
}
function Heading(o) {
  return createElement('h'.concat(o.level), getCoreProps(o), o.children)
}
function List(o) {
  var a = getCoreProps(o)
  return (
    o.start !== null &&
      o.start !== 1 &&
      o.start !== void 0 &&
      (a.start = o.start.toString()),
    createElement(o.ordered ? 'ol' : 'ul', a, o.children)
  )
}
function ListItem(o) {
  var a = null
  if (o.checked !== null && o.checked !== void 0) {
    var s = o.checked
    a = createElement('input', { type: 'checkbox', checked: s, readOnly: !0 })
  }
  return createElement('li', getCoreProps(o), a, o.children)
}
function CodeBlock(o) {
  var a = o.language && 'language-'.concat(o.language),
    s = createElement('code', a ? { className: a } : null, o.value)
  return createElement('pre', getCoreProps(o), s)
}
function InlineCode(o) {
  return createElement('code', getCoreProps(o), o.children)
}
function Html(o) {
  if (o.skipHtml) return null
  var a = o.isBlock ? 'div' : 'span'
  if (o.escapeHtml) {
    var s = React$2.Fragment || a
    return createElement(s, null, o.value)
  }
  var $ = { dangerouslySetInnerHTML: { __html: o.value } }
  return createElement(a, $)
}
function ParsedHtml(o) {
  return o['data-sourcepos']
    ? React$2.cloneElement(o.element, { 'data-sourcepos': o['data-sourcepos'] })
    : o.element
}
function VirtualHtml(o) {
  return createElement(o.tag, getCoreProps(o), o.children)
}
function NullRenderer() {
  return null
}
function getCoreProps(o) {
  return o['data-sourcepos'] ? { 'data-sourcepos': o['data-sourcepos'] } : {}
}
var symbols$1 = {},
  HtmlParser = '__RMD_HTML_PARSER__'
symbols$1.HtmlParser = typeof Symbol > 'u' ? HtmlParser : Symbol(HtmlParser)
function _toConsumableArray$1(o) {
  return (
    _arrayWithoutHoles$1(o) || _iterableToArray$1(o) || _nonIterableSpread$1()
  )
}
function _nonIterableSpread$1() {
  throw new TypeError('Invalid attempt to spread non-iterable instance')
}
function _iterableToArray$1(o) {
  if (
    Symbol.iterator in Object(o) ||
    Object.prototype.toString.call(o) === '[object Arguments]'
  )
    return Array.from(o)
}
function _arrayWithoutHoles$1(o) {
  if (Array.isArray(o)) {
    for (var a = 0, s = new Array(o.length); a < o.length; a++) s[a] = o[a]
    return s
  }
}
var xtend = immutable$2,
  unified = unified_1,
  parse$1 = remarkParse,
  PropTypes = propTypesExports,
  addListMetadata = mdastAddListMetadata,
  naiveHtml = naiveHtml$1,
  disallowNode = disallowNode$1,
  astToReact = astToReact_1,
  wrapTableRows = wrapTableRows$1,
  getDefinitions = getDefinitions$1,
  uriTransformer = uriTransformer$1,
  defaultRenderers = renderers,
  symbols = symbols$1,
  allTypes = Object.keys(defaultRenderers),
  ReactMarkdown = function o(a) {
    var s = a.source || a.children || '',
      $ = a.parserOptions
    if (a.allowedTypes && a.disallowedTypes)
      throw new Error(
        'Only one of `allowedTypes` and `disallowedTypes` should be defined'
      )
    var j = xtend(defaultRenderers, a.renderers),
      _e = [[parse$1, $]].concat(a.plugins || []),
      et = _e.reduce(applyParserPlugin, unified()),
      tt = et.parse(s),
      rt = xtend(a, { renderers: j, definitions: getDefinitions(tt) }),
      nt = determineAstPlugins(a),
      it = et.runSync(tt),
      ot = nt.reduce(function(at, st) {
        return st(at, rt)
      }, it)
    return astToReact(ot, rt)
  }
function applyParserPlugin(o, a) {
  return Array.isArray(a) ? o.use.apply(o, _toConsumableArray$1(a)) : o.use(a)
}
function determineAstPlugins(o) {
  var a = [wrapTableRows, addListMetadata()],
    s = o.disallowedTypes
  o.allowedTypes &&
    (s = allTypes.filter(function(et) {
      return et !== 'root' && o.allowedTypes.indexOf(et) === -1
    }))
  var $ = o.unwrapDisallowed ? 'unwrap' : 'remove'
  s && s.length > 0 && a.push(disallowNode.ofType(s, $)),
    o.allowNode && a.push(disallowNode.ifNotMatch(o.allowNode, $))
  var j = !o.escapeHtml && !o.skipHtml,
    _e = (o.astPlugins || []).some(function(et) {
      var tt = Array.isArray(et) ? et[0] : et
      return tt.identity === symbols.HtmlParser
    })
  return (
    j && !_e && a.push(naiveHtml), o.astPlugins ? a.concat(o.astPlugins) : a
  )
}
ReactMarkdown.defaultProps = {
  renderers: {},
  escapeHtml: !0,
  skipHtml: !1,
  sourcePos: !1,
  rawSourcePos: !1,
  transformLinkUri: uriTransformer,
  astPlugins: [],
  plugins: [],
  parserOptions: {},
}
ReactMarkdown.propTypes = {
  className: PropTypes.string,
  source: PropTypes.string,
  children: PropTypes.string,
  sourcePos: PropTypes.bool,
  rawSourcePos: PropTypes.bool,
  escapeHtml: PropTypes.bool,
  skipHtml: PropTypes.bool,
  allowNode: PropTypes.func,
  allowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),
  disallowedTypes: PropTypes.arrayOf(PropTypes.oneOf(allTypes)),
  transformLinkUri: PropTypes.oneOfType([PropTypes.func, PropTypes.bool]),
  linkTarget: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
  transformImageUri: PropTypes.func,
  astPlugins: PropTypes.arrayOf(PropTypes.func),
  unwrapDisallowed: PropTypes.bool,
  renderers: PropTypes.object,
  plugins: PropTypes.array,
  parserOptions: PropTypes.object,
}
ReactMarkdown.types = allTypes
ReactMarkdown.renderers = defaultRenderers
ReactMarkdown.uriTransformer = uriTransformer
var reactMarkdown = ReactMarkdown
const ReactMarkdown$1 = getDefaultExportFromCjs(reactMarkdown),
  LogView = ({ notificationLog: o, todaysNotifications: a }) =>
    jsxRuntimeExports.jsxs('div', {
      className: 'LogView notification-container',
      children: [
        jsxRuntimeExports.jsx('h3', { children: 'Today' }),
        jsxRuntimeExports.jsx('ul', {
          children: a.map(({ message: s, onClick: $, severity: j }) =>
            jsxRuntimeExports.jsx('li', {
              key: s,
              children: jsxRuntimeExports.jsx(Alert, {
                elevation: 3,
                onClick: $,
                severity: j,
                style: { cursor: $ ? 'pointer' : 'default' },
                children: jsxRuntimeExports.jsx(ReactMarkdown$1, { source: s }),
              }),
            })
          ),
        }),
        jsxRuntimeExports.jsx(Divider, {}),
        jsxRuntimeExports.jsx('ul', {
          children: o.map(({ day: s, notifications: $ }, j) =>
            jsxRuntimeExports.jsxs(
              'li',
              {
                children: [
                  jsxRuntimeExports.jsxs('h3', { children: ['Day ', s] }),
                  ['success', 'info', 'warning', 'error'].map((_e, et) =>
                    $[_e].length
                      ? jsxRuntimeExports.jsx(Alert, {
                          elevation: 3,
                          key: `${_e}_${et}`,
                          severity: _e,
                          children: $[_e].map((tt, rt) =>
                            jsxRuntimeExports.jsx(ReactMarkdown$1, {
                              key: `${rt}_${tt}`,
                              source: tt,
                            })
                          ),
                        })
                      : null
                  ),
                ],
              },
              `${j}_${$.info.join()}`
            )
          ),
        }),
      ],
    })
LogView.propTypes = {
  notificationLog: propTypesExports.array.isRequired,
  todaysNotifications: propTypesExports.array.isRequired,
}
function Consumer$l(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(LogView, { ...a, ...s, ...o }),
  })
}
const Stack = createStack({
  createStyledComponent: styled('div', {
    name: 'MuiStack',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  }),
  useThemeProps: o => useDefaultProps({ props: o, name: 'MuiStack' }),
})
function getFormControlLabelUtilityClasses(o) {
  return generateUtilityClass('MuiFormControlLabel', o)
}
const formControlLabelClasses = generateUtilityClasses('MuiFormControlLabel', [
    'root',
    'labelPlacementStart',
    'labelPlacementTop',
    'labelPlacementBottom',
    'disabled',
    'label',
    'error',
    'required',
    'asterisk',
  ]),
  _excluded$k = [
    'checked',
    'className',
    'componentsProps',
    'control',
    'disabled',
    'disableTypography',
    'inputRef',
    'label',
    'labelPlacement',
    'name',
    'onChange',
    'required',
    'slotProps',
    'value',
  ],
  useUtilityClasses$i = o => {
    const {
        classes: a,
        disabled: s,
        labelPlacement: $,
        error: j,
        required: _e,
      } = o,
      et = {
        root: [
          'root',
          s && 'disabled',
          `labelPlacement${capitalize$2($)}`,
          j && 'error',
          _e && 'required',
        ],
        label: ['label', s && 'disabled'],
        asterisk: ['asterisk', j && 'error'],
      }
    return composeClasses(et, getFormControlLabelUtilityClasses, a)
  },
  FormControlLabelRoot = styled('label', {
    name: 'MuiFormControlLabel',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        { [`& .${formControlLabelClasses.label}`]: a.label },
        a.root,
        a[`labelPlacement${capitalize$2(s.labelPlacement)}`],
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        display: 'inline-flex',
        alignItems: 'center',
        cursor: 'pointer',
        verticalAlign: 'middle',
        WebkitTapHighlightColor: 'transparent',
        marginLeft: -11,
        marginRight: 16,
        [`&.${formControlLabelClasses.disabled}`]: { cursor: 'default' },
      },
      a.labelPlacement === 'start' && {
        flexDirection: 'row-reverse',
        marginLeft: 16,
        marginRight: -11,
      },
      a.labelPlacement === 'top' && {
        flexDirection: 'column-reverse',
        marginLeft: 16,
      },
      a.labelPlacement === 'bottom' && {
        flexDirection: 'column',
        marginLeft: 16,
      },
      {
        [`& .${formControlLabelClasses.label}`]: {
          [`&.${formControlLabelClasses.disabled}`]: {
            color: (o.vars || o).palette.text.disabled,
          },
        },
      }
    )
  ),
  AsteriskComponent = styled('span', {
    name: 'MuiFormControlLabel',
    slot: 'Asterisk',
    overridesResolver: (o, a) => a.asterisk,
  })(({ theme: o }) => ({
    [`&.${formControlLabelClasses.error}`]: {
      color: (o.vars || o).palette.error.main,
    },
  })),
  FormControlLabel = reactExports.forwardRef(function o(a, s) {
    var $, j
    const _e = useDefaultProps({ props: a, name: 'MuiFormControlLabel' }),
      {
        className: et,
        componentsProps: tt = {},
        control: rt,
        disabled: nt,
        disableTypography: it,
        label: ot,
        labelPlacement: at = 'end',
        required: st,
        slotProps: ut = {},
      } = _e,
      ct = _objectWithoutPropertiesLoose$3(_e, _excluded$k),
      dt = useFormControl(),
      ft =
        ($ = nt ?? rt.props.disabled) != null
          ? $
          : dt == null
          ? void 0
          : dt.disabled,
      mt = st ?? rt.props.required,
      vt = { disabled: ft, required: mt }
    ;['checked', 'name', 'onChange', 'value', 'inputRef'].forEach(Ct => {
      typeof rt.props[Ct] > 'u' && typeof _e[Ct] < 'u' && (vt[Ct] = _e[Ct])
    })
    const yt = formControlState({
        props: _e,
        muiFormControl: dt,
        states: ['error'],
      }),
      pt = _extends$5({}, _e, {
        disabled: ft,
        labelPlacement: at,
        required: mt,
        error: yt.error,
      }),
      ht = useUtilityClasses$i(pt),
      At = (j = ut.typography) != null ? j : tt.typography
    let wt = ot
    return (
      wt != null &&
        wt.type !== Typography &&
        !it &&
        (wt = jsxRuntimeExports.jsx(
          Typography,
          _extends$5({ component: 'span' }, At, {
            className: clsx$1(ht.label, At == null ? void 0 : At.className),
            children: wt,
          })
        )),
      jsxRuntimeExports.jsxs(
        FormControlLabelRoot,
        _extends$5(
          { className: clsx$1(ht.root, et), ownerState: pt, ref: s },
          ct,
          {
            children: [
              reactExports.cloneElement(rt, vt),
              mt
                ? jsxRuntimeExports.jsxs(Stack, {
                    display: 'block',
                    children: [
                      wt,
                      jsxRuntimeExports.jsxs(AsteriskComponent, {
                        ownerState: pt,
                        'aria-hidden': !0,
                        className: ht.asterisk,
                        children: ['', '*'],
                      }),
                    ],
                  })
                : wt,
            ],
          }
        )
      )
    )
  })
function getSwitchBaseUtilityClass(o) {
  return generateUtilityClass('PrivateSwitchBase', o)
}
generateUtilityClasses('PrivateSwitchBase', [
  'root',
  'checked',
  'disabled',
  'input',
  'edgeStart',
  'edgeEnd',
])
const _excluded$j = [
    'autoFocus',
    'checked',
    'checkedIcon',
    'className',
    'defaultChecked',
    'disabled',
    'disableFocusRipple',
    'edge',
    'icon',
    'id',
    'inputProps',
    'inputRef',
    'name',
    'onBlur',
    'onChange',
    'onFocus',
    'readOnly',
    'required',
    'tabIndex',
    'type',
    'value',
  ],
  useUtilityClasses$h = o => {
    const { classes: a, checked: s, disabled: $, edge: j } = o,
      _e = {
        root: [
          'root',
          s && 'checked',
          $ && 'disabled',
          j && `edge${capitalize$2(j)}`,
        ],
        input: ['input'],
      }
    return composeClasses(_e, getSwitchBaseUtilityClass, a)
  },
  SwitchBaseRoot = styled(ButtonBase)(({ ownerState: o }) =>
    _extends$5(
      { padding: 9, borderRadius: '50%' },
      o.edge === 'start' && { marginLeft: o.size === 'small' ? -3 : -12 },
      o.edge === 'end' && { marginRight: o.size === 'small' ? -3 : -12 }
    )
  ),
  SwitchBaseInput = styled('input', {
    shouldForwardProp: rootShouldForwardProp,
  })({
    cursor: 'inherit',
    position: 'absolute',
    opacity: 0,
    width: '100%',
    height: '100%',
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1,
  }),
  SwitchBase = reactExports.forwardRef(function o(a, s) {
    const {
        autoFocus: $,
        checked: j,
        checkedIcon: _e,
        className: et,
        defaultChecked: tt,
        disabled: rt,
        disableFocusRipple: nt = !1,
        edge: it = !1,
        icon: ot,
        id: at,
        inputProps: st,
        inputRef: ut,
        name: ct,
        onBlur: dt,
        onChange: ft,
        onFocus: mt,
        readOnly: vt,
        required: yt = !1,
        tabIndex: pt,
        type: ht,
        value: At,
      } = a,
      wt = _objectWithoutPropertiesLoose$3(a, _excluded$j),
      [Ct, Dt] = useControlled({
        controlled: j,
        default: !!tt,
        name: 'SwitchBase',
        state: 'checked',
      }),
      jt = useFormControl(),
      Et = kt => {
        mt && mt(kt), jt && jt.onFocus && jt.onFocus(kt)
      },
      St = kt => {
        dt && dt(kt), jt && jt.onBlur && jt.onBlur(kt)
      },
      Bt = kt => {
        if (kt.nativeEvent.defaultPrevented) return
        const Ot = kt.target.checked
        Dt(Ot), ft && ft(kt, Ot)
      }
    let Mt = rt
    jt && typeof Mt > 'u' && (Mt = jt.disabled)
    const Ut = ht === 'checkbox' || ht === 'radio',
      Wt = _extends$5({}, a, {
        checked: Ct,
        disabled: Mt,
        disableFocusRipple: nt,
        edge: it,
      }),
      Tt = useUtilityClasses$h(Wt)
    return jsxRuntimeExports.jsxs(
      SwitchBaseRoot,
      _extends$5(
        {
          component: 'span',
          className: clsx$1(Tt.root, et),
          centerRipple: !0,
          focusRipple: !nt,
          disabled: Mt,
          tabIndex: null,
          role: void 0,
          onFocus: Et,
          onBlur: St,
          ownerState: Wt,
          ref: s,
        },
        wt,
        {
          children: [
            jsxRuntimeExports.jsx(
              SwitchBaseInput,
              _extends$5(
                {
                  autoFocus: $,
                  checked: j,
                  defaultChecked: tt,
                  className: Tt.input,
                  disabled: Mt,
                  id: Ut ? at : void 0,
                  name: ct,
                  onChange: Bt,
                  readOnly: vt,
                  ref: ut,
                  required: yt,
                  ownerState: Wt,
                  tabIndex: pt,
                  type: ht,
                },
                ht === 'checkbox' && At === void 0 ? {} : { value: At },
                st
              )
            ),
            Ct ? _e : ot,
          ],
        }
      )
    )
  })
function getSwitchUtilityClass(o) {
  return generateUtilityClass('MuiSwitch', o)
}
const switchClasses = generateUtilityClasses('MuiSwitch', [
    'root',
    'edgeStart',
    'edgeEnd',
    'switchBase',
    'colorPrimary',
    'colorSecondary',
    'sizeSmall',
    'sizeMedium',
    'checked',
    'disabled',
    'input',
    'thumb',
    'track',
  ]),
  _excluded$i = ['className', 'color', 'edge', 'size', 'sx'],
  useUtilityClasses$g = o => {
    const {
        classes: a,
        edge: s,
        size: $,
        color: j,
        checked: _e,
        disabled: et,
      } = o,
      tt = {
        root: ['root', s && `edge${capitalize$2(s)}`, `size${capitalize$2($)}`],
        switchBase: [
          'switchBase',
          `color${capitalize$2(j)}`,
          _e && 'checked',
          et && 'disabled',
        ],
        thumb: ['thumb'],
        track: ['track'],
        input: ['input'],
      },
      rt = composeClasses(tt, getSwitchUtilityClass, a)
    return _extends$5({}, a, rt)
  },
  SwitchRoot = styled('span', {
    name: 'MuiSwitch',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        s.edge && a[`edge${capitalize$2(s.edge)}`],
        a[`size${capitalize$2(s.size)}`],
      ]
    },
  })({
    display: 'inline-flex',
    width: 34 + 12 * 2,
    height: 14 + 12 * 2,
    overflow: 'hidden',
    padding: 12,
    boxSizing: 'border-box',
    position: 'relative',
    flexShrink: 0,
    zIndex: 0,
    verticalAlign: 'middle',
    '@media print': { colorAdjust: 'exact' },
    variants: [
      { props: { edge: 'start' }, style: { marginLeft: -8 } },
      { props: { edge: 'end' }, style: { marginRight: -8 } },
      {
        props: { size: 'small' },
        style: {
          width: 40,
          height: 24,
          padding: 7,
          [`& .${switchClasses.thumb}`]: { width: 16, height: 16 },
          [`& .${switchClasses.switchBase}`]: {
            padding: 4,
            [`&.${switchClasses.checked}`]: { transform: 'translateX(16px)' },
          },
        },
      },
    ],
  }),
  SwitchSwitchBase = styled(SwitchBase, {
    name: 'MuiSwitch',
    slot: 'SwitchBase',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.switchBase,
        { [`& .${switchClasses.input}`]: a.input },
        s.color !== 'default' && a[`color${capitalize$2(s.color)}`],
      ]
    },
  })(
    ({ theme: o }) => ({
      position: 'absolute',
      top: 0,
      left: 0,
      zIndex: 1,
      color: o.vars
        ? o.vars.palette.Switch.defaultColor
        : `${
            o.palette.mode === 'light'
              ? o.palette.common.white
              : o.palette.grey[300]
          }`,
      transition: o.transitions.create(['left', 'transform'], {
        duration: o.transitions.duration.shortest,
      }),
      [`&.${switchClasses.checked}`]: { transform: 'translateX(20px)' },
      [`&.${switchClasses.disabled}`]: {
        color: o.vars
          ? o.vars.palette.Switch.defaultDisabledColor
          : `${
              o.palette.mode === 'light'
                ? o.palette.grey[100]
                : o.palette.grey[600]
            }`,
      },
      [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
        opacity: 0.5,
      },
      [`&.${switchClasses.disabled} + .${switchClasses.track}`]: {
        opacity: o.vars
          ? o.vars.opacity.switchTrackDisabled
          : `${o.palette.mode === 'light' ? 0.12 : 0.2}`,
      },
      [`& .${switchClasses.input}`]: { left: '-100%', width: '300%' },
    }),
    ({ theme: o }) => ({
      '&:hover': {
        backgroundColor: o.vars
          ? `rgba(${o.vars.palette.action.activeChannel} / ${o.vars.palette.action.hoverOpacity})`
          : alpha_1(o.palette.action.active, o.palette.action.hoverOpacity),
        '@media (hover: none)': { backgroundColor: 'transparent' },
      },
      variants: [
        ...Object.entries(o.palette)
          .filter(([, a]) => a.main && a.light)
          .map(([a]) => ({
            props: { color: a },
            style: {
              [`&.${switchClasses.checked}`]: {
                color: (o.vars || o).palette[a].main,
                '&:hover': {
                  backgroundColor: o.vars
                    ? `rgba(${o.vars.palette[a].mainChannel} / ${o.vars.palette.action.hoverOpacity})`
                    : alpha_1(o.palette[a].main, o.palette.action.hoverOpacity),
                  '@media (hover: none)': { backgroundColor: 'transparent' },
                },
                [`&.${switchClasses.disabled}`]: {
                  color: o.vars
                    ? o.vars.palette.Switch[`${a}DisabledColor`]
                    : `${
                        o.palette.mode === 'light'
                          ? lighten_1(o.palette[a].main, 0.62)
                          : darken_1(o.palette[a].main, 0.55)
                      }`,
                },
              },
              [`&.${switchClasses.checked} + .${switchClasses.track}`]: {
                backgroundColor: (o.vars || o).palette[a].main,
              },
            },
          })),
      ],
    })
  ),
  SwitchTrack = styled('span', {
    name: 'MuiSwitch',
    slot: 'Track',
    overridesResolver: (o, a) => a.track,
  })(({ theme: o }) => ({
    height: '100%',
    width: '100%',
    borderRadius: 14 / 2,
    zIndex: -1,
    transition: o.transitions.create(['opacity', 'background-color'], {
      duration: o.transitions.duration.shortest,
    }),
    backgroundColor: o.vars
      ? o.vars.palette.common.onBackground
      : `${
          o.palette.mode === 'light'
            ? o.palette.common.black
            : o.palette.common.white
        }`,
    opacity: o.vars
      ? o.vars.opacity.switchTrack
      : `${o.palette.mode === 'light' ? 0.38 : 0.3}`,
  })),
  SwitchThumb = styled('span', {
    name: 'MuiSwitch',
    slot: 'Thumb',
    overridesResolver: (o, a) => a.thumb,
  })(({ theme: o }) => ({
    boxShadow: (o.vars || o).shadows[1],
    backgroundColor: 'currentColor',
    width: 20,
    height: 20,
    borderRadius: '50%',
  })),
  Switch = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiSwitch' }),
      {
        className: j,
        color: _e = 'primary',
        edge: et = !1,
        size: tt = 'medium',
        sx: rt,
      } = $,
      nt = _objectWithoutPropertiesLoose$3($, _excluded$i),
      it = _extends$5({}, $, { color: _e, edge: et, size: tt }),
      ot = useUtilityClasses$g(it),
      at = jsxRuntimeExports.jsx(SwitchThumb, {
        className: ot.thumb,
        ownerState: it,
      })
    return jsxRuntimeExports.jsxs(SwitchRoot, {
      className: clsx$1(ot.root, j),
      sx: rt,
      ownerState: it,
      children: [
        jsxRuntimeExports.jsx(
          SwitchSwitchBase,
          _extends$5(
            {
              type: 'checkbox',
              icon: at,
              checkedIcon: at,
              ref: s,
              ownerState: it,
            },
            nt,
            { classes: _extends$5({}, ot, { root: ot.switchBase }) }
          )
        ),
        jsxRuntimeExports.jsx(SwitchTrack, {
          className: ot.track,
          ownerState: it,
        }),
      ],
    })
  })
var lib$1 = {}
Object.defineProperty(lib$1, '__esModule', { value: !0 })
var _extends$1 =
    Object.assign ||
    function(o) {
      for (var a = 1; a < arguments.length; a++) {
        var s = arguments[a]
        for (var $ in s)
          Object.prototype.hasOwnProperty.call(s, $) && (o[$] = s[$])
      }
      return o
    },
  _typeof$3 =
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? function(o) {
          return typeof o
        }
      : function(o) {
          return o &&
            typeof Symbol == 'function' &&
            o.constructor === Symbol &&
            o !== Symbol.prototype
            ? 'symbol'
            : typeof o
        },
  _createClass$1 = (function() {
    function o(a, s) {
      for (var $ = 0; $ < s.length; $++) {
        var j = s[$]
        ;(j.enumerable = j.enumerable || !1),
          (j.configurable = !0),
          'value' in j && (j.writable = !0),
          Object.defineProperty(a, j.key, j)
      }
    }
    return function(a, s, $) {
      return s && o(a.prototype, s), $ && o(a, $), a
    }
  })(),
  _react = reactExports,
  React$1 = _interopRequireWildcard(_react),
  _reactDom = reactDomExports,
  _reactDom2 = _interopRequireDefault$7(_reactDom)
function _interopRequireDefault$7(o) {
  return o && o.__esModule ? o : { default: o }
}
function _interopRequireWildcard(o) {
  if (o && o.__esModule) return o
  var a = {}
  if (o != null)
    for (var s in o) Object.prototype.hasOwnProperty.call(o, s) && (a[s] = o[s])
  return (a.default = o), a
}
function _objectWithoutProperties$1(o, a) {
  var s = {}
  for (var $ in o)
    a.indexOf($) >= 0 ||
      (Object.prototype.hasOwnProperty.call(o, $) && (s[$] = o[$]))
  return s
}
function _classCallCheck$1(o, a) {
  if (!(o instanceof a))
    throw new TypeError('Cannot call a class as a function')
}
function _possibleConstructorReturn(o, a) {
  if (!o)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    )
  return a && (typeof a == 'object' || typeof a == 'function') ? a : o
}
function _inherits(o, a) {
  if (typeof a != 'function' && a !== null)
    throw new TypeError(
      'Super expression must either be null or a function, not ' + typeof a
    )
  ;(o.prototype = Object.create(a && a.prototype, {
    constructor: { value: o, enumerable: !1, writable: !0, configurable: !0 },
  })),
    a &&
      (Object.setPrototypeOf ? Object.setPrototypeOf(o, a) : (o.__proto__ = a))
}
var FileInput = (function(o) {
    _inherits(a, o)
    function a(s) {
      _classCallCheck$1(this, a)
      var $ = _possibleConstructorReturn(
        this,
        (a.__proto__ || Object.getPrototypeOf(a)).call(this, s)
      )
      ;($.handleChange = function(_e) {
        var et = Array.prototype.slice.call(_e.target.files),
          tt = ($.props.as || 'url').toLowerCase()
        Promise.all(
          et.map(function(rt) {
            return new Promise(function(nt, it) {
              var ot = new FileReader()
              switch (
                ((ot.onload = function(at) {
                  nt([at, rt])
                }),
                tt)
              ) {
                case 'binary': {
                  ot.readAsBinaryString(rt)
                  break
                }
                case 'buffer': {
                  ot.readAsArrayBuffer(rt)
                  break
                }
                case 'text': {
                  ot.readAsText(rt)
                  break
                }
                case 'url': {
                  ot.readAsDataURL(rt)
                  break
                }
              }
            })
          })
        ).then(function(rt) {
          $.props.onChange(_e, rt)
        })
      }),
        ($.triggerInput = function() {
          var _e = _reactDom2.default.findDOMNode($._reactFileReaderInput)
          _e && _e.click()
        })
      var j =
        (typeof window > 'u' ? 'undefined' : _typeof$3(window)) === 'object'
          ? window
          : {}
      return (
        (!j.File || !j.FileReader || !j.FileList || !j.Blob) &&
          console.warn(
            '[react-file-reader-input] Some file APIs detected as not supported. File reader functionality may not fully work.'
          ),
        $
      )
    }
    return (
      _createClass$1(a, [
        {
          key: 'render',
          value: function() {
            var $ = this,
              j = this.props
            j.as
            var _e = j.children,
              et = j.style,
              tt = _objectWithoutProperties$1(j, ['as', 'children', 'style']),
              rt = _e ? { position: 'absolute', top: '-9999px' } : {}
            return React$1.createElement(
              'div',
              {
                className: '_react-file-reader-input',
                onClick: this.triggerInput,
                style: et,
              },
              React$1.createElement(
                'input',
                _extends$1({}, tt, {
                  type: 'file',
                  ref: function(it) {
                    $._reactFileReaderInput = it
                  },
                  onChange: this.handleChange,
                  onClick: function() {
                    $._reactFileReaderInput.value = null
                  },
                  style: rt,
                })
              ),
              _e
            )
          },
        },
      ]),
      a
    )
  })(React$1.Component),
  _default$2 = (lib$1.default = FileInput)
const RandomSeedInput = ({ search: o = window$1.location.search }) => {
  const {
      handlers: { handleRNGSeedChange: a },
    } = reactExports.useContext(FarmhandContext),
    [s, $] = reactExports.useState(new URLSearchParams(o).get('seed') ?? ''),
    j = et => {
      $(et.target.value)
    },
    _e = et => {
      et.preventDefault(), a(s)
    }
  return jsxRuntimeExports.jsx('form', {
    className: 'RandomSeedInput',
    onSubmit: _e,
    children: jsxRuntimeExports.jsx(TextField, {
      value: s,
      variant: 'outlined',
      label: 'Random number seed',
      onChange: j,
      inputProps: { maxLength: 30 },
    }),
  })
}
RandomSeedInput.propTypes = { search: propTypesExports.string }
const SettingsView = ({
  allowCustomPeerCowNames: o,
  handleAllowCustomPeerCowNamesChange: a,
  handleClearPersistedDataClick: s,
  handleExportDataClick: $,
  handleImportDataClick: j,
  handleSaveButtonClick: _e,
  handleShowNotificationsChange: et,
  handleUseAlternateEndDayButtonPositionChange: tt,
  handleShowHomeScreenChange: rt,
  showNotifications: nt,
  useAlternateEndDayButtonPosition: it,
  showHomeScreen: ot,
}) => {
  const [at, st] = reactExports.useState(!1)
  return jsxRuntimeExports.jsxs('div', {
    className: 'SettingsView',
    children: [
      jsxRuntimeExports.jsx('div', {
        className: 'button-row',
        children: jsxRuntimeExports.jsx(Button, {
          color: 'primary',
          onClick: _e,
          variant: 'contained',
          children: 'Save Game',
        }),
      }),
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsx(RandomSeedInput, {}),
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsxs(FormControl, {
        variant: 'standard',
        component: 'fieldset',
        children: [
          jsxRuntimeExports.jsx(FormLabel, {
            component: 'legend',
            children: 'Options',
          }),
          jsxRuntimeExports.jsxs(FormGroup, {
            children: [
              jsxRuntimeExports.jsx(FormControlLabel, {
                control: jsxRuntimeExports.jsx(Switch, {
                  color: 'primary',
                  checked: it,
                  onChange: tt,
                  name: 'use-alternate-end-day-button-position',
                }),
                label: 'Use alternate position for Bed button',
              }),
              jsxRuntimeExports.jsx(FormControlLabel, {
                control: jsxRuntimeExports.jsx(Switch, {
                  color: 'primary',
                  checked: nt,
                  onChange: et,
                  name: 'show-notifications',
                }),
                label: 'Show new notifications',
              }),
              jsxRuntimeExports.jsx(FormControlLabel, {
                control: jsxRuntimeExports.jsx(Switch, {
                  color: 'primary',
                  checked: ot,
                  onChange: rt,
                  name: 'show-home-screen',
                }),
                label: 'Show the Home Screen',
              }),
              jsxRuntimeExports.jsx(FormControlLabel, {
                control: jsxRuntimeExports.jsx(Switch, {
                  color: 'primary',
                  checked: o,
                  onChange: a,
                  name: 'allow-custom-peer-cow-names',
                }),
                label:
                  'Display custom names for cows received from other players',
              }),
            ],
          }),
        ],
      }),
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsxs('div', {
        className: 'button-row',
        children: [
          jsxRuntimeExports.jsx(Tooltip, {
            arrow: !0,
            placement: 'top',
            title: 'Save your game data as a file on your device',
            children: jsxRuntimeExports.jsx(Button, {
              color: 'primary',
              onClick: $,
              variant: 'contained',
              children: 'Export Game Data',
            }),
          }),
          jsxRuntimeExports.jsx(_default$2, {
            as: 'text',
            onChange: (ut, ct) => {
              j(ct)
            },
            children: jsxRuntimeExports.jsx(Tooltip, {
              arrow: !0,
              placement: 'top',
              title: 'Load game data that was previously saved',
              children: jsxRuntimeExports.jsx(Button, {
                color: 'primary',
                variant: 'contained',
                children: 'Import Game Data',
              }),
            }),
          }),
        ],
      }),
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsx('div', {
        className: 'button-row',
        children: jsxRuntimeExports.jsx(Button, {
          color: 'primary',
          onClick: () => st(!0),
          variant: 'contained',
          children: 'Delete Game Data',
        }),
      }),
      jsxRuntimeExports.jsxs(Dialog, {
        className: 'Farmhand',
        open: at,
        onClose: () => st(!1),
        maxWidth: 'xs',
        children: [
          jsxRuntimeExports.jsx(DialogTitle, { children: 'Delete game data?' }),
          jsxRuntimeExports.jsxs(DialogContent, {
            dividers: !0,
            children: [
              jsxRuntimeExports.jsx('p', {
                children:
                  "Are you sure that you want to delete your game data? This can't be undone. You may want to export your game data first.",
              }),
              jsxRuntimeExports.jsxs(DialogActions, {
                children: [
                  jsxRuntimeExports.jsx(Button, {
                    autoFocus: !0,
                    color: 'primary',
                    onClick: () => st(!1),
                    children: 'Cancel',
                  }),
                  jsxRuntimeExports.jsx(Button, {
                    color: 'error',
                    onClick: () => {
                      s(), st(!1)
                    },
                    children: 'Do it',
                  }),
                ],
              }),
            ],
          }),
        ],
      }),
    ],
  })
}
SettingsView.propTypes = {
  allowCustomPeerCowNames: propTypesExports.bool.isRequired,
  handleAllowCustomPeerCowNamesChange: propTypesExports.func.isRequired,
  handleClearPersistedDataClick: propTypesExports.func.isRequired,
  handleExportDataClick: propTypesExports.func.isRequired,
  handleImportDataClick: propTypesExports.func.isRequired,
  handleSaveButtonClick: propTypesExports.func.isRequired,
  handleShowHomeScreenChange: propTypesExports.func.isRequired,
  handleShowNotificationsChange: propTypesExports.func.isRequired,
  handleUseAlternateEndDayButtonPositionChange:
    propTypesExports.func.isRequired,
  showHomeScreen: propTypesExports.bool.isRequired,
  showNotifications: propTypesExports.bool.isRequired,
  useAlternateEndDayButtonPosition: propTypesExports.bool.isRequired,
}
function Consumer$k(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(SettingsView, { ...a, ...s, ...o }),
  })
}
const TableContext = reactExports.createContext()
function getTableUtilityClass(o) {
  return generateUtilityClass('MuiTable', o)
}
generateUtilityClasses('MuiTable', ['root', 'stickyHeader'])
const _excluded$h = [
    'className',
    'component',
    'padding',
    'size',
    'stickyHeader',
  ],
  useUtilityClasses$f = o => {
    const { classes: a, stickyHeader: s } = o
    return composeClasses(
      { root: ['root', s && 'stickyHeader'] },
      getTableUtilityClass,
      a
    )
  },
  TableRoot = styled('table', {
    name: 'MuiTable',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, s.stickyHeader && a.stickyHeader]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {
        display: 'table',
        width: '100%',
        borderCollapse: 'collapse',
        borderSpacing: 0,
        '& caption': _extends$5({}, o.typography.body2, {
          padding: o.spacing(2),
          color: (o.vars || o).palette.text.secondary,
          textAlign: 'left',
          captionSide: 'bottom',
        }),
      },
      a.stickyHeader && { borderCollapse: 'separate' }
    )
  ),
  defaultComponent$2 = 'table',
  Table = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTable' }),
      {
        className: j,
        component: _e = defaultComponent$2,
        padding: et = 'normal',
        size: tt = 'medium',
        stickyHeader: rt = !1,
      } = $,
      nt = _objectWithoutPropertiesLoose$3($, _excluded$h),
      it = _extends$5({}, $, {
        component: _e,
        padding: et,
        size: tt,
        stickyHeader: rt,
      }),
      ot = useUtilityClasses$f(it),
      at = reactExports.useMemo(
        () => ({ padding: et, size: tt, stickyHeader: rt }),
        [et, tt, rt]
      )
    return jsxRuntimeExports.jsx(TableContext.Provider, {
      value: at,
      children: jsxRuntimeExports.jsx(
        TableRoot,
        _extends$5(
          {
            as: _e,
            role: _e === defaultComponent$2 ? null : 'table',
            ref: s,
            className: clsx$1(ot.root, j),
            ownerState: it,
          },
          nt
        )
      ),
    })
  }),
  Tablelvl2Context = reactExports.createContext()
function getTableBodyUtilityClass(o) {
  return generateUtilityClass('MuiTableBody', o)
}
generateUtilityClasses('MuiTableBody', ['root'])
const _excluded$g = ['className', 'component'],
  useUtilityClasses$e = o => {
    const { classes: a } = o
    return composeClasses({ root: ['root'] }, getTableBodyUtilityClass, a)
  },
  TableBodyRoot = styled('tbody', {
    name: 'MuiTableBody',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({ display: 'table-row-group' }),
  tablelvl2 = { variant: 'body' },
  defaultComponent$1 = 'tbody',
  TableBody = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTableBody' }),
      { className: j, component: _e = defaultComponent$1 } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$g),
      tt = _extends$5({}, $, { component: _e }),
      rt = useUtilityClasses$e(tt)
    return jsxRuntimeExports.jsx(Tablelvl2Context.Provider, {
      value: tablelvl2,
      children: jsxRuntimeExports.jsx(
        TableBodyRoot,
        _extends$5(
          {
            className: clsx$1(rt.root, j),
            as: _e,
            ref: s,
            role: _e === defaultComponent$1 ? null : 'rowgroup',
            ownerState: tt,
          },
          et
        )
      ),
    })
  })
function getTableCellUtilityClass(o) {
  return generateUtilityClass('MuiTableCell', o)
}
const tableCellClasses = generateUtilityClasses('MuiTableCell', [
    'root',
    'head',
    'body',
    'footer',
    'sizeSmall',
    'sizeMedium',
    'paddingCheckbox',
    'paddingNone',
    'alignLeft',
    'alignCenter',
    'alignRight',
    'alignJustify',
    'stickyHeader',
  ]),
  _excluded$f = [
    'align',
    'className',
    'component',
    'padding',
    'scope',
    'size',
    'sortDirection',
    'variant',
  ],
  useUtilityClasses$d = o => {
    const {
        classes: a,
        variant: s,
        align: $,
        padding: j,
        size: _e,
        stickyHeader: et,
      } = o,
      tt = {
        root: [
          'root',
          s,
          et && 'stickyHeader',
          $ !== 'inherit' && `align${capitalize$2($)}`,
          j !== 'normal' && `padding${capitalize$2(j)}`,
          `size${capitalize$2(_e)}`,
        ],
      }
    return composeClasses(tt, getTableCellUtilityClass, a)
  },
  TableCellRoot = styled('td', {
    name: 'MuiTableCell',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        a[s.variant],
        a[`size${capitalize$2(s.size)}`],
        s.padding !== 'normal' && a[`padding${capitalize$2(s.padding)}`],
        s.align !== 'inherit' && a[`align${capitalize$2(s.align)}`],
        s.stickyHeader && a.stickyHeader,
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {},
      o.typography.body2,
      {
        display: 'table-cell',
        verticalAlign: 'inherit',
        borderBottom: o.vars
          ? `1px solid ${o.vars.palette.TableCell.border}`
          : `1px solid
    ${
      o.palette.mode === 'light'
        ? lighten_1(alpha_1(o.palette.divider, 1), 0.88)
        : darken_1(alpha_1(o.palette.divider, 1), 0.68)
    }`,
        textAlign: 'left',
        padding: 16,
      },
      a.variant === 'head' && {
        color: (o.vars || o).palette.text.primary,
        lineHeight: o.typography.pxToRem(24),
        fontWeight: o.typography.fontWeightMedium,
      },
      a.variant === 'body' && { color: (o.vars || o).palette.text.primary },
      a.variant === 'footer' && {
        color: (o.vars || o).palette.text.secondary,
        lineHeight: o.typography.pxToRem(21),
        fontSize: o.typography.pxToRem(12),
      },
      a.size === 'small' && {
        padding: '6px 16px',
        [`&.${tableCellClasses.paddingCheckbox}`]: {
          width: 24,
          padding: '0 12px 0 16px',
          '& > *': { padding: 0 },
        },
      },
      a.padding === 'checkbox' && { width: 48, padding: '0 0 0 4px' },
      a.padding === 'none' && { padding: 0 },
      a.align === 'left' && { textAlign: 'left' },
      a.align === 'center' && { textAlign: 'center' },
      a.align === 'right' && {
        textAlign: 'right',
        flexDirection: 'row-reverse',
      },
      a.align === 'justify' && { textAlign: 'justify' },
      a.stickyHeader && {
        position: 'sticky',
        top: 0,
        zIndex: 2,
        backgroundColor: (o.vars || o).palette.background.default,
      }
    )
  ),
  TableCell = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTableCell' }),
      {
        align: j = 'inherit',
        className: _e,
        component: et,
        padding: tt,
        scope: rt,
        size: nt,
        sortDirection: it,
        variant: ot,
      } = $,
      at = _objectWithoutPropertiesLoose$3($, _excluded$f),
      st = reactExports.useContext(TableContext),
      ut = reactExports.useContext(Tablelvl2Context),
      ct = ut && ut.variant === 'head'
    let dt
    et ? (dt = et) : (dt = ct ? 'th' : 'td')
    let ft = rt
    dt === 'td' ? (ft = void 0) : !ft && ct && (ft = 'col')
    const mt = ot || (ut && ut.variant),
      vt = _extends$5({}, $, {
        align: j,
        component: dt,
        padding: tt || (st && st.padding ? st.padding : 'normal'),
        size: nt || (st && st.size ? st.size : 'medium'),
        sortDirection: it,
        stickyHeader: mt === 'head' && st && st.stickyHeader,
        variant: mt,
      }),
      yt = useUtilityClasses$d(vt)
    let pt = null
    return (
      it && (pt = it === 'asc' ? 'ascending' : 'descending'),
      jsxRuntimeExports.jsx(
        TableCellRoot,
        _extends$5(
          {
            as: dt,
            ref: s,
            className: clsx$1(yt.root, _e),
            'aria-sort': pt,
            scope: ft,
            ownerState: vt,
          },
          at
        )
      )
    )
  })
function getTableContainerUtilityClass(o) {
  return generateUtilityClass('MuiTableContainer', o)
}
generateUtilityClasses('MuiTableContainer', ['root'])
const _excluded$e = ['className', 'component'],
  useUtilityClasses$c = o => {
    const { classes: a } = o
    return composeClasses({ root: ['root'] }, getTableContainerUtilityClass, a)
  },
  TableContainerRoot = styled('div', {
    name: 'MuiTableContainer',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })({ width: '100%', overflowX: 'auto' }),
  TableContainer = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTableContainer' }),
      { className: j, component: _e = 'div' } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$e),
      tt = _extends$5({}, $, { component: _e }),
      rt = useUtilityClasses$c(tt)
    return jsxRuntimeExports.jsx(
      TableContainerRoot,
      _extends$5(
        { ref: s, as: _e, className: clsx$1(rt.root, j), ownerState: tt },
        et
      )
    )
  })
function getTableRowUtilityClass(o) {
  return generateUtilityClass('MuiTableRow', o)
}
const tableRowClasses = generateUtilityClasses('MuiTableRow', [
    'root',
    'selected',
    'hover',
    'head',
    'footer',
  ]),
  _excluded$d = ['className', 'component', 'hover', 'selected'],
  useUtilityClasses$b = o => {
    const { classes: a, selected: s, hover: $, head: j, footer: _e } = o
    return composeClasses(
      {
        root: [
          'root',
          s && 'selected',
          $ && 'hover',
          j && 'head',
          _e && 'footer',
        ],
      },
      getTableRowUtilityClass,
      a
    )
  },
  TableRowRoot = styled('tr', {
    name: 'MuiTableRow',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, s.head && a.head, s.footer && a.footer]
    },
  })(({ theme: o }) => ({
    color: 'inherit',
    display: 'table-row',
    verticalAlign: 'middle',
    outline: 0,
    [`&.${tableRowClasses.hover}:hover`]: {
      backgroundColor: (o.vars || o).palette.action.hover,
    },
    [`&.${tableRowClasses.selected}`]: {
      backgroundColor: o.vars
        ? `rgba(${o.vars.palette.primary.mainChannel} / ${o.vars.palette.action.selectedOpacity})`
        : alpha_1(o.palette.primary.main, o.palette.action.selectedOpacity),
      '&:hover': {
        backgroundColor: o.vars
          ? `rgba(${o.vars.palette.primary.mainChannel} / calc(${o.vars.palette.action.selectedOpacity} + ${o.vars.palette.action.hoverOpacity}))`
          : alpha_1(
              o.palette.primary.main,
              o.palette.action.selectedOpacity + o.palette.action.hoverOpacity
            ),
      },
    },
  })),
  defaultComponent = 'tr',
  TableRow = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTableRow' }),
      {
        className: j,
        component: _e = defaultComponent,
        hover: et = !1,
        selected: tt = !1,
      } = $,
      rt = _objectWithoutPropertiesLoose$3($, _excluded$d),
      nt = reactExports.useContext(Tablelvl2Context),
      it = _extends$5({}, $, {
        component: _e,
        hover: et,
        selected: tt,
        head: nt && nt.variant === 'head',
        footer: nt && nt.variant === 'footer',
      }),
      ot = useUtilityClasses$b(it)
    return jsxRuntimeExports.jsx(
      TableRowRoot,
      _extends$5(
        {
          as: _e,
          ref: s,
          className: clsx$1(ot.root, j),
          role: _e === defaultComponent ? null : 'row',
          ownerState: it,
        },
        rt
      )
    )
  }),
  ElevatedPaper$1 = o =>
    jsxRuntimeExports.jsx(Paper, { ...o, elevation: 6, children: o.children }),
  StatsView = ({
    cowsTraded: o,
    experience: a,
    farmName: s,
    historicalDailyLosses: $,
    historicalDailyRevenue: j,
    itemsSold: _e,
    loansTakenOut: et,
    profitabilityStreak: tt,
    record7dayProfitAverage: rt,
    recordProfitabilityStreak: nt,
    recordSingleDayProfit: it,
    revenue: ot,
    todaysLosses: at,
    todaysRevenue: st,
    totalFarmProductsSold: ut = farmProductsSold(_e),
    currentLevel: ct = levelAchieved(a),
  }) =>
    jsxRuntimeExports.jsxs('div', {
      className: 'StatsView',
      children: [
        jsxRuntimeExports.jsx(TableContainer, {
          component: ElevatedPaper$1,
          children: jsxRuntimeExports.jsx(Table, {
            'aria-label': 'Farmer Stats',
            children: jsxRuntimeExports.jsxs(TableBody, {
              children: [
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: 'Farm Name',
                    }),
                    jsxRuntimeExports.jsxs(TableCell, {
                      align: 'right',
                      children: [s, ' Farm'],
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: 'Farmer Level',
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: integerString(ct),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsx(Tooltip, {
                  arrow: !0,
                  placement: 'top',
                  title: FARM_PRODUCTS_TOOLTIP_TEXT,
                  children: jsxRuntimeExports.jsxs(TableRow, {
                    children: [
                      jsxRuntimeExports.jsx(TableCell, {
                        component: 'th',
                        scope: 'row',
                        children: 'Farm Products Sold',
                      }),
                      jsxRuntimeExports.jsx(TableCell, {
                        align: 'right',
                        children: integerString(ut),
                      }),
                    ],
                  }),
                }),
                jsxRuntimeExports.jsx(Tooltip, {
                  arrow: !0,
                  placement: 'top',
                  title: FARM_PRODUCTS_TOOLTIP_TEXT,
                  children: jsxRuntimeExports.jsxs(TableRow, {
                    children: [
                      jsxRuntimeExports.jsx(TableCell, {
                        component: 'th',
                        scope: 'row',
                        children: 'Experience Points Needed for Next Level',
                      }),
                      jsxRuntimeExports.jsx(TableCell, {
                        align: 'right',
                        children: integerString(
                          experienceNeededForLevel(ct + 1) - a
                        ),
                      }),
                    ],
                  }),
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: 'Loans Taken Out',
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: integerString(et),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsx(Tooltip, {
                  arrow: !0,
                  placement: 'top',
                  title: COW_SOLD_TOOLTIP_TEXT,
                  children: jsxRuntimeExports.jsxs(TableRow, {
                    children: [
                      jsxRuntimeExports.jsx(TableCell, {
                        component: 'th',
                        scope: 'row',
                        children: 'Cows traded',
                      }),
                      jsxRuntimeExports.jsx(TableCell, {
                        align: 'right',
                        children: integerString(o),
                      }),
                    ],
                  }),
                }),
              ],
            }),
          }),
        }),
        jsxRuntimeExports.jsx('h3', { children: 'Financial Records' }),
        jsxRuntimeExports.jsx(TableContainer, {
          component: ElevatedPaper$1,
          children: jsxRuntimeExports.jsx(Table, {
            'aria-label': 'Profit and Loss Stats',
            children: jsxRuntimeExports.jsxs(TableBody, {
              children: [
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: "Today's Revenue",
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: moneyString(st),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: "Today's Losses",
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: moneyString(at),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: "Today's Profit",
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      className: classNames({
                        'danger-text': Math.abs(at) > st,
                      }),
                      children: moneyString(getProfit(st, at)),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: 'Record Single Day Profit',
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: moneyString(getProfitRecord(it, st, at)),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: 'Current Profitability Streak',
                    }),
                    jsxRuntimeExports.jsxs(TableCell, {
                      align: 'right',
                      children: [tt, ' ', tt === 1 ? 'day' : 'days'],
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: 'Record Profitability Streak',
                    }),
                    jsxRuntimeExports.jsxs(TableCell, {
                      align: 'right',
                      children: [nt, ' ', nt === 1 ? 'day' : 'days'],
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsxs(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: [
                        DAILY_FINANCIAL_HISTORY_RECORD_LENGTH,
                        '-day Profit Average',
                      ],
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: moneyString(
                        get7DayAverage($.map((dt, ft) => moneyTotal(j[ft], dt)))
                      ),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsxs(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: [
                        'Record ',
                        DAILY_FINANCIAL_HISTORY_RECORD_LENGTH,
                        '-day Profit Average',
                      ],
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: moneyString(rt),
                    }),
                  ],
                }),
                jsxRuntimeExports.jsxs(TableRow, {
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: 'All-Time Total Revenue',
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: moneyString(ot),
                    }),
                  ],
                }),
              ],
            }),
          }),
        }),
        Object.keys(_e).length > 0 &&
          jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              jsxRuntimeExports.jsx('h3', { children: 'Items Sold' }),
              jsxRuntimeExports.jsx(TableContainer, {
                component: ElevatedPaper$1,
                children: jsxRuntimeExports.jsx(Table, {
                  'aria-label': 'Profit and Loss Stats',
                  children: jsxRuntimeExports.jsx(TableBody, {
                    children: sortBy(
                      Object.entries(_e),
                      ([dt]) => itemsMap[dt].name
                    ).map(([dt, ft]) =>
                      jsxRuntimeExports.jsxs(TableRow, {
                        key: dt,
                        children: [
                          jsxRuntimeExports.jsx(TableCell, {
                            component: 'th',
                            scope: 'row',
                            children: itemsMap[dt].name,
                          }),
                          jsxRuntimeExports.jsx(TableCell, {
                            align: 'right',
                            children: integerString(ft),
                          }),
                        ],
                      })
                    ),
                  }),
                }),
              }),
            ],
          }),
      ],
    })
StatsView.propTypes = {
  cowsTraded: propTypesExports.number.isRequired,
  farmName: propTypesExports.string.isRequired,
  historicalDailyLosses: propTypesExports.array.isRequired,
  historicalDailyRevenue: propTypesExports.array.isRequired,
  itemsSold: propTypesExports.object.isRequired,
  profitabilityStreak: propTypesExports.number.isRequired,
  record7dayProfitAverage: propTypesExports.number.isRequired,
  recordProfitabilityStreak: propTypesExports.number.isRequired,
  revenue: propTypesExports.number.isRequired,
  todaysLosses: propTypesExports.number.isRequired,
  todaysRevenue: propTypesExports.number.isRequired,
}
function Consumer$j(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(StatsView, { ...a, ...s, ...o }),
  })
}
const ElevatedPaper = o =>
    jsxRuntimeExports.jsx(Paper, { ...o, elevation: 6, children: o.children }),
  KeybindingsView = () =>
    jsxRuntimeExports.jsxs('div', {
      className: 'KeybindingsView',
      children: [
        jsxRuntimeExports.jsx(TableContainer, {
          component: ElevatedPaper,
          children: jsxRuntimeExports.jsx(Table, {
            'aria-label': 'Keyboard Shortcuts',
            children: jsxRuntimeExports.jsx(TableBody, {
              children: [
                {
                  label: 'Show Keyboard Shortcuts (this screen)',
                  keybinding: 'Shift + ?',
                },
                { label: 'Toggle menu', keybinding: 'M' },
                { label: 'End the day', keybinding: 'Shift + C' },
                { label: 'Go to screen by <1-9> order', keybinding: '<1-9>' },
                { label: 'Go to next screen', keybinding: 'Right arrow key' },
                {
                  label: 'Go to previous screen',
                  keybinding: 'Left arrow key',
                },
                { label: 'Go to Farm Stats', keybinding: 'S' },
                { label: 'Go to Achievements', keybinding: 'A' },
                { label: "Go to Farmer's Log", keybinding: 'L' },
                { label: 'Go to Price Events', keybinding: 'E' },
                { label: 'Go to Bank Account', keybinding: 'B' },
                { label: 'Go to Settings', keybinding: ',' },
              ].map(({ label: o, keybinding: a }) =>
                jsxRuntimeExports.jsxs(TableRow, {
                  key: o,
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: o,
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: a,
                    }),
                  ],
                })
              ),
            }),
          }),
        }),
        jsxRuntimeExports.jsx('h3', {
          children: 'Field-specific keyboard shortcuts',
        }),
        jsxRuntimeExports.jsx(TableContainer, {
          component: ElevatedPaper,
          children: jsxRuntimeExports.jsx(Table, {
            'aria-label': 'Keyboard Shortcuts',
            children: jsxRuntimeExports.jsx(TableBody, {
              children: [
                { label: 'Zoom in', keybinding: '=' },
                { label: 'Zoom out', keybinding: '-' },
              ].map(({ label: o, keybinding: a }) =>
                jsxRuntimeExports.jsxs(TableRow, {
                  key: o,
                  children: [
                    jsxRuntimeExports.jsx(TableCell, {
                      component: 'th',
                      scope: 'row',
                      children: o,
                    }),
                    jsxRuntimeExports.jsx(TableCell, {
                      align: 'right',
                      children: a,
                    }),
                  ],
                })
              ),
            }),
          }),
        }),
      ],
    })
KeybindingsView.propTypes = {}
const boxClasses = generateUtilityClasses('MuiBox', ['root']),
  defaultTheme = createTheme(),
  Box = createBox({
    themeId: THEME_ID,
    defaultTheme,
    defaultClassName: boxClasses.root,
    generateClassName: ClassNameGenerator.generate,
  })
function getCircularProgressUtilityClass(o) {
  return generateUtilityClass('MuiCircularProgress', o)
}
generateUtilityClasses('MuiCircularProgress', [
  'root',
  'determinate',
  'indeterminate',
  'colorPrimary',
  'colorSecondary',
  'svg',
  'circle',
  'circleDeterminate',
  'circleIndeterminate',
  'circleDisableShrink',
])
const _excluded$c = [
  'className',
  'color',
  'disableShrink',
  'size',
  'style',
  'thickness',
  'value',
  'variant',
]
let _ = o => o,
  _t,
  _t2,
  _t3,
  _t4
const SIZE = 44,
  circularRotateKeyframe = keyframes(
    _t ||
      (_t = _`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`)
  ),
  circularDashKeyframe = keyframes(
    _t2 ||
      (_t2 = _`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -125px;
  }
`)
  ),
  useUtilityClasses$a = o => {
    const { classes: a, variant: s, color: $, disableShrink: j } = o,
      _e = {
        root: ['root', s, `color${capitalize$2($)}`],
        svg: ['svg'],
        circle: [
          'circle',
          `circle${capitalize$2(s)}`,
          j && 'circleDisableShrink',
        ],
      }
    return composeClasses(_e, getCircularProgressUtilityClass, a)
  },
  CircularProgressRoot = styled('span', {
    name: 'MuiCircularProgress',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, a[s.variant], a[`color${capitalize$2(s.color)}`]]
    },
  })(
    ({ ownerState: o, theme: a }) =>
      _extends$5(
        { display: 'inline-block' },
        o.variant === 'determinate' && {
          transition: a.transitions.create('transform'),
        },
        o.color !== 'inherit' && { color: (a.vars || a).palette[o.color].main }
      ),
    ({ ownerState: o }) =>
      o.variant === 'indeterminate' &&
      css$2(
        _t3 ||
          (_t3 = _`
      animation: ${0} 1.4s linear infinite;
    `),
        circularRotateKeyframe
      )
  ),
  CircularProgressSVG = styled('svg', {
    name: 'MuiCircularProgress',
    slot: 'Svg',
    overridesResolver: (o, a) => a.svg,
  })({ display: 'block' }),
  CircularProgressCircle = styled('circle', {
    name: 'MuiCircularProgress',
    slot: 'Circle',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.circle,
        a[`circle${capitalize$2(s.variant)}`],
        s.disableShrink && a.circleDisableShrink,
      ]
    },
  })(
    ({ ownerState: o, theme: a }) =>
      _extends$5(
        { stroke: 'currentColor' },
        o.variant === 'determinate' && {
          transition: a.transitions.create('stroke-dashoffset'),
        },
        o.variant === 'indeterminate' && {
          strokeDasharray: '80px, 200px',
          strokeDashoffset: 0,
        }
      ),
    ({ ownerState: o }) =>
      o.variant === 'indeterminate' &&
      !o.disableShrink &&
      css$2(
        _t4 ||
          (_t4 = _`
      animation: ${0} 1.4s ease-in-out infinite;
    `),
        circularDashKeyframe
      )
  ),
  CircularProgress = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiCircularProgress' }),
      {
        className: j,
        color: _e = 'primary',
        disableShrink: et = !1,
        size: tt = 40,
        style: rt,
        thickness: nt = 3.6,
        value: it = 0,
        variant: ot = 'indeterminate',
      } = $,
      at = _objectWithoutPropertiesLoose$3($, _excluded$c),
      st = _extends$5({}, $, {
        color: _e,
        disableShrink: et,
        size: tt,
        thickness: nt,
        value: it,
        variant: ot,
      }),
      ut = useUtilityClasses$a(st),
      ct = {},
      dt = {},
      ft = {}
    if (ot === 'determinate') {
      const mt = 2 * Math.PI * ((SIZE - nt) / 2)
      ;(ct.strokeDasharray = mt.toFixed(3)),
        (ft['aria-valuenow'] = Math.round(it)),
        (ct.strokeDashoffset = `${(((100 - it) / 100) * mt).toFixed(3)}px`),
        (dt.transform = 'rotate(-90deg)')
    }
    return jsxRuntimeExports.jsx(
      CircularProgressRoot,
      _extends$5(
        {
          className: clsx$1(ut.root, j),
          style: _extends$5({ width: tt, height: tt }, dt, rt),
          ownerState: st,
          ref: s,
          role: 'progressbar',
        },
        ft,
        at,
        {
          children: jsxRuntimeExports.jsx(CircularProgressSVG, {
            className: ut.svg,
            ownerState: st,
            viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
            children: jsxRuntimeExports.jsx(CircularProgressCircle, {
              className: ut.circle,
              style: ct,
              ownerState: st,
              cx: SIZE,
              cy: SIZE,
              r: (SIZE - nt) / 2,
              fill: 'none',
              strokeWidth: nt,
            }),
          }),
        }
      )
    )
  })
function DayAndProgressContainer({ dayCount: o, experience: a, itemsSold: s }) {
  const $ = levelAchieved(a),
    j = scaleNumber(
      a,
      experienceNeededForLevel($),
      experienceNeededForLevel($ + 1),
      0,
      100
    ),
    _e = experienceNeededForLevel($ + 1) - a,
    et = $ + 1
  return jsxRuntimeExports.jsxs('h2', {
    className: 'day-and-progress-container',
    children: [
      jsxRuntimeExports.jsxs('span', {
        children: ['Day ', integerString(o), ', level:'],
      }),
      jsxRuntimeExports.jsx(Tooltip, {
        arrow: !0,
        placement: 'top',
        title: EXPERIENCE_GAUGE_TOOLTIP_LABEL`${_e}${et}`,
        children: jsxRuntimeExports.jsxs(Box, {
          children: [
            jsxRuntimeExports.jsx(CircularProgress, {
              value: j,
              variant: 'determinate',
            }),
            jsxRuntimeExports.jsx('span', {
              className: 'current-level',
              children: integerString($),
            }),
          ],
        }),
      }),
    ],
  })
}
DayAndProgressContainer.propTypes = {
  dayCount: propTypesExports.number.isRequired,
  experience: propTypesExports.number.isRequired,
  itemsSold: propTypesExports.object.isRequired,
}
function Consumer$i(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(DayAndProgressContainer, { ...a, ...s, ...o }),
  })
}
const FarmNameDisplay = ({ farmName: o, handleFarmNameUpdate: a }) => {
    const [s, $] = reactExports.useState(o)
    return (
      reactExports.useEffect(() => {
        $(o)
      }, [o, $]),
      jsxRuntimeExports.jsxs('h2', {
        className: 'farm-name',
        children: [
          jsxRuntimeExports.jsx(TextField, {
            variant: 'standard',
            inputProps: { maxLength: 12 },
            onChange: ({ target: { value: j } }) => {
              $(j)
            },
            onBlur: ({ target: { value: j } }) => {
              a(j)
            },
            placeholder: 'Farm Name',
            value: s,
          }),
          ' ',
          'Farm',
        ],
      })
    )
  },
  { FARMERS_LOG, STATS, ACCOUNTING, SETTINGS, KEYBINDINGS } = dialogView,
  dialogTriggerTextMap = {
    [FARMERS_LOG]: "Open Farmer's Log (l)",
    [STATS]: 'View your stats (s)',
    [ACCOUNTING]: 'View Bank Account (b)',
    [SETTINGS]: 'View Settings (comma)',
  },
  dialogTitleMap = {
    [FARMERS_LOG]: "Farmer's Log",
    [STATS]: 'Farm Stats',
    [ACCOUNTING]: 'Bank Account',
    [SETTINGS]: 'Settings',
    [KEYBINDINGS]: 'Keyboard Shortcuts',
  },
  dialogContentMap = {
    [FARMERS_LOG]: jsxRuntimeExports.jsx(Consumer$l, {}),
    [STATS]: jsxRuntimeExports.jsx(Consumer$j, {}),
    [ACCOUNTING]: jsxRuntimeExports.jsx(Consumer$m, {}),
    [SETTINGS]: jsxRuntimeExports.jsx(Consumer$k, {}),
    [KEYBINDINGS]: jsxRuntimeExports.jsx(KeybindingsView, {}),
  },
  Navigation = ({
    blockInput: o,
    currentDialogView: a,
    farmName: s,
    handleClickDialogViewButton: $,
    handleCloseDialogView: j,
    handleDialogViewExited: _e,
    handleFarmNameUpdate: et,
    handleViewChange: tt,
    inventory: rt,
    inventoryLimit: nt,
    isDialogViewOpen: it,
    stageFocus: ot,
    viewList: at,
    currentDialogViewLowerCase: st = a == null ? void 0 : a.toLowerCase(),
    modalTitleId: ut = `${st}-modal-title`,
    modalContentId: ct = `${st}-modal-content`,
  }) =>
    jsxRuntimeExports.jsxs('header', {
      className: 'Navigation',
      children: [
        jsxRuntimeExports.jsx('h1', { children: 'Farmhand' }),
        jsxRuntimeExports.jsxs('p', {
          className: 'version',
          children: ['v', '1.18.26'],
        }),
        jsxRuntimeExports.jsx(FarmNameDisplay, {
          farmName: s,
          handleFarmNameUpdate: et,
        }),
        jsxRuntimeExports.jsx(Consumer$i, {}),
        nt > INFINITE_STORAGE_LIMIT &&
          jsxRuntimeExports.jsxs('h3', {
            className: classNames('inventory-info', {
              'is-inventory-full': !doesInventorySpaceRemain({
                inventory: rt,
                inventoryLimit: nt,
              }),
            }),
            children: [
              'Inventory: ',
              integerString(inventorySpaceConsumed(rt)),
              ' /',
              ' ',
              integerString(nt),
            ],
          }),
        jsxRuntimeExports.jsx(Select, {
          variant: 'standard',
          className: 'view-select',
          onChange: tt,
          value: ot,
          children: at.map((dt, ft) =>
            jsxRuntimeExports.jsxs(MenuItem, {
              key: dt,
              value: dt,
              children: [ft + 1, ': ', STAGE_TITLE_MAP[dt]],
            })
          ),
        }),
        jsxRuntimeExports.jsx('div', {
          className: 'button-array',
          children: [
            { dialogView: FARMERS_LOG, Icon: default_1$8 },
            { dialogView: STATS, Icon: default_1$9 },
            { dialogView: ACCOUNTING, Icon: default_1$a },
            { dialogView: SETTINGS, Icon: default_1$7 },
          ].map(({ dialogView: dt, Icon: ft }) =>
            jsxRuntimeExports.jsx(Tooltip, {
              arrow: !0,
              key: dt,
              placement: 'top',
              title: dialogTriggerTextMap[dt],
              children: jsxRuntimeExports.jsx(Fab, {
                'aria-label': dialogTriggerTextMap[dt],
                color: 'primary',
                onClick: () => $(dt),
                children: jsxRuntimeExports.jsx(ft, {}),
              }),
            })
          ),
        }),
        jsxRuntimeExports.jsxs(Dialog, {
          className: classNames('Farmhand', { 'block-input': o }),
          fullWidth: !0,
          maxWidth: 'xs',
          onClose: j,
          open: it,
          TransitionProps: { onExited: _e },
          'aria-describedby': ut,
          'aria-labelledby': ct,
          children: [
            jsxRuntimeExports.jsx(DialogTitle, {
              id: ut,
              children: dialogTitleMap[a],
            }),
            jsxRuntimeExports.jsx(DialogContent, {
              id: ct,
              children: dialogContentMap[a],
            }),
            jsxRuntimeExports.jsx(DialogActions, {
              children: jsxRuntimeExports.jsx(Button, {
                onClick: j,
                color: 'primary',
                autoFocus: !0,
                children: 'Close',
              }),
            }),
          ],
        }),
      ],
    })
Navigation.propTypes = {
  blockInput: propTypesExports.bool.isRequired,
  farmName: propTypesExports.string.isRequired,
  handleClickDialogViewButton: propTypesExports.func.isRequired,
  handleCloseDialogView: propTypesExports.func.isRequired,
  handleDialogViewExited: propTypesExports.func.isRequired,
  handleFarmNameUpdate: propTypesExports.func.isRequired,
  handleViewChange: propTypesExports.func.isRequired,
  inventory: propTypesExports.array.isRequired,
  inventoryLimit: propTypesExports.number.isRequired,
  isDialogViewOpen: propTypesExports.bool.isRequired,
  stageFocus: propTypesExports.string.isRequired,
  viewList: propTypesExports.array.isRequired,
}
function Consumer$h(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Navigation, { ...a, ...s, ...o }),
  })
}
const AccordionContext = reactExports.createContext({})
function getAccordionUtilityClass(o) {
  return generateUtilityClass('MuiAccordion', o)
}
const accordionClasses = generateUtilityClasses('MuiAccordion', [
    'root',
    'rounded',
    'expanded',
    'disabled',
    'gutters',
    'region',
  ]),
  _excluded$b = [
    'children',
    'className',
    'defaultExpanded',
    'disabled',
    'disableGutters',
    'expanded',
    'onChange',
    'square',
    'slots',
    'slotProps',
    'TransitionComponent',
    'TransitionProps',
  ],
  useUtilityClasses$9 = o => {
    const {
      classes: a,
      square: s,
      expanded: $,
      disabled: j,
      disableGutters: _e,
    } = o
    return composeClasses(
      {
        root: [
          'root',
          !s && 'rounded',
          $ && 'expanded',
          j && 'disabled',
          !_e && 'gutters',
        ],
        region: ['region'],
      },
      getAccordionUtilityClass,
      a
    )
  },
  AccordionRoot = styled(Paper, {
    name: 'MuiAccordion',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        { [`& .${accordionClasses.region}`]: a.region },
        a.root,
        !s.square && a.rounded,
        !s.disableGutters && a.gutters,
      ]
    },
  })(
    ({ theme: o }) => {
      const a = { duration: o.transitions.duration.shortest }
      return {
        position: 'relative',
        transition: o.transitions.create(['margin'], a),
        overflowAnchor: 'none',
        '&::before': {
          position: 'absolute',
          left: 0,
          top: -1,
          right: 0,
          height: 1,
          content: '""',
          opacity: 1,
          backgroundColor: (o.vars || o).palette.divider,
          transition: o.transitions.create(['opacity', 'background-color'], a),
        },
        '&:first-of-type': { '&::before': { display: 'none' } },
        [`&.${accordionClasses.expanded}`]: {
          '&::before': { opacity: 0 },
          '&:first-of-type': { marginTop: 0 },
          '&:last-of-type': { marginBottom: 0 },
          '& + &': { '&::before': { display: 'none' } },
        },
        [`&.${accordionClasses.disabled}`]: {
          backgroundColor: (o.vars || o).palette.action.disabledBackground,
        },
      }
    },
    ({ theme: o }) => ({
      variants: [
        {
          props: a => !a.square,
          style: {
            borderRadius: 0,
            '&:first-of-type': {
              borderTopLeftRadius: (o.vars || o).shape.borderRadius,
              borderTopRightRadius: (o.vars || o).shape.borderRadius,
            },
            '&:last-of-type': {
              borderBottomLeftRadius: (o.vars || o).shape.borderRadius,
              borderBottomRightRadius: (o.vars || o).shape.borderRadius,
              '@supports (-ms-ime-align: auto)': {
                borderBottomLeftRadius: 0,
                borderBottomRightRadius: 0,
              },
            },
          },
        },
        {
          props: a => !a.disableGutters,
          style: { [`&.${accordionClasses.expanded}`]: { margin: '16px 0' } },
        },
      ],
    })
  ),
  Accordion = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiAccordion' }),
      {
        children: j,
        className: _e,
        defaultExpanded: et = !1,
        disabled: tt = !1,
        disableGutters: rt = !1,
        expanded: nt,
        onChange: it,
        square: ot = !1,
        slots: at = {},
        slotProps: st = {},
        TransitionComponent: ut,
        TransitionProps: ct,
      } = $,
      dt = _objectWithoutPropertiesLoose$3($, _excluded$b),
      [ft, mt] = useControlled({
        controlled: nt,
        default: et,
        name: 'Accordion',
        state: 'expanded',
      }),
      vt = reactExports.useCallback(
        St => {
          mt(!ft), it && it(St, !ft)
        },
        [ft, it, mt]
      ),
      [yt, ...pt] = reactExports.Children.toArray(j),
      ht = reactExports.useMemo(
        () => ({ expanded: ft, disabled: tt, disableGutters: rt, toggle: vt }),
        [ft, tt, rt, vt]
      ),
      At = _extends$5({}, $, {
        square: ot,
        disabled: tt,
        disableGutters: rt,
        expanded: ft,
      }),
      wt = useUtilityClasses$9(At),
      Ct = _extends$5({ transition: ut }, at),
      Dt = _extends$5({ transition: ct }, st),
      [jt, Et] = useSlot('transition', {
        elementType: Collapse,
        externalForwardedProps: { slots: Ct, slotProps: Dt },
        ownerState: At,
      })
    return jsxRuntimeExports.jsxs(
      AccordionRoot,
      _extends$5(
        { className: clsx$1(wt.root, _e), ref: s, ownerState: At, square: ot },
        dt,
        {
          children: [
            jsxRuntimeExports.jsx(AccordionContext.Provider, {
              value: ht,
              children: yt,
            }),
            jsxRuntimeExports.jsx(
              jt,
              _extends$5({ in: ft, timeout: 'auto' }, Et, {
                children: jsxRuntimeExports.jsx('div', {
                  'aria-labelledby': yt.props.id,
                  id: yt.props['aria-controls'],
                  role: 'region',
                  className: wt.region,
                  children: pt,
                }),
              })
            ),
          ],
        }
      )
    )
  })
function getAccordionSummaryUtilityClass(o) {
  return generateUtilityClass('MuiAccordionSummary', o)
}
const accordionSummaryClasses = generateUtilityClasses('MuiAccordionSummary', [
    'root',
    'expanded',
    'focusVisible',
    'disabled',
    'gutters',
    'contentGutters',
    'content',
    'expandIconWrapper',
  ]),
  _excluded$a = [
    'children',
    'className',
    'expandIcon',
    'focusVisibleClassName',
    'onClick',
  ],
  useUtilityClasses$8 = o => {
    const { classes: a, expanded: s, disabled: $, disableGutters: j } = o
    return composeClasses(
      {
        root: ['root', s && 'expanded', $ && 'disabled', !j && 'gutters'],
        focusVisible: ['focusVisible'],
        content: ['content', s && 'expanded', !j && 'contentGutters'],
        expandIconWrapper: ['expandIconWrapper', s && 'expanded'],
      },
      getAccordionSummaryUtilityClass,
      a
    )
  },
  AccordionSummaryRoot = styled(ButtonBase, {
    name: 'MuiAccordionSummary',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })(({ theme: o }) => {
    const a = { duration: o.transitions.duration.shortest }
    return {
      display: 'flex',
      minHeight: 48,
      padding: o.spacing(0, 2),
      transition: o.transitions.create(['min-height', 'background-color'], a),
      [`&.${accordionSummaryClasses.focusVisible}`]: {
        backgroundColor: (o.vars || o).palette.action.focus,
      },
      [`&.${accordionSummaryClasses.disabled}`]: {
        opacity: (o.vars || o).palette.action.disabledOpacity,
      },
      [`&:hover:not(.${accordionSummaryClasses.disabled})`]: {
        cursor: 'pointer',
      },
      variants: [
        {
          props: s => !s.disableGutters,
          style: {
            [`&.${accordionSummaryClasses.expanded}`]: { minHeight: 64 },
          },
        },
      ],
    }
  }),
  AccordionSummaryContent = styled('div', {
    name: 'MuiAccordionSummary',
    slot: 'Content',
    overridesResolver: (o, a) => a.content,
  })(({ theme: o }) => ({
    display: 'flex',
    flexGrow: 1,
    margin: '12px 0',
    variants: [
      {
        props: a => !a.disableGutters,
        style: {
          transition: o.transitions.create(['margin'], {
            duration: o.transitions.duration.shortest,
          }),
          [`&.${accordionSummaryClasses.expanded}`]: { margin: '20px 0' },
        },
      },
    ],
  })),
  AccordionSummaryExpandIconWrapper = styled('div', {
    name: 'MuiAccordionSummary',
    slot: 'ExpandIconWrapper',
    overridesResolver: (o, a) => a.expandIconWrapper,
  })(({ theme: o }) => ({
    display: 'flex',
    color: (o.vars || o).palette.action.active,
    transform: 'rotate(0deg)',
    transition: o.transitions.create('transform', {
      duration: o.transitions.duration.shortest,
    }),
    [`&.${accordionSummaryClasses.expanded}`]: { transform: 'rotate(180deg)' },
  })),
  AccordionSummary = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiAccordionSummary' }),
      {
        children: j,
        className: _e,
        expandIcon: et,
        focusVisibleClassName: tt,
        onClick: rt,
      } = $,
      nt = _objectWithoutPropertiesLoose$3($, _excluded$a),
      {
        disabled: it = !1,
        disableGutters: ot,
        expanded: at,
        toggle: st,
      } = reactExports.useContext(AccordionContext),
      ut = ft => {
        st && st(ft), rt && rt(ft)
      },
      ct = _extends$5({}, $, {
        expanded: at,
        disabled: it,
        disableGutters: ot,
      }),
      dt = useUtilityClasses$8(ct)
    return jsxRuntimeExports.jsxs(
      AccordionSummaryRoot,
      _extends$5(
        {
          focusRipple: !1,
          disableRipple: !0,
          disabled: it,
          component: 'div',
          'aria-expanded': at,
          className: clsx$1(dt.root, _e),
          focusVisibleClassName: clsx$1(dt.focusVisible, tt),
          onClick: ut,
          ref: s,
          ownerState: ct,
        },
        nt,
        {
          children: [
            jsxRuntimeExports.jsx(AccordionSummaryContent, {
              className: dt.content,
              ownerState: ct,
              children: j,
            }),
            et &&
              jsxRuntimeExports.jsx(AccordionSummaryExpandIconWrapper, {
                className: dt.expandIconWrapper,
                ownerState: ct,
                children: et,
              }),
          ],
        }
      )
    )
  })
function getAccordionDetailsUtilityClass(o) {
  return generateUtilityClass('MuiAccordionDetails', o)
}
generateUtilityClasses('MuiAccordionDetails', ['root'])
const _excluded$9 = ['className'],
  useUtilityClasses$7 = o => {
    const { classes: a } = o
    return composeClasses(
      { root: ['root'] },
      getAccordionDetailsUtilityClass,
      a
    )
  },
  AccordionDetailsRoot = styled('div', {
    name: 'MuiAccordionDetails',
    slot: 'Root',
    overridesResolver: (o, a) => a.root,
  })(({ theme: o }) => ({ padding: o.spacing(1, 2, 2) })),
  AccordionDetails = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiAccordionDetails' }),
      { className: j } = $,
      _e = _objectWithoutPropertiesLoose$3($, _excluded$9),
      et = $,
      tt = useUtilityClasses$7(et)
    return jsxRuntimeExports.jsx(
      AccordionDetailsRoot,
      _extends$5({ className: clsx$1(tt.root, j), ref: s, ownerState: et }, _e)
    )
  }),
  CheckBoxOutlineBlankIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z',
    }),
    'CheckBoxOutlineBlank'
  ),
  CheckBoxIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z',
    }),
    'CheckBox'
  ),
  IndeterminateCheckBoxIcon = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d:
        'M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z',
    }),
    'IndeterminateCheckBox'
  )
function getCheckboxUtilityClass(o) {
  return generateUtilityClass('MuiCheckbox', o)
}
const checkboxClasses = generateUtilityClasses('MuiCheckbox', [
    'root',
    'checked',
    'disabled',
    'indeterminate',
    'colorPrimary',
    'colorSecondary',
    'sizeSmall',
    'sizeMedium',
  ]),
  _excluded$8 = [
    'checkedIcon',
    'color',
    'icon',
    'indeterminate',
    'indeterminateIcon',
    'inputProps',
    'size',
    'className',
  ],
  useUtilityClasses$6 = o => {
    const { classes: a, indeterminate: s, color: $, size: j } = o,
      _e = {
        root: [
          'root',
          s && 'indeterminate',
          `color${capitalize$2($)}`,
          `size${capitalize$2(j)}`,
        ],
      },
      et = composeClasses(_e, getCheckboxUtilityClass, a)
    return _extends$5({}, a, et)
  },
  CheckboxRoot = styled(SwitchBase, {
    shouldForwardProp: o => rootShouldForwardProp(o) || o === 'classes',
    name: 'MuiCheckbox',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        s.indeterminate && a.indeterminate,
        a[`size${capitalize$2(s.size)}`],
        s.color !== 'default' && a[`color${capitalize$2(s.color)}`],
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      { color: (o.vars || o).palette.text.secondary },
      !a.disableRipple && {
        '&:hover': {
          backgroundColor: o.vars
            ? `rgba(${
                a.color === 'default'
                  ? o.vars.palette.action.activeChannel
                  : o.vars.palette[a.color].mainChannel
              } / ${o.vars.palette.action.hoverOpacity})`
            : alpha_1(
                a.color === 'default'
                  ? o.palette.action.active
                  : o.palette[a.color].main,
                o.palette.action.hoverOpacity
              ),
          '@media (hover: none)': { backgroundColor: 'transparent' },
        },
      },
      a.color !== 'default' && {
        [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {
          color: (o.vars || o).palette[a.color].main,
        },
        [`&.${checkboxClasses.disabled}`]: {
          color: (o.vars || o).palette.action.disabled,
        },
      }
    )
  ),
  defaultCheckedIcon = jsxRuntimeExports.jsx(CheckBoxIcon, {}),
  defaultIcon = jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {}),
  defaultIndeterminateIcon = jsxRuntimeExports.jsx(
    IndeterminateCheckBoxIcon,
    {}
  ),
  Checkbox = reactExports.forwardRef(function o(a, s) {
    var $, j
    const _e = useDefaultProps({ props: a, name: 'MuiCheckbox' }),
      {
        checkedIcon: et = defaultCheckedIcon,
        color: tt = 'primary',
        icon: rt = defaultIcon,
        indeterminate: nt = !1,
        indeterminateIcon: it = defaultIndeterminateIcon,
        inputProps: ot,
        size: at = 'medium',
        className: st,
      } = _e,
      ut = _objectWithoutPropertiesLoose$3(_e, _excluded$8),
      ct = nt ? it : rt,
      dt = nt ? it : et,
      ft = _extends$5({}, _e, { color: tt, indeterminate: nt, size: at }),
      mt = useUtilityClasses$6(ft)
    return jsxRuntimeExports.jsx(
      CheckboxRoot,
      _extends$5(
        {
          type: 'checkbox',
          inputProps: _extends$5({ 'data-indeterminate': nt }, ot),
          icon: reactExports.cloneElement(ct, {
            fontSize: ($ = ct.props.fontSize) != null ? $ : at,
          }),
          checkedIcon: reactExports.cloneElement(dt, {
            fontSize: (j = dt.props.fontSize) != null ? j : at,
          }),
          ownerState: ft,
          ref: s,
          className: clsx$1(mt.root, st),
        },
        ut,
        { classes: mt }
      )
    )
  })
var ExpandMore = {},
  _interopRequireDefault$6 = interopRequireDefaultExports
Object.defineProperty(ExpandMore, '__esModule', { value: !0 })
var default_1$6 = (ExpandMore.default = void 0),
  _createSvgIcon$6 = _interopRequireDefault$6(requireCreateSvgIcon()),
  _jsxRuntime$6 = jsxRuntimeExports
default_1$6 = ExpandMore.default = (0, _createSvgIcon$6.default)(
  (0, _jsxRuntime$6.jsx)('path', {
    d: 'M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z',
  }),
  'ExpandMore'
)
var KeyboardArrowUp = {},
  _interopRequireDefault$5 = interopRequireDefaultExports
Object.defineProperty(KeyboardArrowUp, '__esModule', { value: !0 })
var default_1$5 = (KeyboardArrowUp.default = void 0),
  _createSvgIcon$5 = _interopRequireDefault$5(requireCreateSvgIcon()),
  _jsxRuntime$5 = jsxRuntimeExports
default_1$5 = KeyboardArrowUp.default = (0, _createSvgIcon$5.default)(
  (0, _jsxRuntime$5.jsx)('path', {
    d: 'M7.41 15.41 12 10.83l4.59 4.58L18 14l-6-6-6 6z',
  }),
  'KeyboardArrowUp'
)
var KeyboardArrowDown = {},
  _interopRequireDefault$4 = interopRequireDefaultExports
Object.defineProperty(KeyboardArrowDown, '__esModule', { value: !0 })
var default_1$4 = (KeyboardArrowDown.default = void 0),
  _createSvgIcon$4 = _interopRequireDefault$4(requireCreateSvgIcon()),
  _jsxRuntime$4 = jsxRuntimeExports
default_1$4 = KeyboardArrowDown.default = (0, _createSvgIcon$4.default)(
  (0, _jsxRuntime$4.jsx)('path', {
    d: 'M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z',
  }),
  'KeyboardArrowDown'
)
function getCardActionsUtilityClass(o) {
  return generateUtilityClass('MuiCardActions', o)
}
generateUtilityClasses('MuiCardActions', ['root', 'spacing'])
const _excluded$7 = ['disableSpacing', 'className'],
  useUtilityClasses$5 = o => {
    const { classes: a, disableSpacing: s } = o
    return composeClasses(
      { root: ['root', !s && 'spacing'] },
      getCardActionsUtilityClass,
      a
    )
  },
  CardActionsRoot = styled('div', {
    name: 'MuiCardActions',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, !s.disableSpacing && a.spacing]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      { display: 'flex', alignItems: 'center', padding: 8 },
      !o.disableSpacing && {
        '& > :not(style) ~ :not(style)': { marginLeft: 8 },
      }
    )
  ),
  CardActions = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiCardActions' }),
      { disableSpacing: j = !1, className: _e } = $,
      et = _objectWithoutPropertiesLoose$3($, _excluded$7),
      tt = _extends$5({}, $, { disableSpacing: j }),
      rt = useUtilityClasses$5(tt)
    return jsxRuntimeExports.jsx(
      CardActionsRoot,
      _extends$5({ className: clsx$1(rt.root, _e), ownerState: tt, ref: s }, et)
    )
  }),
  noop$2 = () => {},
  defaultFormatter = o => `${o}`,
  AnimatedNumber = ({ number: o, formatter: a = defaultFormatter }) => {
    const [s, $] = reactExports.useState(o),
      [j, _e] = reactExports.useState(o),
      [et, tt] = reactExports.useState()
    return (
      reactExports.useEffect(() => {
        _e(o)
      }, [o, _e]),
      reactExports.useEffect(() => {
        if (o !== j) {
          et && et.cancel()
          const rt = shiftyExports.tween({
            easing: 'easeOutQuad',
            duration: 750,
            render: ({ number: nt }) => {
              $(Number(nt))
            },
            from: { number: j },
            to: { number: o },
          })
          tt(rt)
        }
        return () => {
          et && et.cancel()
        }
      }, [et, o, j]),
      jsxRuntimeExports.jsx('span', {
        className: 'AnimatedNumber',
        children: a(s),
      })
    )
  }
AnimatedNumber.propTypes = {
  formatter: propTypesExports.func,
  number: propTypesExports.number.isRequired,
}
const Span = styled('span')({}),
  QUANTITY_INPUT_PLACEHOLDER_TEXT = '0',
  QuantityNumberFormat = reactExports.forwardRef(
    ({ min: o, max: a, onChange: s, ...$ }, j) =>
      jsxRuntimeExports.jsx(NumberFormat, {
        isNumericString: !0,
        thousandSeparator: !0,
        getInputRef: j,
        ...$,
        allowNegative: !1,
        decimalScale: 0,
        onValueChange: ({ floatValue: _e = 0 }) => s(Math.min(_e, a)),
      })
  ),
  QuantityTextInput = ({
    handleSubmit: o,
    handleUpdateNumber: a,
    maxQuantity: s,
    value: $,
  }) =>
    jsxRuntimeExports.jsx(TextField, {
      variant: 'standard',
      value: $,
      placeholder: QUANTITY_INPUT_PLACEHOLDER_TEXT,
      inputProps: { pattern: '[0-9]*', min: 0, max: s },
      onChange: a,
      onFocus: j => {
        j.target.select()
      },
      onKeyUp: ({ which: j }) => {
        j === 13 && o()
      },
      InputProps: {
        inputComponent: QuantityNumberFormat,
        endAdornment: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
          children: [
            jsxRuntimeExports.jsx(Span, { sx: { px: 1 }, children: '/' }),
            jsxRuntimeExports.jsx(AnimatedNumber, {
              number: s,
              formatter: integerString,
            }),
          ],
        }),
      },
    }),
  QuantityInput = ({
    handleSubmit: o,
    handleUpdateNumber: a,
    maxQuantity: s,
    setQuantity: $,
    value: j,
  }) => {
    const _e = () => {
        let tt = j - 1
        tt === 0 && (tt = s), $(tt)
      },
      et = () => {
        let tt = j + 1
        tt > s && (tt = 1), $(tt)
      }
    return jsxRuntimeExports.jsxs('div', {
      className: 'QuantityInput',
      children: [
        jsxRuntimeExports.jsx(QuantityTextInput, {
          handleSubmit: o,
          handleUpdateNumber: a,
          maxQuantity: s,
          value: j,
        }),
        jsxRuntimeExports.jsxs('div', {
          className: 'number-nudger-container',
          children: [
            jsxRuntimeExports.jsx(Fab, {
              disabled: !j,
              'aria-label': 'Increment',
              color: 'primary',
              onClick: et,
              size: 'small',
              children: jsxRuntimeExports.jsx(default_1$5, {}),
            }),
            jsxRuntimeExports.jsx(Fab, {
              disabled: !j,
              'aria-label': 'Decrement',
              color: 'primary',
              onClick: _e,
              size: 'small',
              children: jsxRuntimeExports.jsx(default_1$4, {}),
            }),
          ],
        }),
      ],
    })
  }
QuantityInput.propTypes = {
  handleSubmit: propTypesExports.func.isRequired,
  handleUpdateNumber: propTypesExports.func.isRequired,
  maxQuantity: propTypesExports.number.isRequired,
  setQuantity: propTypesExports.func.isRequired,
  value: propTypesExports.number,
}
QuantityInput.defaultProps = { value: 1 }
const ValueIndicator = ({ poorValue: o }) =>
    jsxRuntimeExports.jsx(Tooltip, {
      arrow: !0,
      placement: 'top',
      title: `${o ? 'Poor' : 'Good'} opportunity`,
      children: o
        ? jsxRuntimeExports.jsx(default_1$4, { color: 'error' })
        : jsxRuntimeExports.jsx(default_1$5, { color: 'primary' }),
    }),
  PurchaseValueIndicator = ({
    id: o,
    value: a,
    valueAdjustments: s,
    poorValue: $ = a > itemsMap[o].value,
  }) =>
    jsxRuntimeExports.jsx(ValueIndicator, {
      id: o,
      poorValue: $,
      value: a,
      valueAdjustments: s,
    }),
  SellValueIndicator = ({
    id: o,
    value: a,
    valueAdjustments: s,
    poorValue: $ = a < itemsMap[o].value,
  }) =>
    jsxRuntimeExports.jsx(ValueIndicator, {
      id: o,
      poorValue: $,
      value: a,
      valueAdjustments: s,
    }),
  Item = ({
    completedAchievements: o,
    handleItemPurchaseClick: a,
    handleItemSelectClick: s,
    handleItemSellClick: $,
    historicalValueAdjustments: j,
    inventory: _e,
    inventoryLimit: et,
    isPurchaseView: tt,
    isSelectView: rt,
    isSelected: nt,
    isSellView: it,
    item: ot,
    item: {
      description: at,
      doesPriceFluctuate: st,
      id: ut,
      isReplantable: ct,
      name: dt,
    },
    money: ft,
    playerInventoryQuantities: mt,
    showQuantity: vt,
    valueAdjustments: yt,
    adjustedValue: pt = it && isItemSoldInShop(ot)
      ? getResaleValue(ot)
      : getItemCurrentValue(ot, yt),
    previousDayAdjustedValue: ht = (it && isItemSoldInShop(ot)) ||
    j.length === 0 ||
    !st
      ? null
      : getItemCurrentValue(ot, j[0]),
    maxQuantityPlayerCanPurchase: At = Math.max(
      0,
      Math.min(
        Math.floor(ft / pt),
        inventorySpaceRemaining({ inventory: _e, inventoryLimit: et })
      )
    ),
  }) => {
    const [wt, Ct] = reactExports.useState(1),
      [Dt, jt] = reactExports.useState(1)
    reactExports.useEffect(() => {
      Ct(Math.min(At, Math.max(1, wt)))
    }, [At, wt]),
      reactExports.useEffect(() => {
        jt(Math.min(mt[ut], Dt))
      }, [ut, mt, Dt])
    const Et = () => {
        a(ot, wt), Ct(Math.min(1, At))
      },
      St = () => {
        $(ot, Dt), jt(Math.min(1, mt[ut]))
      },
      Bt = jsxRuntimeExports.jsx('img', { src: items[ut], alt: dt })
    let Mt = pt
    return (
      itemIds$1.has(ut) || (Mt *= getSalePriceMultiplier(o)),
      jsxRuntimeExports.jsxs(Card, {
        className: classNames('Item', {
          'is-selectable': rt,
          'is-selected': nt,
        }),
        onClick: rt ? () => s(ot) : noop$2,
        raised: nt,
        children: [
          jsxRuntimeExports.jsx(CardHeader, {
            avatar:
              !tt && at
                ? jsxRuntimeExports.jsx(Tooltip, {
                    arrow: !0,
                    placement: 'top',
                    title: jsxRuntimeExports.jsx(Typography, { children: at }),
                    children: Bt,
                  })
                : Bt,
            title: dt,
            subheader: jsxRuntimeExports.jsxs('div', {
              children: [
                tt &&
                  jsxRuntimeExports.jsxs('p', {
                    children: [
                      jsxRuntimeExports.jsx(Tooltip, {
                        arrow: !0,
                        placement: 'top',
                        title:
                          ht === null
                            ? ''
                            : `Yesterday's price: ${moneyString(ht)}`,
                        children: jsxRuntimeExports.jsxs('span', {
                          children: [
                            'Price:',
                            ' ',
                            jsxRuntimeExports.jsx(AnimatedNumber, {
                              number: pt,
                              formatter: moneyString,
                            }),
                          ],
                        }),
                      }),
                      o['unlock-crop-price-guide'] &&
                        yt[ut] &&
                        jsxRuntimeExports.jsx(PurchaseValueIndicator, {
                          id: ut,
                          value: pt,
                          valueAdjustments: yt,
                        }),
                    ],
                  }),
                tt &&
                  jsxRuntimeExports.jsxs('p', {
                    children: [
                      'Total:',
                      ' ',
                      wt
                        ? jsxRuntimeExports.jsx(AnimatedNumber, {
                            number: wt * pt,
                            formatter: moneyString,
                          })
                        : null,
                    ],
                  }),
                it &&
                  jsxRuntimeExports.jsxs('p', {
                    children: [
                      jsxRuntimeExports.jsx(Tooltip, {
                        arrow: !0,
                        placement: 'top',
                        title:
                          ht === null
                            ? ''
                            : `Yesterday's sell price: ${moneyString(ht)}`,
                        children: jsxRuntimeExports.jsxs('span', {
                          children: [
                            'Sell price:',
                            ' ',
                            jsxRuntimeExports.jsx(AnimatedNumber, {
                              number: Mt,
                              formatter: moneyString,
                            }),
                          ],
                        }),
                      }),
                      o['unlock-crop-price-guide'] &&
                        yt[ut] &&
                        jsxRuntimeExports.jsx(SellValueIndicator, {
                          id: ut,
                          value: pt,
                          valueAdjustments: yt,
                        }),
                    ],
                  }),
                it &&
                  jsxRuntimeExports.jsxs('p', {
                    children: [
                      'Total:',
                      ' ',
                      Dt
                        ? jsxRuntimeExports.jsx(AnimatedNumber, {
                            number: Dt * Mt,
                            formatter: moneyString,
                          })
                        : null,
                    ],
                  }),
                vt &&
                  jsxRuntimeExports.jsxs('p', {
                    children: [
                      jsxRuntimeExports.jsx('strong', {
                        children: 'In inventory:',
                      }),
                      ' ',
                      jsxRuntimeExports.jsx(AnimatedNumber, {
                        number: mt[ut],
                        formatter: integerString,
                      }),
                    ],
                  }),
                tt &&
                  ot.growsInto &&
                  jsxRuntimeExports.jsxs('p', {
                    children: [
                      'Days to mature:',
                      ' ',
                      getCropLifecycleDuration(
                        getFinalCropItemFromSeedItem(ot)
                      ),
                    ],
                  }),
              ],
            }),
          }),
          tt &&
            (at || ct) &&
            jsxRuntimeExports.jsxs(CardContent, {
              children: [
                at && jsxRuntimeExports.jsx(Typography, { children: at }),
                ct &&
                  jsxRuntimeExports.jsx(Typography, {
                    color: 'textSecondary',
                    children:
                      'Once planted in the field, this item can be returned to your inventory with the hoe and then replanted elsewhere.',
                  }),
              ],
            }),
          jsxRuntimeExports.jsxs(CardActions, {
            children: [
              rt &&
                jsxRuntimeExports.jsx(Button, {
                  className: 'select',
                  color: 'primary',
                  variant: nt ? 'contained' : 'outlined',
                  children: 'Select',
                }),
              tt &&
                jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                  children: [
                    jsxRuntimeExports.jsx(Button, {
                      className: 'purchase',
                      color: 'primary',
                      disabled: !wt || pt * wt > ft,
                      onClick: Et,
                      variant: 'contained',
                      children: 'Buy',
                    }),
                    jsxRuntimeExports.jsx(QuantityInput, {
                      handleSubmit: Et,
                      handleUpdateNumber: Ct,
                      maxQuantity: At,
                      setQuantity: Ct,
                      value: wt,
                    }),
                  ],
                }),
              it &&
                jsxRuntimeExports.jsxs(Box, {
                  display: 'flex',
                  children: [
                    jsxRuntimeExports.jsx(Button, {
                      className: 'sell',
                      color: 'error',
                      disabled: Dt === 0 || !Dt,
                      onClick: St,
                      variant: 'contained',
                      children: 'Sell',
                    }),
                    jsxRuntimeExports.jsx(QuantityInput, {
                      handleSubmit: St,
                      handleUpdateNumber: jt,
                      maxQuantity: mt[ut],
                      setQuantity: jt,
                      value: Dt,
                    }),
                  ],
                }),
            ],
          }),
        ],
      })
    )
  }
Item.propTypes = {
  adjustedValue: propTypesExports.number,
  completedAchievements: propTypesExports.object.isRequired,
  handleItemPurchaseClick: propTypesExports.func,
  handleItemSelectClick: propTypesExports.func,
  handleItemSellClick: propTypesExports.func,
  historicalValueAdjustments: propTypesExports.array.isRequired,
  inventory: propTypesExports.array.isRequired,
  inventoryLimit: propTypesExports.number.isRequired,
  isPurchaseView: propTypesExports.bool,
  isSelectView: propTypesExports.bool,
  isSelected: propTypesExports.bool,
  isSellView: propTypesExports.bool,
  item: propTypesExports.object.isRequired,
  money: propTypesExports.number.isRequired,
  playerInventoryQuantities: propTypesExports.object.isRequired,
  showQuantity: propTypesExports.bool,
  valueAdjustments: propTypesExports.object.isRequired,
}
function Consumer$g(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Item, { ...a, ...s, ...o }),
  })
}
function useUnmount$1(o) {
  const a = reactExports.useRef(o)
  ;(a.current = o),
    reactExports.useEffect(
      () => () => {
        a.current()
      },
      []
    )
}
function useDebounceCallback(o, a = 500, s) {
  const $ = reactExports.useRef()
  useUnmount$1(() => {
    $.current && $.current.cancel()
  })
  const j = reactExports.useMemo(() => {
    const _e = debounce$2(o, a, s),
      et = (...tt) => _e(...tt)
    return (
      (et.cancel = () => {
        _e.cancel()
      }),
      (et.isPending = () => !!$.current),
      (et.flush = () => _e.flush()),
      et
    )
  }, [o, a, s])
  return (
    reactExports.useEffect(() => {
      $.current = debounce$2(o, a, s)
    }, [o, a, s]),
    j
  )
}
function useIsMounted() {
  const o = reactExports.useRef(!1)
  return (
    reactExports.useEffect(
      () => (
        (o.current = !0),
        () => {
          o.current = !1
        }
      ),
      []
    ),
    reactExports.useCallback(() => o.current, [])
  )
}
const SearchBar = ({ placeholder: o, onSearch: a }) => {
  const s = useDebounceCallback(j => {
      a(j)
    }, 300),
    $ = j => {
      s(j.target.value)
    }
  return jsxRuntimeExports.jsx('div', {
    className: 'search-bar',
    children: jsxRuntimeExports.jsx(TextField, {
      variant: 'outlined',
      fullWidth: !0,
      placeholder: o || 'Search...',
      onChange: $,
      inputProps: { 'aria-label': 'search' },
    }),
  })
}
SearchBar.propTypes = {
  placeholder: PropTypes$1.string,
  onSearch: PropTypes$1.func.isRequired,
}
const categoryIds = new Map([
    ['ANIMAL_PRODUCTS', 'ANIMAL_PRODUCTS'],
    ['ANIMAL_SUPPLIES', 'ANIMAL_SUPPLIES'],
    ['CRAFTED_ITEMS', 'CRAFTED_ITEMS'],
    ['WATER_CREDIT', 'WATER_CREDIT'],
    ['MANURE_MANAGER', 'MANURE_MANAGER'],
  ]),
  itemTypeCategoryMap = new Map([
    ['COW_FEED', 'ANIMAL_SUPPLIES'],
    ['CRAFTED_ITEM', 'CRAFTED_ITEMS'],
    ['FERTILIZER', 'FIELD_TOOLS'],
    ['FUEL', 'MINED_RESOURCES'],
    ['HUGGING_MACHINE', 'ANIMAL_SUPPLIES'],
    ['MILK', 'ANIMAL_PRODUCTS'],
    ['ORE', 'MINED_RESOURCES'],
    ['SPRINKLER', 'FIELD_TOOLS'],
    ['STONE', 'MINED_RESOURCES'],
    ['WEED', 'FORAGED_ITEMS'],
    ['WATER_CREDIT', 'WATER_CREDIT'],
    ['MANURE_MANAGER', 'MANURE_MANAGER'],
  ]),
  getItemCategories = () =>
    new Map(Array.from(categoryIds.keys()).map(o => [o, []])),
  separateItemsIntoCategories = o =>
    sortItems(o).reduce((a, s) => {
      var _e, et
      const { type: $ } = itemsMap[s.id],
        j = itemTypeCategoryMap.get($)
      if (j === 'CROPS') {
        const tt = s.isPlantableCrop ? 'SEEDS' : 'CROPS'
        ;(_e = a.get(tt)) == null || _e.push(s)
      } else a.has(j) && ((et = a.get(j)) == null || et.push(s))
      return a
    }, getItemCategories()),
  formatCategoryName = o =>
    o
      .replace(/_/g, ' ')
      .toLowerCase()
      .replace(/\b\w/g, a => a.toUpperCase()),
  Inventory = ({
    items: o,
    playerInventory: a,
    shopInventory: s,
    isPurchaseView: $ = !1,
    isSellView: j = !1,
    itemCategories: _e = separateItemsIntoCategories(o),
    placeholder: et = 'Search inventory...',
  }) => {
    const [tt, rt] = reactExports.useState(''),
      [nt, it] = reactExports.useState([]),
      ot = st => {
        it(ut => (ut.includes(st) ? ut.filter(ct => ct !== st) : [...ut, st]))
      },
      at = Array.from(_e.entries()).reduce((st, [ut, ct]) => {
        const dt = ct.filter(ft => {
          var mt, vt, yt
          return (yt =
            (vt = (mt = itemsMap[ft.id]) == null ? void 0 : mt.name) == null
              ? void 0
              : vt.toLowerCase()) == null
            ? void 0
            : yt.includes(tt.toLowerCase())
        })
        return (
          dt.length && (!nt.length || nt.includes(ut)) && st.set(ut, dt), st
        )
      }, new Map())
    return jsxRuntimeExports.jsxs('div', {
      className: 'Inventory',
      children: [
        jsxRuntimeExports.jsx(SearchBar, { placeholder: et, onSearch: rt }),
        !$ &&
          jsxRuntimeExports.jsxs(Accordion, {
            children: [
              jsxRuntimeExports.jsx(AccordionSummary, {
                expandIcon: jsxRuntimeExports.jsx(default_1$6, {}),
                'aria-controls': 'filter-content',
                id: 'filter-header',
                children: jsxRuntimeExports.jsx('h4', {
                  children: 'Filter by category',
                }),
              }),
              jsxRuntimeExports.jsx(AccordionDetails, {
                children: jsxRuntimeExports.jsx('div', {
                  className: 'filter-section',
                  children: Array.from(categoryIds.keys()).map(st =>
                    jsxRuntimeExports.jsx(
                      FormControlLabel,
                      {
                        sx: { display: 'block' },
                        control: jsxRuntimeExports.jsx(Checkbox, {
                          disabled: $,
                          checked: nt.includes(st),
                          onChange: () => ot(st),
                        }),
                        label: formatCategoryName(st),
                      },
                      st
                    )
                  ),
                }),
              }),
            ],
          }),
        Array.from(at.entries()).map(([st, ut]) =>
          ut.length
            ? jsxRuntimeExports.jsx(
                reactExports.Fragment,
                {
                  children: jsxRuntimeExports.jsxs('section', {
                    children: [
                      jsxRuntimeExports.jsx('h3', {
                        children: formatCategoryName(st),
                      }),
                      jsxRuntimeExports.jsx('ul', {
                        className: 'card-list',
                        children: ut.map(ct =>
                          jsxRuntimeExports.jsx(
                            'li',
                            {
                              children: jsxRuntimeExports.jsx(Consumer$g, {
                                isPurchaseView: $,
                                isSellView: j,
                                item: ct,
                                showQuantity: $,
                              }),
                            },
                            ct.id
                          )
                        ),
                      }),
                    ],
                  }),
                },
                st
              )
            : null
        ),
      ],
    })
  }
Inventory.propTypes = {
  items: propTypesExports.array.isRequired,
  playerInventory: propTypesExports.array,
  shopInventory: propTypesExports.array,
}
function Consumer$f(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Inventory, { ...a, ...s, ...o }),
  })
}
var ArrowDownward = {},
  _interopRequireDefault$3 = interopRequireDefaultExports
Object.defineProperty(ArrowDownward, '__esModule', { value: !0 })
var default_1$3 = (ArrowDownward.default = void 0),
  _createSvgIcon$3 = _interopRequireDefault$3(requireCreateSvgIcon()),
  _jsxRuntime$3 = jsxRuntimeExports
default_1$3 = ArrowDownward.default = (0, _createSvgIcon$3.default)(
  (0, _jsxRuntime$3.jsx)('path', {
    d: 'm20 12-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8z',
  }),
  'ArrowDownward'
)
var ArrowUpward = {},
  _interopRequireDefault$2 = interopRequireDefaultExports
Object.defineProperty(ArrowUpward, '__esModule', { value: !0 })
var default_1$2 = (ArrowUpward.default = void 0),
  _createSvgIcon$2 = _interopRequireDefault$2(requireCreateSvgIcon()),
  _jsxRuntime$2 = jsxRuntimeExports
default_1$2 = ArrowUpward.default = (0, _createSvgIcon$2.default)(
  (0, _jsxRuntime$2.jsx)('path', {
    d: 'm4 12 1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8z',
  }),
  'ArrowUpward'
)
function getTabUtilityClass(o) {
  return generateUtilityClass('MuiTab', o)
}
const tabClasses = generateUtilityClasses('MuiTab', [
    'root',
    'labelIcon',
    'textColorInherit',
    'textColorPrimary',
    'textColorSecondary',
    'selected',
    'disabled',
    'fullWidth',
    'wrapped',
    'iconWrapper',
  ]),
  _excluded$6 = [
    'className',
    'disabled',
    'disableFocusRipple',
    'fullWidth',
    'icon',
    'iconPosition',
    'indicator',
    'label',
    'onChange',
    'onClick',
    'onFocus',
    'selected',
    'selectionFollowsFocus',
    'textColor',
    'value',
    'wrapped',
  ],
  useUtilityClasses$4 = o => {
    const {
        classes: a,
        textColor: s,
        fullWidth: $,
        wrapped: j,
        icon: _e,
        label: et,
        selected: tt,
        disabled: rt,
      } = o,
      nt = {
        root: [
          'root',
          _e && et && 'labelIcon',
          `textColor${capitalize$2(s)}`,
          $ && 'fullWidth',
          j && 'wrapped',
          tt && 'selected',
          rt && 'disabled',
        ],
        iconWrapper: ['iconWrapper'],
      }
    return composeClasses(nt, getTabUtilityClass, a)
  },
  TabRoot = styled(ButtonBase, {
    name: 'MuiTab',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        s.label && s.icon && a.labelIcon,
        a[`textColor${capitalize$2(s.textColor)}`],
        s.fullWidth && a.fullWidth,
        s.wrapped && a.wrapped,
        { [`& .${tabClasses.iconWrapper}`]: a.iconWrapper },
      ]
    },
  })(({ theme: o, ownerState: a }) =>
    _extends$5(
      {},
      o.typography.button,
      {
        maxWidth: 360,
        minWidth: 90,
        position: 'relative',
        minHeight: 48,
        flexShrink: 0,
        padding: '12px 16px',
        overflow: 'hidden',
        whiteSpace: 'normal',
        textAlign: 'center',
      },
      a.label && {
        flexDirection:
          a.iconPosition === 'top' || a.iconPosition === 'bottom'
            ? 'column'
            : 'row',
      },
      { lineHeight: 1.25 },
      a.icon &&
        a.label && {
          minHeight: 72,
          paddingTop: 9,
          paddingBottom: 9,
          [`& > .${tabClasses.iconWrapper}`]: _extends$5(
            {},
            a.iconPosition === 'top' && { marginBottom: 6 },
            a.iconPosition === 'bottom' && { marginTop: 6 },
            a.iconPosition === 'start' && { marginRight: o.spacing(1) },
            a.iconPosition === 'end' && { marginLeft: o.spacing(1) }
          ),
        },
      a.textColor === 'inherit' && {
        color: 'inherit',
        opacity: 0.6,
        [`&.${tabClasses.selected}`]: { opacity: 1 },
        [`&.${tabClasses.disabled}`]: {
          opacity: (o.vars || o).palette.action.disabledOpacity,
        },
      },
      a.textColor === 'primary' && {
        color: (o.vars || o).palette.text.secondary,
        [`&.${tabClasses.selected}`]: {
          color: (o.vars || o).palette.primary.main,
        },
        [`&.${tabClasses.disabled}`]: {
          color: (o.vars || o).palette.text.disabled,
        },
      },
      a.textColor === 'secondary' && {
        color: (o.vars || o).palette.text.secondary,
        [`&.${tabClasses.selected}`]: {
          color: (o.vars || o).palette.secondary.main,
        },
        [`&.${tabClasses.disabled}`]: {
          color: (o.vars || o).palette.text.disabled,
        },
      },
      a.fullWidth && {
        flexShrink: 1,
        flexGrow: 1,
        flexBasis: 0,
        maxWidth: 'none',
      },
      a.wrapped && { fontSize: o.typography.pxToRem(12) }
    )
  ),
  Tab = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTab' }),
      {
        className: j,
        disabled: _e = !1,
        disableFocusRipple: et = !1,
        fullWidth: tt,
        icon: rt,
        iconPosition: nt = 'top',
        indicator: it,
        label: ot,
        onChange: at,
        onClick: st,
        onFocus: ut,
        selected: ct,
        selectionFollowsFocus: dt,
        textColor: ft = 'inherit',
        value: mt,
        wrapped: vt = !1,
      } = $,
      yt = _objectWithoutPropertiesLoose$3($, _excluded$6),
      pt = _extends$5({}, $, {
        disabled: _e,
        disableFocusRipple: et,
        selected: ct,
        icon: !!rt,
        iconPosition: nt,
        label: !!ot,
        fullWidth: tt,
        textColor: ft,
        wrapped: vt,
      }),
      ht = useUtilityClasses$4(pt),
      At =
        rt && ot && reactExports.isValidElement(rt)
          ? reactExports.cloneElement(rt, {
              className: clsx$1(ht.iconWrapper, rt.props.className),
            })
          : rt,
      wt = Dt => {
        !ct && at && at(Dt, mt), st && st(Dt)
      },
      Ct = Dt => {
        dt && !ct && at && at(Dt, mt), ut && ut(Dt)
      }
    return jsxRuntimeExports.jsxs(
      TabRoot,
      _extends$5(
        {
          focusRipple: !et,
          className: clsx$1(ht.root, j),
          ref: s,
          role: 'tab',
          'aria-selected': ct,
          disabled: _e,
          onClick: wt,
          onFocus: Ct,
          ownerState: pt,
          tabIndex: ct ? 0 : -1,
        },
        yt,
        {
          children: [
            nt === 'top' || nt === 'start'
              ? jsxRuntimeExports.jsxs(reactExports.Fragment, {
                  children: [At, ot],
                })
              : jsxRuntimeExports.jsxs(reactExports.Fragment, {
                  children: [ot, At],
                }),
            it,
          ],
        }
      )
    )
  })
function easeInOutSin(o) {
  return (1 + Math.sin(Math.PI * o - Math.PI / 2)) / 2
}
function animate$1(o, a, s, $ = {}, j = () => {}) {
  const { ease: _e = easeInOutSin, duration: et = 300 } = $
  let tt = null
  const rt = a[o]
  let nt = !1
  const it = () => {
      nt = !0
    },
    ot = at => {
      if (nt) {
        j(new Error('Animation cancelled'))
        return
      }
      tt === null && (tt = at)
      const st = Math.min(1, (at - tt) / et)
      if (((a[o] = _e(st) * (s - rt) + rt), st >= 1)) {
        requestAnimationFrame(() => {
          j(null)
        })
        return
      }
      requestAnimationFrame(ot)
    }
  return rt === s
    ? (j(new Error('Element already at target position')), it)
    : (requestAnimationFrame(ot), it)
}
const _excluded$5 = ['onChange'],
  styles$2 = {
    width: 99,
    height: 99,
    position: 'absolute',
    top: -9999,
    overflow: 'scroll',
  }
function ScrollbarSize(o) {
  const { onChange: a } = o,
    s = _objectWithoutPropertiesLoose$3(o, _excluded$5),
    $ = reactExports.useRef(),
    j = reactExports.useRef(null),
    _e = () => {
      $.current = j.current.offsetHeight - j.current.clientHeight
    }
  return (
    useEnhancedEffect$1(() => {
      const et = debounce$4(() => {
          const rt = $.current
          _e(), rt !== $.current && a($.current)
        }),
        tt = ownerWindow(j.current)
      return (
        tt.addEventListener('resize', et),
        () => {
          et.clear(), tt.removeEventListener('resize', et)
        }
      )
    }, [a]),
    reactExports.useEffect(() => {
      _e(), a($.current)
    }, [a]),
    jsxRuntimeExports.jsx('div', _extends$5({ style: styles$2, ref: j }, s))
  )
}
const KeyboardArrowLeft = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d: 'M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z',
    }),
    'KeyboardArrowLeft'
  ),
  KeyboardArrowRight = createSvgIcon$1(
    jsxRuntimeExports.jsx('path', {
      d: 'M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z',
    }),
    'KeyboardArrowRight'
  )
function getTabScrollButtonUtilityClass(o) {
  return generateUtilityClass('MuiTabScrollButton', o)
}
const tabScrollButtonClasses = generateUtilityClasses('MuiTabScrollButton', [
    'root',
    'vertical',
    'horizontal',
    'disabled',
  ]),
  _excluded$4 = [
    'className',
    'slots',
    'slotProps',
    'direction',
    'orientation',
    'disabled',
  ],
  useUtilityClasses$3 = o => {
    const { classes: a, orientation: s, disabled: $ } = o
    return composeClasses(
      { root: ['root', s, $ && 'disabled'] },
      getTabScrollButtonUtilityClass,
      a
    )
  },
  TabScrollButtonRoot = styled(ButtonBase, {
    name: 'MuiTabScrollButton',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [a.root, s.orientation && a[s.orientation]]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      {
        width: 40,
        flexShrink: 0,
        opacity: 0.8,
        [`&.${tabScrollButtonClasses.disabled}`]: { opacity: 0 },
      },
      o.orientation === 'vertical' && {
        width: '100%',
        height: 40,
        '& svg': { transform: `rotate(${o.isRtl ? -90 : 90}deg)` },
      }
    )
  ),
  TabScrollButton = reactExports.forwardRef(function o(a, s) {
    var $, j
    const _e = useDefaultProps({ props: a, name: 'MuiTabScrollButton' }),
      { className: et, slots: tt = {}, slotProps: rt = {}, direction: nt } = _e,
      it = _objectWithoutPropertiesLoose$3(_e, _excluded$4),
      ot = useRtl(),
      at = _extends$5({ isRtl: ot }, _e),
      st = useUtilityClasses$3(at),
      ut = ($ = tt.StartScrollButtonIcon) != null ? $ : KeyboardArrowLeft,
      ct = (j = tt.EndScrollButtonIcon) != null ? j : KeyboardArrowRight,
      dt = useSlotProps({
        elementType: ut,
        externalSlotProps: rt.startScrollButtonIcon,
        additionalProps: { fontSize: 'small' },
        ownerState: at,
      }),
      ft = useSlotProps({
        elementType: ct,
        externalSlotProps: rt.endScrollButtonIcon,
        additionalProps: { fontSize: 'small' },
        ownerState: at,
      })
    return jsxRuntimeExports.jsx(
      TabScrollButtonRoot,
      _extends$5(
        {
          component: 'div',
          className: clsx$1(st.root, et),
          ref: s,
          role: null,
          ownerState: at,
          tabIndex: null,
        },
        it,
        {
          children:
            nt === 'left'
              ? jsxRuntimeExports.jsx(ut, _extends$5({}, dt))
              : jsxRuntimeExports.jsx(ct, _extends$5({}, ft)),
        }
      )
    )
  })
function getTabsUtilityClass(o) {
  return generateUtilityClass('MuiTabs', o)
}
const tabsClasses = generateUtilityClasses('MuiTabs', [
    'root',
    'vertical',
    'flexContainer',
    'flexContainerVertical',
    'centered',
    'scroller',
    'fixed',
    'scrollableX',
    'scrollableY',
    'hideScrollbar',
    'scrollButtons',
    'scrollButtonsHideMobile',
    'indicator',
  ]),
  _excluded$3 = [
    'aria-label',
    'aria-labelledby',
    'action',
    'centered',
    'children',
    'className',
    'component',
    'allowScrollButtonsMobile',
    'indicatorColor',
    'onChange',
    'orientation',
    'ScrollButtonComponent',
    'scrollButtons',
    'selectionFollowsFocus',
    'slots',
    'slotProps',
    'TabIndicatorProps',
    'TabScrollButtonProps',
    'textColor',
    'value',
    'variant',
    'visibleScrollbar',
  ],
  nextItem = (o, a) =>
    o === a
      ? o.firstChild
      : a && a.nextElementSibling
      ? a.nextElementSibling
      : o.firstChild,
  previousItem = (o, a) =>
    o === a
      ? o.lastChild
      : a && a.previousElementSibling
      ? a.previousElementSibling
      : o.lastChild,
  moveFocus = (o, a, s) => {
    let $ = !1,
      j = s(o, a)
    for (; j; ) {
      if (j === o.firstChild) {
        if ($) return
        $ = !0
      }
      const _e = j.disabled || j.getAttribute('aria-disabled') === 'true'
      if (!j.hasAttribute('tabindex') || _e) j = s(o, j)
      else {
        j.focus()
        return
      }
    }
  },
  useUtilityClasses$2 = o => {
    const {
      vertical: a,
      fixed: s,
      hideScrollbar: $,
      scrollableX: j,
      scrollableY: _e,
      centered: et,
      scrollButtonsHideMobile: tt,
      classes: rt,
    } = o
    return composeClasses(
      {
        root: ['root', a && 'vertical'],
        scroller: [
          'scroller',
          s && 'fixed',
          $ && 'hideScrollbar',
          j && 'scrollableX',
          _e && 'scrollableY',
        ],
        flexContainer: [
          'flexContainer',
          a && 'flexContainerVertical',
          et && 'centered',
        ],
        indicator: ['indicator'],
        scrollButtons: ['scrollButtons', tt && 'scrollButtonsHideMobile'],
        scrollableX: [j && 'scrollableX'],
        hideScrollbar: [$ && 'hideScrollbar'],
      },
      getTabsUtilityClass,
      rt
    )
  },
  TabsRoot = styled('div', {
    name: 'MuiTabs',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        { [`& .${tabsClasses.scrollButtons}`]: a.scrollButtons },
        {
          [`& .${tabsClasses.scrollButtons}`]:
            s.scrollButtonsHideMobile && a.scrollButtonsHideMobile,
        },
        a.root,
        s.vertical && a.vertical,
      ]
    },
  })(({ ownerState: o, theme: a }) =>
    _extends$5(
      {
        overflow: 'hidden',
        minHeight: 48,
        WebkitOverflowScrolling: 'touch',
        display: 'flex',
      },
      o.vertical && { flexDirection: 'column' },
      o.scrollButtonsHideMobile && {
        [`& .${tabsClasses.scrollButtons}`]: {
          [a.breakpoints.down('sm')]: { display: 'none' },
        },
      }
    )
  ),
  TabsScroller = styled('div', {
    name: 'MuiTabs',
    slot: 'Scroller',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.scroller,
        s.fixed && a.fixed,
        s.hideScrollbar && a.hideScrollbar,
        s.scrollableX && a.scrollableX,
        s.scrollableY && a.scrollableY,
      ]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      {
        position: 'relative',
        display: 'inline-block',
        flex: '1 1 auto',
        whiteSpace: 'nowrap',
      },
      o.fixed && { overflowX: 'hidden', width: '100%' },
      o.hideScrollbar && {
        scrollbarWidth: 'none',
        '&::-webkit-scrollbar': { display: 'none' },
      },
      o.scrollableX && { overflowX: 'auto', overflowY: 'hidden' },
      o.scrollableY && { overflowY: 'auto', overflowX: 'hidden' }
    )
  ),
  FlexContainer = styled('div', {
    name: 'MuiTabs',
    slot: 'FlexContainer',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.flexContainer,
        s.vertical && a.flexContainerVertical,
        s.centered && a.centered,
      ]
    },
  })(({ ownerState: o }) =>
    _extends$5(
      { display: 'flex' },
      o.vertical && { flexDirection: 'column' },
      o.centered && { justifyContent: 'center' }
    )
  ),
  TabsIndicator = styled('span', {
    name: 'MuiTabs',
    slot: 'Indicator',
    overridesResolver: (o, a) => a.indicator,
  })(({ ownerState: o, theme: a }) =>
    _extends$5(
      {
        position: 'absolute',
        height: 2,
        bottom: 0,
        width: '100%',
        transition: a.transitions.create(),
      },
      o.indicatorColor === 'primary' && {
        backgroundColor: (a.vars || a).palette.primary.main,
      },
      o.indicatorColor === 'secondary' && {
        backgroundColor: (a.vars || a).palette.secondary.main,
      },
      o.vertical && { height: '100%', width: 2, right: 0 }
    )
  ),
  TabsScrollbarSize = styled(ScrollbarSize)({
    overflowX: 'auto',
    overflowY: 'hidden',
    scrollbarWidth: 'none',
    '&::-webkit-scrollbar': { display: 'none' },
  }),
  defaultIndicatorStyle = {},
  Tabs = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiTabs' }),
      j = useTheme$1(),
      _e = useRtl(),
      {
        'aria-label': et,
        'aria-labelledby': tt,
        action: rt,
        centered: nt = !1,
        children: it,
        className: ot,
        component: at = 'div',
        allowScrollButtonsMobile: st = !1,
        indicatorColor: ut = 'primary',
        onChange: ct,
        orientation: dt = 'horizontal',
        ScrollButtonComponent: ft = TabScrollButton,
        scrollButtons: mt = 'auto',
        selectionFollowsFocus: vt,
        slots: yt = {},
        slotProps: pt = {},
        TabIndicatorProps: ht = {},
        TabScrollButtonProps: At = {},
        textColor: wt = 'primary',
        value: Ct,
        variant: Dt = 'standard',
        visibleScrollbar: jt = !1,
      } = $,
      Et = _objectWithoutPropertiesLoose$3($, _excluded$3),
      St = Dt === 'scrollable',
      Bt = dt === 'vertical',
      Mt = Bt ? 'scrollTop' : 'scrollLeft',
      Ut = Bt ? 'top' : 'left',
      Wt = Bt ? 'bottom' : 'right',
      Tt = Bt ? 'clientHeight' : 'clientWidth',
      kt = Bt ? 'height' : 'width',
      Ot = _extends$5({}, $, {
        component: at,
        allowScrollButtonsMobile: st,
        indicatorColor: ut,
        orientation: dt,
        vertical: Bt,
        scrollButtons: mt,
        textColor: wt,
        variant: Dt,
        visibleScrollbar: jt,
        fixed: !St,
        hideScrollbar: St && !jt,
        scrollableX: St && !Bt,
        scrollableY: St && Bt,
        centered: nt && !St,
        scrollButtonsHideMobile: !st,
      }),
      Nt = useUtilityClasses$2(Ot),
      $t = useSlotProps({
        elementType: yt.StartScrollButtonIcon,
        externalSlotProps: pt.startScrollButtonIcon,
        ownerState: Ot,
      }),
      Pt = useSlotProps({
        elementType: yt.EndScrollButtonIcon,
        externalSlotProps: pt.endScrollButtonIcon,
        ownerState: Ot,
      }),
      [Ft, Vt] = reactExports.useState(!1),
      [Xt, Yt] = reactExports.useState(defaultIndicatorStyle),
      [xt, It] = reactExports.useState(!1),
      [Kt, Qt] = reactExports.useState(!1),
      [Ht, Lt] = reactExports.useState(!1),
      [tr, lr] = reactExports.useState({
        overflow: 'hidden',
        scrollbarWidth: 0,
      }),
      yr = new Map(),
      mr = reactExports.useRef(null),
      Er = reactExports.useRef(null),
      ur = () => {
        const vr = mr.current
        let Ar
        if (vr) {
          const Or = vr.getBoundingClientRect()
          Ar = {
            clientWidth: vr.clientWidth,
            scrollLeft: vr.scrollLeft,
            scrollTop: vr.scrollTop,
            scrollLeftNormalized: getNormalizedScrollLeft(
              vr,
              _e ? 'rtl' : 'ltr'
            ),
            scrollWidth: vr.scrollWidth,
            top: Or.top,
            bottom: Or.bottom,
            left: Or.left,
            right: Or.right,
          }
        }
        let Nr
        if (vr && Ct !== !1) {
          const Or = Er.current.children
          if (Or.length > 0) {
            const Fr = Or[yr.get(Ct)]
            Nr = Fr ? Fr.getBoundingClientRect() : null
          }
        }
        return { tabsMeta: Ar, tabMeta: Nr }
      },
      _r = useEventCallback$1(() => {
        const { tabsMeta: vr, tabMeta: Ar } = ur()
        let Nr = 0,
          Or
        if (Bt) (Or = 'top'), Ar && vr && (Nr = Ar.top - vr.top + vr.scrollTop)
        else if (((Or = _e ? 'right' : 'left'), Ar && vr)) {
          const Qr = _e
            ? vr.scrollLeftNormalized + vr.clientWidth - vr.scrollWidth
            : vr.scrollLeft
          Nr = (_e ? -1 : 1) * (Ar[Or] - vr[Or] + Qr)
        }
        const Fr = { [Or]: Nr, [kt]: Ar ? Ar[kt] : 0 }
        if (isNaN(Xt[Or]) || isNaN(Xt[kt])) Yt(Fr)
        else {
          const Qr = Math.abs(Xt[Or] - Fr[Or]),
            qr = Math.abs(Xt[kt] - Fr[kt])
          ;(Qr >= 1 || qr >= 1) && Yt(Fr)
        }
      }),
      Rr = (vr, { animation: Ar = !0 } = {}) => {
        Ar
          ? animate$1(Mt, mr.current, vr, {
              duration: j.transitions.duration.standard,
            })
          : (mr.current[Mt] = vr)
      },
      nr = vr => {
        let Ar = mr.current[Mt]
        Bt
          ? (Ar += vr)
          : ((Ar += vr * (_e ? -1 : 1)),
            (Ar *= _e && detectScrollType() === 'reverse' ? -1 : 1)),
          Rr(Ar)
      },
      fr = () => {
        const vr = mr.current[Tt]
        let Ar = 0
        const Nr = Array.from(Er.current.children)
        for (let Or = 0; Or < Nr.length; Or += 1) {
          const Fr = Nr[Or]
          if (Ar + Fr[Tt] > vr) {
            Or === 0 && (Ar = vr)
            break
          }
          Ar += Fr[Tt]
        }
        return Ar
      },
      gr = () => {
        nr(-1 * fr())
      },
      br = () => {
        nr(fr())
      },
      Sr = reactExports.useCallback(vr => {
        lr({ overflow: null, scrollbarWidth: vr })
      }, []),
      zt = () => {
        const vr = {}
        vr.scrollbarSizeListener = St
          ? jsxRuntimeExports.jsx(TabsScrollbarSize, {
              onChange: Sr,
              className: clsx$1(Nt.scrollableX, Nt.hideScrollbar),
            })
          : null
        const Nr = St && ((mt === 'auto' && (xt || Kt)) || mt === !0)
        return (
          (vr.scrollButtonStart = Nr
            ? jsxRuntimeExports.jsx(
                ft,
                _extends$5(
                  {
                    slots: { StartScrollButtonIcon: yt.StartScrollButtonIcon },
                    slotProps: { startScrollButtonIcon: $t },
                    orientation: dt,
                    direction: _e ? 'right' : 'left',
                    onClick: gr,
                    disabled: !xt,
                  },
                  At,
                  { className: clsx$1(Nt.scrollButtons, At.className) }
                )
              )
            : null),
          (vr.scrollButtonEnd = Nr
            ? jsxRuntimeExports.jsx(
                ft,
                _extends$5(
                  {
                    slots: { EndScrollButtonIcon: yt.EndScrollButtonIcon },
                    slotProps: { endScrollButtonIcon: Pt },
                    orientation: dt,
                    direction: _e ? 'left' : 'right',
                    onClick: br,
                    disabled: !Kt,
                  },
                  At,
                  { className: clsx$1(Nt.scrollButtons, At.className) }
                )
              )
            : null),
          vr
        )
      },
      bt = useEventCallback$1(vr => {
        const { tabsMeta: Ar, tabMeta: Nr } = ur()
        if (!(!Nr || !Ar)) {
          if (Nr[Ut] < Ar[Ut]) {
            const Or = Ar[Mt] + (Nr[Ut] - Ar[Ut])
            Rr(Or, { animation: vr })
          } else if (Nr[Wt] > Ar[Wt]) {
            const Or = Ar[Mt] + (Nr[Wt] - Ar[Wt])
            Rr(Or, { animation: vr })
          }
        }
      }),
      Rt = useEventCallback$1(() => {
        St && mt !== !1 && Lt(!Ht)
      })
    reactExports.useEffect(() => {
      const vr = debounce$4(() => {
        mr.current && _r()
      })
      let Ar
      const Nr = Qr => {
          Qr.forEach(qr => {
            qr.removedNodes.forEach(tn => {
              var en
              ;(en = Ar) == null || en.unobserve(tn)
            }),
              qr.addedNodes.forEach(tn => {
                var en
                ;(en = Ar) == null || en.observe(tn)
              })
          }),
            vr(),
            Rt()
        },
        Or = ownerWindow(mr.current)
      Or.addEventListener('resize', vr)
      let Fr
      return (
        typeof ResizeObserver < 'u' &&
          ((Ar = new ResizeObserver(vr)),
          Array.from(Er.current.children).forEach(Qr => {
            Ar.observe(Qr)
          })),
        typeof MutationObserver < 'u' &&
          ((Fr = new MutationObserver(Nr)),
          Fr.observe(Er.current, { childList: !0 })),
        () => {
          var Qr, qr
          vr.clear(),
            Or.removeEventListener('resize', vr),
            (Qr = Fr) == null || Qr.disconnect(),
            (qr = Ar) == null || qr.disconnect()
        }
      )
    }, [_r, Rt]),
      reactExports.useEffect(() => {
        const vr = Array.from(Er.current.children),
          Ar = vr.length
        if (typeof IntersectionObserver < 'u' && Ar > 0 && St && mt !== !1) {
          const Nr = vr[0],
            Or = vr[Ar - 1],
            Fr = { root: mr.current, threshold: 0.99 },
            Qr = ln => {
              It(!ln[0].isIntersecting)
            },
            qr = new IntersectionObserver(Qr, Fr)
          qr.observe(Nr)
          const tn = ln => {
              Qt(!ln[0].isIntersecting)
            },
            en = new IntersectionObserver(tn, Fr)
          return (
            en.observe(Or),
            () => {
              qr.disconnect(), en.disconnect()
            }
          )
        }
      }, [St, mt, Ht, it == null ? void 0 : it.length]),
      reactExports.useEffect(() => {
        Vt(!0)
      }, []),
      reactExports.useEffect(() => {
        _r()
      }),
      reactExports.useEffect(() => {
        bt(defaultIndicatorStyle !== Xt)
      }, [bt, Xt]),
      reactExports.useImperativeHandle(
        rt,
        () => ({ updateIndicator: _r, updateScrollButtons: Rt }),
        [_r, Rt]
      )
    const qt = jsxRuntimeExports.jsx(
      TabsIndicator,
      _extends$5({}, ht, {
        className: clsx$1(Nt.indicator, ht.className),
        ownerState: Ot,
        style: _extends$5({}, Xt, ht.style),
      })
    )
    let rr = 0
    const ar = reactExports.Children.map(it, vr => {
        if (!reactExports.isValidElement(vr)) return null
        const Ar = vr.props.value === void 0 ? rr : vr.props.value
        yr.set(Ar, rr)
        const Nr = Ar === Ct
        return (
          (rr += 1),
          reactExports.cloneElement(
            vr,
            _extends$5(
              {
                fullWidth: Dt === 'fullWidth',
                indicator: Nr && !Ft && qt,
                selected: Nr,
                selectionFollowsFocus: vt,
                onChange: ct,
                textColor: wt,
                value: Ar,
              },
              rr === 1 && Ct === !1 && !vr.props.tabIndex ? { tabIndex: 0 } : {}
            )
          )
        )
      }),
      ir = vr => {
        const Ar = Er.current,
          Nr = ownerDocument(Ar).activeElement
        if (Nr.getAttribute('role') !== 'tab') return
        let Fr = dt === 'horizontal' ? 'ArrowLeft' : 'ArrowUp',
          Qr = dt === 'horizontal' ? 'ArrowRight' : 'ArrowDown'
        switch (
          (dt === 'horizontal' &&
            _e &&
            ((Fr = 'ArrowRight'), (Qr = 'ArrowLeft')),
          vr.key)
        ) {
          case Fr:
            vr.preventDefault(), moveFocus(Ar, Nr, previousItem)
            break
          case Qr:
            vr.preventDefault(), moveFocus(Ar, Nr, nextItem)
            break
          case 'Home':
            vr.preventDefault(), moveFocus(Ar, null, nextItem)
            break
          case 'End':
            vr.preventDefault(), moveFocus(Ar, null, previousItem)
            break
        }
      },
      Tr = zt()
    return jsxRuntimeExports.jsxs(
      TabsRoot,
      _extends$5(
        { className: clsx$1(Nt.root, ot), ownerState: Ot, ref: s, as: at },
        Et,
        {
          children: [
            Tr.scrollButtonStart,
            Tr.scrollbarSizeListener,
            jsxRuntimeExports.jsxs(TabsScroller, {
              className: Nt.scroller,
              ownerState: Ot,
              style: {
                overflow: tr.overflow,
                [Bt ? `margin${_e ? 'Left' : 'Right'}` : 'marginBottom']: jt
                  ? void 0
                  : -tr.scrollbarWidth,
              },
              ref: mr,
              children: [
                jsxRuntimeExports.jsx(FlexContainer, {
                  'aria-label': et,
                  'aria-labelledby': tt,
                  'aria-orientation': dt === 'vertical' ? 'vertical' : null,
                  className: Nt.flexContainer,
                  ownerState: Ot,
                  onKeyDown: ir,
                  ref: Er,
                  role: 'tablist',
                  children: ar,
                }),
                Ft && qt,
              ],
            }),
            Tr.scrollButtonEnd,
          ],
        }
      )
    )
  })
var define_global_default$1 = {}
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */ function _typeof$2(o) {
  return (
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? (_typeof$2 = function(a) {
          return typeof a
        })
      : (_typeof$2 = function(a) {
          return a &&
            typeof Symbol == 'function' &&
            a.constructor === Symbol &&
            a !== Symbol.prototype
            ? 'symbol'
            : typeof a
        }),
    _typeof$2(o)
  )
}
function _classCallCheck(o, a) {
  if (!(o instanceof a))
    throw new TypeError('Cannot call a class as a function')
}
function _defineProperties(o, a) {
  for (var s = 0; s < a.length; s++) {
    var $ = a[s]
    ;($.enumerable = $.enumerable || !1),
      ($.configurable = !0),
      'value' in $ && ($.writable = !0),
      Object.defineProperty(o, $.key, $)
  }
}
function _createClass(o, a, s) {
  return a && _defineProperties(o.prototype, a), o
}
function _defineProperty$2(o, a, s) {
  return (
    a in o
      ? Object.defineProperty(o, a, {
          value: s,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (o[a] = s),
    o
  )
}
function _objectSpread(o) {
  for (var a = 1; a < arguments.length; a++) {
    var s = arguments[a] != null ? arguments[a] : {},
      $ = Object.keys(s)
    typeof Object.getOwnPropertySymbols == 'function' &&
      ($ = $.concat(
        Object.getOwnPropertySymbols(s).filter(function(j) {
          return Object.getOwnPropertyDescriptor(s, j).enumerable
        })
      )),
      $.forEach(function(j) {
        _defineProperty$2(o, j, s[j])
      })
  }
  return o
}
function _slicedToArray(o, a) {
  return _arrayWithHoles(o) || _iterableToArrayLimit(o, a) || _nonIterableRest()
}
function _arrayWithHoles(o) {
  if (Array.isArray(o)) return o
}
function _iterableToArrayLimit(o, a) {
  var s = [],
    $ = !0,
    j = !1,
    _e = void 0
  try {
    for (
      var et = o[Symbol.iterator](), tt;
      !($ = (tt = et.next()).done) &&
      (s.push(tt.value), !(a && s.length === a));
      $ = !0
    );
  } catch (rt) {
    ;(j = !0), (_e = rt)
  } finally {
    try {
      !$ && et.return != null && et.return()
    } finally {
      if (j) throw _e
    }
  }
  return s
}
function _nonIterableRest() {
  throw new TypeError('Invalid attempt to destructure non-iterable instance')
}
var noop = function o() {},
  _WINDOW = {},
  _DOCUMENT = {},
  _MUTATION_OBSERVER = null,
  _PERFORMANCE = { mark: noop, measure: noop }
try {
  typeof window < 'u' && (_WINDOW = window),
    typeof document < 'u' && (_DOCUMENT = document),
    typeof MutationObserver < 'u' && (_MUTATION_OBSERVER = MutationObserver),
    typeof performance < 'u' && (_PERFORMANCE = performance)
} catch (o) {}
var _ref = _WINDOW.navigator || {},
  _ref$userAgent = _ref.userAgent,
  userAgent = _ref$userAgent === void 0 ? '' : _ref$userAgent,
  WINDOW = _WINDOW,
  DOCUMENT = _DOCUMENT,
  PERFORMANCE = _PERFORMANCE
WINDOW.document
var IS_DOM =
  !!DOCUMENT.documentElement &&
  !!DOCUMENT.head &&
  typeof DOCUMENT.addEventListener == 'function' &&
  typeof DOCUMENT.createElement == 'function'
~userAgent.indexOf('MSIE') || ~userAgent.indexOf('Trident/')
var NAMESPACE_IDENTIFIER = '___FONT_AWESOME___',
  DEFAULT_FAMILY_PREFIX = 'fa',
  DEFAULT_REPLACEMENT_CLASS = 'svg-inline--fa',
  DATA_FA_I2SVG = 'data-fa-i2svg'
;(function() {
  try {
    return !0
  } catch {
    return !1
  }
})()
var DUOTONE_CLASSES = {
    GROUP: 'group',
    SWAP_OPACITY: 'swap-opacity',
    PRIMARY: 'primary',
    SECONDARY: 'secondary',
  },
  initial = WINDOW.FontAwesomeConfig || {}
function getAttrConfig(o) {
  var a = DOCUMENT.querySelector('script[' + o + ']')
  if (a) return a.getAttribute(o)
}
function coerce(o) {
  return o === '' ? !0 : o === 'false' ? !1 : o === 'true' ? !0 : o
}
if (DOCUMENT && typeof DOCUMENT.querySelector == 'function') {
  var attrs = [
    ['data-family-prefix', 'familyPrefix'],
    ['data-replacement-class', 'replacementClass'],
    ['data-auto-replace-svg', 'autoReplaceSvg'],
    ['data-auto-add-css', 'autoAddCss'],
    ['data-auto-a11y', 'autoA11y'],
    ['data-search-pseudo-elements', 'searchPseudoElements'],
    ['data-observe-mutations', 'observeMutations'],
    ['data-mutate-approach', 'mutateApproach'],
    ['data-keep-original-source', 'keepOriginalSource'],
    ['data-measure-performance', 'measurePerformance'],
    ['data-show-missing-icons', 'showMissingIcons'],
  ]
  attrs.forEach(function(o) {
    var a = _slicedToArray(o, 2),
      s = a[0],
      $ = a[1],
      j = coerce(getAttrConfig(s))
    j != null && (initial[$] = j)
  })
}
var _default$1 = {
    familyPrefix: DEFAULT_FAMILY_PREFIX,
    replacementClass: DEFAULT_REPLACEMENT_CLASS,
    autoReplaceSvg: !0,
    autoAddCss: !0,
    autoA11y: !0,
    searchPseudoElements: !1,
    observeMutations: !0,
    mutateApproach: 'async',
    keepOriginalSource: !0,
    measurePerformance: !1,
    showMissingIcons: !0,
  },
  _config = _objectSpread({}, _default$1, initial)
_config.autoReplaceSvg || (_config.observeMutations = !1)
var config = _objectSpread({}, _config)
WINDOW.FontAwesomeConfig = config
var w = WINDOW || {}
w[NAMESPACE_IDENTIFIER] || (w[NAMESPACE_IDENTIFIER] = {})
w[NAMESPACE_IDENTIFIER].styles || (w[NAMESPACE_IDENTIFIER].styles = {})
w[NAMESPACE_IDENTIFIER].hooks || (w[NAMESPACE_IDENTIFIER].hooks = {})
w[NAMESPACE_IDENTIFIER].shims || (w[NAMESPACE_IDENTIFIER].shims = [])
var namespace = w[NAMESPACE_IDENTIFIER],
  functions = [],
  listener = function o() {
    DOCUMENT.removeEventListener('DOMContentLoaded', o),
      (loaded = 1),
      functions.map(function(a) {
        return a()
      })
  },
  loaded = !1
IS_DOM &&
  ((loaded = (DOCUMENT.documentElement.doScroll
    ? /^loaded|^c/
    : /^loaded|^i|^c/
  ).test(DOCUMENT.readyState)),
  loaded || DOCUMENT.addEventListener('DOMContentLoaded', listener))
var PENDING = 'pending',
  SETTLED = 'settled',
  FULFILLED = 'fulfilled',
  REJECTED = 'rejected',
  NOOP = function o() {},
  isNode =
    typeof define_global_default$1 < 'u' &&
    typeof define_global_default$1.process < 'u' &&
    typeof define_global_default$1.process.emit == 'function',
  asyncSetTimer = typeof setImmediate > 'u' ? setTimeout : setImmediate,
  asyncQueue = [],
  asyncTimer
function asyncFlush() {
  for (var o = 0; o < asyncQueue.length; o++) asyncQueue[o][0](asyncQueue[o][1])
  ;(asyncQueue = []), (asyncTimer = !1)
}
function asyncCall(o, a) {
  asyncQueue.push([o, a]),
    asyncTimer || ((asyncTimer = !0), asyncSetTimer(asyncFlush, 0))
}
function invokeResolver(o, a) {
  function s(j) {
    resolve(a, j)
  }
  function $(j) {
    reject(a, j)
  }
  try {
    o(s, $)
  } catch (j) {
    $(j)
  }
}
function invokeCallback(o) {
  var a = o.owner,
    s = a._state,
    $ = a._data,
    j = o[s],
    _e = o.then
  if (typeof j == 'function') {
    s = FULFILLED
    try {
      $ = j($)
    } catch (et) {
      reject(_e, et)
    }
  }
  handleThenable(_e, $) ||
    (s === FULFILLED && resolve(_e, $), s === REJECTED && reject(_e, $))
}
function handleThenable(o, a) {
  var s
  try {
    if (o === a)
      throw new TypeError(
        'A promises callback cannot return that same promise.'
      )
    if (a && (typeof a == 'function' || _typeof$2(a) === 'object')) {
      var $ = a.then
      if (typeof $ == 'function')
        return (
          $.call(
            a,
            function(j) {
              s || ((s = !0), a === j ? fulfill(o, j) : resolve(o, j))
            },
            function(j) {
              s || ((s = !0), reject(o, j))
            }
          ),
          !0
        )
    }
  } catch (j) {
    return s || reject(o, j), !0
  }
  return !1
}
function resolve(o, a) {
  ;(o === a || !handleThenable(o, a)) && fulfill(o, a)
}
function fulfill(o, a) {
  o._state === PENDING &&
    ((o._state = SETTLED), (o._data = a), asyncCall(publishFulfillment, o))
}
function reject(o, a) {
  o._state === PENDING &&
    ((o._state = SETTLED), (o._data = a), asyncCall(publishRejection, o))
}
function publish(o) {
  o._then = o._then.forEach(invokeCallback)
}
function publishFulfillment(o) {
  ;(o._state = FULFILLED), publish(o)
}
function publishRejection(o) {
  ;(o._state = REJECTED),
    publish(o),
    !o._handled &&
      isNode &&
      define_global_default$1.process.emit('unhandledRejection', o._data, o)
}
function notifyRejectionHandled(o) {
  define_global_default$1.process.emit('rejectionHandled', o)
}
function P(o) {
  if (typeof o != 'function')
    throw new TypeError('Promise resolver ' + o + ' is not a function')
  if (!(this instanceof P))
    throw new TypeError(
      "Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
    )
  ;(this._then = []), invokeResolver(o, this)
}
P.prototype = {
  constructor: P,
  _state: PENDING,
  _then: null,
  _data: void 0,
  _handled: !1,
  then: function o(a, s) {
    var $ = {
      owner: this,
      then: new this.constructor(NOOP),
      fulfilled: a,
      rejected: s,
    }
    return (
      (s || a) &&
        !this._handled &&
        ((this._handled = !0),
        this._state === REJECTED &&
          isNode &&
          asyncCall(notifyRejectionHandled, this)),
      this._state === FULFILLED || this._state === REJECTED
        ? asyncCall(invokeCallback, $)
        : this._then.push($),
      $.then
    )
  },
  catch: function o(a) {
    return this.then(null, a)
  },
}
P.all = function(o) {
  if (!Array.isArray(o))
    throw new TypeError('You must pass an array to Promise.all().')
  return new P(function(a, s) {
    var $ = [],
      j = 0
    function _e(rt) {
      return (
        j++,
        function(nt) {
          ;($[rt] = nt), --j || a($)
        }
      )
    }
    for (var et = 0, tt; et < o.length; et++)
      (tt = o[et]),
        tt && typeof tt.then == 'function' ? tt.then(_e(et), s) : ($[et] = tt)
    j || a($)
  })
}
P.race = function(o) {
  if (!Array.isArray(o))
    throw new TypeError('You must pass an array to Promise.race().')
  return new P(function(a, s) {
    for (var $ = 0, j; $ < o.length; $++)
      (j = o[$]), j && typeof j.then == 'function' ? j.then(a, s) : a(j)
  })
}
P.resolve = function(o) {
  return o && _typeof$2(o) === 'object' && o.constructor === P
    ? o
    : new P(function(a) {
        a(o)
      })
}
P.reject = function(o) {
  return new P(function(a, s) {
    s(o)
  })
}
var meaninglessTransform = {
  size: 16,
  x: 0,
  y: 0,
  rotate: 0,
  flipX: !1,
  flipY: !1,
}
function insertCss(o) {
  if (!(!o || !IS_DOM)) {
    var a = DOCUMENT.createElement('style')
    a.setAttribute('type', 'text/css'), (a.innerHTML = o)
    for (
      var s = DOCUMENT.head.childNodes, $ = null, j = s.length - 1;
      j > -1;
      j--
    ) {
      var _e = s[j],
        et = (_e.tagName || '').toUpperCase()
      ;['STYLE', 'LINK'].indexOf(et) > -1 && ($ = _e)
    }
    return DOCUMENT.head.insertBefore(a, $), o
  }
}
var idPool = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
function nextUniqueId() {
  for (var o = 12, a = ''; o-- > 0; ) a += idPool[(Math.random() * 62) | 0]
  return a
}
function htmlEscape(o) {
  return ''
    .concat(o)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
}
function joinAttributes(o) {
  return Object.keys(o || {})
    .reduce(function(a, s) {
      return a + ''.concat(s, '="').concat(htmlEscape(o[s]), '" ')
    }, '')
    .trim()
}
function joinStyles(o) {
  return Object.keys(o || {}).reduce(function(a, s) {
    return a + ''.concat(s, ': ').concat(o[s], ';')
  }, '')
}
function transformIsMeaningful(o) {
  return (
    o.size !== meaninglessTransform.size ||
    o.x !== meaninglessTransform.x ||
    o.y !== meaninglessTransform.y ||
    o.rotate !== meaninglessTransform.rotate ||
    o.flipX ||
    o.flipY
  )
}
function transformForSvg(o) {
  var a = o.transform,
    s = o.containerWidth,
    $ = o.iconWidth,
    j = { transform: 'translate('.concat(s / 2, ' 256)') },
    _e = 'translate('.concat(a.x * 32, ', ').concat(a.y * 32, ') '),
    et = 'scale('
      .concat((a.size / 16) * (a.flipX ? -1 : 1), ', ')
      .concat((a.size / 16) * (a.flipY ? -1 : 1), ') '),
    tt = 'rotate('.concat(a.rotate, ' 0 0)'),
    rt = {
      transform: ''
        .concat(_e, ' ')
        .concat(et, ' ')
        .concat(tt),
    },
    nt = { transform: 'translate('.concat(($ / 2) * -1, ' -256)') }
  return { outer: j, inner: rt, path: nt }
}
var ALL_SPACE = { x: 0, y: 0, width: '100%', height: '100%' }
function fillBlack(o) {
  var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
  return (
    o.attributes && (o.attributes.fill || a) && (o.attributes.fill = 'black'), o
  )
}
function deGroup(o) {
  return o.tag === 'g' ? o.children : [o]
}
function makeIconMasking(o) {
  var a = o.children,
    s = o.attributes,
    $ = o.main,
    j = o.mask,
    _e = o.maskId,
    et = o.transform,
    tt = $.width,
    rt = $.icon,
    nt = j.width,
    it = j.icon,
    ot = transformForSvg({ transform: et, containerWidth: nt, iconWidth: tt }),
    at = {
      tag: 'rect',
      attributes: _objectSpread({}, ALL_SPACE, { fill: 'white' }),
    },
    st = rt.children ? { children: rt.children.map(fillBlack) } : {},
    ut = {
      tag: 'g',
      attributes: _objectSpread({}, ot.inner),
      children: [
        fillBlack(
          _objectSpread(
            {
              tag: rt.tag,
              attributes: _objectSpread({}, rt.attributes, ot.path),
            },
            st
          )
        ),
      ],
    },
    ct = { tag: 'g', attributes: _objectSpread({}, ot.outer), children: [ut] },
    dt = 'mask-'.concat(_e || nextUniqueId()),
    ft = 'clip-'.concat(_e || nextUniqueId()),
    mt = {
      tag: 'mask',
      attributes: _objectSpread({}, ALL_SPACE, {
        id: dt,
        maskUnits: 'userSpaceOnUse',
        maskContentUnits: 'userSpaceOnUse',
      }),
      children: [at, ct],
    },
    vt = {
      tag: 'defs',
      children: [
        { tag: 'clipPath', attributes: { id: ft }, children: deGroup(it) },
        mt,
      ],
    }
  return (
    a.push(vt, {
      tag: 'rect',
      attributes: _objectSpread(
        {
          fill: 'currentColor',
          'clip-path': 'url(#'.concat(ft, ')'),
          mask: 'url(#'.concat(dt, ')'),
        },
        ALL_SPACE
      ),
    }),
    { children: a, attributes: s }
  )
}
function makeIconStandard(o) {
  var a = o.children,
    s = o.attributes,
    $ = o.main,
    j = o.transform,
    _e = o.styles,
    et = joinStyles(_e)
  if ((et.length > 0 && (s.style = et), transformIsMeaningful(j))) {
    var tt = transformForSvg({
      transform: j,
      containerWidth: $.width,
      iconWidth: $.width,
    })
    a.push({
      tag: 'g',
      attributes: _objectSpread({}, tt.outer),
      children: [
        {
          tag: 'g',
          attributes: _objectSpread({}, tt.inner),
          children: [
            {
              tag: $.icon.tag,
              children: $.icon.children,
              attributes: _objectSpread({}, $.icon.attributes, tt.path),
            },
          ],
        },
      ],
    })
  } else a.push($.icon)
  return { children: a, attributes: s }
}
function asIcon(o) {
  var a = o.children,
    s = o.main,
    $ = o.mask,
    j = o.attributes,
    _e = o.styles,
    et = o.transform
  if (transformIsMeaningful(et) && s.found && !$.found) {
    var tt = s.width,
      rt = s.height,
      nt = { x: tt / rt / 2, y: 0.5 }
    j.style = joinStyles(
      _objectSpread({}, _e, {
        'transform-origin': ''
          .concat(nt.x + et.x / 16, 'em ')
          .concat(nt.y + et.y / 16, 'em'),
      })
    )
  }
  return [{ tag: 'svg', attributes: j, children: a }]
}
function asSymbol(o) {
  var a = o.prefix,
    s = o.iconName,
    $ = o.children,
    j = o.attributes,
    _e = o.symbol,
    et =
      _e === !0
        ? ''
            .concat(a, '-')
            .concat(config.familyPrefix, '-')
            .concat(s)
        : _e
  return [
    {
      tag: 'svg',
      attributes: { style: 'display: none;' },
      children: [
        {
          tag: 'symbol',
          attributes: _objectSpread({}, j, { id: et }),
          children: $,
        },
      ],
    },
  ]
}
function makeInlineSvgAbstract(o) {
  var a = o.icons,
    s = a.main,
    $ = a.mask,
    j = o.prefix,
    _e = o.iconName,
    et = o.transform,
    tt = o.symbol,
    rt = o.title,
    nt = o.maskId,
    it = o.titleId,
    ot = o.extra,
    at = o.watchable,
    st = at === void 0 ? !1 : at,
    ut = $.found ? $ : s,
    ct = ut.width,
    dt = ut.height,
    ft = j === 'fak',
    mt = ft ? '' : 'fa-w-'.concat(Math.ceil((ct / dt) * 16)),
    vt = [
      config.replacementClass,
      _e ? ''.concat(config.familyPrefix, '-').concat(_e) : '',
      mt,
    ]
      .filter(function(Dt) {
        return ot.classes.indexOf(Dt) === -1
      })
      .filter(function(Dt) {
        return Dt !== '' || !!Dt
      })
      .concat(ot.classes)
      .join(' '),
    yt = {
      children: [],
      attributes: _objectSpread({}, ot.attributes, {
        'data-prefix': j,
        'data-icon': _e,
        class: vt,
        role: ot.attributes.role || 'img',
        xmlns: 'http://www.w3.org/2000/svg',
        viewBox: '0 0 '.concat(ct, ' ').concat(dt),
      }),
    },
    pt =
      ft && !~ot.classes.indexOf('fa-fw')
        ? { width: ''.concat((ct / dt) * 16 * 0.0625, 'em') }
        : {}
  st && (yt.attributes[DATA_FA_I2SVG] = ''),
    rt &&
      yt.children.push({
        tag: 'title',
        attributes: {
          id:
            yt.attributes['aria-labelledby'] ||
            'title-'.concat(it || nextUniqueId()),
        },
        children: [rt],
      })
  var ht = _objectSpread({}, yt, {
      prefix: j,
      iconName: _e,
      main: s,
      mask: $,
      maskId: nt,
      transform: et,
      symbol: tt,
      styles: _objectSpread({}, pt, ot.styles),
    }),
    At = $.found && s.found ? makeIconMasking(ht) : makeIconStandard(ht),
    wt = At.children,
    Ct = At.attributes
  return (
    (ht.children = wt), (ht.attributes = Ct), tt ? asSymbol(ht) : asIcon(ht)
  )
}
var noop$1 = function o() {}
config.measurePerformance &&
  PERFORMANCE &&
  PERFORMANCE.mark &&
  PERFORMANCE.measure
var reduce = function o(a, s, $, j) {
  var _e = Object.keys(a),
    et = _e.length,
    tt = s,
    rt,
    nt,
    it
  for (
    $ === void 0 ? ((rt = 1), (it = a[_e[0]])) : ((rt = 0), (it = $));
    rt < et;
    rt++
  )
    (nt = _e[rt]), (it = tt(it, a[nt], nt, a))
  return it
}
function defineIcons(o, a) {
  var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
    $ = s.skipHooks,
    j = $ === void 0 ? !1 : $,
    _e = Object.keys(a).reduce(function(et, tt) {
      var rt = a[tt],
        nt = !!rt.icon
      return nt ? (et[rt.iconName] = rt.icon) : (et[tt] = rt), et
    }, {})
  typeof namespace.hooks.addPack == 'function' && !j
    ? namespace.hooks.addPack(o, _e)
    : (namespace.styles[o] = _objectSpread({}, namespace.styles[o] || {}, _e)),
    o === 'fas' && defineIcons('fa', a)
}
var styles$1 = namespace.styles,
  shims = namespace.shims,
  build = function o() {
    var a = function(j) {
      return reduce(
        styles$1,
        function(_e, et, tt) {
          return (_e[tt] = reduce(et, j, {})), _e
        },
        {}
      )
    }
    a(function($, j, _e) {
      return j[3] && ($[j[3]] = _e), $
    }),
      a(function($, j, _e) {
        var et = j[2]
        return (
          ($[_e] = _e),
          et.forEach(function(tt) {
            $[tt] = _e
          }),
          $
        )
      })
    var s = 'far' in styles$1
    reduce(
      shims,
      function($, j) {
        var _e = j[0],
          et = j[1],
          tt = j[2]
        return (
          et === 'far' && !s && (et = 'fas'),
          ($[_e] = { prefix: et, iconName: tt }),
          $
        )
      },
      {}
    )
  }
build()
namespace.styles
function iconFromMapping(o, a, s) {
  if (o && o[a] && o[a][s]) return { prefix: a, iconName: s, icon: o[a][s] }
}
function toHtml(o) {
  var a = o.tag,
    s = o.attributes,
    $ = s === void 0 ? {} : s,
    j = o.children,
    _e = j === void 0 ? [] : j
  return typeof o == 'string'
    ? htmlEscape(o)
    : '<'
        .concat(a, ' ')
        .concat(joinAttributes($), '>')
        .concat(_e.map(toHtml).join(''), '</')
        .concat(a, '>')
}
var parseTransformString = function o(a) {
  var s = { size: 16, x: 0, y: 0, flipX: !1, flipY: !1, rotate: 0 }
  return a
    ? a
        .toLowerCase()
        .split(' ')
        .reduce(function($, j) {
          var _e = j.toLowerCase().split('-'),
            et = _e[0],
            tt = _e.slice(1).join('-')
          if (et && tt === 'h') return ($.flipX = !0), $
          if (et && tt === 'v') return ($.flipY = !0), $
          if (((tt = parseFloat(tt)), isNaN(tt))) return $
          switch (et) {
            case 'grow':
              $.size = $.size + tt
              break
            case 'shrink':
              $.size = $.size - tt
              break
            case 'left':
              $.x = $.x - tt
              break
            case 'right':
              $.x = $.x + tt
              break
            case 'up':
              $.y = $.y - tt
              break
            case 'down':
              $.y = $.y + tt
              break
            case 'rotate':
              $.rotate = $.rotate + tt
              break
          }
          return $
        }, s)
    : s
}
function MissingIcon(o) {
  ;(this.name = 'MissingIcon'),
    (this.message = o || 'Icon unavailable'),
    (this.stack = new Error().stack)
}
MissingIcon.prototype = Object.create(Error.prototype)
MissingIcon.prototype.constructor = MissingIcon
var FILL = { fill: 'currentColor' },
  ANIMATION_BASE = {
    attributeType: 'XML',
    repeatCount: 'indefinite',
    dur: '2s',
  }
_objectSpread({}, FILL, {
  d:
    'M156.5,447.7l-12.6,29.5c-18.7-9.5-35.9-21.2-51.5-34.9l22.7-22.7C127.6,430.5,141.5,440,156.5,447.7z M40.6,272H8.5 c1.4,21.2,5.4,41.7,11.7,61.1L50,321.2C45.1,305.5,41.8,289,40.6,272z M40.6,240c1.4-18.8,5.2-37,11.1-54.1l-29.5-12.6 C14.7,194.3,10,216.7,8.5,240H40.6z M64.3,156.5c7.8-14.9,17.2-28.8,28.1-41.5L69.7,92.3c-13.7,15.6-25.5,32.8-34.9,51.5 L64.3,156.5z M397,419.6c-13.9,12-29.4,22.3-46.1,30.4l11.9,29.8c20.7-9.9,39.8-22.6,56.9-37.6L397,419.6z M115,92.4 c13.9-12,29.4-22.3,46.1-30.4l-11.9-29.8c-20.7,9.9-39.8,22.6-56.8,37.6L115,92.4z M447.7,355.5c-7.8,14.9-17.2,28.8-28.1,41.5 l22.7,22.7c13.7-15.6,25.5-32.9,34.9-51.5L447.7,355.5z M471.4,272c-1.4,18.8-5.2,37-11.1,54.1l29.5,12.6 c7.5-21.1,12.2-43.5,13.6-66.8H471.4z M321.2,462c-15.7,5-32.2,8.2-49.2,9.4v32.1c21.2-1.4,41.7-5.4,61.1-11.7L321.2,462z M240,471.4c-18.8-1.4-37-5.2-54.1-11.1l-12.6,29.5c21.1,7.5,43.5,12.2,66.8,13.6V471.4z M462,190.8c5,15.7,8.2,32.2,9.4,49.2h32.1 c-1.4-21.2-5.4-41.7-11.7-61.1L462,190.8z M92.4,397c-12-13.9-22.3-29.4-30.4-46.1l-29.8,11.9c9.9,20.7,22.6,39.8,37.6,56.9 L92.4,397z M272,40.6c18.8,1.4,36.9,5.2,54.1,11.1l12.6-29.5C317.7,14.7,295.3,10,272,8.5V40.6z M190.8,50 c15.7-5,32.2-8.2,49.2-9.4V8.5c-21.2,1.4-41.7,5.4-61.1,11.7L190.8,50z M442.3,92.3L419.6,115c12,13.9,22.3,29.4,30.5,46.1 l29.8-11.9C470,128.5,457.3,109.4,442.3,92.3z M397,92.4l22.7-22.7c-15.6-13.7-32.8-25.5-51.5-34.9l-12.6,29.5 C370.4,72.1,384.4,81.5,397,92.4z',
})
var OPACITY_ANIMATE = _objectSpread({}, ANIMATION_BASE, {
  attributeName: 'opacity',
})
_objectSpread({}, FILL, { cx: '256', cy: '364', r: '28' }),
  _objectSpread({}, ANIMATION_BASE, {
    attributeName: 'r',
    values: '28;14;28;28;14;28;',
  }),
  _objectSpread({}, OPACITY_ANIMATE, { values: '1;0;1;1;0;1;' })
_objectSpread({}, FILL, {
  opacity: '1',
  d:
    'M263.7,312h-16c-6.6,0-12-5.4-12-12c0-71,77.4-63.9,77.4-107.8c0-20-17.8-40.2-57.4-40.2c-29.1,0-44.3,9.6-59.2,28.7 c-3.9,5-11.1,6-16.2,2.4l-13.1-9.2c-5.6-3.9-6.9-11.8-2.6-17.2c21.2-27.2,46.4-44.7,91.2-44.7c52.3,0,97.4,29.8,97.4,80.2 c0,67.6-77.4,63.5-77.4,107.8C275.7,306.6,270.3,312,263.7,312z',
}),
  _objectSpread({}, OPACITY_ANIMATE, { values: '1;0;0;0;0;1;' })
_objectSpread({}, FILL, {
  opacity: '0',
  d:
    'M232.5,134.5l7,168c0.3,6.4,5.6,11.5,12,11.5h9c6.4,0,11.7-5.1,12-11.5l7-168c0.3-6.8-5.2-12.5-12-12.5h-23 C237.7,122,232.2,127.7,232.5,134.5z',
}),
  _objectSpread({}, OPACITY_ANIMATE, { values: '0;0;1;1;0;0;' })
namespace.styles
function asFoundIcon(o) {
  var a = o[0],
    s = o[1],
    $ = o.slice(4),
    j = _slicedToArray($, 1),
    _e = j[0],
    et = null
  return (
    Array.isArray(_e)
      ? (et = {
          tag: 'g',
          attributes: {
            class: ''
              .concat(config.familyPrefix, '-')
              .concat(DUOTONE_CLASSES.GROUP),
          },
          children: [
            {
              tag: 'path',
              attributes: {
                class: ''
                  .concat(config.familyPrefix, '-')
                  .concat(DUOTONE_CLASSES.SECONDARY),
                fill: 'currentColor',
                d: _e[0],
              },
            },
            {
              tag: 'path',
              attributes: {
                class: ''
                  .concat(config.familyPrefix, '-')
                  .concat(DUOTONE_CLASSES.PRIMARY),
                fill: 'currentColor',
                d: _e[1],
              },
            },
          ],
        })
      : (et = { tag: 'path', attributes: { fill: 'currentColor', d: _e } }),
    { found: !0, width: a, height: s, icon: et }
  )
}
namespace.styles
var baseStyles = `svg:not(:root).svg-inline--fa {
  overflow: visible;
}

.svg-inline--fa {
  display: inline-block;
  font-size: inherit;
  height: 1em;
  overflow: visible;
  vertical-align: -0.125em;
}
.svg-inline--fa.fa-lg {
  vertical-align: -0.225em;
}
.svg-inline--fa.fa-w-1 {
  width: 0.0625em;
}
.svg-inline--fa.fa-w-2 {
  width: 0.125em;
}
.svg-inline--fa.fa-w-3 {
  width: 0.1875em;
}
.svg-inline--fa.fa-w-4 {
  width: 0.25em;
}
.svg-inline--fa.fa-w-5 {
  width: 0.3125em;
}
.svg-inline--fa.fa-w-6 {
  width: 0.375em;
}
.svg-inline--fa.fa-w-7 {
  width: 0.4375em;
}
.svg-inline--fa.fa-w-8 {
  width: 0.5em;
}
.svg-inline--fa.fa-w-9 {
  width: 0.5625em;
}
.svg-inline--fa.fa-w-10 {
  width: 0.625em;
}
.svg-inline--fa.fa-w-11 {
  width: 0.6875em;
}
.svg-inline--fa.fa-w-12 {
  width: 0.75em;
}
.svg-inline--fa.fa-w-13 {
  width: 0.8125em;
}
.svg-inline--fa.fa-w-14 {
  width: 0.875em;
}
.svg-inline--fa.fa-w-15 {
  width: 0.9375em;
}
.svg-inline--fa.fa-w-16 {
  width: 1em;
}
.svg-inline--fa.fa-w-17 {
  width: 1.0625em;
}
.svg-inline--fa.fa-w-18 {
  width: 1.125em;
}
.svg-inline--fa.fa-w-19 {
  width: 1.1875em;
}
.svg-inline--fa.fa-w-20 {
  width: 1.25em;
}
.svg-inline--fa.fa-pull-left {
  margin-right: 0.3em;
  width: auto;
}
.svg-inline--fa.fa-pull-right {
  margin-left: 0.3em;
  width: auto;
}
.svg-inline--fa.fa-border {
  height: 1.5em;
}
.svg-inline--fa.fa-li {
  width: 2em;
}
.svg-inline--fa.fa-fw {
  width: 1.25em;
}

.fa-layers svg.svg-inline--fa {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.fa-layers {
  display: inline-block;
  height: 1em;
  position: relative;
  text-align: center;
  vertical-align: -0.125em;
  width: 1em;
}
.fa-layers svg.svg-inline--fa {
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter, .fa-layers-text {
  display: inline-block;
  position: absolute;
  text-align: center;
}

.fa-layers-text {
  left: 50%;
  top: 50%;
  -webkit-transform: translate(-50%, -50%);
          transform: translate(-50%, -50%);
  -webkit-transform-origin: center center;
          transform-origin: center center;
}

.fa-layers-counter {
  background-color: #ff253a;
  border-radius: 1em;
  -webkit-box-sizing: border-box;
          box-sizing: border-box;
  color: #fff;
  height: 1.5em;
  line-height: 1;
  max-width: 5em;
  min-width: 1.5em;
  overflow: hidden;
  padding: 0.25em;
  right: 0;
  text-overflow: ellipsis;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-bottom-right {
  bottom: 0;
  right: 0;
  top: auto;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: bottom right;
          transform-origin: bottom right;
}

.fa-layers-bottom-left {
  bottom: 0;
  left: 0;
  right: auto;
  top: auto;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: bottom left;
          transform-origin: bottom left;
}

.fa-layers-top-right {
  right: 0;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top right;
          transform-origin: top right;
}

.fa-layers-top-left {
  left: 0;
  right: auto;
  top: 0;
  -webkit-transform: scale(0.25);
          transform: scale(0.25);
  -webkit-transform-origin: top left;
          transform-origin: top left;
}

.fa-lg {
  font-size: 1.3333333333em;
  line-height: 0.75em;
  vertical-align: -0.0667em;
}

.fa-xs {
  font-size: 0.75em;
}

.fa-sm {
  font-size: 0.875em;
}

.fa-1x {
  font-size: 1em;
}

.fa-2x {
  font-size: 2em;
}

.fa-3x {
  font-size: 3em;
}

.fa-4x {
  font-size: 4em;
}

.fa-5x {
  font-size: 5em;
}

.fa-6x {
  font-size: 6em;
}

.fa-7x {
  font-size: 7em;
}

.fa-8x {
  font-size: 8em;
}

.fa-9x {
  font-size: 9em;
}

.fa-10x {
  font-size: 10em;
}

.fa-fw {
  text-align: center;
  width: 1.25em;
}

.fa-ul {
  list-style-type: none;
  margin-left: 2.5em;
  padding-left: 0;
}
.fa-ul > li {
  position: relative;
}

.fa-li {
  left: -2em;
  position: absolute;
  text-align: center;
  width: 2em;
  line-height: inherit;
}

.fa-border {
  border: solid 0.08em #eee;
  border-radius: 0.1em;
  padding: 0.2em 0.25em 0.15em;
}

.fa-pull-left {
  float: left;
}

.fa-pull-right {
  float: right;
}

.fa.fa-pull-left,
.fas.fa-pull-left,
.far.fa-pull-left,
.fal.fa-pull-left,
.fab.fa-pull-left {
  margin-right: 0.3em;
}
.fa.fa-pull-right,
.fas.fa-pull-right,
.far.fa-pull-right,
.fal.fa-pull-right,
.fab.fa-pull-right {
  margin-left: 0.3em;
}

.fa-spin {
  -webkit-animation: fa-spin 2s infinite linear;
          animation: fa-spin 2s infinite linear;
}

.fa-pulse {
  -webkit-animation: fa-spin 1s infinite steps(8);
          animation: fa-spin 1s infinite steps(8);
}

@-webkit-keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}

@keyframes fa-spin {
  0% {
    -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
  }
  100% {
    -webkit-transform: rotate(360deg);
            transform: rotate(360deg);
  }
}
.fa-rotate-90 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";
  -webkit-transform: rotate(90deg);
          transform: rotate(90deg);
}

.fa-rotate-180 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";
  -webkit-transform: rotate(180deg);
          transform: rotate(180deg);
}

.fa-rotate-270 {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";
  -webkit-transform: rotate(270deg);
          transform: rotate(270deg);
}

.fa-flip-horizontal {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";
  -webkit-transform: scale(-1, 1);
          transform: scale(-1, 1);
}

.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  -webkit-transform: scale(1, -1);
          transform: scale(1, -1);
}

.fa-flip-both, .fa-flip-horizontal.fa-flip-vertical {
  -ms-filter: "progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";
  -webkit-transform: scale(-1, -1);
          transform: scale(-1, -1);
}

:root .fa-rotate-90,
:root .fa-rotate-180,
:root .fa-rotate-270,
:root .fa-flip-horizontal,
:root .fa-flip-vertical,
:root .fa-flip-both {
  -webkit-filter: none;
          filter: none;
}

.fa-stack {
  display: inline-block;
  height: 2em;
  position: relative;
  width: 2.5em;
}

.fa-stack-1x,
.fa-stack-2x {
  bottom: 0;
  left: 0;
  margin: auto;
  position: absolute;
  right: 0;
  top: 0;
}

.svg-inline--fa.fa-stack-1x {
  height: 1em;
  width: 1.25em;
}
.svg-inline--fa.fa-stack-2x {
  height: 2em;
  width: 2.5em;
}

.fa-inverse {
  color: #fff;
}

.sr-only {
  border: 0;
  clip: rect(0, 0, 0, 0);
  height: 1px;
  margin: -1px;
  overflow: hidden;
  padding: 0;
  position: absolute;
  width: 1px;
}

.sr-only-focusable:active, .sr-only-focusable:focus {
  clip: auto;
  height: auto;
  margin: 0;
  overflow: visible;
  position: static;
  width: auto;
}

.svg-inline--fa .fa-primary {
  fill: var(--fa-primary-color, currentColor);
  opacity: 1;
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa .fa-secondary {
  fill: var(--fa-secondary-color, currentColor);
  opacity: 0.4;
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-primary {
  opacity: 0.4;
  opacity: var(--fa-secondary-opacity, 0.4);
}

.svg-inline--fa.fa-swap-opacity .fa-secondary {
  opacity: 1;
  opacity: var(--fa-primary-opacity, 1);
}

.svg-inline--fa mask .fa-primary,
.svg-inline--fa mask .fa-secondary {
  fill: black;
}

.fad.fa-inverse {
  color: #fff;
}`
function css$1() {
  var o = DEFAULT_FAMILY_PREFIX,
    a = DEFAULT_REPLACEMENT_CLASS,
    s = config.familyPrefix,
    $ = config.replacementClass,
    j = baseStyles
  if (s !== o || $ !== a) {
    var _e = new RegExp('\\.'.concat(o, '\\-'), 'g'),
      et = new RegExp('\\--'.concat(o, '\\-'), 'g'),
      tt = new RegExp('\\.'.concat(a), 'g')
    j = j
      .replace(_e, '.'.concat(s, '-'))
      .replace(et, '--'.concat(s, '-'))
      .replace(tt, '.'.concat($))
  }
  return j
}
var Library = (function() {
  function o() {
    _classCallCheck(this, o), (this.definitions = {})
  }
  return (
    _createClass(o, [
      {
        key: 'add',
        value: function() {
          for (
            var s = this, $ = arguments.length, j = new Array($), _e = 0;
            _e < $;
            _e++
          )
            j[_e] = arguments[_e]
          var et = j.reduce(this._pullDefinitions, {})
          Object.keys(et).forEach(function(tt) {
            ;(s.definitions[tt] = _objectSpread(
              {},
              s.definitions[tt] || {},
              et[tt]
            )),
              defineIcons(tt, et[tt]),
              build()
          })
        },
      },
      {
        key: 'reset',
        value: function() {
          this.definitions = {}
        },
      },
      {
        key: '_pullDefinitions',
        value: function(s, $) {
          var j = $.prefix && $.iconName && $.icon ? { 0: $ } : $
          return (
            Object.keys(j).map(function(_e) {
              var et = j[_e],
                tt = et.prefix,
                rt = et.iconName,
                nt = et.icon
              s[tt] || (s[tt] = {}), (s[tt][rt] = nt)
            }),
            s
          )
        },
      },
    ]),
    o
  )
})()
function ensureCss() {
  config.autoAddCss &&
    !_cssInserted &&
    (insertCss(css$1()), (_cssInserted = !0))
}
function apiObject(o, a) {
  return (
    Object.defineProperty(o, 'abstract', { get: a }),
    Object.defineProperty(o, 'html', {
      get: function() {
        return o.abstract.map(function($) {
          return toHtml($)
        })
      },
    }),
    Object.defineProperty(o, 'node', {
      get: function() {
        if (IS_DOM) {
          var $ = DOCUMENT.createElement('div')
          return ($.innerHTML = o.html), $.children
        }
      },
    }),
    o
  )
}
function findIconDefinition(o) {
  var a = o.prefix,
    s = a === void 0 ? 'fa' : a,
    $ = o.iconName
  if ($)
    return (
      iconFromMapping(library.definitions, s, $) ||
      iconFromMapping(namespace.styles, s, $)
    )
}
function resolveIcons(o) {
  return function(a) {
    var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      $ = (a || {}).icon ? a : findIconDefinition(a || {}),
      j = s.mask
    return (
      j && (j = (j || {}).icon ? j : findIconDefinition(j || {})),
      o($, _objectSpread({}, s, { mask: j }))
    )
  }
}
var library = new Library(),
  _cssInserted = !1,
  parse = {
    transform: function o(a) {
      return parseTransformString(a)
    },
  },
  icon = resolveIcons(function(o) {
    var a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
      s = a.transform,
      $ = s === void 0 ? meaninglessTransform : s,
      j = a.symbol,
      _e = j === void 0 ? !1 : j,
      et = a.mask,
      tt = et === void 0 ? null : et,
      rt = a.maskId,
      nt = rt === void 0 ? null : rt,
      it = a.title,
      ot = it === void 0 ? null : it,
      at = a.titleId,
      st = at === void 0 ? null : at,
      ut = a.classes,
      ct = ut === void 0 ? [] : ut,
      dt = a.attributes,
      ft = dt === void 0 ? {} : dt,
      mt = a.styles,
      vt = mt === void 0 ? {} : mt
    if (o) {
      var yt = o.prefix,
        pt = o.iconName,
        ht = o.icon
      return apiObject(_objectSpread({ type: 'icon' }, o), function() {
        return (
          ensureCss(),
          config.autoA11y &&
            (ot
              ? (ft['aria-labelledby'] = ''
                  .concat(config.replacementClass, '-title-')
                  .concat(st || nextUniqueId()))
              : ((ft['aria-hidden'] = 'true'), (ft.focusable = 'false'))),
          makeInlineSvgAbstract({
            icons: {
              main: asFoundIcon(ht),
              mask: tt
                ? asFoundIcon(tt.icon)
                : { found: !1, width: null, height: null, icon: {} },
            },
            prefix: yt,
            iconName: pt,
            transform: _objectSpread({}, meaninglessTransform, $),
            symbol: _e,
            title: ot,
            maskId: nt,
            titleId: st,
            extra: { attributes: ft, styles: vt, classes: ct },
          })
        )
      })
    }
  })
function ownKeys(o, a) {
  var s = Object.keys(o)
  if (Object.getOwnPropertySymbols) {
    var $ = Object.getOwnPropertySymbols(o)
    a &&
      ($ = $.filter(function(j) {
        return Object.getOwnPropertyDescriptor(o, j).enumerable
      })),
      s.push.apply(s, $)
  }
  return s
}
function _objectSpread2(o) {
  for (var a = 1; a < arguments.length; a++) {
    var s = arguments[a] != null ? arguments[a] : {}
    a % 2
      ? ownKeys(Object(s), !0).forEach(function($) {
          _defineProperty$1(o, $, s[$])
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(o, Object.getOwnPropertyDescriptors(s))
      : ownKeys(Object(s)).forEach(function($) {
          Object.defineProperty(o, $, Object.getOwnPropertyDescriptor(s, $))
        })
  }
  return o
}
function _typeof$1(o) {
  '@babel/helpers - typeof'
  return (
    (_typeof$1 =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function(a) {
            return typeof a
          }
        : function(a) {
            return a &&
              typeof Symbol == 'function' &&
              a.constructor === Symbol &&
              a !== Symbol.prototype
              ? 'symbol'
              : typeof a
          }),
    _typeof$1(o)
  )
}
function _defineProperty$1(o, a, s) {
  return (
    a in o
      ? Object.defineProperty(o, a, {
          value: s,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (o[a] = s),
    o
  )
}
function _objectWithoutPropertiesLoose(o, a) {
  if (o == null) return {}
  var s = {},
    $ = Object.keys(o),
    j,
    _e
  for (_e = 0; _e < $.length; _e++)
    (j = $[_e]), !(a.indexOf(j) >= 0) && (s[j] = o[j])
  return s
}
function _objectWithoutProperties(o, a) {
  if (o == null) return {}
  var s = _objectWithoutPropertiesLoose(o, a),
    $,
    j
  if (Object.getOwnPropertySymbols) {
    var _e = Object.getOwnPropertySymbols(o)
    for (j = 0; j < _e.length; j++)
      ($ = _e[j]),
        !(a.indexOf($) >= 0) &&
          Object.prototype.propertyIsEnumerable.call(o, $) &&
          (s[$] = o[$])
  }
  return s
}
function _toConsumableArray(o) {
  return (
    _arrayWithoutHoles(o) ||
    _iterableToArray(o) ||
    _unsupportedIterableToArray(o) ||
    _nonIterableSpread()
  )
}
function _arrayWithoutHoles(o) {
  if (Array.isArray(o)) return _arrayLikeToArray(o)
}
function _iterableToArray(o) {
  if (
    (typeof Symbol < 'u' && o[Symbol.iterator] != null) ||
    o['@@iterator'] != null
  )
    return Array.from(o)
}
function _unsupportedIterableToArray(o, a) {
  if (o) {
    if (typeof o == 'string') return _arrayLikeToArray(o, a)
    var s = Object.prototype.toString.call(o).slice(8, -1)
    if (
      (s === 'Object' && o.constructor && (s = o.constructor.name),
      s === 'Map' || s === 'Set')
    )
      return Array.from(o)
    if (s === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(s))
      return _arrayLikeToArray(o, a)
  }
}
function _arrayLikeToArray(o, a) {
  ;(a == null || a > o.length) && (a = o.length)
  for (var s = 0, $ = new Array(a); s < a; s++) $[s] = o[s]
  return $
}
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}
function classList(o) {
  var a,
    s = o.beat,
    $ = o.fade,
    j = o.beatFade,
    _e = o.bounce,
    et = o.shake,
    tt = o.flash,
    rt = o.spin,
    nt = o.spinPulse,
    it = o.spinReverse,
    ot = o.pulse,
    at = o.fixedWidth,
    st = o.inverse,
    ut = o.border,
    ct = o.listItem,
    dt = o.flip,
    ft = o.size,
    mt = o.rotation,
    vt = o.pull,
    yt =
      ((a = {
        'fa-beat': s,
        'fa-fade': $,
        'fa-beat-fade': j,
        'fa-bounce': _e,
        'fa-shake': et,
        'fa-flash': tt,
        'fa-spin': rt,
        'fa-spin-reverse': it,
        'fa-spin-pulse': nt,
        'fa-pulse': ot,
        'fa-fw': at,
        'fa-inverse': st,
        'fa-border': ut,
        'fa-li': ct,
        'fa-flip': dt === !0,
        'fa-flip-horizontal': dt === 'horizontal' || dt === 'both',
        'fa-flip-vertical': dt === 'vertical' || dt === 'both',
      }),
      _defineProperty$1(a, 'fa-'.concat(ft), typeof ft < 'u' && ft !== null),
      _defineProperty$1(
        a,
        'fa-rotate-'.concat(mt),
        typeof mt < 'u' && mt !== null && mt !== 0
      ),
      _defineProperty$1(
        a,
        'fa-pull-'.concat(vt),
        typeof vt < 'u' && vt !== null
      ),
      _defineProperty$1(a, 'fa-swap-opacity', o.swapOpacity),
      a)
  return Object.keys(yt)
    .map(function(pt) {
      return yt[pt] ? pt : null
    })
    .filter(function(pt) {
      return pt
    })
}
function _isNumerical(o) {
  return (o = o - 0), o === o
}
function camelize(o) {
  return _isNumerical(o)
    ? o
    : ((o = o.replace(/[\-_\s]+(.)?/g, function(a, s) {
        return s ? s.toUpperCase() : ''
      })),
      o.substr(0, 1).toLowerCase() + o.substr(1))
}
var _excluded$1$1 = ['style']
function capitalize(o) {
  return o.charAt(0).toUpperCase() + o.slice(1)
}
function styleToObject(o) {
  return o
    .split(';')
    .map(function(a) {
      return a.trim()
    })
    .filter(function(a) {
      return a
    })
    .reduce(function(a, s) {
      var $ = s.indexOf(':'),
        j = camelize(s.slice(0, $)),
        _e = s.slice($ + 1).trim()
      return j.startsWith('webkit') ? (a[capitalize(j)] = _e) : (a[j] = _e), a
    }, {})
}
function convert(o, a) {
  var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}
  if (typeof a == 'string') return a
  var $ = (a.children || []).map(function(rt) {
      return convert(o, rt)
    }),
    j = Object.keys(a.attributes || {}).reduce(
      function(rt, nt) {
        var it = a.attributes[nt]
        switch (nt) {
          case 'class':
            ;(rt.attrs.className = it), delete a.attributes.class
            break
          case 'style':
            rt.attrs.style = styleToObject(it)
            break
          default:
            nt.indexOf('aria-') === 0 || nt.indexOf('data-') === 0
              ? (rt.attrs[nt.toLowerCase()] = it)
              : (rt.attrs[camelize(nt)] = it)
        }
        return rt
      },
      { attrs: {} }
    ),
    _e = s.style,
    et = _e === void 0 ? {} : _e,
    tt = _objectWithoutProperties(s, _excluded$1$1)
  return (
    (j.attrs.style = _objectSpread2(_objectSpread2({}, j.attrs.style), et)),
    o.apply(
      void 0,
      [a.tag, _objectSpread2(_objectSpread2({}, j.attrs), tt)].concat(
        _toConsumableArray($)
      )
    )
  )
}
var PRODUCTION = !1
try {
  PRODUCTION = !0
} catch (o) {}
function log() {
  if (!PRODUCTION && console && typeof console.error == 'function') {
    var o
    ;(o = console).error.apply(o, arguments)
  }
}
function normalizeIconArgs(o) {
  if (o && _typeof$1(o) === 'object' && o.prefix && o.iconName && o.icon)
    return o
  if (parse.icon) return parse.icon(o)
  if (o === null) return null
  if (o && _typeof$1(o) === 'object' && o.prefix && o.iconName) return o
  if (Array.isArray(o) && o.length === 2)
    return { prefix: o[0], iconName: o[1] }
  if (typeof o == 'string') return { prefix: 'fas', iconName: o }
}
function objectWithKey(o, a) {
  return (Array.isArray(a) && a.length > 0) || (!Array.isArray(a) && a)
    ? _defineProperty$1({}, o, a)
    : {}
}
var _excluded$2 = ['forwardedRef']
function FontAwesomeIcon(o) {
  var a = o.forwardedRef,
    s = _objectWithoutProperties(o, _excluded$2),
    $ = s.icon,
    j = s.mask,
    _e = s.symbol,
    et = s.className,
    tt = s.title,
    rt = s.titleId,
    nt = s.maskId,
    it = normalizeIconArgs($),
    ot = objectWithKey(
      'classes',
      [].concat(
        _toConsumableArray(classList(s)),
        _toConsumableArray(et.split(' '))
      )
    ),
    at = objectWithKey(
      'transform',
      typeof s.transform == 'string'
        ? parse.transform(s.transform)
        : s.transform
    ),
    st = objectWithKey('mask', normalizeIconArgs(j)),
    ut = icon(
      it,
      _objectSpread2(
        _objectSpread2(_objectSpread2(_objectSpread2({}, ot), at), st),
        {},
        { symbol: _e, title: tt, titleId: rt, maskId: nt }
      )
    )
  if (!ut) return log('Could not find icon', it), null
  var ct = ut.abstract,
    dt = { ref: a }
  return (
    Object.keys(s).forEach(function(ft) {
      FontAwesomeIcon.defaultProps.hasOwnProperty(ft) || (dt[ft] = s[ft])
    }),
    convertCurry(ct[0], dt)
  )
}
FontAwesomeIcon.displayName = 'FontAwesomeIcon'
FontAwesomeIcon.propTypes = {
  beat: PropTypes$1.bool,
  border: PropTypes$1.bool,
  beatFade: PropTypes$1.bool,
  bounce: PropTypes$1.bool,
  className: PropTypes$1.string,
  fade: PropTypes$1.bool,
  flash: PropTypes$1.bool,
  mask: PropTypes$1.oneOfType([
    PropTypes$1.object,
    PropTypes$1.array,
    PropTypes$1.string,
  ]),
  maskId: PropTypes$1.string,
  fixedWidth: PropTypes$1.bool,
  inverse: PropTypes$1.bool,
  flip: PropTypes$1.oneOf([!0, !1, 'horizontal', 'vertical', 'both']),
  icon: PropTypes$1.oneOfType([
    PropTypes$1.object,
    PropTypes$1.array,
    PropTypes$1.string,
  ]),
  listItem: PropTypes$1.bool,
  pull: PropTypes$1.oneOf(['right', 'left']),
  pulse: PropTypes$1.bool,
  rotation: PropTypes$1.oneOf([0, 90, 180, 270]),
  shake: PropTypes$1.bool,
  size: PropTypes$1.oneOf([
    '2xs',
    'xs',
    'sm',
    'lg',
    'xl',
    '2xl',
    '1x',
    '2x',
    '3x',
    '4x',
    '5x',
    '6x',
    '7x',
    '8x',
    '9x',
    '10x',
  ]),
  spin: PropTypes$1.bool,
  spinPulse: PropTypes$1.bool,
  spinReverse: PropTypes$1.bool,
  symbol: PropTypes$1.oneOfType([PropTypes$1.bool, PropTypes$1.string]),
  title: PropTypes$1.string,
  titleId: PropTypes$1.string,
  transform: PropTypes$1.oneOfType([PropTypes$1.string, PropTypes$1.object]),
  swapOpacity: PropTypes$1.bool,
}
FontAwesomeIcon.defaultProps = {
  border: !1,
  className: '',
  mask: null,
  maskId: null,
  fixedWidth: !1,
  inverse: !1,
  flip: !1,
  icon: null,
  listItem: !1,
  pull: null,
  pulse: !1,
  rotation: null,
  size: null,
  spin: !1,
  spinPulse: !1,
  spinReverse: !1,
  beat: !1,
  fade: !1,
  beatFade: !1,
  bounce: !1,
  shake: !1,
  symbol: !1,
  title: '',
  titleId: null,
  transform: null,
  swapOpacity: !1,
}
var convertCurry = convert.bind(null, React$5.createElement)
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */ var faHeart$1 = {
    prefix: 'fas',
    iconName: 'heart',
    icon: [
      512,
      512,
      [],
      'f004',
      'M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z',
    ],
  },
  faMars = {
    prefix: 'fas',
    iconName: 'mars',
    icon: [
      384,
      512,
      [],
      'f222',
      'M372 64h-79c-10.7 0-16 12.9-8.5 20.5l16.9 16.9-80.7 80.7c-22.2-14-48.5-22.1-76.7-22.1C64.5 160 0 224.5 0 304s64.5 144 144 144 144-64.5 144-144c0-28.2-8.1-54.5-22.1-76.7l80.7-80.7 16.9 16.9c7.6 7.6 20.5 2.2 20.5-8.5V76c0-6.6-5.4-12-12-12zM144 384c-44.1 0-80-35.9-80-80s35.9-80 80-80 80 35.9 80 80-35.9 80-80 80z',
    ],
  },
  faVenus = {
    prefix: 'fas',
    iconName: 'venus',
    icon: [
      288,
      512,
      [],
      'f221',
      'M288 176c0-79.5-64.5-144-144-144S0 96.5 0 176c0 68.5 47.9 125.9 112 140.4V368H76c-6.6 0-12 5.4-12 12v40c0 6.6 5.4 12 12 12h36v36c0 6.6 5.4 12 12 12h40c6.6 0 12-5.4 12-12v-36h36c6.6 0 12-5.4 12-12v-40c0-6.6-5.4-12-12-12h-36v-51.6c64.1-14.5 112-71.9 112-140.4zm-224 0c0-44.1 35.9-80 80-80s80 35.9 80 80-35.9 80-80 80-80-35.9-80-80z',
    ],
  }
/*!
 * Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com
 * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
 */ var faHeart = {
  prefix: 'far',
  iconName: 'heart',
  icon: [
    512,
    512,
    [],
    'f004',
    'M458.4 64.3C400.6 15.7 311.3 23 256 79.3 200.7 23 111.4 15.6 53.6 64.3-21.6 127.6-10.6 230.8 43 285.5l175.4 178.7c10 10.2 23.4 15.9 37.6 15.9 14.3 0 27.6-5.6 37.6-15.8L469 285.6c53.5-54.7 64.7-157.9-10.6-221.3zm-23.6 187.5L259.4 430.5c-2.4 2.4-4.4 2.4-6.8 0L77.2 251.8c-36.5-37.2-43.9-107.6 7.3-150.7 38.9-32.7 98.9-27.8 136.5 10.5l35 35.7 35-35.7c37.8-38.5 97.8-43.2 136.5-10.6 51.1 43.1 43.5 113.9 7.3 150.8z',
  ],
}
const Bloodline = ({ colorsInBloodline: o }) =>
  jsxRuntimeExports.jsx('ul', {
    className: 'Bloodline',
    children: Object.keys(o)
      .sort()
      .map(a =>
        jsxRuntimeExports.jsx(Tooltip, {
          key: a,
          arrow: !0,
          placement: 'top',
          title: COW_COLOR_NAMES[a],
          children: jsxRuntimeExports.jsx('li', { className: a.toLowerCase() }),
        })
      ),
  })
Bloodline.propTypes = { colorsInBloodline: propTypesExports.object.isRequired }
const Bloodline$1 = reactExports.memo(Bloodline),
  isHeartFull = (o, a) => o + 0.5 < a,
  getCowMapById = memoize(o => o.reduce((a, s) => ((a[s.id] = s), a), {})),
  Subheader = ({
    canCowBeTradedFor: o,
    cow: a,
    cowBreedingPen: s,
    cowIdOfferedForTrade: $,
    cowInventory: j,
    cowValue: _e,
    handleCowAutomaticHugChange: et,
    handleCowBreedChange: tt,
    huggingMachinesRemain: rt,
    id: nt,
    isCowPurchased: it,
  }) => {
    const ot = a.happiness * 10,
      at = isCowInBreedingPen(a, s),
      st = s.cowId1 === null || s.cowId2 === null,
      ut = $ === a.id,
      ct = s.cowId1 ?? s.cowId2,
      dt = getCowMapById(j)[ct ?? ''],
      ft = a.gender !== (dt == null ? void 0 : dt.gender),
      mt = st && ft && !ut,
      vt = !mt && !at,
      yt = it && nt !== a.originalOwnerId && nt === a.ownerId
    return jsxRuntimeExports.jsxs('div', {
      className: 'Subheader',
      children: [
        jsxRuntimeExports.jsx(Bloodline$1, {
          colorsInBloodline: a.colorsInBloodline,
        }),
        (it || $) &&
          jsxRuntimeExports.jsxs('p', {
            children: [
              a.daysOld,
              ' ',
              a.daysOld === 1 ? 'day' : 'days',
              ' old',
            ],
          }),
        jsxRuntimeExports.jsxs('p', {
          children: ['Color: ', COW_COLOR_NAMES[a.color]],
        }),
        jsxRuntimeExports.jsxs('p', {
          children: [
            a.originalOwnerId === '' ? 'Price' : 'Value',
            ':',
            ' ',
            moneyString(_e),
          ],
        }),
        jsxRuntimeExports.jsxs('p', {
          children: ['Weight: ', getCowWeight(a), ' lbs.'],
        }),
        (it || o) &&
          jsxRuntimeExports.jsxs('p', {
            children: ['Times traded: ', integerString(a.timesTraded)],
          }),
        yt &&
          jsxRuntimeExports.jsxs('p', {
            children: [
              'Original owner: ',
              jsxRuntimeExports.jsx('strong', {
                children: getPlayerName(a.originalOwnerId),
              }),
            ],
          }),
        it &&
          jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              jsxRuntimeExports.jsx('ol', {
                className: 'hearts',
                children: nullArray(10).map((pt, ht) =>
                  jsxRuntimeExports.jsx(
                    'li',
                    {
                      children: jsxRuntimeExports.jsx(FontAwesomeIcon, {
                        icon: isHeartFull(ht, ot) ? faHeart$1 : faHeart,
                        className: classNames('heart', {
                          'is-full': isHeartFull(ht, ot),
                        }),
                      }),
                    },
                    `${a.id}_${ht}`
                  )
                ),
              }),
              jsxRuntimeExports.jsx(Tooltip, {
                arrow: !0,
                placement: 'top',
                title: jsxRuntimeExports.jsxs(Typography, {
                  children: [
                    'Check this box to put ',
                    a.name,
                    ' into a ',
                    huggingMachine$1.name,
                    ' ',
                    'and automatically hug them at the start of every day. Requires a Hugging Machine in your inventory.',
                  ],
                }),
                children: jsxRuntimeExports.jsx(FormControlLabel, {
                  control: jsxRuntimeExports.jsx(Checkbox, {
                    color: 'primary',
                    checked: a.isUsingHuggingMachine,
                    onChange: pt => et && et(pt, a),
                  }),
                  disabled: !a.isUsingHuggingMachine && !rt,
                  label: 'Hug automatically',
                }),
              }),
              jsxRuntimeExports.jsx(Tooltip, {
                arrow: !0,
                placement: 'top',
                disableFocusListener: vt,
                disableHoverListener: vt,
                disableTouchListener: vt,
                title: jsxRuntimeExports.jsx(Typography, {
                  children: at
                    ? `Uncheck this box to return ${a.name} to the regular pen.`
                    : `Check this box to move ${
                        a.name
                      } to the breeding pen to mate with a ${
                        a.gender === genders.MALE ? 'female' : 'male'
                      } cow.`,
                }),
                children: jsxRuntimeExports.jsx(FormControlLabel, {
                  control: jsxRuntimeExports.jsx(Checkbox, {
                    color: 'primary',
                    checked: at,
                    onChange: pt => tt && tt(pt, a),
                  }),
                  disabled: at ? !1 : !mt,
                  label: 'Breed',
                }),
              }),
            ],
          }),
      ],
    })
  }
Subheader.propTypes = {
  canCowBeTradedFor: propTypesExports.bool.isRequired,
  cow: propTypesExports.object.isRequired,
  cowBreedingPen: propTypesExports.object.isRequired,
  cowIdOfferedForTrade: propTypesExports.string.isRequired,
  cowInventory: propTypesExports.array.isRequired,
  handleCowAutomaticHugChange: propTypesExports.func,
  handleCowBreedChange: propTypesExports.func,
  huggingMachinesRemain: propTypesExports.bool.isRequired,
  id: propTypesExports.string.isRequired,
  isCowPurchased: propTypesExports.bool,
}
const genderIcons = { [genders.FEMALE]: faVenus, [genders.MALE]: faMars },
  CowCard = ({
    allowCustomPeerCowNames: o,
    cow: a,
    cowBreedingPen: s,
    cowIdOfferedForTrade: $,
    cowInventory: j,
    debounced: _e,
    handleCowAutomaticHugChange: et,
    handleCowBreedChange: tt,
    handleCowHugClick: rt,
    handleCowOfferClick: nt,
    handleCowPurchaseClick: it,
    handleCowWithdrawClick: ot,
    handleCowSellClick: at,
    handleCowTradeClick: st,
    id: ut,
    inventory: ct,
    isCowOfferedForTradeByPeer: dt,
    isSelected: ft,
    isOnline: mt,
    money: vt,
    purchasedCowPen: yt,
    huggingMachinesRemain: pt = areHuggingMachinesInInventory(ct),
  }) => {
    var Tt
    const ht = getCowDisplayName(a, ut, o),
      [At, wt] = reactExports.useState(ht),
      [Ct, Dt] = reactExports.useState(pixel),
      jt = reactExports.useRef(null),
      Et = reactExports.useRef(null),
      St = !!j.find(({ id: kt }) => kt === a.id) && !dt,
      Bt = getCowValue(a, a.originalOwnerId !== ''),
      Mt = mt && !isCowInBreedingPen(a, s),
      Ut = !!(dt && $.length > 0),
      Wt = useIsMounted()
    return (
      reactExports.useEffect(() => {
        ;(async () => {
          const kt = await getCowImage(a)
          Wt() !== !1 && Dt(kt)
        })(),
          wt(getCowDisplayName(a, ut, o))
      }, [a, ut, o, Wt]),
      reactExports.useEffect(() => {
        if (ft) {
          const { current: kt } = Et,
            { current: Ot } = jt
          if (!kt || !Ot) return
          kt.scrollIntoView &&
            !isInViewport(Ot) &&
            kt.scrollIntoView({ behavior: 'smooth' })
        }
      }, [ft]),
      jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [
          jsxRuntimeExports.jsx('a', {
            className: 'CowCard-scroll-anchor',
            href: `#cow-${a.id}`,
            ref: Et,
            children: '',
          }),
          jsxRuntimeExports.jsxs(Card, {
            className: classNames('CowCard', {
              'is-selected': ft,
              'is-purchased': St,
            }),
            raised: ft,
            ref: jt,
            children: [
              ft &&
                jsxRuntimeExports.jsxs('span', {
                  className: 'visually_hidden',
                  children: [At, ' is currently selected'],
                }),
              jsxRuntimeExports.jsx(CardHeader, {
                avatar: jsxRuntimeExports.jsx('img', { src: Ct, alt: 'Cow' }),
                title: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                  children: [
                    St
                      ? jsxRuntimeExports.jsx(TextField, {
                          variant: 'standard',
                          disabled: ut !== a.originalOwnerId,
                          onChange: kt => {
                            wt(kt.target.value),
                              _e == null ||
                                _e.handleCowNameInputChange({ ...kt }, a)
                          },
                          placeholder: 'Name',
                          value: At,
                        })
                      : At,
                    ' ',
                    jsxRuntimeExports.jsx(FontAwesomeIcon, {
                      icon: genderIcons[a.gender],
                    }),
                  ],
                }),
                subheader: jsxRuntimeExports.jsx(Subheader, {
                  canCowBeTradedFor: Ut,
                  cow: a,
                  cowBreedingPen: s,
                  cowIdOfferedForTrade: $,
                  cowInventory: j,
                  cowValue: Bt,
                  handleCowBreedChange: tt,
                  handleCowAutomaticHugChange: et,
                  huggingMachinesRemain: pt,
                  id: ut,
                  isCowPurchased: St,
                }),
              }),
              jsxRuntimeExports.jsxs(CardActions, {
                children: [
                  !St &&
                    !dt &&
                    jsxRuntimeExports.jsx(Button, {
                      className: 'purchase',
                      color: 'primary',
                      disabled:
                        Bt > vt ||
                        j.length >=
                          (((Tt = PURCHASEABLE_COW_PENS.get(yt)) == null
                            ? void 0
                            : Tt.cows) ?? 0),
                      onClick: () => it(a),
                      variant: 'contained',
                      children: 'Buy',
                    }),
                  Ut &&
                    jsxRuntimeExports.jsx(Tooltip, {
                      arrow: !0,
                      placement: 'top',
                      title:
                        'The game will be saved when the trade is completed.',
                      children: jsxRuntimeExports.jsx(Button, {
                        className: 'purchase',
                        color: 'primary',
                        onClick: () => st(a),
                        variant: 'contained',
                        children: 'Trade',
                      }),
                    }),
                  St &&
                    jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                      children: [
                        jsxRuntimeExports.jsx(Button, {
                          className: 'hug',
                          color: 'primary',
                          onClick: () => rt && rt(a),
                          variant: 'contained',
                          children: 'Hug',
                        }),
                        Mt &&
                          ($ === a.id
                            ? jsxRuntimeExports.jsx(Tooltip, {
                                arrow: !0,
                                placement: 'top',
                                title: WITHDRAW_COW_FROM_TRADE`${ht}`,
                                children: jsxRuntimeExports.jsx(Button, {
                                  className: 'offer',
                                  color: 'primary',
                                  onClick: () => {
                                    ot && ot(a)
                                  },
                                  variant: 'contained',
                                  children: 'Withdraw',
                                }),
                              })
                            : jsxRuntimeExports.jsx(Tooltip, {
                                arrow: !0,
                                placement: 'top',
                                title: jsxRuntimeExports.jsx(Typography, {
                                  children: OFFER_COW_FOR_TRADE`${ht}`,
                                }),
                                children: jsxRuntimeExports.jsx(Button, {
                                  className: 'offer',
                                  color: 'primary',
                                  onClick: () => {
                                    nt && nt(a)
                                  },
                                  variant: 'contained',
                                  children: 'Offer',
                                }),
                              })),
                        jsxRuntimeExports.jsx(Button, {
                          className: 'sell',
                          color: 'error',
                          onClick: () => at(a),
                          variant: 'contained',
                          children: 'Sell',
                        }),
                      ],
                    }),
                ],
              }),
            ],
          }),
        ],
      })
    )
  }
CowCard.propTypes = {
  allowCustomPeerCowNames: propTypesExports.bool.isRequired,
  cow: propTypesExports.object.isRequired,
  cowBreedingPen: propTypesExports.object.isRequired,
  cowIdOfferedForTrade: propTypesExports.string.isRequired,
  cowInventory: propTypesExports.array.isRequired,
  debounced: propTypesExports.object,
  handleCowAutomaticHugChange: propTypesExports.func,
  handleCowBreedChange: propTypesExports.func,
  handleCowHugClick: propTypesExports.func,
  handleCowNameInputChange: propTypesExports.func,
  handleCowOfferClick: propTypesExports.func,
  handleCowPurchaseClick: propTypesExports.func,
  handleCowWithdrawClick: propTypesExports.func,
  handleCowSellClick: propTypesExports.func,
  handleCowTradeClick: propTypesExports.func,
  id: propTypesExports.string.isRequired,
  inventory: propTypesExports.array.isRequired,
  isCowOfferedForTradeByPeer: propTypesExports.bool,
  isOnline: propTypesExports.bool.isRequired,
  isSelected: propTypesExports.bool,
  money: propTypesExports.number.isRequired,
  purchasedCowPen: propTypesExports.number.isRequired,
}
function Consumer$e(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(CowCard, { ...a, ...s, ...o }),
  })
}
const TabPanel$3 = o => {
  const { children: a, value: s, index: $, ...j } = o
  return jsxRuntimeExports.jsx('section', {
    role: 'tabpanel',
    hidden: s !== $,
    id: `cow-context-tabpanel-${$}`,
    'aria-labelledby': `cow-context-tab-${$}`,
    ...j,
    children: s === $ ? a : null,
  })
}
TabPanel$3.propTypes = {
  children: propTypesExports.node,
  index: propTypesExports.number.isRequired,
  value: propTypesExports.number.isRequired,
}
const a11yProps$3 = o => ({
    id: `cow-context-tab-${o}`,
    'aria-controls': `cow-context-tabpanel-${o}`,
  }),
  { AGE, COLOR, GENDER, HAPPINESS, VALUE, WEIGHT } = enumify([
    'AGE',
    'COLOR',
    'GENDER',
    'HAPPINESS',
    'VALUE',
    'WEIGHT',
  ]),
  sortCows = (o, a, s) => {
    let $ = _e => _e
    a === VALUE
      ? ($ = getCowSellValue)
      : a === WEIGHT
      ? ($ = getCowWeight)
      : a === AGE
      ? ($ = ({ daysOld: _e }) => _e)
      : a === COLOR
      ? ($ = ({ color: _e }) => _e)
      : a === GENDER
      ? ($ = ({ gender: _e }) => _e)
      : a === HAPPINESS && ($ = ({ happiness: _e }) => _e)
    const j = sortBy(o, $)
    return s ? j.reverse() : j
  }
/*!
 * @param {farmhand.cowBreedingPen} cowBreedingPen
 * @returns {number}
 */ const numberOfCowsBreeding = ({ cowId1: o, cowId2: a }) =>
    o ? (a ? 2 : 1) : 0,
  CowPenContextMenu = ({
    cowBreedingPen: o,
    cowForSale: a,
    cowInventory: s,
    handleCowAutomaticHugChange: $,
    handleCowBreedChange: j,
    handleCowHugClick: _e,
    handleCowNameInputChange: et,
    handleCowOfferClick: tt,
    handleCowSelect: rt,
    handleCowSellClick: nt,
    handleCowWithdrawClick: it,
    purchasedCowPen: ot,
    selectedCowId: at,
  }) => {
    var At
    const [st, ut] = reactExports.useState(AGE),
      [ct, dt] = reactExports.useState(!1),
      [ft, mt] = reactExports.useState(0),
      [vt, yt] = reactExports.useState('')
    reactExports.useEffect(() => {
      yt('')
    }, [ft])
    const pt = vt
        ? s.filter(wt => wt.name.toLowerCase().includes(vt.toLowerCase()))
        : s,
      ht = vt
        ? inventory$1.filter(wt =>
            wt.name.toLowerCase().includes(vt.toLowerCase())
          )
        : inventory$1
    return jsxRuntimeExports.jsxs('div', {
      className: 'CowPenContextMenu',
      children: [
        jsxRuntimeExports.jsx('h3', { children: 'For sale' }),
        jsxRuntimeExports.jsx(Consumer$e, {
          cow: a,
          isSelected: !1,
          isCowOfferedForTradeByPeer: !1,
        }),
        jsxRuntimeExports.jsxs(Tabs, {
          value: ft,
          onChange: (wt, Ct) => mt(Ct),
          'aria-label': 'Cow tabs',
          sx: { mt: '1rem' },
          children: [
            jsxRuntimeExports.jsx(Tab, { label: 'Cows', ...a11yProps$3(0) }),
            jsxRuntimeExports.jsx(Tab, {
              label: 'Breeding Pen',
              ...a11yProps$3(1),
            }),
            jsxRuntimeExports.jsx(Tab, {
              label: 'Supplies',
              ...a11yProps$3(2),
            }),
          ],
        }),
        jsxRuntimeExports.jsxs(TabPanel$3, {
          value: ft,
          index: 0,
          children: [
            jsxRuntimeExports.jsxs('h3', {
              children: [
                'Capacity: ',
                s.length,
                ' /',
                ' ',
                (At = PURCHASEABLE_COW_PENS.get(ot)) == null ? void 0 : At.cows,
              ],
            }),
            s.length > 0 &&
              jsxRuntimeExports.jsx(SearchBar, {
                placeholder: 'Search cows by name...',
                onSearch: yt,
              }),
            pt.length > 0 &&
              jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [
                  pt.length > 1 &&
                    jsxRuntimeExports.jsxs('div', {
                      className: 'sort-wrapper',
                      children: [
                        jsxRuntimeExports.jsx(Fab, {
                          'aria-label': 'Toggle sorting order',
                          onClick: () => dt(!ct),
                          color: 'primary',
                          children: ct
                            ? jsxRuntimeExports.jsx(default_1$2, {})
                            : jsxRuntimeExports.jsx(default_1$3, {}),
                        }),
                        jsxRuntimeExports.jsxs(Select, {
                          variant: 'standard',
                          className: 'sort-select',
                          displayEmpty: !0,
                          value: st,
                          onChange: ({ target: { value: wt } }) =>
                            ut(String(wt)),
                          children: [
                            jsxRuntimeExports.jsx(MenuItem, {
                              value: VALUE,
                              children: 'Sort by Value',
                            }),
                            jsxRuntimeExports.jsx(MenuItem, {
                              value: AGE,
                              children: 'Sort by Age',
                            }),
                            jsxRuntimeExports.jsx(MenuItem, {
                              value: HAPPINESS,
                              children: 'Sort by Happiness',
                            }),
                            jsxRuntimeExports.jsx(MenuItem, {
                              value: WEIGHT,
                              children: 'Sort by Weight',
                            }),
                            jsxRuntimeExports.jsx(MenuItem, {
                              value: GENDER,
                              children: 'Sort by Gender',
                            }),
                            jsxRuntimeExports.jsx(MenuItem, {
                              value: COLOR,
                              children: 'Sort by Color',
                            }),
                          ],
                        }),
                      ],
                    }),
                  jsxRuntimeExports.jsx('ul', {
                    className: 'card-list purchased-cows',
                    children: sortCows(pt, st, ct).map(wt =>
                      isCowInBreedingPen(wt, o)
                        ? null
                        : jsxRuntimeExports.jsx('li', {
                            key: wt.id,
                            onFocus: () => rt(wt),
                            onClick: () => rt(wt),
                            children: jsxRuntimeExports.jsx(Consumer$e, {
                              cow: wt,
                              handleCowAutomaticHugChange: $,
                              handleCowBreedChange: j,
                              handleCowHugClick: _e,
                              handleCowNameInputChange: et,
                              handleCowOfferClick: tt,
                              handleCowSellClick: nt,
                              handleCowWithdrawClick: it,
                              isCowPurchased: !0,
                              isCowOfferedForTradeByPeer: !1,
                              isSelected: wt.id === at,
                            }),
                          })
                    ),
                  }),
                ],
              }),
          ],
        }),
        jsxRuntimeExports.jsx(TabPanel$3, {
          value: ft,
          index: 1,
          children: (() => {
            const wt = nullArray(numberOfCowsBreeding(o))
              .map((Ct, Dt) => {
                const jt = o[`cowId${Dt + 1}`],
                  Et = findCowById(s, jt)
                return !Et || !Et.name.toLowerCase().includes(vt.toLowerCase())
                  ? null
                  : Et
              })
              .filter(Boolean)
            return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [
                jsxRuntimeExports.jsxs('h3', {
                  children: ['Capacity: ', numberOfCowsBreeding(o), ' / 2'],
                }),
                s.length > 0 &&
                  jsxRuntimeExports.jsx(SearchBar, {
                    placeholder: 'Search cows by name...',
                    onSearch: yt,
                  }),
                jsxRuntimeExports.jsx('ul', {
                  className: 'card-list purchased-cows breeding-cows',
                  children: wt.map(Ct => {
                    if (!Ct) throw new TypeError('cow is undefined')
                    return jsxRuntimeExports.jsx(
                      'li',
                      {
                        children: jsxRuntimeExports.jsx(Consumer$e, {
                          cow: Ct,
                          handleCowAutomaticHugChange: $,
                          handleCowBreedChange: j,
                          handleCowHugClick: _e,
                          handleCowNameInputChange: et,
                          handleCowOfferClick: tt,
                          handleCowSellClick: nt,
                          handleCowWithdrawClick: it,
                          isCowPurchased: !0,
                          isCowOfferedForTradeByPeer: !1,
                          isSelected: Ct.id === at,
                        }),
                      },
                      Ct.id
                    )
                  }),
                }),
              ],
            })
          })(),
        }),
        jsxRuntimeExports.jsxs(TabPanel$3, {
          value: ft,
          index: 2,
          children: [
            inventory$1.length > 0 &&
              jsxRuntimeExports.jsx(SearchBar, {
                placeholder: 'Search supplies...',
                onSearch: yt,
              }),
            jsxRuntimeExports.jsx('ul', {
              className: 'card-list',
              children: ht.map(wt =>
                jsxRuntimeExports.jsx(
                  'li',
                  {
                    children: jsxRuntimeExports.jsx(Consumer$g, {
                      item: wt,
                      isPurchaseView: !0,
                      showQuantity: !0,
                    }),
                  },
                  wt.id
                )
              ),
            }),
          ],
        }),
      ],
    })
  }
CowPenContextMenu.propTypes = {
  cowForSale: propTypesExports.object.isRequired,
  cowInventory: propTypesExports.array.isRequired,
  handleCowAutomaticHugChange: propTypesExports.func.isRequired,
  handleCowBreedChange: propTypesExports.func.isRequired,
  handleCowHugClick: propTypesExports.func.isRequired,
  handleCowNameInputChange: propTypesExports.func.isRequired,
  handleCowOfferClick: propTypesExports.func.isRequired,
  handleCowSelect: propTypesExports.func.isRequired,
  handleCowSellClick: propTypesExports.func.isRequired,
  handleCowWithdrawClick: propTypesExports.func.isRequired,
  purchasedCowPen: propTypesExports.number.isRequired,
  selectedCowId: propTypesExports.string.isRequired,
}
function Consumer$d() {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: o, handlers: a }) =>
      jsxRuntimeExports.jsx(CowPenContextMenu, { ...o, ...a }),
  })
}
const PlayerInventory = reactExports.memo(
    ({ playerInventory: o }) =>
      jsxRuntimeExports.jsx(Consumer$f, { items: o, isSellView: !0 }),
    (o, a) => o.playerInventory === a.playerInventory
  ),
  ContextPane = ({ playerInventory: o, stageFocus: a }) =>
    jsxRuntimeExports.jsx('div', {
      className: 'ContextPane',
      children:
        a === stageFocusType.COW_PEN
          ? jsxRuntimeExports.jsx(Consumer$d, {})
          : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [
                jsxRuntimeExports.jsx('h2', { children: 'Inventory' }),
                jsxRuntimeExports.jsx(PlayerInventory, { playerInventory: o }),
              ],
            }),
    })
ContextPane.propTypes = {
  playerInventory: propTypesExports.array.isRequired,
  stageFocus: propTypesExports.string.isRequired,
}
function Consumer$c() {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: o, handlers: a }) =>
      jsxRuntimeExports.jsx(ContextPane, { ...o, ...a }),
  })
}
function areArraysEqual(o, a, s = ($, j) => $ === j) {
  return o.length === a.length && o.every(($, j) => s($, a[j]))
}
const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2
function asc(o, a) {
  return o - a
}
function findClosest(o, a) {
  var s
  const { index: $ } =
    (s = o.reduce((j, _e, et) => {
      const tt = Math.abs(a - _e)
      return j === null || tt < j.distance || tt === j.distance
        ? { distance: tt, index: et }
        : j
    }, null)) != null
      ? s
      : {}
  return $
}
function trackFinger(o, a) {
  if (a.current !== void 0 && o.changedTouches) {
    const s = o
    for (let $ = 0; $ < s.changedTouches.length; $ += 1) {
      const j = s.changedTouches[$]
      if (j.identifier === a.current) return { x: j.clientX, y: j.clientY }
    }
    return !1
  }
  return { x: o.clientX, y: o.clientY }
}
function valueToPercent(o, a, s) {
  return ((o - a) * 100) / (s - a)
}
function percentToValue(o, a, s) {
  return (s - a) * o + a
}
function getDecimalPrecision(o) {
  if (Math.abs(o) < 1) {
    const s = o.toExponential().split('e-'),
      $ = s[0].split('.')[1]
    return ($ ? $.length : 0) + parseInt(s[1], 10)
  }
  const a = o.toString().split('.')[1]
  return a ? a.length : 0
}
function roundValueToStep(o, a, s) {
  const $ = Math.round((o - s) / a) * a + s
  return Number($.toFixed(getDecimalPrecision(a)))
}
function setValueIndex({ values: o, newValue: a, index: s }) {
  const $ = o.slice()
  return ($[s] = a), $.sort(asc)
}
function focusThumb({ sliderRef: o, activeIndex: a, setActive: s }) {
  var $, j
  const _e = ownerDocument(o.current)
  if (
    !(($ = o.current) != null && $.contains(_e.activeElement)) ||
    Number(
      _e == null || (j = _e.activeElement) == null
        ? void 0
        : j.getAttribute('data-index')
    ) !== a
  ) {
    var et
    ;(et = o.current) == null ||
      et.querySelector(`[type="range"][data-index="${a}"]`).focus()
  }
  s && s(a)
}
function areValuesEqual(o, a) {
  return typeof o == 'number' && typeof a == 'number'
    ? o === a
    : typeof o == 'object' && typeof a == 'object'
    ? areArraysEqual(o, a)
    : !1
}
const axisProps = {
    horizontal: {
      offset: o => ({ left: `${o}%` }),
      leap: o => ({ width: `${o}%` }),
    },
    'horizontal-reverse': {
      offset: o => ({ right: `${o}%` }),
      leap: o => ({ width: `${o}%` }),
    },
    vertical: {
      offset: o => ({ bottom: `${o}%` }),
      leap: o => ({ height: `${o}%` }),
    },
  },
  Identity$1 = o => o
let cachedSupportsTouchActionNone
function doesSupportTouchActionNone() {
  return (
    cachedSupportsTouchActionNone === void 0 &&
      (typeof CSS < 'u' && typeof CSS.supports == 'function'
        ? (cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none'))
        : (cachedSupportsTouchActionNone = !0)),
    cachedSupportsTouchActionNone
  )
}
function useSlider(o) {
  const {
      'aria-labelledby': a,
      defaultValue: s,
      disabled: $ = !1,
      disableSwap: j = !1,
      isRtl: _e = !1,
      marks: et = !1,
      max: tt = 100,
      min: rt = 0,
      name: nt,
      onChange: it,
      onChangeCommitted: ot,
      orientation: at = 'horizontal',
      rootRef: st,
      scale: ut = Identity$1,
      step: ct = 1,
      shiftStep: dt = 10,
      tabIndex: ft,
      value: mt,
    } = o,
    vt = reactExports.useRef(),
    [yt, pt] = reactExports.useState(-1),
    [ht, At] = reactExports.useState(-1),
    [wt, Ct] = reactExports.useState(!1),
    Dt = reactExports.useRef(0),
    [jt, Et] = useControlled({
      controlled: mt,
      default: s ?? rt,
      name: 'Slider',
    }),
    St =
      it &&
      ((bt, Rt, qt) => {
        const rr = bt.nativeEvent || bt,
          ar = new rr.constructor(rr.type, rr)
        Object.defineProperty(ar, 'target', {
          writable: !0,
          value: { value: Rt, name: nt },
        }),
          it(ar, Rt, qt)
      }),
    Bt = Array.isArray(jt)
  let Mt = Bt ? jt.slice().sort(asc) : [jt]
  Mt = Mt.map(bt => (bt == null ? rt : clamp$2(bt, rt, tt)))
  const Ut =
      et === !0 && ct !== null
        ? [...Array(Math.floor((tt - rt) / ct) + 1)].map((bt, Rt) => ({
            value: rt + ct * Rt,
          }))
        : et || [],
    Wt = Ut.map(bt => bt.value),
    {
      isFocusVisibleRef: Tt,
      onBlur: kt,
      onFocus: Ot,
      ref: Nt,
    } = useIsFocusVisible(),
    [$t, Pt] = reactExports.useState(-1),
    Ft = reactExports.useRef(),
    Vt = useForkRef(Nt, Ft),
    Xt = useForkRef(st, Vt),
    Yt = bt => Rt => {
      var qt
      const rr = Number(Rt.currentTarget.getAttribute('data-index'))
      Ot(Rt),
        Tt.current === !0 && Pt(rr),
        At(rr),
        bt == null || (qt = bt.onFocus) == null || qt.call(bt, Rt)
    },
    xt = bt => Rt => {
      var qt
      kt(Rt),
        Tt.current === !1 && Pt(-1),
        At(-1),
        bt == null || (qt = bt.onBlur) == null || qt.call(bt, Rt)
    },
    It = (bt, Rt) => {
      const qt = Number(bt.currentTarget.getAttribute('data-index')),
        rr = Mt[qt],
        ar = Wt.indexOf(rr)
      let ir = Rt
      if (Ut && ct == null) {
        const Tr = Wt[Wt.length - 1]
        ir > Tr
          ? (ir = Tr)
          : ir < Wt[0]
          ? (ir = Wt[0])
          : (ir = ir < rr ? Wt[ar - 1] : Wt[ar + 1])
      }
      if (((ir = clamp$2(ir, rt, tt)), Bt)) {
        j && (ir = clamp$2(ir, Mt[qt - 1] || -1 / 0, Mt[qt + 1] || 1 / 0))
        const Tr = ir
        ir = setValueIndex({ values: Mt, newValue: ir, index: qt })
        let vr = qt
        j || (vr = ir.indexOf(Tr)),
          focusThumb({ sliderRef: Ft, activeIndex: vr })
      }
      Et(ir),
        Pt(qt),
        St && !areValuesEqual(ir, jt) && St(bt, ir, qt),
        ot && ot(bt, ir)
    },
    Kt = bt => Rt => {
      var qt
      if (ct !== null) {
        const rr = Number(Rt.currentTarget.getAttribute('data-index')),
          ar = Mt[rr]
        let ir = null
        ;((Rt.key === 'ArrowLeft' || Rt.key === 'ArrowDown') && Rt.shiftKey) ||
        Rt.key === 'PageDown'
          ? (ir = Math.max(ar - dt, rt))
          : (((Rt.key === 'ArrowRight' || Rt.key === 'ArrowUp') &&
              Rt.shiftKey) ||
              Rt.key === 'PageUp') &&
            (ir = Math.min(ar + dt, tt)),
          ir !== null && (It(Rt, ir), Rt.preventDefault())
      }
      bt == null || (qt = bt.onKeyDown) == null || qt.call(bt, Rt)
    }
  useEnhancedEffect$1(() => {
    if ($ && Ft.current.contains(document.activeElement)) {
      var bt
      ;(bt = document.activeElement) == null || bt.blur()
    }
  }, [$]),
    $ && yt !== -1 && pt(-1),
    $ && $t !== -1 && Pt(-1)
  const Qt = bt => Rt => {
      var qt
      ;(qt = bt.onChange) == null || qt.call(bt, Rt),
        It(Rt, Rt.target.valueAsNumber)
    },
    Ht = reactExports.useRef()
  let Lt = at
  _e && at === 'horizontal' && (Lt += '-reverse')
  const tr = ({ finger: bt, move: Rt = !1 }) => {
      const { current: qt } = Ft,
        {
          width: rr,
          height: ar,
          bottom: ir,
          left: Tr,
        } = qt.getBoundingClientRect()
      let vr
      Lt.indexOf('vertical') === 0
        ? (vr = (ir - bt.y) / ar)
        : (vr = (bt.x - Tr) / rr),
        Lt.indexOf('-reverse') !== -1 && (vr = 1 - vr)
      let Ar
      if (((Ar = percentToValue(vr, rt, tt)), ct))
        Ar = roundValueToStep(Ar, ct, rt)
      else {
        const Or = findClosest(Wt, Ar)
        Ar = Wt[Or]
      }
      Ar = clamp$2(Ar, rt, tt)
      let Nr = 0
      if (Bt) {
        Rt ? (Nr = Ht.current) : (Nr = findClosest(Mt, Ar)),
          j && (Ar = clamp$2(Ar, Mt[Nr - 1] || -1 / 0, Mt[Nr + 1] || 1 / 0))
        const Or = Ar
        ;(Ar = setValueIndex({ values: Mt, newValue: Ar, index: Nr })),
          (j && Rt) || ((Nr = Ar.indexOf(Or)), (Ht.current = Nr))
      }
      return { newValue: Ar, activeIndex: Nr }
    },
    lr = useEventCallback$1(bt => {
      const Rt = trackFinger(bt, vt)
      if (!Rt) return
      if (((Dt.current += 1), bt.type === 'mousemove' && bt.buttons === 0)) {
        yr(bt)
        return
      }
      const { newValue: qt, activeIndex: rr } = tr({ finger: Rt, move: !0 })
      focusThumb({ sliderRef: Ft, activeIndex: rr, setActive: pt }),
        Et(qt),
        !wt && Dt.current > INTENTIONAL_DRAG_COUNT_THRESHOLD && Ct(!0),
        St && !areValuesEqual(qt, jt) && St(bt, qt, rr)
    }),
    yr = useEventCallback$1(bt => {
      const Rt = trackFinger(bt, vt)
      if ((Ct(!1), !Rt)) return
      const { newValue: qt } = tr({ finger: Rt, move: !0 })
      pt(-1),
        bt.type === 'touchend' && At(-1),
        ot && ot(bt, qt),
        (vt.current = void 0),
        Er()
    }),
    mr = useEventCallback$1(bt => {
      if ($) return
      doesSupportTouchActionNone() || bt.preventDefault()
      const Rt = bt.changedTouches[0]
      Rt != null && (vt.current = Rt.identifier)
      const qt = trackFinger(bt, vt)
      if (qt !== !1) {
        const { newValue: ar, activeIndex: ir } = tr({ finger: qt })
        focusThumb({ sliderRef: Ft, activeIndex: ir, setActive: pt }),
          Et(ar),
          St && !areValuesEqual(ar, jt) && St(bt, ar, ir)
      }
      Dt.current = 0
      const rr = ownerDocument(Ft.current)
      rr.addEventListener('touchmove', lr, { passive: !0 }),
        rr.addEventListener('touchend', yr, { passive: !0 })
    }),
    Er = reactExports.useCallback(() => {
      const bt = ownerDocument(Ft.current)
      bt.removeEventListener('mousemove', lr),
        bt.removeEventListener('mouseup', yr),
        bt.removeEventListener('touchmove', lr),
        bt.removeEventListener('touchend', yr)
    }, [yr, lr])
  reactExports.useEffect(() => {
    const { current: bt } = Ft
    return (
      bt.addEventListener('touchstart', mr, {
        passive: doesSupportTouchActionNone(),
      }),
      () => {
        bt.removeEventListener('touchstart', mr), Er()
      }
    )
  }, [Er, mr]),
    reactExports.useEffect(() => {
      $ && Er()
    }, [$, Er])
  const ur = bt => Rt => {
      var qt
      if (
        ((qt = bt.onMouseDown) == null || qt.call(bt, Rt),
        $ || Rt.defaultPrevented || Rt.button !== 0)
      )
        return
      Rt.preventDefault()
      const rr = trackFinger(Rt, vt)
      if (rr !== !1) {
        const { newValue: ir, activeIndex: Tr } = tr({ finger: rr })
        focusThumb({ sliderRef: Ft, activeIndex: Tr, setActive: pt }),
          Et(ir),
          St && !areValuesEqual(ir, jt) && St(Rt, ir, Tr)
      }
      Dt.current = 0
      const ar = ownerDocument(Ft.current)
      ar.addEventListener('mousemove', lr, { passive: !0 }),
        ar.addEventListener('mouseup', yr)
    },
    _r = valueToPercent(Bt ? Mt[0] : rt, rt, tt),
    Rr = valueToPercent(Mt[Mt.length - 1], rt, tt) - _r,
    nr = (bt = {}) => {
      const Rt = extractEventHandlers(bt),
        qt = { onMouseDown: ur(Rt || {}) },
        rr = _extends$5({}, Rt, qt)
      return _extends$5({}, bt, { ref: Xt }, rr)
    },
    fr = bt => Rt => {
      var qt
      ;(qt = bt.onMouseOver) == null || qt.call(bt, Rt)
      const rr = Number(Rt.currentTarget.getAttribute('data-index'))
      At(rr)
    },
    gr = bt => Rt => {
      var qt
      ;(qt = bt.onMouseLeave) == null || qt.call(bt, Rt), At(-1)
    }
  return {
    active: yt,
    axis: Lt,
    axisProps,
    dragging: wt,
    focusedThumbIndex: $t,
    getHiddenInputProps: (bt = {}) => {
      var Rt
      const qt = extractEventHandlers(bt),
        rr = {
          onChange: Qt(qt || {}),
          onFocus: Yt(qt || {}),
          onBlur: xt(qt || {}),
          onKeyDown: Kt(qt || {}),
        },
        ar = _extends$5({}, qt, rr)
      return _extends$5(
        {
          tabIndex: ft,
          'aria-labelledby': a,
          'aria-orientation': at,
          'aria-valuemax': ut(tt),
          'aria-valuemin': ut(rt),
          name: nt,
          type: 'range',
          min: o.min,
          max: o.max,
          step:
            o.step === null && o.marks
              ? 'any'
              : (Rt = o.step) != null
              ? Rt
              : void 0,
          disabled: $,
        },
        bt,
        ar,
        {
          style: _extends$5({}, visuallyHidden, {
            direction: _e ? 'rtl' : 'ltr',
            width: '100%',
            height: '100%',
          }),
        }
      )
    },
    getRootProps: nr,
    getThumbProps: (bt = {}) => {
      const Rt = extractEventHandlers(bt),
        qt = { onMouseOver: fr(Rt || {}), onMouseLeave: gr(Rt || {}) }
      return _extends$5({}, bt, Rt, qt)
    },
    marks: Ut,
    open: ht,
    range: Bt,
    rootRef: Xt,
    trackLeap: Rr,
    trackOffset: _r,
    values: Mt,
    getThumbStyle: bt => ({
      pointerEvents: yt !== -1 && yt !== bt ? 'none' : void 0,
    }),
  }
}
const shouldSpreadAdditionalProps = o => !o || !isHostComponent(o)
function getSliderUtilityClass(o) {
  return generateUtilityClass('MuiSlider', o)
}
const sliderClasses = generateUtilityClasses('MuiSlider', [
    'root',
    'active',
    'colorPrimary',
    'colorSecondary',
    'colorError',
    'colorInfo',
    'colorSuccess',
    'colorWarning',
    'disabled',
    'dragging',
    'focusVisible',
    'mark',
    'markActive',
    'marked',
    'markLabel',
    'markLabelActive',
    'rail',
    'sizeSmall',
    'thumb',
    'thumbColorPrimary',
    'thumbColorSecondary',
    'thumbColorError',
    'thumbColorSuccess',
    'thumbColorInfo',
    'thumbColorWarning',
    'track',
    'trackInverted',
    'trackFalse',
    'thumbSizeSmall',
    'valueLabel',
    'valueLabelOpen',
    'valueLabelCircle',
    'valueLabelLabel',
    'vertical',
  ]),
  useValueLabelClasses = o => {
    const { open: a } = o
    return {
      offset: clsx$1(a && sliderClasses.valueLabelOpen),
      circle: sliderClasses.valueLabelCircle,
      label: sliderClasses.valueLabelLabel,
    }
  }
function SliderValueLabel$1(o) {
  const { children: a, className: s, value: $ } = o,
    j = useValueLabelClasses(o)
  return a
    ? reactExports.cloneElement(
        a,
        { className: clsx$1(a.props.className) },
        jsxRuntimeExports.jsxs(reactExports.Fragment, {
          children: [
            a.props.children,
            jsxRuntimeExports.jsx('span', {
              className: clsx$1(j.offset, s),
              'aria-hidden': !0,
              children: jsxRuntimeExports.jsx('span', {
                className: j.circle,
                children: jsxRuntimeExports.jsx('span', {
                  className: j.label,
                  children: $,
                }),
              }),
            }),
          ],
        })
      )
    : null
}
const _excluded$1 = [
  'aria-label',
  'aria-valuetext',
  'aria-labelledby',
  'component',
  'components',
  'componentsProps',
  'color',
  'classes',
  'className',
  'disableSwap',
  'disabled',
  'getAriaLabel',
  'getAriaValueText',
  'marks',
  'max',
  'min',
  'name',
  'onChange',
  'onChangeCommitted',
  'orientation',
  'shiftStep',
  'size',
  'step',
  'scale',
  'slotProps',
  'slots',
  'tabIndex',
  'track',
  'value',
  'valueLabelDisplay',
  'valueLabelFormat',
]
function Identity(o) {
  return o
}
const SliderRoot = styled('span', {
    name: 'MuiSlider',
    slot: 'Root',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.root,
        a[`color${capitalize$2(s.color)}`],
        s.size !== 'medium' && a[`size${capitalize$2(s.size)}`],
        s.marked && a.marked,
        s.orientation === 'vertical' && a.vertical,
        s.track === 'inverted' && a.trackInverted,
        s.track === !1 && a.trackFalse,
      ]
    },
  })(({ theme: o }) => {
    var a
    return {
      borderRadius: 12,
      boxSizing: 'content-box',
      display: 'inline-block',
      position: 'relative',
      cursor: 'pointer',
      touchAction: 'none',
      WebkitTapHighlightColor: 'transparent',
      '@media print': { colorAdjust: 'exact' },
      [`&.${sliderClasses.disabled}`]: {
        pointerEvents: 'none',
        cursor: 'default',
        color: (o.vars || o).palette.grey[400],
      },
      [`&.${sliderClasses.dragging}`]: {
        [`& .${sliderClasses.thumb}, & .${sliderClasses.track}`]: {
          transition: 'none',
        },
      },
      variants: [
        ...Object.keys(((a = o.vars) != null ? a : o).palette)
          .filter(s => {
            var $
            return (($ = o.vars) != null ? $ : o).palette[s].main
          })
          .map(s => ({
            props: { color: s },
            style: { color: (o.vars || o).palette[s].main },
          })),
        {
          props: { orientation: 'horizontal' },
          style: {
            height: 4,
            width: '100%',
            padding: '13px 0',
            '@media (pointer: coarse)': { padding: '20px 0' },
          },
        },
        {
          props: { orientation: 'horizontal', size: 'small' },
          style: { height: 2 },
        },
        {
          props: { orientation: 'horizontal', marked: !0 },
          style: { marginBottom: 20 },
        },
        {
          props: { orientation: 'vertical' },
          style: {
            height: '100%',
            width: 4,
            padding: '0 13px',
            '@media (pointer: coarse)': { padding: '0 20px' },
          },
        },
        {
          props: { orientation: 'vertical', size: 'small' },
          style: { width: 2 },
        },
        {
          props: { orientation: 'vertical', marked: !0 },
          style: { marginRight: 44 },
        },
      ],
    }
  }),
  SliderRail = styled('span', {
    name: 'MuiSlider',
    slot: 'Rail',
    overridesResolver: (o, a) => a.rail,
  })({
    display: 'block',
    position: 'absolute',
    borderRadius: 'inherit',
    backgroundColor: 'currentColor',
    opacity: 0.38,
    variants: [
      {
        props: { orientation: 'horizontal' },
        style: {
          width: '100%',
          height: 'inherit',
          top: '50%',
          transform: 'translateY(-50%)',
        },
      },
      {
        props: { orientation: 'vertical' },
        style: {
          height: '100%',
          width: 'inherit',
          left: '50%',
          transform: 'translateX(-50%)',
        },
      },
      { props: { track: 'inverted' }, style: { opacity: 1 } },
    ],
  }),
  SliderTrack = styled('span', {
    name: 'MuiSlider',
    slot: 'Track',
    overridesResolver: (o, a) => a.track,
  })(({ theme: o }) => {
    var a
    return {
      display: 'block',
      position: 'absolute',
      borderRadius: 'inherit',
      border: '1px solid currentColor',
      backgroundColor: 'currentColor',
      transition: o.transitions.create(['left', 'width', 'bottom', 'height'], {
        duration: o.transitions.duration.shortest,
      }),
      variants: [
        { props: { size: 'small' }, style: { border: 'none' } },
        {
          props: { orientation: 'horizontal' },
          style: {
            height: 'inherit',
            top: '50%',
            transform: 'translateY(-50%)',
          },
        },
        {
          props: { orientation: 'vertical' },
          style: {
            width: 'inherit',
            left: '50%',
            transform: 'translateX(-50%)',
          },
        },
        { props: { track: !1 }, style: { display: 'none' } },
        ...Object.keys(((a = o.vars) != null ? a : o).palette)
          .filter(s => {
            var $
            return (($ = o.vars) != null ? $ : o).palette[s].main
          })
          .map(s => ({
            props: { color: s, track: 'inverted' },
            style: _extends$5(
              {},
              o.vars
                ? {
                    backgroundColor: o.vars.palette.Slider[`${s}Track`],
                    borderColor: o.vars.palette.Slider[`${s}Track`],
                  }
                : _extends$5(
                    {
                      backgroundColor: lighten_1(o.palette[s].main, 0.62),
                      borderColor: lighten_1(o.palette[s].main, 0.62),
                    },
                    o.applyStyles('dark', {
                      backgroundColor: darken_1(o.palette[s].main, 0.5),
                    }),
                    o.applyStyles('dark', {
                      borderColor: darken_1(o.palette[s].main, 0.5),
                    })
                  )
            ),
          })),
      ],
    }
  }),
  SliderThumb = styled('span', {
    name: 'MuiSlider',
    slot: 'Thumb',
    overridesResolver: (o, a) => {
      const { ownerState: s } = o
      return [
        a.thumb,
        a[`thumbColor${capitalize$2(s.color)}`],
        s.size !== 'medium' && a[`thumbSize${capitalize$2(s.size)}`],
      ]
    },
  })(({ theme: o }) => {
    var a
    return {
      position: 'absolute',
      width: 20,
      height: 20,
      boxSizing: 'border-box',
      borderRadius: '50%',
      outline: 0,
      backgroundColor: 'currentColor',
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      transition: o.transitions.create(['box-shadow', 'left', 'bottom'], {
        duration: o.transitions.duration.shortest,
      }),
      '&::before': {
        position: 'absolute',
        content: '""',
        borderRadius: 'inherit',
        width: '100%',
        height: '100%',
        boxShadow: (o.vars || o).shadows[2],
      },
      '&::after': {
        position: 'absolute',
        content: '""',
        borderRadius: '50%',
        width: 42,
        height: 42,
        top: '50%',
        left: '50%',
        transform: 'translate(-50%, -50%)',
      },
      [`&.${sliderClasses.disabled}`]: { '&:hover': { boxShadow: 'none' } },
      variants: [
        {
          props: { size: 'small' },
          style: { width: 12, height: 12, '&::before': { boxShadow: 'none' } },
        },
        {
          props: { orientation: 'horizontal' },
          style: { top: '50%', transform: 'translate(-50%, -50%)' },
        },
        {
          props: { orientation: 'vertical' },
          style: { left: '50%', transform: 'translate(-50%, 50%)' },
        },
        ...Object.keys(((a = o.vars) != null ? a : o).palette)
          .filter(s => {
            var $
            return (($ = o.vars) != null ? $ : o).palette[s].main
          })
          .map(s => ({
            props: { color: s },
            style: {
              [`&:hover, &.${sliderClasses.focusVisible}`]: _extends$5(
                {},
                o.vars
                  ? {
                      boxShadow: `0px 0px 0px 8px rgba(${o.vars.palette[s].mainChannel} / 0.16)`,
                    }
                  : {
                      boxShadow: `0px 0px 0px 8px ${alpha_1(
                        o.palette[s].main,
                        0.16
                      )}`,
                    },
                { '@media (hover: none)': { boxShadow: 'none' } }
              ),
              [`&.${sliderClasses.active}`]: _extends$5(
                {},
                o.vars
                  ? {
                      boxShadow: `0px 0px 0px 14px rgba(${o.vars.palette[s].mainChannel} / 0.16)`,
                    }
                  : {
                      boxShadow: `0px 0px 0px 14px ${alpha_1(
                        o.palette[s].main,
                        0.16
                      )}`,
                    }
              ),
            },
          })),
      ],
    }
  }),
  SliderValueLabel = styled(SliderValueLabel$1, {
    name: 'MuiSlider',
    slot: 'ValueLabel',
    overridesResolver: (o, a) => a.valueLabel,
  })(({ theme: o }) =>
    _extends$5({ zIndex: 1, whiteSpace: 'nowrap' }, o.typography.body2, {
      fontWeight: 500,
      transition: o.transitions.create(['transform'], {
        duration: o.transitions.duration.shortest,
      }),
      position: 'absolute',
      backgroundColor: (o.vars || o).palette.grey[600],
      borderRadius: 2,
      color: (o.vars || o).palette.common.white,
      display: 'flex',
      alignItems: 'center',
      justifyContent: 'center',
      padding: '0.25rem 0.75rem',
      variants: [
        {
          props: { orientation: 'horizontal' },
          style: {
            transform: 'translateY(-100%) scale(0)',
            top: '-10px',
            transformOrigin: 'bottom center',
            '&::before': {
              position: 'absolute',
              content: '""',
              width: 8,
              height: 8,
              transform: 'translate(-50%, 50%) rotate(45deg)',
              backgroundColor: 'inherit',
              bottom: 0,
              left: '50%',
            },
            [`&.${sliderClasses.valueLabelOpen}`]: {
              transform: 'translateY(-100%) scale(1)',
            },
          },
        },
        {
          props: { orientation: 'vertical' },
          style: {
            transform: 'translateY(-50%) scale(0)',
            right: '30px',
            top: '50%',
            transformOrigin: 'right center',
            '&::before': {
              position: 'absolute',
              content: '""',
              width: 8,
              height: 8,
              transform: 'translate(-50%, -50%) rotate(45deg)',
              backgroundColor: 'inherit',
              right: -8,
              top: '50%',
            },
            [`&.${sliderClasses.valueLabelOpen}`]: {
              transform: 'translateY(-50%) scale(1)',
            },
          },
        },
        {
          props: { size: 'small' },
          style: {
            fontSize: o.typography.pxToRem(12),
            padding: '0.25rem 0.5rem',
          },
        },
        {
          props: { orientation: 'vertical', size: 'small' },
          style: { right: '20px' },
        },
      ],
    })
  ),
  SliderMark = styled('span', {
    name: 'MuiSlider',
    slot: 'Mark',
    shouldForwardProp: o => slotShouldForwardProp(o) && o !== 'markActive',
    overridesResolver: (o, a) => {
      const { markActive: s } = o
      return [a.mark, s && a.markActive]
    },
  })(({ theme: o }) => ({
    position: 'absolute',
    width: 2,
    height: 2,
    borderRadius: 1,
    backgroundColor: 'currentColor',
    variants: [
      {
        props: { orientation: 'horizontal' },
        style: { top: '50%', transform: 'translate(-1px, -50%)' },
      },
      {
        props: { orientation: 'vertical' },
        style: { left: '50%', transform: 'translate(-50%, 1px)' },
      },
      {
        props: { markActive: !0 },
        style: {
          backgroundColor: (o.vars || o).palette.background.paper,
          opacity: 0.8,
        },
      },
    ],
  })),
  SliderMarkLabel = styled('span', {
    name: 'MuiSlider',
    slot: 'MarkLabel',
    shouldForwardProp: o => slotShouldForwardProp(o) && o !== 'markLabelActive',
    overridesResolver: (o, a) => a.markLabel,
  })(({ theme: o }) =>
    _extends$5({}, o.typography.body2, {
      color: (o.vars || o).palette.text.secondary,
      position: 'absolute',
      whiteSpace: 'nowrap',
      variants: [
        {
          props: { orientation: 'horizontal' },
          style: {
            top: 30,
            transform: 'translateX(-50%)',
            '@media (pointer: coarse)': { top: 40 },
          },
        },
        {
          props: { orientation: 'vertical' },
          style: {
            left: 36,
            transform: 'translateY(50%)',
            '@media (pointer: coarse)': { left: 44 },
          },
        },
        {
          props: { markLabelActive: !0 },
          style: { color: (o.vars || o).palette.text.primary },
        },
      ],
    })
  ),
  useUtilityClasses$1 = o => {
    const {
        disabled: a,
        dragging: s,
        marked: $,
        orientation: j,
        track: _e,
        classes: et,
        color: tt,
        size: rt,
      } = o,
      nt = {
        root: [
          'root',
          a && 'disabled',
          s && 'dragging',
          $ && 'marked',
          j === 'vertical' && 'vertical',
          _e === 'inverted' && 'trackInverted',
          _e === !1 && 'trackFalse',
          tt && `color${capitalize$2(tt)}`,
          rt && `size${capitalize$2(rt)}`,
        ],
        rail: ['rail'],
        track: ['track'],
        mark: ['mark'],
        markActive: ['markActive'],
        markLabel: ['markLabel'],
        markLabelActive: ['markLabelActive'],
        valueLabel: ['valueLabel'],
        thumb: [
          'thumb',
          a && 'disabled',
          rt && `thumbSize${capitalize$2(rt)}`,
          tt && `thumbColor${capitalize$2(tt)}`,
        ],
        active: ['active'],
        disabled: ['disabled'],
        focusVisible: ['focusVisible'],
      }
    return composeClasses(nt, getSliderUtilityClass, et)
  },
  Forward = ({ children: o }) => o,
  Slider = reactExports.forwardRef(function o(a, s) {
    var $,
      j,
      _e,
      et,
      tt,
      rt,
      nt,
      it,
      ot,
      at,
      st,
      ut,
      ct,
      dt,
      ft,
      mt,
      vt,
      yt,
      pt,
      ht,
      At,
      wt,
      Ct,
      Dt
    const jt = useDefaultProps({ props: a, name: 'MuiSlider' }),
      Et = useRtl(),
      {
        'aria-label': St,
        'aria-valuetext': Bt,
        'aria-labelledby': Mt,
        component: Ut = 'span',
        components: Wt = {},
        componentsProps: Tt = {},
        color: kt = 'primary',
        classes: Ot,
        className: Nt,
        disableSwap: $t = !1,
        disabled: Pt = !1,
        getAriaLabel: Ft,
        getAriaValueText: Vt,
        marks: Xt = !1,
        max: Yt = 100,
        min: xt = 0,
        orientation: It = 'horizontal',
        shiftStep: Kt = 10,
        size: Qt = 'medium',
        step: Ht = 1,
        scale: Lt = Identity,
        slotProps: tr,
        slots: lr,
        track: yr = 'normal',
        valueLabelDisplay: mr = 'off',
        valueLabelFormat: Er = Identity,
      } = jt,
      ur = _objectWithoutPropertiesLoose$3(jt, _excluded$1),
      _r = _extends$5({}, jt, {
        isRtl: Et,
        max: Yt,
        min: xt,
        classes: Ot,
        disabled: Pt,
        disableSwap: $t,
        orientation: It,
        marks: Xt,
        color: kt,
        size: Qt,
        step: Ht,
        shiftStep: Kt,
        scale: Lt,
        track: yr,
        valueLabelDisplay: mr,
        valueLabelFormat: Er,
      }),
      {
        axisProps: Rr,
        getRootProps: nr,
        getHiddenInputProps: fr,
        getThumbProps: gr,
        open: br,
        active: Sr,
        axis: zt,
        focusedThumbIndex: bt,
        range: Rt,
        dragging: qt,
        marks: rr,
        values: ar,
        trackOffset: ir,
        trackLeap: Tr,
        getThumbStyle: vr,
      } = useSlider(_extends$5({}, _r, { rootRef: s }))
    ;(_r.marked = rr.length > 0 && rr.some(Kr => Kr.label)),
      (_r.dragging = qt),
      (_r.focusedThumbIndex = bt)
    const Ar = useUtilityClasses$1(_r),
      Nr =
        ($ = (j = lr == null ? void 0 : lr.root) != null ? j : Wt.Root) != null
          ? $
          : SliderRoot,
      Or =
        (_e = (et = lr == null ? void 0 : lr.rail) != null ? et : Wt.Rail) !=
        null
          ? _e
          : SliderRail,
      Fr =
        (tt = (rt = lr == null ? void 0 : lr.track) != null ? rt : Wt.Track) !=
        null
          ? tt
          : SliderTrack,
      Qr =
        (nt = (it = lr == null ? void 0 : lr.thumb) != null ? it : Wt.Thumb) !=
        null
          ? nt
          : SliderThumb,
      qr =
        (ot =
          (at = lr == null ? void 0 : lr.valueLabel) != null
            ? at
            : Wt.ValueLabel) != null
          ? ot
          : SliderValueLabel,
      tn =
        (st = (ut = lr == null ? void 0 : lr.mark) != null ? ut : Wt.Mark) !=
        null
          ? st
          : SliderMark,
      en =
        (ct =
          (dt = lr == null ? void 0 : lr.markLabel) != null
            ? dt
            : Wt.MarkLabel) != null
          ? ct
          : SliderMarkLabel,
      ln =
        (ft = (mt = lr == null ? void 0 : lr.input) != null ? mt : Wt.Input) !=
        null
          ? ft
          : 'input',
      yn = (vt = tr == null ? void 0 : tr.root) != null ? vt : Tt.root,
      Bn = (yt = tr == null ? void 0 : tr.rail) != null ? yt : Tt.rail,
      xn = (pt = tr == null ? void 0 : tr.track) != null ? pt : Tt.track,
      vn = (ht = tr == null ? void 0 : tr.thumb) != null ? ht : Tt.thumb,
      on =
        (At = tr == null ? void 0 : tr.valueLabel) != null ? At : Tt.valueLabel,
      Cn = (wt = tr == null ? void 0 : tr.mark) != null ? wt : Tt.mark,
      dn =
        (Ct = tr == null ? void 0 : tr.markLabel) != null ? Ct : Tt.markLabel,
      An = (Dt = tr == null ? void 0 : tr.input) != null ? Dt : Tt.input,
      Jr = useSlotProps({
        elementType: Nr,
        getSlotProps: nr,
        externalSlotProps: yn,
        externalForwardedProps: ur,
        additionalProps: _extends$5(
          {},
          shouldSpreadAdditionalProps(Nr) && { as: Ut }
        ),
        ownerState: _extends$5({}, _r, yn == null ? void 0 : yn.ownerState),
        className: [Ar.root, Nt],
      }),
      En = useSlotProps({
        elementType: Or,
        externalSlotProps: Bn,
        ownerState: _r,
        className: Ar.rail,
      }),
      Pn = useSlotProps({
        elementType: Fr,
        externalSlotProps: xn,
        additionalProps: {
          style: _extends$5({}, Rr[zt].offset(ir), Rr[zt].leap(Tr)),
        },
        ownerState: _extends$5({}, _r, xn == null ? void 0 : xn.ownerState),
        className: Ar.track,
      }),
      pn = useSlotProps({
        elementType: Qr,
        getSlotProps: gr,
        externalSlotProps: vn,
        ownerState: _extends$5({}, _r, vn == null ? void 0 : vn.ownerState),
        className: Ar.thumb,
      }),
      Tn = useSlotProps({
        elementType: qr,
        externalSlotProps: on,
        ownerState: _extends$5({}, _r, on == null ? void 0 : on.ownerState),
        className: Ar.valueLabel,
      }),
      _n = useSlotProps({
        elementType: tn,
        externalSlotProps: Cn,
        ownerState: _r,
        className: Ar.mark,
      }),
      hn = useSlotProps({
        elementType: en,
        externalSlotProps: dn,
        ownerState: _r,
        className: Ar.markLabel,
      }),
      wn = useSlotProps({
        elementType: ln,
        getSlotProps: fr,
        externalSlotProps: An,
        ownerState: _r,
      })
    return jsxRuntimeExports.jsxs(
      Nr,
      _extends$5({}, Jr, {
        children: [
          jsxRuntimeExports.jsx(Or, _extends$5({}, En)),
          jsxRuntimeExports.jsx(Fr, _extends$5({}, Pn)),
          rr
            .filter(Kr => Kr.value >= xt && Kr.value <= Yt)
            .map((Kr, Vr) => {
              const In = valueToPercent(Kr.value, xt, Yt),
                Sn = Rr[zt].offset(In)
              let an
              return (
                yr === !1
                  ? (an = ar.indexOf(Kr.value) !== -1)
                  : (an =
                      (yr === 'normal' &&
                        (Rt
                          ? Kr.value >= ar[0] && Kr.value <= ar[ar.length - 1]
                          : Kr.value <= ar[0])) ||
                      (yr === 'inverted' &&
                        (Rt
                          ? Kr.value <= ar[0] || Kr.value >= ar[ar.length - 1]
                          : Kr.value >= ar[0]))),
                jsxRuntimeExports.jsxs(
                  reactExports.Fragment,
                  {
                    children: [
                      jsxRuntimeExports.jsx(
                        tn,
                        _extends$5(
                          { 'data-index': Vr },
                          _n,
                          !isHostComponent(tn) && { markActive: an },
                          {
                            style: _extends$5({}, Sn, _n.style),
                            className: clsx$1(
                              _n.className,
                              an && Ar.markActive
                            ),
                          }
                        )
                      ),
                      Kr.label != null
                        ? jsxRuntimeExports.jsx(
                            en,
                            _extends$5(
                              { 'aria-hidden': !0, 'data-index': Vr },
                              hn,
                              !isHostComponent(en) && { markLabelActive: an },
                              {
                                style: _extends$5({}, Sn, hn.style),
                                className: clsx$1(
                                  Ar.markLabel,
                                  hn.className,
                                  an && Ar.markLabelActive
                                ),
                                children: Kr.label,
                              }
                            )
                          )
                        : null,
                    ],
                  },
                  Vr
                )
              )
            }),
          ar.map((Kr, Vr) => {
            const In = valueToPercent(Kr, xt, Yt),
              Sn = Rr[zt].offset(In),
              an = mr === 'off' ? Forward : qr
            return jsxRuntimeExports.jsx(
              an,
              _extends$5(
                {},
                !isHostComponent(an) && {
                  valueLabelFormat: Er,
                  valueLabelDisplay: mr,
                  value: typeof Er == 'function' ? Er(Lt(Kr), Vr) : Er,
                  index: Vr,
                  open: br === Vr || Sr === Vr || mr === 'on',
                  disabled: Pt,
                },
                Tn,
                {
                  children: jsxRuntimeExports.jsx(
                    Qr,
                    _extends$5({ 'data-index': Vr }, pn, {
                      className: clsx$1(
                        Ar.thumb,
                        pn.className,
                        Sr === Vr && Ar.active,
                        bt === Vr && Ar.focusVisible
                      ),
                      style: _extends$5({}, Sn, vr(Vr), pn.style),
                      children: jsxRuntimeExports.jsx(
                        ln,
                        _extends$5(
                          {
                            'data-index': Vr,
                            'aria-label': Ft ? Ft(Vr) : St,
                            'aria-valuenow': Lt(Kr),
                            'aria-labelledby': Mt,
                            'aria-valuetext': Vt ? Vt(Lt(Kr), Vr) : Bt,
                            value: ar[Vr],
                          },
                          wn
                        )
                      ),
                    })
                  ),
                }
              ),
              Vr
            )
          }),
        ],
      })
    )
  })
var ZoomIn = {},
  _interopRequireDefault$1 = interopRequireDefaultExports
Object.defineProperty(ZoomIn, '__esModule', { value: !0 })
var default_1$1 = (ZoomIn.default = void 0),
  _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon()),
  _jsxRuntime$1 = jsxRuntimeExports
default_1$1 = ZoomIn.default = (0, _createSvgIcon$1.default)(
  [
    (0, _jsxRuntime$1.jsx)(
      'path',
      {
        d:
          'M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14',
      },
      '0'
    ),
    (0, _jsxRuntime$1.jsx)(
      'path',
      { d: 'M12 10h-2v2H9v-2H7V9h2V7h1v2h2z' },
      '1'
    ),
  ],
  'ZoomIn'
)
var ZoomOut = {},
  _interopRequireDefault = interopRequireDefaultExports
Object.defineProperty(ZoomOut, '__esModule', { value: !0 })
var default_1 = (ZoomOut.default = void 0),
  _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon()),
  _jsxRuntime = jsxRuntimeExports
default_1 = ZoomOut.default = (0, _createSvgIcon.default)(
  (0, _jsxRuntime.jsx)('path', {
    d:
      'M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14M7 9h5v1H7z',
  }),
  'ZoomOut'
)
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */ var extendStatics$1 = function(
  o,
  a
) {
  return (
    (extendStatics$1 =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function(s, $) {
          s.__proto__ = $
        }) ||
      function(s, $) {
        for (var j in $) $.hasOwnProperty(j) && (s[j] = $[j])
      }),
    extendStatics$1(o, a)
  )
}
function __extends$1(o, a) {
  extendStatics$1(o, a)
  function s() {
    this.constructor = o
  }
  o.prototype =
    a === null ? Object.create(a) : ((s.prototype = a.prototype), new s())
}
var __assign$1 = function() {
  return (
    (__assign$1 =
      Object.assign ||
      function(a) {
        for (var s, $ = 1, j = arguments.length; $ < j; $++) {
          s = arguments[$]
          for (var _e in s)
            Object.prototype.hasOwnProperty.call(s, _e) && (a[_e] = s[_e])
        }
        return a
      }),
    __assign$1.apply(this, arguments)
  )
}
function __rest$1(o, a) {
  var s = {}
  for (var $ in o)
    Object.prototype.hasOwnProperty.call(o, $) &&
      a.indexOf($) < 0 &&
      (s[$] = o[$])
  if (o != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var j = 0, $ = Object.getOwnPropertySymbols(o); j < $.length; j++)
      a.indexOf($[j]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(o, $[j]) &&
        (s[$[j]] = o[$[j]])
  return s
}
var initialState = {
    wrapperComponent: null,
    contentComponent: null,
    previousScale: 1,
    scale: 1,
    positionX: 0,
    positionY: 0,
    options: {
      disabled: !1,
      transformEnabled: !0,
      minPositionX: null,
      maxPositionX: null,
      minPositionY: null,
      maxPositionY: null,
      minScale: 1,
      maxScale: 8,
      limitToBounds: !0,
      limitToWrapper: !1,
      centerContent: !0,
      wrapperClass: '',
      contentClass: '',
    },
    wheel: {
      disabled: !1,
      step: 5,
      wheelEnabled: !0,
      touchPadEnabled: !0,
      limitsOnWheel: !1,
    },
    pan: {
      disabled: !1,
      panAnimationType: 'linear',
      lockAxisX: !1,
      lockAxisY: !1,
      velocity: !0,
      velocityEqualToMove: !0,
      velocitySensitivity: 2,
      velocityActiveScale: 1,
      velocityMinSpeed: 1,
      velocityBaseTime: 1600,
      velocityAnimationType: 'easeOutQuart',
      padding: !0,
      paddingSize: 30,
      panReturnAnimationTime: 400,
      panReturnAnimationType: 'easeOut',
      disableOnTarget: [],
    },
    pinch: { disabled: !1 },
    zoomIn: {
      disabled: !1,
      step: 20,
      animation: !0,
      animationType: 'easeOut',
      animationTime: 200,
    },
    zoomOut: {
      disabled: !1,
      step: 20,
      animation: !0,
      animationType: 'easeOut',
      animationTime: 200,
    },
    doubleClick: {
      disabled: !1,
      step: 20,
      mode: 'zoomIn',
      animation: !0,
      animationType: 'easeOut',
      animationTime: 200,
    },
    reset: {
      disabled: !1,
      animation: !0,
      animationType: 'easeOut',
      animationTime: 200,
    },
    scalePadding: {
      disabled: !1,
      size: 0.2,
      animationTime: 200,
      animationType: 'easeOut',
    },
  },
  roundNumber = function(o, a) {
    return Number(o.toFixed(a))
  },
  checkIsNumber = function(o, a) {
    return typeof o == 'number' ? o : a
  },
  boundLimiter = function(o, a, s, $) {
    return $
      ? o < a
        ? roundNumber(a, 2)
        : o > s
        ? roundNumber(s, 2)
        : roundNumber(o, 2)
      : roundNumber(o, 2)
  },
  calculateBoundingArea = function(o, a, s, $, j, _e, et) {
    var tt = o > a ? s * (et ? 1 : 0.5) : 0,
      rt = $ > j ? _e * (et ? 1 : 0.5) : 0,
      nt = o - a - tt,
      it = tt,
      ot = $ - j - rt,
      at = rt
    return {
      minPositionX: nt,
      maxPositionX: it,
      minPositionY: ot,
      maxPositionY: at,
    }
  },
  getDistance = function(o, a) {
    return Math.sqrt(
      Math.pow(o.pageX - a.pageX, 2) + Math.pow(o.pageY - a.pageY, 2)
    )
  },
  deleteUndefinedProps = function(o) {
    var a = __assign$1({}, o)
    return (
      Object.keys(a).forEach(function(s) {
        return a[s] === void 0 && delete a[s]
      }),
      a
    )
  },
  handleCallback = function(o, a) {
    o && typeof o == 'function' && o(a)
  },
  handleWheelStop = function(o, a, s) {
    var $ = s.scale,
      j = s.options,
      _e = j.maxScale,
      et = j.minScale
    return o
      ? $ < _e ||
          $ > et ||
          Math.sign(o.deltaY) !== Math.sign(a.deltaY) ||
          (o.deltaY > 0 && o.deltaY < a.deltaY) ||
          (o.deltaY < 0 && o.deltaY > a.deltaY) ||
          Math.sign(o.deltaY) !== Math.sign(a.deltaY)
      : !1
  },
  mergeProps = function(o, a) {
    return Object.keys(o).reduce(function(s, $) {
      return (
        typeof a[$] == 'object' && a[$] !== null
          ? (s[$] = __assign$1(__assign$1({}, o[$]), a[$]))
          : (s[$] = a[$] === void 0 ? o[$] : a[$]),
        s
      )
    }, {})
  }
function getWindowScaleY(o) {
  return o ? window.innerHeight / o.offsetHeight : 0
}
function getWindowScaleX(o) {
  return o ? window.innerWidth / o.offsetWidth : 0
}
var easeOut = function(o) {
    return -Math.cos(o * Math.PI) / 2 + 0.5
  },
  linear = function(o) {
    return o
  },
  easeInQuad = function(o) {
    return o * o
  },
  easeOutQuad = function(o) {
    return o * (2 - o)
  },
  easeInOutQuad = function(o) {
    return o < 0.5 ? 2 * o * o : -1 + (4 - 2 * o) * o
  },
  easeInCubic = function(o) {
    return o * o * o
  },
  easeOutCubic = function(o) {
    return --o * o * o + 1
  },
  easeInOutCubic = function(o) {
    return o < 0.5 ? 4 * o * o * o : (o - 1) * (2 * o - 2) * (2 * o - 2) + 1
  },
  easeInQuart = function(o) {
    return o * o * o * o
  },
  easeOutQuart = function(o) {
    return 1 - --o * o * o * o
  },
  easeInOutQuart = function(o) {
    return o < 0.5 ? 8 * o * o * o * o : 1 - 8 * --o * o * o * o
  },
  easeInQuint = function(o) {
    return o * o * o * o * o
  },
  easeOutQuint = function(o) {
    return 1 + --o * o * o * o * o
  },
  easeInOutQuint = function(o) {
    return o < 0.5 ? 16 * o * o * o * o * o : 1 + 16 * --o * o * o * o * o
  },
  availableAnimations = {
    easeOut,
    linear,
    easeInQuad,
    easeOutQuad,
    easeInOutQuad,
    easeInCubic,
    easeOutCubic,
    easeInOutCubic,
    easeInQuart,
    easeOutQuart,
    easeInOutQuart,
    easeInQuint,
    easeOutQuint,
    easeInOutQuint,
  }
function handleDisableAnimation() {
  this.mounted &&
    (this.animation && cancelAnimationFrame(this.animation),
    (this.animate = !1),
    (this.animation = !1),
    (this.velocity = !1))
}
function animate(o, a, s) {
  var $ = this
  if (this.mounted) {
    var j = new Date().getTime(),
      _e = 1
    handleDisableAnimation.call(this),
      (this.animation = function() {
        if (!(!$.animation || !$.mounted)) {
          var et = new Date().getTime() - j,
            tt = et / a,
            rt = availableAnimations[o],
            nt = rt(tt)
          et >= a
            ? (s(_e), ($.animation = null))
            : (s(nt), requestAnimationFrame($.animation))
        }
      }),
      requestAnimationFrame(this.animation)
  }
}
function animateComponent(o) {
  var a = this,
    s = o.targetState,
    $ = o.speed,
    j = o.type,
    _e = this.stateProvider,
    et = _e.scale,
    tt = _e.positionX,
    rt = _e.positionY,
    nt = s.scale - et,
    it = s.positionX - tt,
    ot = s.positionY - rt
  $ === 0
    ? ((this.stateProvider.previousScale = this.stateProvider.scale),
      (this.stateProvider.scale = s.scale),
      (this.stateProvider.positionX = s.positionX),
      (this.stateProvider.positionY = s.positionY),
      this.applyTransformation())
    : animate.call(this, j, $, function(at) {
        ;(a.stateProvider.previousScale = a.stateProvider.scale),
          (a.stateProvider.scale = et + nt * at),
          (a.stateProvider.positionX = tt + it * at),
          (a.stateProvider.positionY = rt + ot * at),
          a.applyTransformation()
      })
}
function checkZoomBounds(o, a, s, $, j) {
  var _e = j ? $ : 0,
    et = a - _e
  return !isNaN(s) && o >= s ? s : !isNaN(a) && o <= et ? et : o
}
function checkPositionBounds(o, a, s, $, j, _e) {
  var et = s.minPositionX,
    tt = s.minPositionY,
    rt = s.maxPositionX,
    nt = s.maxPositionY,
    it = _e ? (j * _e.offsetWidth) / 100 : 0,
    ot = _e ? (j * _e.offsetHeight) / 100 : 0,
    at = boundLimiter(o, et - it, rt + it, $),
    st = boundLimiter(a, tt - ot, nt + ot, $)
  return { x: at, y: st }
}
function getDelta(o, a) {
  var s = o ? (o.deltaY < 0 ? 1 : -1) : 0,
    $ = checkIsNumber(a, s)
  return $
}
function wheelMousePosition(o, a, s) {
  var $ = a.getBoundingClientRect(),
    j = (o.clientX - $.left) / s,
    _e = (o.clientY - $.top) / s
  return (
    (isNaN(j) || isNaN(_e)) && console.error('No mouse or touch offset found'),
    { mouseX: j, mouseY: _e }
  )
}
function getComponentsSizes(o, a, s) {
  var $ = o.offsetWidth,
    j = o.offsetHeight,
    _e = a.offsetWidth,
    et = a.offsetHeight,
    tt = _e * s,
    rt = et * s,
    nt = $ - tt,
    it = j - rt
  return {
    wrapperWidth: $,
    wrapperHeight: j,
    newContentWidth: tt,
    newDiffWidth: nt,
    newContentHeight: rt,
    newDiffHeight: it,
  }
}
function handleCalculatePositions(o, a, s, $, j) {
  var _e = this.stateProvider,
    et = _e.scale,
    tt = _e.positionX,
    rt = _e.positionY,
    nt = _e.options.transformEnabled,
    it = s - et
  if (typeof o != 'number' || typeof a != 'number')
    return console.error('Mouse X and Y position were not provided!')
  if (!nt) return { newPositionX: tt, newPositionY: rt }
  var ot = tt - o * it,
    at = rt - a * it,
    st = checkPositionBounds(ot, at, $, j, 0, null)
  return st
}
function getClientPosition(o) {
  var a = o.touches
  return a && a.length === 1
    ? { clientX: a[0].clientX, clientY: a[0].clientY }
    : a
    ? null
    : { clientX: o.clientX, clientY: o.clientY }
}
function handlePanning(o) {
  var a = this.stateProvider,
    s = a.scale,
    $ = a.positionX,
    j = a.positionY,
    _e = a.options,
    et = _e.limitToBounds,
    tt = _e.minScale,
    rt = a.pan,
    nt = rt.lockAxisX,
    it = rt.lockAxisY,
    ot = rt.padding,
    at = rt.paddingSize,
    st = a.wrapperComponent
  if (this.startCoords) {
    var ut = this.startCoords,
      ct = ut.x,
      dt = ut.y,
      ft = getClientPosition(o)
    if (!ft) return console.error('Cannot find mouse client positions')
    var mt = ft.clientX,
      vt = ft.clientY,
      yt = mt - ct,
      pt = vt - dt,
      ht = nt ? $ : yt,
      At = it ? j : pt,
      wt = ot && s >= tt ? at : 0
    if (!(ht === $ && At === j)) {
      var Ct = checkPositionBounds(ht, At, this.bounds, et, wt, st)
      handlePaddingAnimation.call(this, Ct.x, Ct.y)
    }
  }
}
function handlePanningAnimation() {
  var o = this.stateProvider,
    a = o.scale,
    s = o.options.minScale,
    $ = o.pan,
    j = $.disabled,
    _e = $.padding,
    et = $.panReturnAnimationTime,
    tt = $.panReturnAnimationType,
    rt = j || a < s || !_e
  if (!rt) {
    var nt = handlePanToBounds.call(this)
    animateComponent.call(this, { targetState: nt, speed: et, type: tt })
  }
}
function handlePanToBounds() {
  var o = this.stateProvider,
    a = o.positionX,
    s = o.positionY,
    $ = o.scale,
    j = o.options,
    _e = j.disabled,
    et = j.limitToBounds,
    tt = j.limitToWrapper,
    rt = this.state.wrapperComponent
  if (!_e) {
    var nt = this.bounds,
      it = nt.maxPositionX,
      ot = nt.minPositionX,
      at = nt.maxPositionY,
      st = nt.minPositionY,
      ut = a > it || a < ot,
      ct = s > at || s < st,
      dt = a > it ? rt.offsetWidth : this.stateProvider.minPositionX || 0,
      ft = s > at ? rt.offsetHeight : this.stateProvider.minPositionY || 0,
      mt = dt,
      vt = ft,
      yt = handleCalculatePositions.call(
        this,
        mt,
        vt,
        $,
        this.bounds,
        et || tt
      ),
      pt = yt.x,
      ht = yt.y
    return { scale: $, positionX: ut ? pt : a, positionY: ct ? ht : s }
  }
}
function handlePaddingAnimation(o, a) {
  var s = this.stateProvider.pan.padding
  s &&
    ((this.stateProvider.positionX = o),
    (this.stateProvider.positionY = a),
    this.applyTransformation())
}
function handleCalculateZoom(o, a, s, $, j) {
  var _e = this.stateProvider,
    et = _e.scale,
    tt = _e.options,
    rt = tt.maxScale,
    nt = tt.minScale,
    it = _e.scalePadding,
    ot = it.size,
    at = it.disabled,
    st = _e.wrapperComponent,
    ut = null
  if (j) {
    var ct = window.innerWidth * 1e-4,
      dt = o < 0 ? 30 : 20
    ut = et + (a - a * ct) * o * (et / dt)
  } else {
    var ft = 2 - window.innerWidth / st.offsetWidth,
      ct = Math.max(0.2, Math.min(0.99, ft)),
      dt = 20
    ut = et + a * o * ((et - et * ct) / dt)
  }
  if ($) return ut
  var mt = s ? !1 : !at,
    vt = checkZoomBounds(roundNumber(ut, 3), nt, rt, ot, mt)
  return vt
}
function handleCalculateBounds(o, a) {
  var s = this.stateProvider,
    $ = s.wrapperComponent,
    j = s.contentComponent,
    _e = getComponentsSizes($, j, o),
    et = _e.wrapperWidth,
    tt = _e.wrapperHeight,
    rt = _e.newContentWidth,
    nt = _e.newDiffWidth,
    it = _e.newContentHeight,
    ot = _e.newDiffHeight,
    at = calculateBoundingArea(et, rt, nt, tt, it, ot, a)
  return (this.bounds = at), at
}
function handleWheelZoom(o) {
  var a = this.stateProvider,
    s = a.scale,
    $ = a.contentComponent,
    j = a.options.limitToBounds,
    _e = a.scalePadding,
    et = _e.size,
    tt = _e.disabled,
    rt = a.wheel,
    nt = rt.step,
    it = rt.limitsOnWheel
  o.preventDefault(), o.stopPropagation()
  var ot = getDelta(o, null),
    at = handleCalculateZoom.call(this, ot, nt, !o.ctrlKey)
  if (s !== at) {
    var st = handleCalculateBounds.call(this, at, !it),
      ut = wheelMousePosition(o, $, s),
      ct = ut.mouseX,
      dt = ut.mouseY,
      ft = j && (tt || et === 0 || it),
      mt = handleCalculatePositions.call(this, ct, dt, at, st, ft),
      vt = mt.x,
      yt = mt.y
    ;(this.bounds = st),
      (this.stateProvider.previousScale = s),
      (this.stateProvider.scale = at),
      (this.stateProvider.positionX = vt),
      (this.stateProvider.positionY = yt),
      this.applyTransformation()
  }
}
function handleZoomToPoint(o, a, s, $, j) {
  var _e = this.stateProvider,
    et = _e.contentComponent,
    tt = _e.options,
    rt = tt.disabled,
    nt = tt.minScale,
    it = tt.maxScale,
    ot = tt.limitToBounds,
    at = tt.limitToWrapper
  if (!(rt || o)) {
    var st = checkZoomBounds(roundNumber(a, 2), nt, it, null, null),
      ut = handleCalculateBounds.call(this, st, at),
      ct = s,
      dt = $
    if (j) {
      var ft = wheelMousePosition(j, et, a)
      ;(ct = ft.mouseX), (dt = ft.mouseY)
    }
    var mt = handleCalculatePositions.call(this, ct, dt, st, ut, ot),
      vt = mt.x,
      yt = mt.y
    return { scale: st, positionX: vt, positionY: yt }
  }
}
function handlePaddingAnimation$1() {
  var o = this.stateProvider,
    a = o.scale,
    s = o.wrapperComponent,
    $ = o.options,
    j = $.minScale,
    _e = $.limitToBounds,
    et = o.scalePadding,
    tt = et.disabled,
    rt = et.animationTime,
    nt = et.animationType,
    it = tt || a >= j
  if (((a >= 1 || _e) && handlePanningAnimation.call(this), !it)) {
    var ot = s.offsetWidth / 2,
      at = s.offsetHeight / 2,
      st = handleZoomToPoint.call(this, !1, j, ot, at, null)
    animateComponent.call(this, { targetState: st, speed: rt, type: nt })
  }
}
function handleDoubleClick(o) {
  o.preventDefault(), o.stopPropagation()
  var a = this.stateProvider,
    s = a.contentComponent,
    $ = a.scale,
    j = a.doubleClick,
    _e = j.disabled,
    et = j.mode,
    tt = j.step,
    rt = j.animationTime,
    nt = j.animationType
  if (et === 'reset') return resetTransformations.call(this, o, rt)
  var it = et === 'zoomOut' ? -1 : 1,
    ot = handleCalculateZoom.call(this, it, tt, void 0, void 0, !0),
    at = wheelMousePosition(o, s, $),
    st = at.mouseX,
    ut = at.mouseY,
    ct = handleZoomToPoint.call(this, _e, ot, st, ut)
  if (ct.scale !== $) {
    var dt = handleCalculateZoom.call(this, it, tt, !0, void 0, !0),
      ft = getButtonAnimationTime(dt, ot, rt)
    animateComponent.call(this, { targetState: ct, speed: ft, type: nt })
  }
}
function handleZoomControls(o, a) {
  var s = this.stateProvider,
    $ = s.scale,
    j = s.positionX,
    _e = s.positionY,
    et = s.wrapperComponent,
    tt = s.zoomIn,
    rt = s.zoomOut,
    nt = et.offsetWidth,
    it = et.offsetHeight,
    ot = (nt / 2 - j) / $,
    at = (it / 2 - _e) / $,
    st = handleCalculateZoom.call(this, o, a, void 0, void 0, !0),
    ut = st > $,
    ct = ut ? tt.animationTime : rt.animationTime,
    dt = ut ? tt.animationType : rt.animationType,
    ft = ut ? tt.disabled : rt.disabled,
    mt = handleZoomToPoint.call(this, ft, st, ot, at)
  if (mt.scale !== $) {
    var vt = handleCalculateZoom.call(this, o, a, !0, void 0, !0),
      yt = getButtonAnimationTime(vt, st, ct)
    animateComponent.call(this, { targetState: mt, speed: yt, type: dt })
  }
}
function resetTransformations(o) {
  var a = this.props.defaultValues,
    s = a.defaultScale,
    $ = a.defaultPositionX,
    j = a.defaultPositionY,
    _e = this.stateProvider,
    et = _e.scale,
    tt = _e.positionX,
    rt = _e.positionY,
    nt = _e.reset,
    it = _e.options,
    ot = it.disabled,
    at = it.limitToBounds,
    st = it.centerContent,
    ut = it.limitToWrapper
  if (!(ot || nt.disabled) && !(et === s && tt === $ && rt === j)) {
    var ct = typeof o == 'number' ? o : nt.animationTime,
      dt = checkIsNumber(s, initialState.scale),
      ft = checkIsNumber($, initialState.positionX),
      mt = checkIsNumber(j, initialState.positionY)
    if ((at && !ut) || st) {
      var vt = handleCalculateBounds.call(this, dt, ut)
      ;(ft = vt.minPositionX), (mt = vt.minPositionY)
    }
    var yt = { scale: dt, positionX: ft, positionY: mt }
    animateComponent.call(this, {
      targetState: yt,
      speed: ct,
      type: nt.animationType,
    })
  }
}
function getButtonAnimationTime(o, a, s) {
  return s * (a / o)
}
function round(o, a) {
  var s = Math.pow(10, a)
  return Math.round(o * s) / s
}
function getCurrentDistance(o) {
  return getDistance(o.touches[0], o.touches[1])
}
function checkIfInfinite(o) {
  return o === 1 / 0 || o === -1 / 0
}
function calculatePinchZoom(o, a) {
  var s = this.stateProvider,
    $ = s.options,
    j = $.minScale,
    _e = $.maxScale,
    et = s.scalePadding,
    tt = et.size,
    rt = et.disabled
  if (typeof a != 'number' || typeof o != 'number')
    return console.error('Pinch touches distance was not provided')
  if (!(o < 0)) {
    var nt = o / a,
      it = nt * this.pinchStartScale
    return checkZoomBounds(roundNumber(it, 2), j, _e, tt, !rt)
  }
}
function calculateMidpoint(o, a, s) {
  var $ = s.getBoundingClientRect(),
    j = o.touches,
    _e = round(j[0].clientX - $.left, 5),
    et = round(j[0].clientY - $.top, 5),
    tt = round(j[1].clientX - $.left, 5),
    rt = round(j[1].clientY - $.top, 5)
  return { mouseX: (_e + tt) / 2 / a, mouseY: (et + rt) / 2 / a }
}
function handleZoomPinch(o) {
  var a = this.stateProvider,
    s = a.scale,
    $ = a.options,
    j = $.limitToBounds,
    _e = $.limitToWrapper,
    et = a.scalePadding,
    tt = et.disabled,
    rt = et.size,
    nt = a.wheel.limitsOnWheel,
    it = a.pinch,
    ot = this.state.contentComponent
  if (
    !(it.disabled || this.stateProvider.options.disabled) &&
    (o.cancelable && (o.preventDefault(), o.stopPropagation()),
    this.pinchStartDistance !== null)
  ) {
    var at = calculateMidpoint(o, s, ot),
      st = at.mouseX,
      ut = at.mouseY
    if (!(checkIfInfinite(st) || checkIfInfinite(ut))) {
      var ct = getCurrentDistance(o),
        dt = calculatePinchZoom.call(this, ct, this.pinchStartDistance)
      if (!(checkIfInfinite(dt) || dt === s)) {
        var ft = handleCalculateBounds.call(this, dt, _e),
          mt = j && (tt || rt === 0 || nt),
          vt = handleCalculatePositions.call(this, st, ut, dt, ft, mt),
          yt = vt.x,
          pt = vt.y
        ;(this.lastDistance = ct),
          (this.stateProvider.positionX = yt),
          (this.stateProvider.positionY = pt),
          (this.stateProvider.scale = dt),
          (this.stateProvider.previousScale = s),
          this.applyTransformation()
      }
    }
  }
}
var throttleTime = 30
function velocityTimeSpeed(o, a) {
  var s = this.stateProvider.pan.velocityEqualToMove
  return s ? a - a / Math.max(1, o) : a
}
function handleEnableVelocity() {
  this.setState({ startAnimation: !1 })
}
function handleFireVelocity() {
  this.setState({ startAnimation: !0 })
}
function animateVelocity() {
  var o = this,
    a = this.stateProvider,
    s = a.positionX,
    $ = a.positionY,
    j = a.options.limitToBounds,
    _e = a.pan,
    et = _e.velocityBaseTime,
    tt = _e.lockAxisX,
    rt = _e.lockAxisY,
    nt = _e.velocityAnimationType,
    it = _e.panReturnAnimationTime,
    ot = _e.panReturnAnimationType,
    at = _e.padding,
    st = _e.paddingSize,
    ut = a.wrapperComponent
  if (this.mounted) {
    if (!this.velocity || !this.bounds) return handleDisableAnimation.call(this)
    var ct = this.bounds,
      dt = ct.maxPositionX,
      ft = ct.minPositionX,
      mt = ct.maxPositionY,
      vt = ct.minPositionY,
      yt = this.velocity,
      pt = yt.velocityX,
      ht = yt.velocityY,
      At = yt.velocity,
      wt = velocityTimeSpeed.call(this, At, et)
    if (!wt) {
      handlePanningAnimation.call(this)
      return
    }
    var Ct = pt,
      Dt = ht,
      jt = wt > it ? wt : it,
      Et = at ? st : 0,
      St = ut ? (Et * ut.offsetWidth) / 100 : 0,
      Bt = ut ? (Et * ut.offsetHeight) / 100 : 0,
      Mt = dt + St,
      Ut = ft - St,
      Wt = mt + Bt,
      Tt = vt - Bt,
      kt = checkPositionBounds(s, $, this.bounds, j, Et, ut),
      Ot = new Date().getTime()
    animate.call(this, nt, jt, function(Nt) {
      var $t = new Date().getTime() - Ot,
        Pt = $t / it,
        Ft = availableAnimations[ot],
        Vt = Ft(Pt)
      ;($t > it || Vt > 1 || Vt === 1 / 0 || Vt === -1 / 0) && (Vt = 1)
      var Xt = getPosition(tt, Ct, Nt, Vt, ft, dt, j, s, kt.x, Ut, Mt),
        Yt = getPosition(rt, Dt, Nt, Vt, vt, mt, j, $, kt.y, Tt, Wt)
      ;(s !== Xt || $ !== Yt) &&
        ((o.stateProvider.positionX = Xt),
        (o.stateProvider.positionY = Yt),
        o.applyTransformation())
    })
  }
}
function calculateVelocityStart(o) {
  var a = this,
    s = this.stateProvider,
    $ = s.scale,
    j = s.options.disabled,
    _e = s.pan,
    et = _e.velocity,
    tt = _e.velocitySensitivity,
    rt = _e.velocityActiveScale,
    nt = _e.velocityMinSpeed,
    it = s.wrapperComponent
  if (!(!et || rt >= $ || j)) {
    handleEnableVelocity.call(this)
    var ot = Date.now()
    if (this.lastMousePosition) {
      var at = getClientPosition(o)
      if (!at) return console.error('No mouse or touch position detected')
      var st = at.clientX,
        ut = at.clientY,
        ct = st - this.lastMousePosition.clientX,
        dt = ut - this.lastMousePosition.clientY,
        ft = ot - this.velocityTime,
        mt = 2 - it.offsetWidth / window.innerWidth,
        vt = 2 - it.offsetHeight / window.innerHeight,
        yt = 20 * Math.max(nt, Math.min(2, mt)),
        pt = 20 * Math.max(nt, Math.min(2, vt)),
        ht = (ct / ft) * tt * $ * yt,
        At = (dt / ft) * tt * $ * pt,
        wt = ct * ct + dt * dt,
        Ct = (Math.sqrt(wt) / ft) * tt
      if (this.velocity && Ct < this.velocity.velocity && this.throttle) return
      ;(this.velocity = { velocityX: ht, velocityY: At, velocity: Ct }),
        this.throttle && clearTimeout(this.throttle),
        (this.throttle = setTimeout(function() {
          a.mounted && (a.throttle = !1)
        }, throttleTime))
    }
    var Dt = getClientPosition(o)
    ;(this.lastMousePosition = Dt), (this.velocityTime = ot)
  }
}
function getPosition(o, a, s, $, j, _e, et, tt, rt, nt, it) {
  if (et) {
    if (rt > j && tt > _e) {
      var ot = rt - (rt - _e) * $
      return ot > it ? it : ot < _e ? _e : ot
    }
    if (rt < j && tt < j) {
      var ot = rt - (rt - j) * $
      return ot < nt ? nt : ot > j ? j : ot
    }
  }
  if (o) return rt
  var at = tt + a * s
  return boundLimiter(at, j, _e, et)
}
function makePassiveEventOption(o) {
  return o
}
var propsList = [
    'previousScale',
    'scale',
    'positionX',
    'positionY',
    'defaultPositionX',
    'defaultPositionY',
    'defaultScale',
    'onWheelStart',
    'onWheel',
    'onWheelStop',
    'onPanningStart',
    'onPanning',
    'onPanningStop',
    'onPinchingStart',
    'onPinching',
    'onPinchingStop',
    'onZoomChange',
    'options',
    'wheel',
    'scalePadding',
    'pan',
    'pinch',
    'zoomIn',
    'zoomOut',
    'doubleClick',
    'reset',
  ],
  getValidPropsFromObject = function(o) {
    return Object.keys(o).reduce(function(a, s) {
      return propsList.includes(s) && (a[s] = o[s]), a
    }, {})
  },
  Context = React$5.createContext({}),
  wheelStopEventTimer = null,
  wheelStopEventTime = 180,
  wheelAnimationTimer = null,
  wheelAnimationTime = 100,
  StateProvider = (function(o) {
    __extends$1(a, o)
    function a() {
      var s = (o !== null && o.apply(this, arguments)) || this
      return (
        (s.mounted = !0),
        (s.state = { wrapperComponent: void 0, contentComponent: void 0 }),
        (s.stateProvider = __assign$1(
          __assign$1(
            __assign$1(
              __assign$1({}, initialState),
              mergeProps(initialState, s.props.dynamicValues)
            ),
            s.props.defaultValues
          ),
          {
            previousScale:
              s.props.dynamicValues.scale ||
              s.props.defaultValues.scale ||
              initialState.scale,
          }
        )),
        (s.windowToWrapperScaleX = 0),
        (s.windowToWrapperScaleY = 0),
        (s.startCoords = null),
        (s.isDown = !1),
        (s.pinchStartDistance = null),
        (s.lastDistance = null),
        (s.pinchStartScale = null),
        (s.distance = null),
        (s.bounds = null),
        (s.velocityTime = null),
        (s.lastMousePosition = null),
        (s.velocity = null),
        (s.offsetX = null),
        (s.offsetY = null),
        (s.throttle = !1),
        (s.previousWheelEvent = null),
        (s.lastScale = null),
        (s.animate = null),
        (s.animation = null),
        (s.maxBounds = null),
        (s.handleWheel = function($) {
          var j = s.stateProvider,
            _e = j.scale,
            et = j.wheel,
            tt = et.disabled,
            rt = et.wheelEnabled,
            nt = et.touchPadEnabled,
            it = s.props,
            ot = it.onWheelStart,
            at = it.onWheel,
            st = it.onWheelStop,
            ut = s.state,
            ct = ut.wrapperComponent,
            dt = ut.contentComponent
          s.isDown ||
            tt ||
            s.stateProvider.options.disabled ||
            !ct ||
            !dt ||
            (!rt && !$.ctrlKey) ||
            (!nt && $.ctrlKey) ||
            (wheelStopEventTimer ||
              ((s.lastScale = _e),
              handleDisableAnimation.call(s),
              handleCallback(ot, s.getCallbackProps())),
            handleWheelZoom.call(s, $),
            handleCallback(at, s.getCallbackProps()),
            s.applyTransformation(null, null, null),
            (s.previousWheelEvent = $),
            handleWheelStop(s.previousWheelEvent, $, s.stateProvider) &&
              (clearTimeout(wheelStopEventTimer),
              (wheelStopEventTimer = setTimeout(function() {
                s.mounted &&
                  (handleCallback(st, s.getCallbackProps()),
                  (wheelStopEventTimer = null))
              }, wheelStopEventTime))),
            (s.animate = !1),
            (s.lastScale = s.stateProvider.scale),
            clearTimeout(wheelAnimationTimer),
            (wheelAnimationTimer = setTimeout(function() {
              s.mounted && handlePaddingAnimation$1.call(s, $)
            }, wheelAnimationTime)))
        }),
        (s.checkPanningTarget = function($) {
          var j = s.stateProvider.pan.disableOnTarget
          return (
            j
              .map(function(_e) {
                return _e.toUpperCase()
              })
              .includes($.target.tagName) ||
            j.find(function(_e) {
              return $.target.classList.value.includes(_e)
            })
          )
        }),
        (s.checkIsPanningActive = function($) {
          var j = s.stateProvider.pan.disabled,
            _e = s.state,
            et = _e.wrapperComponent,
            tt = _e.contentComponent
          return (
            !s.isDown ||
            j ||
            s.stateProvider.options.disabled ||
            ($.touches &&
              ($.touches.length !== 1 ||
                Math.abs(s.startCoords.x - $.touches[0].clientX) < 1 ||
                Math.abs(s.startCoords.y - $.touches[0].clientY) < 1)) ||
            !et ||
            !tt
          )
        }),
        (s.handleSetUpPanning = function($, j) {
          var _e = s.stateProvider,
            et = _e.positionX,
            tt = _e.positionY
          ;(s.isDown = !0),
            (s.startCoords = { x: $ - et, y: j - tt }),
            handleCallback(s.props.onPanningStart, s.getCallbackProps())
        }),
        (s.handleStartPanning = function($) {
          var j = s.stateProvider,
            _e = j.wrapperComponent,
            et = j.scale,
            tt = j.options,
            rt = tt.minScale,
            nt = tt.maxScale,
            it = tt.limitToWrapper,
            ot = j.pan.disabled,
            at = $.target,
            st = $.touches
          ot ||
            s.stateProvider.options.disabled ||
            (_e && !_e.contains(at)) ||
            s.checkPanningTarget($) ||
            et < rt ||
            et > nt ||
            (handleDisableAnimation.call(s),
            (s.bounds = handleCalculateBounds.call(s, et, it)),
            st &&
              st.length === 1 &&
              s.handleSetUpPanning(st[0].clientX, st[0].clientY),
            st || s.handleSetUpPanning($.clientX, $.clientY))
        }),
        (s.handlePanning = function($) {
          s.isDown && $.preventDefault(),
            !s.checkIsPanningActive($) &&
              ($.stopPropagation(),
              calculateVelocityStart.call(s, $),
              handlePanning.call(s, $),
              handleCallback(s.props.onPanning, s.getCallbackProps()))
        }),
        (s.handleStopPanning = function() {
          if (s.isDown) {
            ;(s.isDown = !1),
              (s.animate = !1),
              (s.animation = !1),
              handleFireVelocity.call(s),
              handleCallback(s.props.onPanningStop, s.getCallbackProps())
            var $ = s.stateProvider,
              j = $.pan.velocity,
              _e = $.scale
            s.velocity && j && _e > 1
              ? animateVelocity.call(s)
              : handlePanningAnimation.call(s)
          }
        }),
        (s.handlePinchStart = function($) {
          var j = s.stateProvider.scale
          $.preventDefault(),
            $.stopPropagation(),
            handleDisableAnimation.call(s)
          var _e = getDistance($.touches[0], $.touches[1])
          ;(s.pinchStartDistance = _e),
            (s.lastDistance = _e),
            (s.pinchStartScale = j),
            (s.isDown = !1),
            handleCallback(s.props.onPinchingStart, s.getCallbackProps())
        }),
        (s.handlePinch = function($) {
          ;(s.isDown = !1),
            handleZoomPinch.call(s, $),
            handleCallback(s.props.onPinching, s.getCallbackProps())
        }),
        (s.handlePinchStop = function() {
          typeof s.pinchStartScale == 'number' &&
            ((s.isDown = !1),
            (s.velocity = null),
            (s.lastDistance = null),
            (s.pinchStartScale = null),
            (s.pinchStartDistance = null),
            handlePaddingAnimation$1.call(s),
            handleCallback(s.props.onPinchingStop, s.getCallbackProps()))
        }),
        (s.handleTouchStart = function($) {
          var j = s.stateProvider,
            _e = j.wrapperComponent,
            et = j.contentComponent,
            tt = j.scale,
            rt = j.options,
            nt = rt.disabled,
            it = rt.minScale,
            ot = $.touches
          if (!(nt || !_e || !et || tt < it)) {
            if ((handleDisableAnimation.call(s), ot && ot.length === 1))
              return s.handleStartPanning($)
            if (ot && ot.length === 2) return s.handlePinchStart($)
          }
        }),
        (s.handleTouch = function($) {
          var j = s.stateProvider,
            _e = j.pan,
            et = j.pinch,
            tt = j.options
          if (!tt.disabled) {
            if (!_e.disabled && $.touches.length === 1)
              return s.handlePanning($)
            if (!et.disabled && $.touches.length === 2) return s.handlePinch($)
          }
        }),
        (s.handleTouchStop = function() {
          s.handleStopPanning(), s.handlePinchStop()
        }),
        (s.zoomIn = function($) {
          var j = s.stateProvider,
            _e = j.zoomIn,
            et = _e.disabled,
            tt = _e.step,
            rt = j.options,
            nt = s.state,
            it = nt.wrapperComponent,
            ot = nt.contentComponent
          if (!$) throw Error('Zoom in function requires event prop')
          et || rt.disabled || !it || !ot || handleZoomControls.call(s, 1, tt)
        }),
        (s.zoomOut = function($) {
          var j = s.stateProvider,
            _e = j.zoomOut,
            et = _e.disabled,
            tt = _e.step,
            rt = j.options,
            nt = s.state,
            it = nt.wrapperComponent,
            ot = nt.contentComponent
          if (!$) throw Error('Zoom out function requires event prop')
          et || rt.disabled || !it || !ot || handleZoomControls.call(s, -1, tt)
        }),
        (s.handleDbClick = function($) {
          var j = s.stateProvider,
            _e = j.options,
            et = j.doubleClick,
            tt = et.disabled,
            rt = et.step,
            nt = s.state,
            it = nt.wrapperComponent,
            ot = nt.contentComponent
          if (!$) throw Error('Double click function requires event prop')
          tt || _e.disabled || !it || !ot || handleDoubleClick.call(s, $, 1, rt)
        }),
        (s.setScale = function($, j, _e) {
          j === void 0 && (j = 200), _e === void 0 && (_e = 'easeOut')
          var et = s.stateProvider,
            tt = et.positionX,
            rt = et.positionY,
            nt = et.scale,
            it = et.options.disabled,
            ot = s.state,
            at = ot.wrapperComponent,
            st = ot.contentComponent
          if (!(it || !at || !st)) {
            var ut = { positionX: tt, positionY: rt, scale: isNaN($) ? nt : $ }
            animateComponent.call(s, { targetState: ut, speed: j, type: _e })
          }
        }),
        (s.setPositionX = function($, j, _e) {
          j === void 0 && (j = 200), _e === void 0 && (_e = 'easeOut')
          var et = s.stateProvider,
            tt = et.positionX,
            rt = et.positionY,
            nt = et.scale,
            it = et.options,
            ot = it.disabled,
            at = it.transformEnabled,
            st = s.state,
            ut = st.wrapperComponent,
            ct = st.contentComponent
          if (!(ot || !at || !ut || !ct)) {
            var dt = { positionX: isNaN($) ? tt : $, positionY: rt, scale: nt }
            animateComponent.call(s, { targetState: dt, speed: j, type: _e })
          }
        }),
        (s.setPositionY = function($, j, _e) {
          j === void 0 && (j = 200), _e === void 0 && (_e = 'easeOut')
          var et = s.stateProvider,
            tt = et.positionX,
            rt = et.scale,
            nt = et.positionY,
            it = et.options,
            ot = it.disabled,
            at = it.transformEnabled,
            st = s.state,
            ut = st.wrapperComponent,
            ct = st.contentComponent
          if (!(ot || !at || !ut || !ct)) {
            var dt = { positionX: tt, positionY: isNaN($) ? nt : $, scale: rt }
            animateComponent.call(s, { targetState: dt, speed: j, type: _e })
          }
        }),
        (s.setTransform = function($, j, _e, et, tt) {
          et === void 0 && (et = 200), tt === void 0 && (tt = 'easeOut')
          var rt = s.stateProvider,
            nt = rt.positionX,
            it = rt.positionY,
            ot = rt.scale,
            at = rt.options,
            st = at.disabled,
            ut = at.transformEnabled,
            ct = s.state,
            dt = ct.wrapperComponent,
            ft = ct.contentComponent
          if (!(st || !ut || !dt || !ft)) {
            var mt = {
              positionX: isNaN($) ? nt : $,
              positionY: isNaN(j) ? it : j,
              scale: isNaN(_e) ? ot : _e,
            }
            animateComponent.call(s, { targetState: mt, speed: et, type: tt })
          }
        }),
        (s.resetTransform = function() {
          var $ = s.stateProvider.options,
            j = $.disabled,
            _e = $.transformEnabled
          j || !_e || resetTransformations.call(s)
        }),
        (s.setDefaultState = function() {
          ;(s.animation = null),
            (s.stateProvider = __assign$1(
              __assign$1(__assign$1({}, s.stateProvider), {
                scale: initialState.scale,
                positionX: initialState.positionX,
                positionY: initialState.positionY,
              }),
              s.props.defaultValues
            )),
            s.forceUpdate()
        }),
        (s.setWrapperComponent = function($) {
          s.setState({ wrapperComponent: $ })
        }),
        (s.setContentComponent = function($) {
          s.setState({ contentComponent: $ }, function() {
            var j = s.stateProvider,
              _e = j.wrapperComponent,
              et = j.options,
              tt = et.centerContent,
              rt = et.limitToBounds,
              nt = et.limitToWrapper,
              it = j.scale,
              ot = s.props.defaultValues,
              at = ot.positionX,
              st = ot.positionY
            if ((rt && !nt) || (tt && !at && !st)) {
              var ut = 'translate(25%, 25%) scale(' + it + ')'
              ;($.style.transform = ut),
                ($.style.WebkitTransform = ut),
                s.forceUpdate()
              var ct = new Date().getTime(),
                dt = 2e3,
                ft = setInterval(function() {
                  if (_e.offsetWidth) {
                    var mt = handleCalculateBounds.call(s, it, !1)
                    ;(s.stateProvider.positionX = mt.minPositionX),
                      (s.stateProvider.positionY = mt.minPositionY),
                      s.applyTransformation(null, null, null),
                      clearInterval(ft),
                      (ft = null)
                  } else new Date().getTime() - ct > dt && (clearInterval(ft), (ft = null))
                }, 20)
            } else s.applyTransformation(null, null, null)
          })
        }),
        (s.applyTransformation = function($, j, _e) {
          if (s.mounted) {
            var et = s.state.contentComponent,
              tt = s.props.onZoomChange,
              rt = s.stateProvider,
              nt = rt.previousScale,
              it = rt.scale,
              ot = rt.positionX,
              at = rt.positionY
            if (!et) return console.error('There is no content component')
            var st =
              'translate(' +
              (j || ot) +
              'px, ' +
              (_e || at) +
              'px) scale(' +
              ($ || it) +
              ')'
            ;(et.style.transform = st),
              (et.style.WebkitTransform = st),
              s.forceUpdate(),
              tt && nt !== it && handleCallback(tt, s.getCallbackProps())
          }
        }),
        (s.getCallbackProps = function() {
          return getValidPropsFromObject(s.stateProvider)
        }),
        s
      )
    }
    return (
      (a.prototype.componentDidMount = function() {
        var s = !1
        window.addEventListener('mousedown', this.handleStartPanning, s),
          window.addEventListener('mousemove', this.handlePanning, s),
          window.addEventListener('mouseup', this.handleStopPanning, s)
      }),
      (a.prototype.componentWillUnmount = function() {
        var s = !1
        window.removeEventListener('mousedown', this.handleStartPanning, s),
          window.removeEventListener('mousemove', this.handlePanning, s),
          window.removeEventListener('mouseup', this.handleStopPanning, s),
          handleDisableAnimation.call(this)
      }),
      (a.prototype.componentDidUpdate = function(s, $) {
        var j = this.state,
          _e = j.wrapperComponent,
          et = j.contentComponent,
          tt = this.props.dynamicValues
        if (
          (!$.contentComponent &&
            et &&
            (this.stateProvider.contentComponent = et),
          !$.wrapperComponent && _e && _e !== void 0)
        ) {
          ;(this.stateProvider.wrapperComponent = _e),
            (this.windowToWrapperScaleX = getWindowScaleX(_e)),
            (this.windowToWrapperScaleY = getWindowScaleY(_e))
          var rt = !1
          _e.addEventListener('wheel', this.handleWheel, rt),
            _e.addEventListener('dblclick', this.handleDbClick, rt),
            _e.addEventListener('touchstart', this.handleTouchStart, rt),
            _e.addEventListener('touchmove', this.handleTouch, rt),
            _e.addEventListener('touchend', this.handleTouchStop, rt)
        }
        ;((_e && et) || s.dynamicValues !== tt) &&
          (this.maxBounds = handleCalculateBounds.call(
            this,
            this.stateProvider.scale,
            this.stateProvider.options.limitToWrapper
          )),
          s.dynamicValues &&
            s.dynamicValues !== tt &&
            ((this.animation = null),
            (this.stateProvider = __assign$1(
              __assign$1({}, this.stateProvider),
              mergeProps(this.stateProvider, tt)
            )),
            this.applyTransformation(null, null, null))
      }),
      (a.prototype.render = function() {
        var s = this.state,
          $ = s.wrapperComponent,
          j = s.contentComponent,
          _e = {
            loaded: !!($ && j),
            state: this.getCallbackProps(),
            dispatch: {
              setScale: this.setScale,
              setPositionX: this.setPositionX,
              setPositionY: this.setPositionY,
              zoomIn: this.zoomIn,
              zoomOut: this.zoomOut,
              setTransform: this.setTransform,
              resetTransform: this.resetTransform,
              setDefaultState: this.setDefaultState,
            },
            nodes: {
              setWrapperComponent: this.setWrapperComponent,
              setContentComponent: this.setContentComponent,
            },
          },
          et = this.props.children,
          tt =
            typeof et == 'function'
              ? et(__assign$1(__assign$1({}, _e.state), _e.dispatch))
              : et
        return React$5.createElement(Context.Provider, { value: _e }, tt)
      }),
      a
    )
  })(reactExports.Component),
  TransformWrapper = function(o) {
    var a = o.children,
      s = o.defaultPositionX,
      $ = o.defaultPositionY,
      j = o.defaultScale,
      _e = o.onWheelStart,
      et = o.onWheel,
      tt = o.onWheelStop,
      rt = o.onPanningStart,
      nt = o.onPanning,
      it = o.onPanningStop,
      ot = o.onPinchingStart,
      at = o.onPinching,
      st = o.onPinchingStop,
      ut = o.onZoomChange,
      ct = __rest$1(o, [
        'children',
        'defaultPositionX',
        'defaultPositionY',
        'defaultScale',
        'onWheelStart',
        'onWheel',
        'onWheelStop',
        'onPanningStart',
        'onPanning',
        'onPanningStop',
        'onPinchingStart',
        'onPinching',
        'onPinchingStop',
        'onZoomChange',
      ]),
      dt = __assign$1({}, ct)
    return (
      dt.options &&
        dt.options.limitToWrapper &&
        (dt.options.limitToBounds = !0),
      React$5.createElement(
        StateProvider,
        {
          defaultValues: deleteUndefinedProps({
            positionX: s,
            positionY: $,
            scale: j,
          }),
          dynamicValues: deleteUndefinedProps(getValidPropsFromObject(dt)),
          onWheelStart: _e,
          onWheel: et,
          onWheelStop: tt,
          onPanningStart: rt,
          onPanning: nt,
          onPanningStop: it,
          onPinchingStart: ot,
          onPinching: at,
          onPinchingStop: st,
          onZoomChange: ut,
        },
        a
      )
    )
  }
function styleInject(o, a) {
  a === void 0 && (a = {})
  var s = a.insertAt
  if (!(typeof document > 'u')) {
    var $ = document.head || document.getElementsByTagName('head')[0],
      j = document.createElement('style')
    ;(j.type = 'text/css'),
      s === 'top' && $.firstChild
        ? $.insertBefore(j, $.firstChild)
        : $.appendChild(j),
      j.styleSheet
        ? (j.styleSheet.cssText = o)
        : j.appendChild(document.createTextNode(o))
  }
}
var css = `.TransformComponent-module_container__3NwNd {
  position: relative;
  width: fit-content;
  height: fit-content;
  overflow: hidden;
  -webkit-touch-callout: none; /* iOS Safari */
  -webkit-user-select: none; /* Safari */
  -khtml-user-select: none; /* Konqueror HTML */
  -moz-user-select: none; /* Firefox */
  -ms-user-select: none; /* Internet Explorer/Edge */
  user-select: none;
  margin: 0;
  padding: 0;
}
.TransformComponent-module_content__TZU5O {
  display: flex;
  flex-wrap: wrap;
  width: fit-content;
  height: fit-content;
  margin: 0;
  padding: 0;
  transform-origin: 0% 0%;
}
.TransformComponent-module_content__TZU5O img {
  pointer-events: none;
}
`,
  styles = {
    container: 'TransformComponent-module_container__3NwNd',
    content: 'TransformComponent-module_content__TZU5O',
  }
styleInject(css)
var TransformComponent = (function(o) {
  __extends$1(a, o)
  function a() {
    var s = (o !== null && o.apply(this, arguments)) || this
    return (
      (s.wrapperRef = React$5.createRef()),
      (s.contentRef = React$5.createRef()),
      s
    )
  }
  return (
    (a.prototype.componentDidMount = function() {
      var s = this.context.nodes
      s.setWrapperComponent(this.wrapperRef.current),
        s.setContentComponent(this.contentRef.current)
    }),
    (a.prototype.render = function() {
      var s = this.props.children,
        $ = this.context.state,
        j = $.positionX,
        _e = $.positionY,
        et = $.scale,
        tt = $.options,
        rt = tt.wrapperClass,
        nt = tt.contentClass,
        it = {
          WebkitTransform:
            'translate(' + j + 'px, ' + _e + 'px) scale(' + et + ')',
          transform: 'translate(' + j + 'px, ' + _e + 'px) scale(' + et + ')',
        }
      return React$5.createElement(
        'div',
        {
          ref: this.wrapperRef,
          className: 'react-transform-component ' + styles.container + ' ' + rt,
        },
        React$5.createElement(
          'div',
          {
            ref: this.contentRef,
            className: 'react-transform-element ' + styles.content + ' ' + nt,
            style: it,
          },
          s
        )
      )
    }),
    a
  )
})(React$5.Component)
TransformComponent.contextType = Context
const getBackgroundStyles = o => {
  if (!o) return null
  const a = []
  return (
    o.fertilizerType === fertilizerType.STANDARD
      ? a.push(`url(${plotStates['fertilized-plot']})`)
      : o.fertilizerType === fertilizerType.RAINBOW &&
        a.push(`url(${plotStates['rainbow-fertilized-plot']})`),
    o.wasWateredToday
      ? a.push(`url(${plotStates['watered-plot']})`)
      : o.isShoveled && a.push(`url(${plotStates['shoveled-plot']})`),
    a.join(', ')
  )
}
/*!
 * @param {(farmhand.plotContent|farmhand.crop)?} plotContent
 * @returns {number?}
 */ const getDaysLeftToMature = o =>
    o && o.daysWatered > -1
      ? Math.max(
          0,
          Math.ceil(
            (getCropLifecycleDuration(o ? itemsMap[o.itemId] : null) -
              o.daysWatered) /
              (1 +
                (o.fertilizerType === fertilizerType.NONE
                  ? 0
                  : FERTILIZER_BONUS))
          )
        )
      : null,
  Plot = ({
    handlePlotClick: o,
    isInHoverRange: a,
    plotContent: s,
    selectedItemId: $,
    setHoveredPlot: j,
    x: _e,
    y: et,
    image: tt = getPlotImage(s, _e, et),
    lifeStage: rt = s &&
      getPlotContentType(s) === itemType.CROP &&
      getCropLifeStage(s),
    canBeHarvested: nt = rt === cropLifeStage.GROWN ||
      (s && getPlotContentType(s) === itemType.WEED),
  }) => {
    var pt
    const it = s ? itemsMap[s.itemId] : null,
      ot = getDaysLeftToMature(s),
      at = s && getPlotContentType(s) === itemType.CROP,
      st =
        ((pt = itemsMap[s == null ? void 0 : s.itemId]) == null
          ? void 0
          : pt.type) === itemType.SCARECROW,
      [ut, ct] = reactExports.useState(!1),
      [dt, ft] = reactExports.useState(!!(s != null && s.isShoveled))
    reactExports.useEffect(() => {
      !dt && s != null && s.isShoveled && s != null && s.oreId && ct(!0)
    }, [dt, s]),
      reactExports.useEffect(() => {
        s === null && (ft(!1), ct(!1))
      }, [s])
    const mt = !!(
      tt &&
      (ut || s.itemId || getPlotContentType(s) === itemType.CROP)
    )
    let vt = null
    if (it) {
      const ht =
          it.type === itemType.CROP &&
          getCropLifeStage(s) === cropLifeStage.SEED,
        At = cropItemIdToSeedItemMap[it.id]
      vt = ht ? At.name : it.name
    } else if (ut || (s != null && s.isShoveled)) {
      const ht = itemsMap[s == null ? void 0 : s.oreId]
      vt = ht ? SHOVELED_PLOT`${ht}` : SHOVELED
    }
    const yt = jsxRuntimeExports.jsx('div', {
      className: classNames('Plot', {
        'is-empty': !s,
        'is-in-hover-range': a,
        crop: at,
        'can-be-harvested': nt,
        'can-be-fertilized':
          (at && s.fertilizerType === fertilizerType.NONE) ||
          (st &&
            s.fertilizerType === fertilizerType.NONE &&
            $ === 'rainbow-fertilizer'),
        'can-be-mined': !s,
        'is-replantable': s && (it == null ? void 0 : it.isReplantable),
      }),
      style: { backgroundImage: getBackgroundStyles(s) },
      onClick: () => o(_e, et),
      onMouseOver: () => j({ x: _e, y: et }),
      children: jsxRuntimeExports.jsx('img', {
        className: classNames('square', {
          ...(at && { animated: nt, heartBeat: nt }),
          ...(ut && { animated: !0, 'was-just-shoveled': !0 }),
        }),
        style: { backgroundImage: mt ? `url(${tt})` : void 0 },
        src: pixel,
        alt: vt ?? 'Empty plot',
      }),
    })
    return s
      ? jsxRuntimeExports.jsx(Tooltip, {
          followCursor: !0,
          placement: 'top',
          title: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              vt ? jsxRuntimeExports.jsx(Typography, { children: vt }) : null,
              at &&
                jsxRuntimeExports.jsx(Typography, {
                  children: ot
                    ? `Days of watering to mature: ${ot}`
                    : 'Ready to harvest!',
                }),
            ],
          }),
          children: yt,
        })
      : yt
  }
Plot.propTypes = {
  handlePlotClick: propTypesExports.func.isRequired,
  isInHoverRange: propTypesExports.bool.isRequired,
  lifeStage: propTypesExports.string,
  plotContent: propTypesExports.object,
  selectedItemId: propTypesExports.string.isRequired,
  setHoveredPlot: propTypesExports.func.isRequired,
  x: propTypesExports.number.isRequired,
  y: propTypesExports.number.isRequired,
}
function Consumer$b(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Plot, { ...a, ...s, ...o }),
  })
}
const GridContext = reactExports.createContext()
function getGridUtilityClass(o) {
  return generateUtilityClass('MuiGrid', o)
}
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
  DIRECTIONS = ['column-reverse', 'column', 'row-reverse', 'row'],
  WRAPS = ['nowrap', 'wrap-reverse', 'wrap'],
  GRID_SIZES = ['auto', !0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],
  gridClasses = generateUtilityClasses('MuiGrid', [
    'root',
    'container',
    'item',
    'zeroMinWidth',
    ...SPACINGS.map(o => `spacing-xs-${o}`),
    ...DIRECTIONS.map(o => `direction-xs-${o}`),
    ...WRAPS.map(o => `wrap-xs-${o}`),
    ...GRID_SIZES.map(o => `grid-xs-${o}`),
    ...GRID_SIZES.map(o => `grid-sm-${o}`),
    ...GRID_SIZES.map(o => `grid-md-${o}`),
    ...GRID_SIZES.map(o => `grid-lg-${o}`),
    ...GRID_SIZES.map(o => `grid-xl-${o}`),
  ]),
  _excluded = [
    'className',
    'columns',
    'columnSpacing',
    'component',
    'container',
    'direction',
    'item',
    'rowSpacing',
    'spacing',
    'wrap',
    'zeroMinWidth',
  ]
function getOffset(o) {
  const a = parseFloat(o)
  return `${a}${String(o).replace(String(a), '') || 'px'}`
}
function generateGrid({ theme: o, ownerState: a }) {
  let s
  return o.breakpoints.keys.reduce(($, j) => {
    let _e = {}
    if ((a[j] && (s = a[j]), !s)) return $
    if (s === !0) _e = { flexBasis: 0, flexGrow: 1, maxWidth: '100%' }
    else if (s === 'auto')
      _e = {
        flexBasis: 'auto',
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: 'none',
        width: 'auto',
      }
    else {
      const et = resolveBreakpointValues({
          values: a.columns,
          breakpoints: o.breakpoints.values,
        }),
        tt = typeof et == 'object' ? et[j] : et
      if (tt == null) return $
      const rt = `${Math.round((s / tt) * 1e8) / 1e6}%`
      let nt = {}
      if (a.container && a.item && a.columnSpacing !== 0) {
        const it = o.spacing(a.columnSpacing)
        if (it !== '0px') {
          const ot = `calc(${rt} + ${getOffset(it)})`
          nt = { flexBasis: ot, maxWidth: ot }
        }
      }
      _e = _extends$5({ flexBasis: rt, flexGrow: 0, maxWidth: rt }, nt)
    }
    return (
      o.breakpoints.values[j] === 0
        ? Object.assign($, _e)
        : ($[o.breakpoints.up(j)] = _e),
      $
    )
  }, {})
}
function generateDirection({ theme: o, ownerState: a }) {
  const s = resolveBreakpointValues({
    values: a.direction,
    breakpoints: o.breakpoints.values,
  })
  return handleBreakpoints({ theme: o }, s, $ => {
    const j = { flexDirection: $ }
    return (
      $.indexOf('column') === 0 &&
        (j[`& > .${gridClasses.item}`] = { maxWidth: 'none' }),
      j
    )
  })
}
function extractZeroValueBreakpointKeys({ breakpoints: o, values: a }) {
  let s = ''
  Object.keys(a).forEach(j => {
    s === '' && a[j] !== 0 && (s = j)
  })
  const $ = Object.keys(o).sort((j, _e) => o[j] - o[_e])
  return $.slice(0, $.indexOf(s))
}
function generateRowGap({ theme: o, ownerState: a }) {
  const { container: s, rowSpacing: $ } = a
  let j = {}
  if (s && $ !== 0) {
    const _e = resolveBreakpointValues({
      values: $,
      breakpoints: o.breakpoints.values,
    })
    let et
    typeof _e == 'object' &&
      (et = extractZeroValueBreakpointKeys({
        breakpoints: o.breakpoints.values,
        values: _e,
      })),
      (j = handleBreakpoints({ theme: o }, _e, (tt, rt) => {
        var nt
        const it = o.spacing(tt)
        return it !== '0px'
          ? {
              marginTop: `-${getOffset(it)}`,
              [`& > .${gridClasses.item}`]: { paddingTop: getOffset(it) },
            }
          : (nt = et) != null && nt.includes(rt)
          ? {}
          : { marginTop: 0, [`& > .${gridClasses.item}`]: { paddingTop: 0 } }
      }))
  }
  return j
}
function generateColumnGap({ theme: o, ownerState: a }) {
  const { container: s, columnSpacing: $ } = a
  let j = {}
  if (s && $ !== 0) {
    const _e = resolveBreakpointValues({
      values: $,
      breakpoints: o.breakpoints.values,
    })
    let et
    typeof _e == 'object' &&
      (et = extractZeroValueBreakpointKeys({
        breakpoints: o.breakpoints.values,
        values: _e,
      })),
      (j = handleBreakpoints({ theme: o }, _e, (tt, rt) => {
        var nt
        const it = o.spacing(tt)
        return it !== '0px'
          ? {
              width: `calc(100% + ${getOffset(it)})`,
              marginLeft: `-${getOffset(it)}`,
              [`& > .${gridClasses.item}`]: { paddingLeft: getOffset(it) },
            }
          : (nt = et) != null && nt.includes(rt)
          ? {}
          : {
              width: '100%',
              marginLeft: 0,
              [`& > .${gridClasses.item}`]: { paddingLeft: 0 },
            }
      }))
  }
  return j
}
function resolveSpacingStyles(o, a, s = {}) {
  if (!o || o <= 0) return []
  if (
    (typeof o == 'string' && !Number.isNaN(Number(o))) ||
    typeof o == 'number'
  )
    return [s[`spacing-xs-${String(o)}`]]
  const $ = []
  return (
    a.forEach(j => {
      const _e = o[j]
      Number(_e) > 0 && $.push(s[`spacing-${j}-${String(_e)}`])
    }),
    $
  )
}
const GridRoot = styled('div', {
  name: 'MuiGrid',
  slot: 'Root',
  overridesResolver: (o, a) => {
    const { ownerState: s } = o,
      {
        container: $,
        direction: j,
        item: _e,
        spacing: et,
        wrap: tt,
        zeroMinWidth: rt,
        breakpoints: nt,
      } = s
    let it = []
    $ && (it = resolveSpacingStyles(et, nt, a))
    const ot = []
    return (
      nt.forEach(at => {
        const st = s[at]
        st && ot.push(a[`grid-${at}-${String(st)}`])
      }),
      [
        a.root,
        $ && a.container,
        _e && a.item,
        rt && a.zeroMinWidth,
        ...it,
        j !== 'row' && a[`direction-xs-${String(j)}`],
        tt !== 'wrap' && a[`wrap-xs-${String(tt)}`],
        ...ot,
      ]
    )
  },
})(
  ({ ownerState: o }) =>
    _extends$5(
      { boxSizing: 'border-box' },
      o.container && { display: 'flex', flexWrap: 'wrap', width: '100%' },
      o.item && { margin: 0 },
      o.zeroMinWidth && { minWidth: 0 },
      o.wrap !== 'wrap' && { flexWrap: o.wrap }
    ),
  generateDirection,
  generateRowGap,
  generateColumnGap,
  generateGrid
)
function resolveSpacingClasses(o, a) {
  if (!o || o <= 0) return []
  if (
    (typeof o == 'string' && !Number.isNaN(Number(o))) ||
    typeof o == 'number'
  )
    return [`spacing-xs-${String(o)}`]
  const s = []
  return (
    a.forEach($ => {
      const j = o[$]
      if (Number(j) > 0) {
        const _e = `spacing-${$}-${String(j)}`
        s.push(_e)
      }
    }),
    s
  )
}
const useUtilityClasses = o => {
    const {
      classes: a,
      container: s,
      direction: $,
      item: j,
      spacing: _e,
      wrap: et,
      zeroMinWidth: tt,
      breakpoints: rt,
    } = o
    let nt = []
    s && (nt = resolveSpacingClasses(_e, rt))
    const it = []
    rt.forEach(at => {
      const st = o[at]
      st && it.push(`grid-${at}-${String(st)}`)
    })
    const ot = {
      root: [
        'root',
        s && 'container',
        j && 'item',
        tt && 'zeroMinWidth',
        ...nt,
        $ !== 'row' && `direction-xs-${String($)}`,
        et !== 'wrap' && `wrap-xs-${String(et)}`,
        ...it,
      ],
    }
    return composeClasses(ot, getGridUtilityClass, a)
  },
  Grid = reactExports.forwardRef(function o(a, s) {
    const $ = useDefaultProps({ props: a, name: 'MuiGrid' }),
      { breakpoints: j } = useTheme$1(),
      _e = extendSxProp($),
      {
        className: et,
        columns: tt,
        columnSpacing: rt,
        component: nt = 'div',
        container: it = !1,
        direction: ot = 'row',
        item: at = !1,
        rowSpacing: st,
        spacing: ut = 0,
        wrap: ct = 'wrap',
        zeroMinWidth: dt = !1,
      } = _e,
      ft = _objectWithoutPropertiesLoose$3(_e, _excluded),
      mt = st || ut,
      vt = rt || ut,
      yt = reactExports.useContext(GridContext),
      pt = it ? tt || 12 : yt,
      ht = {},
      At = _extends$5({}, ft)
    j.keys.forEach(Dt => {
      ft[Dt] != null && ((ht[Dt] = ft[Dt]), delete At[Dt])
    })
    const wt = _extends$5(
        {},
        _e,
        {
          columns: pt,
          container: it,
          direction: ot,
          item: at,
          rowSpacing: mt,
          columnSpacing: vt,
          wrap: ct,
          zeroMinWidth: dt,
          spacing: ut,
        },
        ht,
        { breakpoints: j.keys }
      ),
      Ct = useUtilityClasses(wt)
    return jsxRuntimeExports.jsx(GridContext.Provider, {
      value: pt,
      children: jsxRuntimeExports.jsx(
        GridRoot,
        _extends$5(
          { ownerState: wt, className: clsx$1(Ct.root, et), as: nt, ref: s },
          At
        )
      ),
    })
  }),
  {
    CLEANUP: CLEANUP$2,
    HARVEST: HARVEST$2,
    MINE: MINE$2,
    WATER: WATER$2,
  } = fieldMode,
  tools = {
    wateringCan: {
      alt: WATERING_CAN_ALT_TEXT,
      fieldKey: 'shift+1',
      fieldMode: WATER$2,
      hiddenText: WATERING_CAN_HIDDEN_TEXT,
      id: 'watering-can',
      levelInfo: TOOL_LEVEL_INFO.WATERING_CAN,
      order: 1,
      type: toolType.WATERING_CAN,
    },
    scythe: {
      alt: SCYTHE_ALT_TEXT,
      fieldKey: 'shift+2',
      fieldMode: HARVEST$2,
      hiddenText: SCYTHE_HIDDEN_TEXT,
      id: 'scythe',
      levelInfo: TOOL_LEVEL_INFO.SCYTHE,
      order: 2,
      type: toolType.SCYTHE,
    },
    hoe: {
      alt: HOE_ALT_TEXT,
      fieldKey: 'shift+3',
      fieldMode: CLEANUP$2,
      hiddenText: HOE_HIDDEN_TEXT,
      id: 'hoe',
      levelInfo: TOOL_LEVEL_INFO.HOE,
      order: 3,
      type: toolType.HOE,
    },
    shovel: {
      alt: SHOVEL_ALT_TEXT,
      fieldKey: 'shift+4',
      fieldMode: MINE$2,
      hiddenText: SHOVEL_HIDDEN_TEXT,
      id: 'shovel',
      levelInfo: TOOL_LEVEL_INFO.SHOVEL,
      order: 4,
      type: toolType.SHOVEL,
    },
  },
  getTools = memoize(o => {
    const a = []
    for (let s of Object.values(tools))
      o[s.type] !== toolLevel.UNAVAILABLE && a.push(s)
    return a.sort((s, $) => s.order > $.order)
  }),
  getToolImage = o => {
    if (o.level === toolLevel.DEFAULT) return tools$1[o.id]
    const a = `${o.id}-${o.level.toLowerCase()}`
    return craftedItems[a]
  },
  Toolbelt = ({ fieldMode: o, handleFieldModeSelect: a, toolLevels: s }) => {
    const $ = getTools(s)
    return jsxRuntimeExports.jsx('div', {
      className: 'Toolbelt',
      children: jsxRuntimeExports.jsx('div', {
        className: 'button-array',
        children: $.map(
          ({
            alt: j,
            fieldMode: _e,
            fieldKey: et,
            hiddenText: tt,
            id: rt,
            levelInfo: nt,
            type: it,
          }) =>
            jsxRuntimeExports.jsx(Tooltip, {
              followCursor: !0,
              key: _e,
              placement: 'top',
              title: jsxRuntimeExports.jsxs(Typography, {
                component: 'div',
                children: [
                  jsxRuntimeExports.jsx('p', { children: j }),
                  jsxRuntimeExports.jsx(ReactMarkdown$1, {
                    className: 'markdown',
                    source: nt[s[it]],
                  }),
                  jsxRuntimeExports.jsxs('p', { children: ['(', et, ')'] }),
                ],
              }),
              children: jsxRuntimeExports.jsxs(Button, {
                className: classNames({ selected: _e === o }),
                color: 'primary',
                onClick: () => a(_e),
                variant: _e === o ? 'contained' : 'text',
                children: [
                  jsxRuntimeExports.jsx('img', {
                    className: `square ${rt}`,
                    src: pixel,
                    style: {
                      backgroundImage: `url(${getToolImage({
                        level: s[it],
                        id: rt,
                      })})`,
                    },
                    alt: j,
                  }),
                  jsxRuntimeExports.jsx('span', {
                    className: 'visually_hidden',
                    children: tt,
                  }),
                ],
              }),
            })
        ),
      }),
    })
  }
Toolbelt.propTypes = {
  fieldMode: PropTypes$1.string.isRequired,
  handleFieldModeSelect: PropTypes$1.func,
}
Toolbelt.defaultProps = { handleFieldModeSelect: noop$2, toolLevels: {} }
function Consumer$a(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Toolbelt, { ...a, ...s, ...o }),
  })
}
const ItemList = ({
  handleItemSelectClick: o,
  items: a,
  playerInventoryQuantities: s,
  selectedItemId: $,
}) =>
  jsxRuntimeExports.jsx('div', {
    className: 'button-array',
    children: sortItems(a).map(j =>
      jsxRuntimeExports.jsx(Tooltip, {
        followCursor: !0,
        key: j.id,
        placement: 'top',
        title: jsxRuntimeExports.jsx(Typography, { children: j.name }),
        children: jsxRuntimeExports.jsxs(Button, {
          className: classNames({ 'is-selected': j.id === $ }),
          color: 'primary',
          onClick: () => o(j),
          variant: j.id === $ ? 'contained' : 'text',
          children: [
            jsxRuntimeExports.jsx('img', {
              alt: j.name,
              className: 'square',
              src: pixel,
              style: { backgroundImage: `url(${items[j.id]}` },
            }),
            jsxRuntimeExports.jsx('p', {
              className: 'quantity',
              children: integerString(s[j.id]),
            }),
          ],
        }),
      })
    ),
  })
ItemList.propTypes = {
  handleItemSelectClick: propTypesExports.func,
  items: propTypesExports.array.isRequired,
  playerInventoryQuantities: propTypesExports.object.isRequired,
  selectedItemId: propTypesExports.string.isRequired,
}
const QuickSelect = ({
  fieldToolInventory: o,
  handleItemSelectClick: a,
  playerInventoryQuantities: s,
  plantableCropInventory: $,
  selectedItemId: j,
}) =>
  jsxRuntimeExports.jsx(Paper, {
    className: 'QuickSelect',
    elevation: 10,
    children: jsxRuntimeExports.jsxs(Grid, {
      container: !0,
      alignItems: 'center',
      wrap: 'nowrap',
      children: [
        jsxRuntimeExports.jsx(Consumer$a, {}),
        $.length > 0 &&
          jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              jsxRuntimeExports.jsx(Divider, {
                orientation: 'vertical',
                flexItem: !0,
              }),
              jsxRuntimeExports.jsx(ItemList, {
                handleItemSelectClick: a,
                items: $,
                playerInventoryQuantities: s,
                selectedItemId: j,
              }),
            ],
          }),
        o.length > 0 &&
          jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              jsxRuntimeExports.jsx(Divider, {
                orientation: 'vertical',
                flexItem: !0,
              }),
              jsxRuntimeExports.jsx(ItemList, {
                handleItemSelectClick: a,
                items: o,
                playerInventoryQuantities: s,
                selectedItemId: j,
              }),
            ],
          }),
      ],
    }),
  })
QuickSelect.propTypes = {
  fieldToolInventory: propTypesExports.array.isRequired,
  handleItemSelectClick: propTypesExports.func,
  plantableCropInventory: propTypesExports.array.isRequired,
  playerInventoryQuantities: propTypesExports.object.isRequired,
  selectedItemId: propTypesExports.string.isRequired,
}
function Consumer$9(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(QuickSelect, { ...a, ...s, ...o }),
  })
}
const {
    CLEANUP: CLEANUP$1,
    FERTILIZE,
    HARVEST: HARVEST$1,
    MINE: MINE$1,
    OBSERVE: OBSERVE$1,
    PLANT: PLANT$1,
    SET_SCARECROW,
    SET_SPRINKLER,
    WATER: WATER$1,
  } = fieldMode,
  zoomKeyMap = { zoomIn: ['=', 'plus'], zoomOut: '-' },
  fieldKeyMap = {
    selectWateringCan: tools.wateringCan.fieldKey,
    selectScythe: tools.scythe.fieldKey,
    selectHoe: tools.hoe.fieldKey,
  }
tools.shovel && (fieldKeyMap.selectShovel = tools.shovel.fieldKey)
const isInHoverRange = ({
    experience: o,
    fieldMode: a,
    hoveredPlotRangeSize: s,
    hoveredPlot: { x: $, y: j },
    x: _e,
    y: et,
  }) => {
    if ($ == null || a === OBSERVE$1) return !1
    let tt = s
    switch (a) {
      case SET_SPRINKLER:
        tt = getLevelEntitlements(levelAchieved(o)).sprinklerRange
        break
      case SET_SCARECROW:
        tt = Number.MAX_SAFE_INTEGER
        break
    }
    const rt = 2 * tt,
      nt = $ - tt,
      it = j - tt,
      ot = nt + rt,
      at = it + rt
    return _e >= nt && _e <= ot && et >= it && et <= at
  },
  MemoPlot = reactExports.memo(
    o => {
      const {
        hoveredPlot: a,
        plotContent: s,
        setHoveredPlot: $,
        x: j,
        y: _e,
      } = o
      return jsxRuntimeExports.jsx(Consumer$b, {
        hoveredPlot: a,
        isInHoverRange: isInHoverRange(o),
        plotContent: s,
        setHoveredPlot: $,
        x: j,
        y: _e,
      })
    },
    (o, a) =>
      isInHoverRange(o) !== isInHoverRange(a)
        ? !1
        : o.plotContent === a.plotContent &&
          o.hoveredPlotRangeSize === a.hoveredPlotRangeSize
  )
MemoPlot.propTypes = {
  experience: propTypesExports.number.isRequired,
  fieldMode: propTypesExports.string.isRequired,
  hoveredPlot: propTypesExports.object.isRequired,
  hoveredPlotRangeSize: propTypesExports.number.isRequired,
  plotContent: propTypesExports.object,
  setHoveredPlot: propTypesExports.func.isRequired,
  x: propTypesExports.number.isRequired,
  y: propTypesExports.number.isRequired,
}
const FieldContentWrapper = ({
  fieldContent: o,
  previousScale: a,
  resetTransform: s,
  scale: $,
  zoomIn: j,
  zoomOut: _e,
}) => (
  reactExports.useEffect(() => {
    $ === 1 && a !== 1 && s()
  }, [$, a, s]),
  jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [
      jsxRuntimeExports.jsx(index_esExports.GlobalHotKeys, {
        keyMap: zoomKeyMap,
        handlers: { zoomIn: j, zoomOut: _e },
      }),
      jsxRuntimeExports.jsx(TransformComponent, { children: o }),
      jsxRuntimeExports.jsx('div', {
        className: 'fab-buttons zoom-controls zoom-in-wrapper',
        children: jsxRuntimeExports.jsx(Tooltip, {
          placement: 'top',
          title: 'Zoom In',
          children: jsxRuntimeExports.jsx(Fab, {
            'aria-label': 'Zoom In',
            color: 'primary',
            onClick: j,
            children: jsxRuntimeExports.jsx(default_1$1, {}),
          }),
        }),
      }),
      jsxRuntimeExports.jsx('div', {
        className: 'fab-buttons zoom-controls zoom-out-wrapper',
        children: jsxRuntimeExports.jsx(Tooltip, {
          placement: 'top',
          title: 'Zoom Out',
          children: jsxRuntimeExports.jsx(Fab, {
            'aria-label': 'Zoom Out',
            color: 'primary',
            onClick: _e,
            children: jsxRuntimeExports.jsx(default_1, {}),
          }),
        }),
      }),
    ],
  })
)
FieldContentWrapper.propTypes = {
  fieldContent: propTypesExports.element.isRequired,
}
const FieldContent = ({
  columns: o,
  experience: a,
  field: s,
  fieldMode: $,
  handleCombineEnabledChange: j,
  hoveredPlot: _e,
  hoveredPlotRangeSize: et,
  isCombineEnabled: tt,
  purchasedCombine: rt,
  rows: nt,
  setHoveredPlot: it,
}) =>
  jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [
      jsxRuntimeExports.jsx('div', {
        className: 'row-wrapper',
        onMouseLeave: () => it({ x: null, y: null }),
        children: nullArray(nt).map((ot, at) =>
          jsxRuntimeExports.jsx(
            'div',
            {
              className: 'row',
              children: nullArray(o).map((st, ut, ct, dt = s[at][ut]) =>
                jsxRuntimeExports.jsx(
                  MemoPlot,
                  {
                    experience: a,
                    fieldMode: $,
                    hoveredPlot: _e,
                    hoveredPlotRangeSize: et,
                    plotContent: dt,
                    setHoveredPlot: it,
                    x: ut,
                    y: at,
                  },
                  ut
                )
              ),
            },
            at
          )
        ),
      }),
      rt
        ? jsxRuntimeExports.jsx(FormControl, {
            variant: 'standard',
            component: 'fieldset',
            children: jsxRuntimeExports.jsx(FormGroup, {
              children: jsxRuntimeExports.jsx(FormControlLabel, {
                control: jsxRuntimeExports.jsx(Switch, {
                  color: 'primary',
                  checked: tt,
                  onChange: j,
                  name: 'is-combine-enabled',
                }),
                label: 'Automatically harvest crops at the start of every day',
              }),
            }),
          })
        : null,
    ],
  })
FieldContent.propTypes = {
  columns: propTypesExports.number.isRequired,
  experience: propTypesExports.number.isRequired,
  field: propTypesExports.array.isRequired,
  fieldMode: propTypesExports.string.isRequired,
  handleCombineEnabledChange: propTypesExports.func.isRequired,
  hoveredPlot: propTypesExports.object.isRequired,
  hoveredPlotRangeSize: propTypesExports.number.isRequired,
  isCombineEnabled: propTypesExports.bool.isRequired,
  purchasedCombine: propTypesExports.number.isRequired,
  rows: propTypesExports.number.isRequired,
  setHoveredPlot: propTypesExports.func.isRequired,
}
const adjustableRangeFieldModes = new Set([
    CLEANUP$1,
    FERTILIZE,
    HARVEST$1,
    MINE$1,
    PLANT$1,
    WATER$1,
  ]),
  RangeSliderValueLabelComponent = ({ children: o, open: a, value: s }) =>
    jsxRuntimeExports.jsx(Tooltip, {
      open: a,
      placement: 'top',
      title: jsxRuntimeExports.jsxs(Typography, {
        children: ['Range: ', s, ' x ', s],
      }),
      children: o,
    }),
  Field = o => {
    const {
        field: a,
        fieldMode: s,
        handleFieldActionRangeChange: $,
        hoveredPlotRangeSize: j,
        inventory: _e,
        inventoryLimit: et,
        purchasedField: tt,
      } = o,
      [rt, nt] = reactExports.useState({ x: null, y: null }),
      [it, ot] = reactExports.useState(1),
      [at, st] = reactExports.useState(j)
    reactExports.useEffect(() => {
      st(j)
    }, [j])
    const ut = ct => {
      st(ct), $(ct)
    }
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsx(index_esExports.GlobalHotKeys, {
          keyMap: fieldKeyMap,
        }),
        jsxRuntimeExports.jsxs('div', {
          className: classNames('Field', {
            'cleanup-mode': s === CLEANUP$1,
            'fertilize-mode': s === FERTILIZE,
            'harvest-mode': s === HARVEST$1,
            'mine-mode': s === MINE$1,
            'is-inventory-full': !doesInventorySpaceRemain({
              inventory: _e,
              inventoryLimit: et,
            }),
            'plant-mode': s === PLANT$1,
            'set-scarecrow-mode': s === SET_SCARECROW,
            'set-sprinkler-mode': s === SET_SPRINKLER,
            'water-mode': s === WATER$1,
          }),
          'data-purchased-field': tt,
          'data-testid': 'field',
          children: [
            jsxRuntimeExports.jsx(TransformWrapper, {
              options: { limitToBounds: !1 },
              reset: { animationTime: 0 },
              pan: { disabled: it <= 1 },
              zoomIn: { animationTime: 0 },
              zoomOut: { animationTime: 0 },
              onZoomChange: ({ scale: ct }) => {
                ct >= 1 && ot(ct)
              },
              wheel: { disabled: !0 },
              doubleClick: { disabled: !0 },
              children: ct =>
                jsxRuntimeExports.jsx(FieldContentWrapper, {
                  ...ct,
                  fieldContent: jsxRuntimeExports.jsx(FieldContent, {
                    ...o,
                    hoveredPlot: rt,
                    setHoveredPlot: nt,
                  }),
                }),
            }),
            adjustableRangeFieldModes.has(s) &&
              jsxRuntimeExports.jsx('div', {
                className: 'slider-wrapper',
                children: jsxRuntimeExports.jsx(Slider, {
                  marks: !0,
                  max: a.length - 1,
                  min: 0,
                  onChange: (ct, dt) => ut(dt),
                  step: 1,
                  value: at,
                  valueLabelDisplay: 'auto',
                  valueLabelFormat: ct => `${ct * 2 + 1}`,
                  components: { ValueLabel: RangeSliderValueLabelComponent },
                }),
              }),
            jsxRuntimeExports.jsx(Consumer$9, {}),
          ],
        }),
      ],
    })
  }
Field.propTypes = {
  columns: propTypesExports.number.isRequired,
  experience: propTypesExports.number.isRequired,
  field: propTypesExports.array.isRequired,
  fieldMode: propTypesExports.string.isRequired,
  handleCombineEnabledChange: propTypesExports.func.isRequired,
  handleFieldActionRangeChange: propTypesExports.func.isRequired,
  hoveredPlotRangeSize: propTypesExports.number.isRequired,
  inventory: propTypesExports.array.isRequired,
  inventoryLimit: propTypesExports.number.isRequired,
  isCombineEnabled: propTypesExports.bool.isRequired,
  purchasedCombine: propTypesExports.number.isRequired,
  purchasedField: propTypesExports.number.isRequired,
  rows: propTypesExports.number.isRequired,
}
function Consumer$8(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Field, { ...a, ...s, ...o }),
  })
}
const Forest = () =>
  jsxRuntimeExports.jsx('div', { children: "'welcome to da forest'" })
propTypesExports.shape({
  description: propTypesExports.string.isRequired,
  id: propTypesExports.string.isRequired,
  name: propTypesExports.string.isRequired,
  rewardDescription: propTypesExports.string.isRequired,
}).isRequired,
  propTypesExports.object.isRequired,
  propTypesExports.bool
var useWindowSize$1 = {},
  extendStatics = function(o, a) {
    return (
      (extendStatics =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function(s, $) {
            s.__proto__ = $
          }) ||
        function(s, $) {
          for (var j in $)
            Object.prototype.hasOwnProperty.call($, j) && (s[j] = $[j])
        }),
      extendStatics(o, a)
    )
  }
function __extends(o, a) {
  if (typeof a != 'function' && a !== null)
    throw new TypeError(
      'Class extends value ' + String(a) + ' is not a constructor or null'
    )
  extendStatics(o, a)
  function s() {
    this.constructor = o
  }
  o.prototype =
    a === null ? Object.create(a) : ((s.prototype = a.prototype), new s())
}
var __assign = function() {
  return (
    (__assign =
      Object.assign ||
      function(a) {
        for (var s, $ = 1, j = arguments.length; $ < j; $++) {
          s = arguments[$]
          for (var _e in s)
            Object.prototype.hasOwnProperty.call(s, _e) && (a[_e] = s[_e])
        }
        return a
      }),
    __assign.apply(this, arguments)
  )
}
function __rest(o, a) {
  var s = {}
  for (var $ in o)
    Object.prototype.hasOwnProperty.call(o, $) &&
      a.indexOf($) < 0 &&
      (s[$] = o[$])
  if (o != null && typeof Object.getOwnPropertySymbols == 'function')
    for (var j = 0, $ = Object.getOwnPropertySymbols(o); j < $.length; j++)
      a.indexOf($[j]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(o, $[j]) &&
        (s[$[j]] = o[$[j]])
  return s
}
function __decorate(o, a, s, $) {
  var j = arguments.length,
    _e =
      j < 3 ? a : $ === null ? ($ = Object.getOwnPropertyDescriptor(a, s)) : $,
    et
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function')
    _e = Reflect.decorate(o, a, s, $)
  else
    for (var tt = o.length - 1; tt >= 0; tt--)
      (et = o[tt]) &&
        (_e = (j < 3 ? et(_e) : j > 3 ? et(a, s, _e) : et(a, s)) || _e)
  return j > 3 && _e && Object.defineProperty(a, s, _e), _e
}
function __param(o, a) {
  return function(s, $) {
    a(s, $, o)
  }
}
function __esDecorate(o, a, s, $, j, _e) {
  function et(ft) {
    if (ft !== void 0 && typeof ft != 'function')
      throw new TypeError('Function expected')
    return ft
  }
  for (
    var tt = $.kind,
      rt = tt === 'getter' ? 'get' : tt === 'setter' ? 'set' : 'value',
      nt = !a && o ? ($.static ? o : o.prototype) : null,
      it = a || (nt ? Object.getOwnPropertyDescriptor(nt, $.name) : {}),
      ot,
      at = !1,
      st = s.length - 1;
    st >= 0;
    st--
  ) {
    var ut = {}
    for (var ct in $) ut[ct] = ct === 'access' ? {} : $[ct]
    for (var ct in $.access) ut.access[ct] = $.access[ct]
    ut.addInitializer = function(ft) {
      if (at)
        throw new TypeError(
          'Cannot add initializers after decoration has completed'
        )
      _e.push(et(ft || null))
    }
    var dt = (0, s[st])(
      tt === 'accessor' ? { get: it.get, set: it.set } : it[rt],
      ut
    )
    if (tt === 'accessor') {
      if (dt === void 0) continue
      if (dt === null || typeof dt != 'object')
        throw new TypeError('Object expected')
      ;(ot = et(dt.get)) && (it.get = ot),
        (ot = et(dt.set)) && (it.set = ot),
        (ot = et(dt.init)) && j.unshift(ot)
    } else (ot = et(dt)) && (tt === 'field' ? j.unshift(ot) : (it[rt] = ot))
  }
  nt && Object.defineProperty(nt, $.name, it), (at = !0)
}
function __runInitializers(o, a, s) {
  for (var $ = arguments.length > 2, j = 0; j < a.length; j++)
    s = $ ? a[j].call(o, s) : a[j].call(o)
  return $ ? s : void 0
}
function __propKey(o) {
  return typeof o == 'symbol' ? o : ''.concat(o)
}
function __setFunctionName(o, a, s) {
  return (
    typeof a == 'symbol' &&
      (a = a.description ? '['.concat(a.description, ']') : ''),
    Object.defineProperty(o, 'name', {
      configurable: !0,
      value: s ? ''.concat(s, ' ', a) : a,
    })
  )
}
function __metadata(o, a) {
  if (typeof Reflect == 'object' && typeof Reflect.metadata == 'function')
    return Reflect.metadata(o, a)
}
function __awaiter(o, a, s, $) {
  function j(_e) {
    return _e instanceof s
      ? _e
      : new s(function(et) {
          et(_e)
        })
  }
  return new (s || (s = Promise))(function(_e, et) {
    function tt(it) {
      try {
        nt($.next(it))
      } catch (ot) {
        et(ot)
      }
    }
    function rt(it) {
      try {
        nt($.throw(it))
      } catch (ot) {
        et(ot)
      }
    }
    function nt(it) {
      it.done ? _e(it.value) : j(it.value).then(tt, rt)
    }
    nt(($ = $.apply(o, a || [])).next())
  })
}
function __generator(o, a) {
  var s = {
      label: 0,
      sent: function() {
        if (_e[0] & 1) throw _e[1]
        return _e[1]
      },
      trys: [],
      ops: [],
    },
    $,
    j,
    _e,
    et = Object.create(
      (typeof Iterator == 'function' ? Iterator : Object).prototype
    )
  return (
    (et.next = tt(0)),
    (et.throw = tt(1)),
    (et.return = tt(2)),
    typeof Symbol == 'function' &&
      (et[Symbol.iterator] = function() {
        return this
      }),
    et
  )
  function tt(nt) {
    return function(it) {
      return rt([nt, it])
    }
  }
  function rt(nt) {
    if ($) throw new TypeError('Generator is already executing.')
    for (; et && ((et = 0), nt[0] && (s = 0)), s; )
      try {
        if (
          (($ = 1),
          j &&
            (_e =
              nt[0] & 2
                ? j.return
                : nt[0]
                ? j.throw || ((_e = j.return) && _e.call(j), 0)
                : j.next) &&
            !(_e = _e.call(j, nt[1])).done)
        )
          return _e
        switch (((j = 0), _e && (nt = [nt[0] & 2, _e.value]), nt[0])) {
          case 0:
          case 1:
            _e = nt
            break
          case 4:
            return s.label++, { value: nt[1], done: !1 }
          case 5:
            s.label++, (j = nt[1]), (nt = [0])
            continue
          case 7:
            ;(nt = s.ops.pop()), s.trys.pop()
            continue
          default:
            if (
              ((_e = s.trys),
              !(_e = _e.length > 0 && _e[_e.length - 1]) &&
                (nt[0] === 6 || nt[0] === 2))
            ) {
              s = 0
              continue
            }
            if (nt[0] === 3 && (!_e || (nt[1] > _e[0] && nt[1] < _e[3]))) {
              s.label = nt[1]
              break
            }
            if (nt[0] === 6 && s.label < _e[1]) {
              ;(s.label = _e[1]), (_e = nt)
              break
            }
            if (_e && s.label < _e[2]) {
              ;(s.label = _e[2]), s.ops.push(nt)
              break
            }
            _e[2] && s.ops.pop(), s.trys.pop()
            continue
        }
        nt = a.call(o, s)
      } catch (it) {
        ;(nt = [6, it]), (j = 0)
      } finally {
        $ = _e = 0
      }
    if (nt[0] & 5) throw nt[1]
    return { value: nt[0] ? nt[1] : void 0, done: !0 }
  }
}
var __createBinding = Object.create
  ? function(o, a, s, $) {
      $ === void 0 && ($ = s)
      var j = Object.getOwnPropertyDescriptor(a, s)
      ;(!j || ('get' in j ? !a.__esModule : j.writable || j.configurable)) &&
        (j = {
          enumerable: !0,
          get: function() {
            return a[s]
          },
        }),
        Object.defineProperty(o, $, j)
    }
  : function(o, a, s, $) {
      $ === void 0 && ($ = s), (o[$] = a[s])
    }
function __exportStar(o, a) {
  for (var s in o)
    s !== 'default' &&
      !Object.prototype.hasOwnProperty.call(a, s) &&
      __createBinding(a, o, s)
}
function __values(o) {
  var a = typeof Symbol == 'function' && Symbol.iterator,
    s = a && o[a],
    $ = 0
  if (s) return s.call(o)
  if (o && typeof o.length == 'number')
    return {
      next: function() {
        return (
          o && $ >= o.length && (o = void 0), { value: o && o[$++], done: !o }
        )
      },
    }
  throw new TypeError(
    a ? 'Object is not iterable.' : 'Symbol.iterator is not defined.'
  )
}
function __read(o, a) {
  var s = typeof Symbol == 'function' && o[Symbol.iterator]
  if (!s) return o
  var $ = s.call(o),
    j,
    _e = [],
    et
  try {
    for (; (a === void 0 || a-- > 0) && !(j = $.next()).done; ) _e.push(j.value)
  } catch (tt) {
    et = { error: tt }
  } finally {
    try {
      j && !j.done && (s = $.return) && s.call($)
    } finally {
      if (et) throw et.error
    }
  }
  return _e
}
function __spread() {
  for (var o = [], a = 0; a < arguments.length; a++)
    o = o.concat(__read(arguments[a]))
  return o
}
function __spreadArrays() {
  for (var o = 0, a = 0, s = arguments.length; a < s; a++)
    o += arguments[a].length
  for (var $ = Array(o), j = 0, a = 0; a < s; a++)
    for (var _e = arguments[a], et = 0, tt = _e.length; et < tt; et++, j++)
      $[j] = _e[et]
  return $
}
function __spreadArray(o, a, s) {
  if (s || arguments.length === 2)
    for (var $ = 0, j = a.length, _e; $ < j; $++)
      (_e || !($ in a)) &&
        (_e || (_e = Array.prototype.slice.call(a, 0, $)), (_e[$] = a[$]))
  return o.concat(_e || Array.prototype.slice.call(a))
}
function __await(o) {
  return this instanceof __await ? ((this.v = o), this) : new __await(o)
}
function __asyncGenerator(o, a, s) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var $ = s.apply(o, a || []),
    j,
    _e = []
  return (
    (j = Object.create(
      (typeof AsyncIterator == 'function' ? AsyncIterator : Object).prototype
    )),
    tt('next'),
    tt('throw'),
    tt('return', et),
    (j[Symbol.asyncIterator] = function() {
      return this
    }),
    j
  )
  function et(st) {
    return function(ut) {
      return Promise.resolve(ut).then(st, ot)
    }
  }
  function tt(st, ut) {
    $[st] &&
      ((j[st] = function(ct) {
        return new Promise(function(dt, ft) {
          _e.push([st, ct, dt, ft]) > 1 || rt(st, ct)
        })
      }),
      ut && (j[st] = ut(j[st])))
  }
  function rt(st, ut) {
    try {
      nt($[st](ut))
    } catch (ct) {
      at(_e[0][3], ct)
    }
  }
  function nt(st) {
    st.value instanceof __await
      ? Promise.resolve(st.value.v).then(it, ot)
      : at(_e[0][2], st)
  }
  function it(st) {
    rt('next', st)
  }
  function ot(st) {
    rt('throw', st)
  }
  function at(st, ut) {
    st(ut), _e.shift(), _e.length && rt(_e[0][0], _e[0][1])
  }
}
function __asyncDelegator(o) {
  var a, s
  return (
    (a = {}),
    $('next'),
    $('throw', function(j) {
      throw j
    }),
    $('return'),
    (a[Symbol.iterator] = function() {
      return this
    }),
    a
  )
  function $(j, _e) {
    a[j] = o[j]
      ? function(et) {
          return (s = !s)
            ? { value: __await(o[j](et)), done: !1 }
            : _e
            ? _e(et)
            : et
        }
      : _e
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError('Symbol.asyncIterator is not defined.')
  var a = o[Symbol.asyncIterator],
    s
  return a
    ? a.call(o)
    : ((o = typeof __values == 'function' ? __values(o) : o[Symbol.iterator]()),
      (s = {}),
      $('next'),
      $('throw'),
      $('return'),
      (s[Symbol.asyncIterator] = function() {
        return this
      }),
      s)
  function $(_e) {
    s[_e] =
      o[_e] &&
      function(et) {
        return new Promise(function(tt, rt) {
          ;(et = o[_e](et)), j(tt, rt, et.done, et.value)
        })
      }
  }
  function j(_e, et, tt, rt) {
    Promise.resolve(rt).then(function(nt) {
      _e({ value: nt, done: tt })
    }, et)
  }
}
function __makeTemplateObject(o, a) {
  return (
    Object.defineProperty
      ? Object.defineProperty(o, 'raw', { value: a })
      : (o.raw = a),
    o
  )
}
var __setModuleDefault = Object.create
  ? function(o, a) {
      Object.defineProperty(o, 'default', { enumerable: !0, value: a })
    }
  : function(o, a) {
      o.default = a
    }
function __importStar(o) {
  if (o && o.__esModule) return o
  var a = {}
  if (o != null)
    for (var s in o)
      s !== 'default' &&
        Object.prototype.hasOwnProperty.call(o, s) &&
        __createBinding(a, o, s)
  return __setModuleDefault(a, o), a
}
function __importDefault(o) {
  return o && o.__esModule ? o : { default: o }
}
function __classPrivateFieldGet(o, a, s, $) {
  if (s === 'a' && !$)
    throw new TypeError('Private accessor was defined without a getter')
  if (typeof a == 'function' ? o !== a || !$ : !a.has(o))
    throw new TypeError(
      'Cannot read private member from an object whose class did not declare it'
    )
  return s === 'm' ? $ : s === 'a' ? $.call(o) : $ ? $.value : a.get(o)
}
function __classPrivateFieldSet(o, a, s, $, j) {
  if ($ === 'm') throw new TypeError('Private method is not writable')
  if ($ === 'a' && !j)
    throw new TypeError('Private accessor was defined without a setter')
  if (typeof a == 'function' ? o !== a || !j : !a.has(o))
    throw new TypeError(
      'Cannot write private member to an object whose class did not declare it'
    )
  return $ === 'a' ? j.call(o, s) : j ? (j.value = s) : a.set(o, s), s
}
function __classPrivateFieldIn(o, a) {
  if (a === null || (typeof a != 'object' && typeof a != 'function'))
    throw new TypeError("Cannot use 'in' operator on non-object")
  return typeof o == 'function' ? a === o : o.has(a)
}
function __addDisposableResource(o, a, s) {
  if (a != null) {
    if (typeof a != 'object' && typeof a != 'function')
      throw new TypeError('Object expected.')
    var $, j
    if (s) {
      if (!Symbol.asyncDispose)
        throw new TypeError('Symbol.asyncDispose is not defined.')
      $ = a[Symbol.asyncDispose]
    }
    if ($ === void 0) {
      if (!Symbol.dispose) throw new TypeError('Symbol.dispose is not defined.')
      ;($ = a[Symbol.dispose]), s && (j = $)
    }
    if (typeof $ != 'function') throw new TypeError('Object not disposable.')
    j &&
      ($ = function() {
        try {
          j.call(this)
        } catch (_e) {
          return Promise.reject(_e)
        }
      }),
      o.stack.push({ value: a, dispose: $, async: s })
  } else s && o.stack.push({ async: !0 })
  return a
}
var _SuppressedError =
  typeof SuppressedError == 'function'
    ? SuppressedError
    : function(o, a, s) {
        var $ = new Error(s)
        return (
          ($.name = 'SuppressedError'), ($.error = o), ($.suppressed = a), $
        )
      }
function __disposeResources(o) {
  function a(_e) {
    ;(o.error = o.hasError
      ? new _SuppressedError(
          _e,
          o.error,
          'An error was suppressed during disposal.'
        )
      : _e),
      (o.hasError = !0)
  }
  var s,
    $ = 0
  function j() {
    for (; (s = o.stack.pop()); )
      try {
        if (!s.async && $ === 1)
          return ($ = 0), o.stack.push(s), Promise.resolve().then(j)
        if (s.dispose) {
          var _e = s.dispose.call(s.value)
          if (s.async)
            return (
              ($ |= 2),
              Promise.resolve(_e).then(j, function(et) {
                return a(et), j()
              })
            )
        } else $ |= 1
      } catch (et) {
        a(et)
      }
    if ($ === 1) return o.hasError ? Promise.reject(o.error) : Promise.resolve()
    if (o.hasError) throw o.error
  }
  return j()
}
const tslib_es6 = {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __createBinding,
    __exportStar,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn,
    __addDisposableResource,
    __disposeResources,
  },
  tslib_es6$1 = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        __addDisposableResource,
        get __assign() {
          return __assign
        },
        __asyncDelegator,
        __asyncGenerator,
        __asyncValues,
        __await,
        __awaiter,
        __classPrivateFieldGet,
        __classPrivateFieldIn,
        __classPrivateFieldSet,
        __createBinding,
        __decorate,
        __disposeResources,
        __esDecorate,
        __exportStar,
        __extends,
        __generator,
        __importDefault,
        __importStar,
        __makeTemplateObject,
        __metadata,
        __param,
        __propKey,
        __read,
        __rest,
        __runInitializers,
        __setFunctionName,
        __spread,
        __spreadArray,
        __spreadArrays,
        __values,
        default: tslib_es6,
      },
      Symbol.toStringTag,
      { value: 'Module' }
    )
  ),
  require$$0 = getAugmentedNamespace(tslib_es6$1)
var useRafState = {},
  useUnmount = {},
  useEffectOnce = {},
  hasRequiredUseEffectOnce
function requireUseEffectOnce() {
  if (hasRequiredUseEffectOnce) return useEffectOnce
  ;(hasRequiredUseEffectOnce = 1),
    Object.defineProperty(useEffectOnce, '__esModule', { value: !0 })
  var o = reactExports,
    a = function(s) {
      o.useEffect(s, [])
    }
  return (useEffectOnce.default = a), useEffectOnce
}
var hasRequiredUseUnmount
function requireUseUnmount() {
  if (hasRequiredUseUnmount) return useUnmount
  ;(hasRequiredUseUnmount = 1),
    Object.defineProperty(useUnmount, '__esModule', { value: !0 })
  var o = require$$0,
    a = reactExports,
    s = o.__importDefault(requireUseEffectOnce()),
    $ = function(j) {
      var _e = a.useRef(j)
      ;(_e.current = j),
        s.default(function() {
          return function() {
            return _e.current()
          }
        })
    }
  return (useUnmount.default = $), useUnmount
}
var hasRequiredUseRafState
function requireUseRafState() {
  if (hasRequiredUseRafState) return useRafState
  ;(hasRequiredUseRafState = 1),
    Object.defineProperty(useRafState, '__esModule', { value: !0 })
  var o = require$$0,
    a = reactExports,
    s = o.__importDefault(requireUseUnmount()),
    $ = function(j) {
      var _e = a.useRef(0),
        et = a.useState(j),
        tt = et[0],
        rt = et[1],
        nt = a.useCallback(function(it) {
          cancelAnimationFrame(_e.current),
            (_e.current = requestAnimationFrame(function() {
              rt(it)
            }))
        }, [])
      return (
        s.default(function() {
          cancelAnimationFrame(_e.current)
        }),
        [tt, nt]
      )
    }
  return (useRafState.default = $), useRafState
}
var util = {},
  hasRequiredUtil
function requireUtil() {
  if (hasRequiredUtil) return util
  ;(hasRequiredUtil = 1),
    Object.defineProperty(util, '__esModule', { value: !0 }),
    (util.isNavigator = util.isBrowser = util.off = util.on = util.noop = void 0)
  var o = function() {}
  util.noop = o
  function a($) {
    for (var j = [], _e = 1; _e < arguments.length; _e++)
      j[_e - 1] = arguments[_e]
    $ && $.addEventListener && $.addEventListener.apply($, j)
  }
  util.on = a
  function s($) {
    for (var j = [], _e = 1; _e < arguments.length; _e++)
      j[_e - 1] = arguments[_e]
    $ && $.removeEventListener && $.removeEventListener.apply($, j)
  }
  return (
    (util.off = s),
    (util.isBrowser = typeof window < 'u'),
    (util.isNavigator = typeof navigator < 'u'),
    util
  )
}
Object.defineProperty(useWindowSize$1, '__esModule', { value: !0 })
var tslib_1 = require$$0,
  react_1 = reactExports,
  useRafState_1 = tslib_1.__importDefault(requireUseRafState()),
  util_1 = requireUtil(),
  useWindowSize = function(o, a) {
    o === void 0 && (o = 1 / 0), a === void 0 && (a = 1 / 0)
    var s = useRafState_1.default({
        width: util_1.isBrowser ? window.innerWidth : o,
        height: util_1.isBrowser ? window.innerHeight : a,
      }),
      $ = s[0],
      j = s[1]
    return (
      react_1.useEffect(function() {
        if (util_1.isBrowser) {
          var _e = function() {
            j({ width: window.innerWidth, height: window.innerHeight })
          }
          return (
            util_1.on(window, 'resize', _e),
            function() {
              util_1.off(window, 'resize', _e)
            }
          )
        }
      }, []),
      $
    )
  },
  _default = (useWindowSize$1.default = useWindowSize),
  reactConfetti_min = { exports: {} }
;(function(o, a) {
  ;(function(s, $) {
    o.exports = $(reactExports)
  })(typeof self < 'u' ? self : commonjsGlobal$1, function(s) {
    return (function($) {
      var j = {}
      function _e(et) {
        if (j[et]) return j[et].exports
        var tt = (j[et] = { i: et, l: !1, exports: {} })
        return (
          $[et].call(tt.exports, tt, tt.exports, _e), (tt.l = !0), tt.exports
        )
      }
      return (
        (_e.m = $),
        (_e.c = j),
        (_e.d = function(et, tt, rt) {
          _e.o(et, tt) ||
            Object.defineProperty(et, tt, { enumerable: !0, get: rt })
        }),
        (_e.r = function(et) {
          typeof Symbol < 'u' &&
            Symbol.toStringTag &&
            Object.defineProperty(et, Symbol.toStringTag, { value: 'Module' }),
            Object.defineProperty(et, '__esModule', { value: !0 })
        }),
        (_e.t = function(et, tt) {
          if (
            (1 & tt && (et = _e(et)),
            8 & tt || (4 & tt && typeof et == 'object' && et && et.__esModule))
          )
            return et
          var rt = Object.create(null)
          if (
            (_e.r(rt),
            Object.defineProperty(rt, 'default', { enumerable: !0, value: et }),
            2 & tt && typeof et != 'string')
          )
            for (var nt in et)
              _e.d(
                rt,
                nt,
                function(it) {
                  return et[it]
                }.bind(null, nt)
              )
          return rt
        }),
        (_e.n = function(et) {
          var tt =
            et && et.__esModule
              ? function() {
                  return et.default
                }
              : function() {
                  return et
                }
          return _e.d(tt, 'a', tt), tt
        }),
        (_e.o = function(et, tt) {
          return Object.prototype.hasOwnProperty.call(et, tt)
        }),
        (_e.p = ''),
        _e((_e.s = 2))
      )
    })([
      function($, j) {
        $.exports = s
      },
      function($, j, _e) {
        var et = {
          linear: function(tt, rt, nt, it) {
            return ((nt - rt) * tt) / it + rt
          },
          easeInQuad: function(tt, rt, nt, it) {
            return (nt - rt) * (tt /= it) * tt + rt
          },
          easeOutQuad: function(tt, rt, nt, it) {
            return -(nt - rt) * (tt /= it) * (tt - 2) + rt
          },
          easeInOutQuad: function(tt, rt, nt, it) {
            var ot = nt - rt
            return (tt /= it / 2) < 1
              ? (ot / 2) * tt * tt + rt
              : (-ot / 2) * (--tt * (tt - 2) - 1) + rt
          },
          easeInCubic: function(tt, rt, nt, it) {
            return (nt - rt) * (tt /= it) * tt * tt + rt
          },
          easeOutCubic: function(tt, rt, nt, it) {
            return (nt - rt) * ((tt = tt / it - 1) * tt * tt + 1) + rt
          },
          easeInOutCubic: function(tt, rt, nt, it) {
            var ot = nt - rt
            return (tt /= it / 2) < 1
              ? (ot / 2) * tt * tt * tt + rt
              : (ot / 2) * ((tt -= 2) * tt * tt + 2) + rt
          },
          easeInQuart: function(tt, rt, nt, it) {
            return (nt - rt) * (tt /= it) * tt * tt * tt + rt
          },
          easeOutQuart: function(tt, rt, nt, it) {
            return -(nt - rt) * ((tt = tt / it - 1) * tt * tt * tt - 1) + rt
          },
          easeInOutQuart: function(tt, rt, nt, it) {
            var ot = nt - rt
            return (tt /= it / 2) < 1
              ? (ot / 2) * tt * tt * tt * tt + rt
              : (-ot / 2) * ((tt -= 2) * tt * tt * tt - 2) + rt
          },
          easeInQuint: function(tt, rt, nt, it) {
            return (nt - rt) * (tt /= it) * tt * tt * tt * tt + rt
          },
          easeOutQuint: function(tt, rt, nt, it) {
            return (nt - rt) * ((tt = tt / it - 1) * tt * tt * tt * tt + 1) + rt
          },
          easeInOutQuint: function(tt, rt, nt, it) {
            var ot = nt - rt
            return (tt /= it / 2) < 1
              ? (ot / 2) * tt * tt * tt * tt * tt + rt
              : (ot / 2) * ((tt -= 2) * tt * tt * tt * tt + 2) + rt
          },
          easeInSine: function(tt, rt, nt, it) {
            var ot = nt - rt
            return -ot * Math.cos((tt / it) * (Math.PI / 2)) + ot + rt
          },
          easeOutSine: function(tt, rt, nt, it) {
            return (nt - rt) * Math.sin((tt / it) * (Math.PI / 2)) + rt
          },
          easeInOutSine: function(tt, rt, nt, it) {
            return (-(nt - rt) / 2) * (Math.cos((Math.PI * tt) / it) - 1) + rt
          },
          easeInExpo: function(tt, rt, nt, it) {
            return tt == 0
              ? rt
              : (nt - rt) * Math.pow(2, 10 * (tt / it - 1)) + rt
          },
          easeOutExpo: function(tt, rt, nt, it) {
            var ot = nt - rt
            return tt == it
              ? rt + ot
              : ot * (1 - Math.pow(2, (-10 * tt) / it)) + rt
          },
          easeInOutExpo: function(tt, rt, nt, it) {
            var ot = nt - rt
            return tt === 0
              ? rt
              : tt === it
              ? rt + ot
              : (tt /= it / 2) < 1
              ? (ot / 2) * Math.pow(2, 10 * (tt - 1)) + rt
              : (ot / 2) * (2 - Math.pow(2, -10 * --tt)) + rt
          },
          easeInCirc: function(tt, rt, nt, it) {
            return -(nt - rt) * (Math.sqrt(1 - (tt /= it) * tt) - 1) + rt
          },
          easeOutCirc: function(tt, rt, nt, it) {
            return (nt - rt) * Math.sqrt(1 - (tt = tt / it - 1) * tt) + rt
          },
          easeInOutCirc: function(tt, rt, nt, it) {
            var ot = nt - rt
            return (tt /= it / 2) < 1
              ? (-ot / 2) * (Math.sqrt(1 - tt * tt) - 1) + rt
              : (ot / 2) * (Math.sqrt(1 - (tt -= 2) * tt) + 1) + rt
          },
          easeInElastic: function(tt, rt, nt, it) {
            var ot,
              at,
              st,
              ut = nt - rt
            return (
              (st = 1.70158),
              tt === 0
                ? rt
                : (tt /= it) == 1
                ? rt + ut
                : ((at = 0) || (at = 0.3 * it),
                  (ot = ut) < Math.abs(ut)
                    ? ((ot = ut), (st = at / 4))
                    : (st = (at / (2 * Math.PI)) * Math.asin(ut / ot)),
                  -ot *
                    Math.pow(2, 10 * (tt -= 1)) *
                    Math.sin(((tt * it - st) * (2 * Math.PI)) / at) +
                    rt)
            )
          },
          easeOutElastic: function(tt, rt, nt, it) {
            var ot,
              at,
              st,
              ut = nt - rt
            return (
              (st = 1.70158),
              tt === 0
                ? rt
                : (tt /= it) == 1
                ? rt + ut
                : ((at = 0) || (at = 0.3 * it),
                  (ot = ut) < Math.abs(ut)
                    ? ((ot = ut), (st = at / 4))
                    : (st = (at / (2 * Math.PI)) * Math.asin(ut / ot)),
                  ot *
                    Math.pow(2, -10 * tt) *
                    Math.sin(((tt * it - st) * (2 * Math.PI)) / at) +
                    ut +
                    rt)
            )
          },
          easeInOutElastic: function(tt, rt, nt, it) {
            var ot,
              at,
              st,
              ut = nt - rt
            return (
              (st = 1.70158),
              tt === 0
                ? rt
                : (tt /= it / 2) == 2
                ? rt + ut
                : ((at = 0) || (at = it * 0.44999999999999996),
                  (ot = ut) < Math.abs(ut)
                    ? ((ot = ut), (st = at / 4))
                    : (st = (at / (2 * Math.PI)) * Math.asin(ut / ot)),
                  tt < 1
                    ? ot *
                        Math.pow(2, 10 * (tt -= 1)) *
                        Math.sin(((tt * it - st) * (2 * Math.PI)) / at) *
                        -0.5 +
                      rt
                    : ot *
                        Math.pow(2, -10 * (tt -= 1)) *
                        Math.sin(((tt * it - st) * (2 * Math.PI)) / at) *
                        0.5 +
                      ut +
                      rt)
            )
          },
          easeInBack: function(tt, rt, nt, it, ot) {
            return (
              ot === void 0 && (ot = 1.70158),
              (nt - rt) * (tt /= it) * tt * ((ot + 1) * tt - ot) + rt
            )
          },
          easeOutBack: function(tt, rt, nt, it, ot) {
            return (
              ot === void 0 && (ot = 1.70158),
              (nt - rt) * ((tt = tt / it - 1) * tt * ((ot + 1) * tt + ot) + 1) +
                rt
            )
          },
          easeInOutBack: function(tt, rt, nt, it, ot) {
            var at = nt - rt
            return (
              ot === void 0 && (ot = 1.70158),
              (tt /= it / 2) < 1
                ? (at / 2) * (tt * tt * ((1 + (ot *= 1.525)) * tt - ot)) + rt
                : (at / 2) *
                    ((tt -= 2) * tt * ((1 + (ot *= 1.525)) * tt + ot) + 2) +
                  rt
            )
          },
          easeInBounce: function(tt, rt, nt, it) {
            var ot = nt - rt
            return ot - et.easeOutBounce(it - tt, 0, ot, it) + rt
          },
          easeOutBounce: function(tt, rt, nt, it) {
            var ot = nt - rt
            return (tt /= it) < 0.36363636363636365
              ? ot * (7.5625 * tt * tt) + rt
              : tt < 0.7272727272727273
              ? ot * (7.5625 * (tt -= 0.5454545454545454) * tt + 0.75) + rt
              : tt < 0.9090909090909091
              ? ot * (7.5625 * (tt -= 0.8181818181818182) * tt + 0.9375) + rt
              : ot * (7.5625 * (tt -= 0.9545454545454546) * tt + 0.984375) + rt
          },
          easeInOutBounce: function(tt, rt, nt, it) {
            var ot = nt - rt
            return tt < it / 2
              ? 0.5 * et.easeInBounce(2 * tt, 0, ot, it) + rt
              : 0.5 * et.easeOutBounce(2 * tt - it, 0, ot, it) + 0.5 * ot + rt
          },
        }
        $.exports = et
      },
      function($, j, _e) {
        $.exports = _e(3)
      },
      function($, j, _e) {
        _e.r(j),
          _e.d(j, 'ReactConfetti', function() {
            return Yt
          })
        var et,
          tt,
          rt = _e(0),
          nt = _e.n(rt),
          it = _e(1),
          ot = _e.n(it)
        function at(xt, It) {
          return xt + Math.random() * (It - xt)
        }
        function st(xt, It) {
          for (var Kt = 0; Kt < It.length; Kt++) {
            var Qt = It[Kt]
            ;(Qt.enumerable = Qt.enumerable || !1),
              (Qt.configurable = !0),
              'value' in Qt && (Qt.writable = !0),
              Object.defineProperty(xt, Qt.key, Qt)
          }
        }
        function ut(xt, It, Kt) {
          return (
            It in xt
              ? Object.defineProperty(xt, It, {
                  value: Kt,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (xt[It] = Kt),
            xt
          )
        }
        ;(function(xt) {
          ;(xt[(xt.Circle = 0)] = 'Circle'),
            (xt[(xt.Square = 1)] = 'Square'),
            (xt[(xt.Strip = 2)] = 'Strip')
        })(et || (et = {})),
          (function(xt) {
            ;(xt[(xt.Positive = 1)] = 'Positive'),
              (xt[(xt.Negative = -1)] = 'Negative')
          })(tt || (tt = {}))
        var ct = (function() {
          function xt(Qt, Ht, Lt, tr) {
            ;(function(Rr, nr) {
              if (!(Rr instanceof nr))
                throw new TypeError('Cannot call a class as a function')
            })(this, xt),
              ut(this, 'context', void 0),
              ut(this, 'radius', void 0),
              ut(this, 'x', void 0),
              ut(this, 'y', void 0),
              ut(this, 'w', void 0),
              ut(this, 'h', void 0),
              ut(this, 'vx', void 0),
              ut(this, 'vy', void 0),
              ut(this, 'shape', void 0),
              ut(this, 'angle', void 0),
              ut(this, 'angularSpin', void 0),
              ut(this, 'color', void 0),
              ut(this, 'rotateY', void 0),
              ut(this, 'rotationDirection', void 0),
              ut(this, 'getOptions', void 0),
              (this.getOptions = Ht)
            var lr,
              yr,
              mr = this.getOptions(),
              Er = mr.colors,
              ur = mr.initialVelocityX,
              _r = mr.initialVelocityY
            ;(this.context = Qt),
              (this.x = Lt),
              (this.y = tr),
              (this.w = at(5, 20)),
              (this.h = at(5, 20)),
              (this.radius = at(5, 10)),
              (this.vx =
                typeof ur == 'number' ? at(-ur, ur) : at(ur.min, ur.max)),
              (this.vy =
                typeof _r == 'number' ? at(-_r, 0) : at(_r.min, _r.max)),
              (this.shape =
                ((lr = 0),
                (yr = 2),
                Math.floor(lr + Math.random() * (yr - lr + 1)))),
              (this.angle = (at(0, 360) * Math.PI) / 180),
              (this.angularSpin = at(-0.2, 0.2)),
              (this.color = Er[Math.floor(Math.random() * Er.length)]),
              (this.rotateY = at(0, 1)),
              (this.rotationDirection = at(0, 1) ? tt.Positive : tt.Negative)
          }
          var It, Kt
          return (
            (It = xt),
            (Kt = [
              {
                key: 'update',
                value: function() {
                  var Qt = this.getOptions(),
                    Ht = Qt.gravity,
                    Lt = Qt.wind,
                    tr = Qt.friction,
                    lr = Qt.opacity,
                    yr = Qt.drawShape
                  ;(this.x += this.vx),
                    (this.y += this.vy),
                    (this.vy += Ht),
                    (this.vx += Lt),
                    (this.vx *= tr),
                    (this.vy *= tr),
                    this.rotateY >= 1 && this.rotationDirection === tt.Positive
                      ? (this.rotationDirection = tt.Negative)
                      : this.rotateY <= -1 &&
                        this.rotationDirection === tt.Negative &&
                        (this.rotationDirection = tt.Positive)
                  var mr = 0.1 * this.rotationDirection
                  if (
                    ((this.rotateY += mr),
                    (this.angle += this.angularSpin),
                    this.context.save(),
                    this.context.translate(this.x, this.y),
                    this.context.rotate(this.angle),
                    this.context.scale(1, this.rotateY),
                    this.context.rotate(this.angle),
                    this.context.beginPath(),
                    (this.context.fillStyle = this.color),
                    (this.context.strokeStyle = this.color),
                    (this.context.globalAlpha = lr),
                    (this.context.lineCap = 'round'),
                    (this.context.lineWidth = 2),
                    yr && typeof yr == 'function')
                  )
                    yr.call(this, this.context)
                  else
                    switch (this.shape) {
                      case et.Circle:
                        this.context.beginPath(),
                          this.context.arc(0, 0, this.radius, 0, 2 * Math.PI),
                          this.context.fill()
                        break
                      case et.Square:
                        this.context.fillRect(
                          -this.w / 2,
                          -this.h / 2,
                          this.w,
                          this.h
                        )
                        break
                      case et.Strip:
                        this.context.fillRect(
                          -this.w / 6,
                          -this.h / 2,
                          this.w / 3,
                          this.h
                        )
                    }
                  this.context.closePath(), this.context.restore()
                },
              },
            ]) && st(It.prototype, Kt),
            xt
          )
        })()
        function dt(xt, It, Kt) {
          return (
            It in xt
              ? Object.defineProperty(xt, It, {
                  value: Kt,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (xt[It] = Kt),
            xt
          )
        }
        var ft = function xt(It, Kt) {
          var Qt = this
          ;(function(Lt, tr) {
            if (!(Lt instanceof tr))
              throw new TypeError('Cannot call a class as a function')
          })(this, xt),
            dt(this, 'canvas', void 0),
            dt(this, 'context', void 0),
            dt(this, 'getOptions', void 0),
            dt(this, 'x', 0),
            dt(this, 'y', 0),
            dt(this, 'w', 0),
            dt(this, 'h', 0),
            dt(this, 'lastNumberOfPieces', 0),
            dt(this, 'tweenInitTime', Date.now()),
            dt(this, 'particles', []),
            dt(this, 'particlesGenerated', 0),
            dt(this, 'removeParticleAt', function(Lt) {
              Qt.particles.splice(Lt, 1)
            }),
            dt(this, 'getParticle', function() {
              var Lt = at(Qt.x, Qt.w + Qt.x),
                tr = at(Qt.y, Qt.h + Qt.y)
              return new ct(Qt.context, Qt.getOptions, Lt, tr)
            }),
            dt(this, 'animate', function() {
              var Lt = Qt.canvas,
                tr = Qt.context,
                lr = Qt.particlesGenerated,
                yr = Qt.lastNumberOfPieces,
                mr = Qt.getOptions(),
                Er = mr.run,
                ur = mr.recycle,
                _r = mr.numberOfPieces,
                Rr = mr.debug,
                nr = mr.tweenFunction,
                fr = mr.tweenDuration
              if (!Er) return !1
              var gr = Qt.particles.length,
                br = ur ? gr : lr,
                Sr = Date.now()
              if (br < _r) {
                yr !== _r &&
                  ((Qt.tweenInitTime = Sr), (Qt.lastNumberOfPieces = _r))
                for (
                  var zt = Qt.tweenInitTime,
                    bt = nr(
                      Sr - zt > fr ? fr : Math.max(0, Sr - zt),
                      br,
                      _r,
                      fr
                    ),
                    Rt = Math.round(bt - br),
                    qt = 0;
                  qt < Rt;
                  qt++
                )
                  Qt.particles.push(Qt.getParticle())
                Qt.particlesGenerated += Rt
              }
              return (
                Rr &&
                  ((tr.font = '12px sans-serif'),
                  (tr.fillStyle = '#333'),
                  (tr.textAlign = 'right'),
                  tr.fillText(
                    'Particles: '.concat(gr),
                    Lt.width - 10,
                    Lt.height - 20
                  )),
                Qt.particles.forEach(function(rr, ar) {
                  rr.update(),
                    (rr.y > Lt.height ||
                      rr.y < -100 ||
                      rr.x > Lt.width + 100 ||
                      rr.x < -100) &&
                      (ur && br <= _r
                        ? (Qt.particles[ar] = Qt.getParticle())
                        : Qt.removeParticleAt(ar))
                }),
                gr > 0 || br < _r
              )
            }),
            (this.canvas = It)
          var Ht = this.canvas.getContext('2d')
          if (!Ht) throw new Error('Could not get canvas context')
          ;(this.context = Ht), (this.getOptions = Kt)
        }
        function mt(xt, It) {
          var Kt = Object.keys(xt)
          if (Object.getOwnPropertySymbols) {
            var Qt = Object.getOwnPropertySymbols(xt)
            It &&
              (Qt = Qt.filter(function(Ht) {
                return Object.getOwnPropertyDescriptor(xt, Ht).enumerable
              })),
              Kt.push.apply(Kt, Qt)
          }
          return Kt
        }
        function vt(xt) {
          for (var It = 1; It < arguments.length; It++) {
            var Kt = arguments[It] != null ? arguments[It] : {}
            It % 2
              ? mt(Object(Kt), !0).forEach(function(Qt) {
                  pt(xt, Qt, Kt[Qt])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(
                  xt,
                  Object.getOwnPropertyDescriptors(Kt)
                )
              : mt(Object(Kt)).forEach(function(Qt) {
                  Object.defineProperty(
                    xt,
                    Qt,
                    Object.getOwnPropertyDescriptor(Kt, Qt)
                  )
                })
          }
          return xt
        }
        function yt(xt, It) {
          for (var Kt = 0; Kt < It.length; Kt++) {
            var Qt = It[Kt]
            ;(Qt.enumerable = Qt.enumerable || !1),
              (Qt.configurable = !0),
              'value' in Qt && (Qt.writable = !0),
              Object.defineProperty(xt, Qt.key, Qt)
          }
        }
        function pt(xt, It, Kt) {
          return (
            It in xt
              ? Object.defineProperty(xt, It, {
                  value: Kt,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (xt[It] = Kt),
            xt
          )
        }
        var ht = {
            width: typeof window < 'u' ? window.innerWidth : 300,
            height: typeof window < 'u' ? window.innerHeight : 200,
            numberOfPieces: 200,
            friction: 0.99,
            wind: 0,
            gravity: 0.1,
            initialVelocityX: 4,
            initialVelocityY: 10,
            colors: [
              '#f44336',
              '#e91e63',
              '#9c27b0',
              '#673ab7',
              '#3f51b5',
              '#2196f3',
              '#03a9f4',
              '#00bcd4',
              '#009688',
              '#4CAF50',
              '#8BC34A',
              '#CDDC39',
              '#FFEB3B',
              '#FFC107',
              '#FF9800',
              '#FF5722',
              '#795548',
            ],
            opacity: 1,
            debug: !1,
            tweenFunction: ot.a.easeInOutQuad,
            tweenDuration: 5e3,
            recycle: !0,
            run: !0,
          },
          At = (function() {
            function xt(Qt, Ht) {
              var Lt = this
              ;(function(lr, yr) {
                if (!(lr instanceof yr))
                  throw new TypeError('Cannot call a class as a function')
              })(this, xt),
                pt(this, 'canvas', void 0),
                pt(this, 'context', void 0),
                pt(this, '_options', void 0),
                pt(this, 'generator', void 0),
                pt(this, 'rafId', void 0),
                pt(this, 'setOptionsWithDefaults', function(lr) {
                  var yr = {
                    confettiSource: { x: 0, y: 0, w: Lt.canvas.width, h: 0 },
                  }
                  ;(Lt._options = vt(vt(vt({}, yr), ht), lr)),
                    Object.assign(Lt, lr.confettiSource)
                }),
                pt(this, 'update', function() {
                  var lr = Lt.options,
                    yr = lr.run,
                    mr = lr.onConfettiComplete,
                    Er = Lt.canvas,
                    ur = Lt.context
                  yr &&
                    ((ur.fillStyle = 'white'),
                    ur.clearRect(0, 0, Er.width, Er.height)),
                    Lt.generator.animate()
                      ? (Lt.rafId = requestAnimationFrame(Lt.update))
                      : (mr &&
                          typeof mr == 'function' &&
                          Lt.generator.particlesGenerated > 0 &&
                          mr.call(Lt, Lt),
                        (Lt._options.run = !1))
                }),
                pt(this, 'reset', function() {
                  Lt.generator &&
                    Lt.generator.particlesGenerated > 0 &&
                    ((Lt.generator.particlesGenerated = 0),
                    (Lt.generator.particles = []),
                    (Lt.generator.lastNumberOfPieces = 0))
                }),
                pt(this, 'stop', function() {
                  ;(Lt.options = { run: !1 }),
                    Lt.rafId &&
                      (cancelAnimationFrame(Lt.rafId), (Lt.rafId = void 0))
                }),
                (this.canvas = Qt)
              var tr = this.canvas.getContext('2d')
              if (!tr) throw new Error('Could not get canvas context')
              ;(this.context = tr),
                (this.generator = new ft(this.canvas, function() {
                  return Lt.options
                })),
                (this.options = Ht),
                this.update()
            }
            var It, Kt
            return (
              (It = xt),
              (Kt = [
                {
                  key: 'options',
                  get: function() {
                    return this._options
                  },
                  set: function(Qt) {
                    var Ht = this._options && this._options.run,
                      Lt = this._options && this._options.recycle
                    this.setOptionsWithDefaults(Qt),
                      this.generator &&
                        (Object.assign(
                          this.generator,
                          this.options.confettiSource
                        ),
                        typeof Qt.recycle == 'boolean' &&
                          Qt.recycle &&
                          Lt === !1 &&
                          (this.generator.lastNumberOfPieces = this.generator.particles.length)),
                      typeof Qt.run == 'boolean' &&
                        Qt.run &&
                        Ht === !1 &&
                        this.update()
                  },
                },
              ]) && yt(It.prototype, Kt),
              xt
            )
          })()
        function wt(xt) {
          return (
            (function(It) {
              if (Array.isArray(It)) return Mt(It)
            })(xt) ||
            (function(It) {
              if (typeof Symbol < 'u' && Symbol.iterator in Object(It))
                return Array.from(It)
            })(xt) ||
            Bt(xt) ||
            (function() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            })()
          )
        }
        function Ct(xt) {
          return (Ct =
            typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
              ? function(It) {
                  return typeof It
                }
              : function(It) {
                  return It &&
                    typeof Symbol == 'function' &&
                    It.constructor === Symbol &&
                    It !== Symbol.prototype
                    ? 'symbol'
                    : typeof It
                })(xt)
        }
        function Dt() {
          return (Dt =
            Object.assign ||
            function(xt) {
              for (var It = 1; It < arguments.length; It++) {
                var Kt = arguments[It]
                for (var Qt in Kt)
                  Object.prototype.hasOwnProperty.call(Kt, Qt) &&
                    (xt[Qt] = Kt[Qt])
              }
              return xt
            }).apply(this, arguments)
        }
        function jt(xt, It) {
          var Kt = Object.keys(xt)
          if (Object.getOwnPropertySymbols) {
            var Qt = Object.getOwnPropertySymbols(xt)
            It &&
              (Qt = Qt.filter(function(Ht) {
                return Object.getOwnPropertyDescriptor(xt, Ht).enumerable
              })),
              Kt.push.apply(Kt, Qt)
          }
          return Kt
        }
        function Et(xt) {
          for (var It = 1; It < arguments.length; It++) {
            var Kt = arguments[It] != null ? arguments[It] : {}
            It % 2
              ? jt(Object(Kt), !0).forEach(function(Qt) {
                  Pt(xt, Qt, Kt[Qt])
                })
              : Object.getOwnPropertyDescriptors
              ? Object.defineProperties(
                  xt,
                  Object.getOwnPropertyDescriptors(Kt)
                )
              : jt(Object(Kt)).forEach(function(Qt) {
                  Object.defineProperty(
                    xt,
                    Qt,
                    Object.getOwnPropertyDescriptor(Kt, Qt)
                  )
                })
          }
          return xt
        }
        function St(xt, It) {
          return (
            (function(Kt) {
              if (Array.isArray(Kt)) return Kt
            })(xt) ||
            (function(Kt, Qt) {
              if (!(typeof Symbol > 'u' || !(Symbol.iterator in Object(Kt)))) {
                var Ht = [],
                  Lt = !0,
                  tr = !1,
                  lr = void 0
                try {
                  for (
                    var yr, mr = Kt[Symbol.iterator]();
                    !(Lt = (yr = mr.next()).done) &&
                    (Ht.push(yr.value), !Qt || Ht.length !== Qt);
                    Lt = !0
                  );
                } catch (Er) {
                  ;(tr = !0), (lr = Er)
                } finally {
                  try {
                    Lt || mr.return == null || mr.return()
                  } finally {
                    if (tr) throw lr
                  }
                }
                return Ht
              }
            })(xt, It) ||
            Bt(xt, It) ||
            (function() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
            })()
          )
        }
        function Bt(xt, It) {
          if (xt) {
            if (typeof xt == 'string') return Mt(xt, It)
            var Kt = Object.prototype.toString.call(xt).slice(8, -1)
            return (
              Kt === 'Object' && xt.constructor && (Kt = xt.constructor.name),
              Kt === 'Map' || Kt === 'Set'
                ? Array.from(xt)
                : Kt === 'Arguments' ||
                  /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Kt)
                ? Mt(xt, It)
                : void 0
            )
          }
        }
        function Mt(xt, It) {
          ;(It == null || It > xt.length) && (It = xt.length)
          for (var Kt = 0, Qt = new Array(It); Kt < It; Kt++) Qt[Kt] = xt[Kt]
          return Qt
        }
        function Ut(xt, It) {
          if (!(xt instanceof It))
            throw new TypeError('Cannot call a class as a function')
        }
        function Wt(xt, It) {
          for (var Kt = 0; Kt < It.length; Kt++) {
            var Qt = It[Kt]
            ;(Qt.enumerable = Qt.enumerable || !1),
              (Qt.configurable = !0),
              'value' in Qt && (Qt.writable = !0),
              Object.defineProperty(xt, Qt.key, Qt)
          }
        }
        function Tt(xt, It) {
          return (Tt =
            Object.setPrototypeOf ||
            function(Kt, Qt) {
              return (Kt.__proto__ = Qt), Kt
            })(xt, It)
        }
        function kt(xt) {
          var It = (function() {
            if (
              typeof Reflect > 'u' ||
              !Reflect.construct ||
              Reflect.construct.sham
            )
              return !1
            if (typeof Proxy == 'function') return !0
            try {
              return (
                Date.prototype.toString.call(
                  Reflect.construct(Date, [], function() {})
                ),
                !0
              )
            } catch {
              return !1
            }
          })()
          return function() {
            var Kt,
              Qt = $t(xt)
            if (It) {
              var Ht = $t(this).constructor
              Kt = Reflect.construct(Qt, arguments, Ht)
            } else Kt = Qt.apply(this, arguments)
            return Ot(this, Kt)
          }
        }
        function Ot(xt, It) {
          return !It || (Ct(It) !== 'object' && typeof It != 'function')
            ? Nt(xt)
            : It
        }
        function Nt(xt) {
          if (xt === void 0)
            throw new ReferenceError(
              "this hasn't been initialised - super() hasn't been called"
            )
          return xt
        }
        function $t(xt) {
          return ($t = Object.setPrototypeOf
            ? Object.getPrototypeOf
            : function(It) {
                return It.__proto__ || Object.getPrototypeOf(It)
              })(xt)
        }
        function Pt(xt, It, Kt) {
          return (
            It in xt
              ? Object.defineProperty(xt, It, {
                  value: Kt,
                  enumerable: !0,
                  configurable: !0,
                  writable: !0,
                })
              : (xt[It] = Kt),
            xt
          )
        }
        var Ft = nt.a.createRef(),
          Vt = (function(xt) {
            ;(function(Lt, tr) {
              if (typeof tr != 'function' && tr !== null)
                throw new TypeError(
                  'Super expression must either be null or a function'
                )
              ;(Lt.prototype = Object.create(tr && tr.prototype, {
                constructor: { value: Lt, writable: !0, configurable: !0 },
              })),
                tr && Tt(Lt, tr)
            })(Ht, xt)
            var It,
              Kt,
              Qt = kt(Ht)
            function Ht(Lt) {
              var tr
              Ut(this, Ht)
              for (
                var lr = arguments.length,
                  yr = new Array(lr > 1 ? lr - 1 : 0),
                  mr = 1;
                mr < lr;
                mr++
              )
                yr[mr - 1] = arguments[mr]
              return (
                Pt(
                  Nt((tr = Qt.call.apply(Qt, [this, Lt].concat(yr)))),
                  'canvas',
                  nt.a.createRef()
                ),
                Pt(Nt(tr), 'confetti', void 0),
                (tr.canvas = Lt.canvasRef || Ft),
                tr
              )
            }
            return (
              (It = Ht),
              (Kt = [
                {
                  key: 'componentDidMount',
                  value: function() {
                    if (this.canvas.current) {
                      var Lt = Xt(this.props)[0]
                      this.confetti = new At(this.canvas.current, Lt)
                    }
                  },
                },
                {
                  key: 'componentDidUpdate',
                  value: function() {
                    var Lt = Xt(this.props)[0]
                    this.confetti && (this.confetti.options = Lt)
                  },
                },
                {
                  key: 'componentWillUnmount',
                  value: function() {
                    this.confetti && this.confetti.stop(),
                      (this.confetti = void 0)
                  },
                },
                {
                  key: 'render',
                  value: function() {
                    var Lt = St(Xt(this.props), 2),
                      tr = Lt[0],
                      lr = Lt[1],
                      yr = Et(
                        {
                          zIndex: 2,
                          position: 'absolute',
                          pointerEvents: 'none',
                          top: 0,
                          left: 0,
                          bottom: 0,
                          right: 0,
                        },
                        lr.style
                      )
                    return nt.a.createElement(
                      'canvas',
                      Dt(
                        {
                          width: tr.width,
                          height: tr.height,
                          ref: this.canvas,
                        },
                        lr,
                        { style: yr }
                      )
                    )
                  },
                },
              ]) && Wt(It.prototype, Kt),
              Ht
            )
          })(rt.Component)
        function Xt(xt) {
          var It = {},
            Kt = {},
            Qt = [].concat(wt(Object.keys(ht)), [
              'confettiSource',
              'drawShape',
              'onConfettiComplete',
            ]),
            Ht = ['canvasRef']
          for (var Lt in xt) {
            var tr = xt[Lt]
            Qt.includes(Lt)
              ? (It[Lt] = tr)
              : Ht.includes(Lt)
              ? (Ht[Lt] = tr)
              : (Kt[Lt] = tr)
          }
          return [It, Kt, {}]
        }
        Pt(Vt, 'defaultProps', Et({}, ht)),
          Pt(Vt, 'displayName', 'ReactConfetti')
        var Yt = nt.a.forwardRef(function(xt, It) {
          return nt.a.createElement(Vt, Dt({ canvasRef: It }, xt))
        })
        j.default = Yt
      },
    ]).default
  })
})(reactConfetti_min)
var reactConfetti_minExports = reactConfetti_min.exports
const Confetti = getDefaultExportFromCjs(reactConfetti_minExports),
  randomInt = (o, a) => Math.floor(o + random() * (a - o + 1)),
  drawSnowflake = function(o) {
    const a = this.numPoints || randomInt(3, 4) * 2
    this.numPoints = a
    const s = this.radius * 0.2,
      $ = this.radius * 0.8
    o.beginPath(), o.moveTo(0, 0 - $)
    for (let j = 1; j < a * 2; j++) {
      const _e = j % 2 === 0 ? $ : s,
        et = _e * Math.sin((j * Math.PI) / a),
        tt = -1 * _e * Math.cos((j * Math.PI) / a)
      o.lineTo(et, tt)
    }
    o.fill(), o.stroke(), o.closePath()
  },
  SnowBackground = () => {
    const { width: o, height: a } = _default()
    return jsxRuntimeExports.jsx(Confetti, {
      style: { position: 'fixed' },
      width: o,
      height: a,
      drawShape: drawSnowflake,
      colors: ['#FFFFFF', '#CBDDF8'],
      gravity: 0.03,
      numberOfPieces: 10,
      wind: 0.01,
    })
  },
  onboardingAchievements = [
    achievementsMap['plant-crop'],
    achievementsMap['water-crop'],
    achievementsMap['harvest-crop'],
    achievementsMap['purchase-cow-pen'],
  ],
  getRemainingOnboardingAchievements = memoize(o =>
    onboardingAchievements.filter(a => a && !o[a.id])
  ),
  environmentAllowsInstall = ['production', 'development'].includes(
    'production'
  ),
  VALID_ORIGINS = [
    'https://jeremyckahn.github.io',
    'https://www.farmhand.life',
    'http://localhost:3000',
  ],
  isInstallable =
    environmentAllowsInstall &&
    !window$1.matchMedia('(display-mode: standalone)').matches &&
    VALID_ORIGINS.includes(window$1.location.origin),
  Home = ({
    completedAchievements: o,
    handleViewChangeButtonClick: a,
    remainingOnboardingAchievements: s = getRemainingOnboardingAchievements(o),
  }) =>
    jsxRuntimeExports.jsxs('div', {
      className: 'Home',
      children: [
        isDecember()
          ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
              children: [
                jsxRuntimeExports.jsx(SnowBackground, {}),
                jsxRuntimeExports.jsxs('h1', {
                  className: 'holiday-greeting',
                  children: [
                    'Happy holidays!',
                    ' ',
                    jsxRuntimeExports.jsx('span', {
                      role: 'img',
                      'aria-label': 'Snowman',
                      children: '',
                    }),
                  ],
                }),
              ],
            })
          : jsxRuntimeExports.jsx('h1', { children: 'Welcome!' }),
        jsxRuntimeExports.jsxs(Accordion, {
          children: [
            jsxRuntimeExports.jsx(AccordionSummary, {
              expandIcon: jsxRuntimeExports.jsx(default_1$6, {}),
              children: jsxRuntimeExports.jsx('h2', {
                children: 'Click to read a note from the developer',
              }),
            }),
            jsxRuntimeExports.jsx(AccordionDetails, {
              children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
                linkTarget: '_blank',
                className: 'markdown',
                source: `
Hi, you're playing **Farmhand**! This is an open source game project created by Jeremy Kahn and edited by project group HoTsPot. It simulates Water Credits, their role in livestock farming and other items/technology that is available in real-life and can help farmers save up more Water Credits.

This game is still in alpha version, so any opinions and suggestions are welcome!
    `,
              }),
            }),
          ],
        }),
        jsxRuntimeExports.jsx(Divider, {}),
        jsxRuntimeExports.jsx(Card, {
          children: jsxRuntimeExports.jsxs(CardContent, {
            children: [
              jsxRuntimeExports.jsx(ReactMarkdown$1, {
                className: 'markdown',
                linkTarget: '_blank',
                source: `
### How to play

The goal of Farmhand is to make money by buying, growing, harvesting, and then selling crops. Keep an eye on prices though, because they go up and down every day! The best farmers buy seeds for a low price and sell them for a high price.

If you can master the art of the harvest, there's no limit to how profitable you can become! Every farmer starts with a $${STANDARD_LOAN_AMOUNT} loan from the bank. If you run out of money, you can always take out another loan. Be careful though, because the bank takes a portion of your sales until the debt is repaid. You can access your bank account in the menu.
    `,
              }),
              s.length
                ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                    children: [
                      jsxRuntimeExports.jsx(ReactMarkdown$1, {
                        className: 'markdown',
                        linkTarget: '_blank',
                        source: `
### Getting started

It looks like you're new here. Thanks for stopping by! Here are some goals to help you get familiar with the game.
    `,
                      }),
                      jsxRuntimeExports.jsx('ul', { className: 'card-list' }),
                    ],
                  })
                : null,
              jsxRuntimeExports.jsx(Button, {
                color: 'primary',
                onClick: () => a(stageFocusType.SHOP),
                variant: 'contained',
                children: 'Go to the shop',
              }),
            ],
          }),
        }),
        jsxRuntimeExports.jsx(Divider, {}),
        isInstallable &&
          jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              jsxRuntimeExports.jsx(Card, {
                children: jsxRuntimeExports.jsx(CardContent, {
                  children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
                    className: 'markdown',
                    linkTarget: '_blank',
                    source: `
### Installation

Farmhand can be installed to your device right from this web page! Once installed, the game can be played with or without an internet connection.

If you're playing on a mobile device, all you need to do is [add it to your home screen](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Guides/Installing#add_to_home_screen). If you're playing it on desktop Chrome or Microsoft Edge, [you can install it as an app there as well](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Guides/Installing#installing_pwas).
    `,
                  }),
                }),
              }),
              jsxRuntimeExports.jsx(Divider, {}),
            ],
          }),
        jsxRuntimeExports.jsx(Card, {
          children: jsxRuntimeExports.jsx(CardContent, {
            children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
              className: 'markdown',
              linkTarget: '_blank',
              source: `
### A few other tips

* Press the bed button in the top-right of the screen to end the farm day and advance the game. This also saves your progress.

* Crops need to be watered daily to grow.

* Keep the field free of weeds with the scythe or the hoe.

* Crafting items out of harvested crops in the Workshop is an excellent way to make money!

* Purchasing a cow pen will allow you to buy, sell, milk, and breed cows. Can you breed the mythical Rainbow Cow?

* Put up a scarecrow to protect your field!

* Watch your inventory space as you obtain items. You can purchase additional Storage Units in the shop.

* You'll be able to unlock new crops and items as you level up. Sell crops, milk, and crafted items to gain experience!

* Bank loans accrue interest daily, so pay off your balance as soon as you can.

* Press "Shift + ?" to see all of the keyboard shortcuts available to you.

    `,
            }),
          }),
        }),
      ],
    })
Home.propTypes = {
  completedAchievements: propTypesExports.object.isRequired,
  handleViewChangeButtonClick: propTypesExports.func.isRequired,
}
function Consumer$7(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Home, { ...a, ...s, ...o }),
  })
}
const manureManagerImage = items['manure-manager'],
  randomPosition = () => 10 + random() * 80,
  Dn = class Dn extends reactExports.Component {
    constructor() {
      super(...arguments)
      Wr(this, 'state', {
        cowImage: pixel,
        isTransitioning: !1,
        moveDirection: RIGHT,
        rotate: 0,
        showHugAnimation: !1,
        x: randomPosition(),
        y: randomPosition(),
      })
      Wr(this, 'repositionTimeoutId', null)
      Wr(this, 'animateHugTimeoutId', null)
      Wr(this, 'tweenable', new shiftyExports.Tweenable())
      Wr(this, 'isComponentMounted', !1)
      Wr(this, 'move', async () => {
        const s = randomPosition(),
          { moveDirection: $, x: j, y: _e } = this.state,
          et = s < this.state.x ? LEFT : RIGHT
        if ((this.setState({ moveDirection: et }), $ !== et)) {
          const tt = ({ rotate: rt }) => {
            this.setState({ rotate: rt })
          }
          try {
            const rt = Dn.flipAnimationDuration,
              nt = 'swingTo'
            et === LEFT
              ? await this.tweenable.tween({
                  from: { rotate: 0 },
                  to: { rotate: 180 },
                  easing: nt,
                  duration: rt,
                  render: tt,
                })
              : await this.tweenable.tween({
                  from: { rotate: 180 },
                  to: { rotate: 0 },
                  easing: nt,
                  duration: rt,
                  render: tt,
                })
          } catch {
            return
          }
        }
        this.setState({ isTransitioning: !0 })
        try {
          await this.tweenable.tween({
            from: { x: j, y: _e },
            to: { x: s, y: randomPosition() },
            duration: Dn.transitionAnimationDuration,
            render: ({ x: tt, y: rt }) => {
              this.setState({ x: tt, y: rt })
            },
            easing: 'linear',
          })
        } catch {
          return
        }
        this.setState({ isTransitioning: !1 }), this.scheduleMove()
      })
      Wr(this, 'repositionTimeoutHandler', () => {
        ;(this.repositionTimeoutId = null), this.move()
      })
      Wr(this, 'scheduleMove', () => {
        this.props.isSelected ||
          (this.repositionTimeoutId = setTimeout(
            this.repositionTimeoutHandler,
            random() * this.waitVariance
          ))
      })
    }
    get waitVariance() {
      return 2e3 * this.props.cowInventory.length
    }
    componentDidUpdate(s) {
      this.props.isSelected &&
        !s.isSelected &&
        this.repositionTimeoutId !== null &&
        clearTimeout(this.repositionTimeoutId),
        !this.props.isSelected && s.isSelected && this.scheduleMove(),
        this.props.cow.happinessBoostsToday > s.cow.happinessBoostsToday &&
          !this.state.showHugAnimation &&
          (this.setState({ showHugAnimation: !0 }),
          (this.animateHugTimeoutId = setTimeout(
            () => this.setState({ showHugAnimation: !1 }),
            Dn.hugAnimationDuration
          )))
    }
    componentDidMount() {
      ;(this.isComponentMounted = !0),
        this.scheduleMove(),
        (async () => {
          const s = await getCowImage(this.props.cow)
          this.isComponentMounted && this.setState({ cowImage: s })
        })()
    }
    componentWillUnmount() {
      ;[this.repositionTimeoutId, this.animateHugTimeoutId].forEach(
        s => typeof s == 'number' && clearTimeout(s)
      ),
        (this.isComponentMounted = !1),
        this.tweenable.cancel()
    }
    render() {
      const {
          props: {
            allowCustomPeerCowNames: s,
            cow: $,
            handleCowClick: j,
            id: _e,
            isSelected: et,
          },
          state: {
            cowImage: tt,
            isTransitioning: rt,
            rotate: nt,
            showHugAnimation: it,
            x: ot,
            y: at,
          },
        } = this,
        st = getCowDisplayName($, _e, s)
      return jsxRuntimeExports.jsxs('div', {
        className: classNames('cow', {
          'is-transitioning': rt,
          'is-selected': et,
          'is-loaded': tt !== pixel,
        }),
        onClick: () => j($),
        style: { left: `${ot}%`, top: `${at}%` },
        children: [
          et &&
            jsxRuntimeExports.jsxs('p', {
              className: 'visually_hidden',
              children: [st, ' is selected'],
            }),
          jsxRuntimeExports.jsx(Tooltip, {
            arrow: !0,
            placement: 'top',
            title: jsxRuntimeExports.jsx(Typography, { children: st }),
            open: et,
            PopperProps: { disablePortal: !0 },
            children: jsxRuntimeExports.jsxs('div', {
              style: { transform: `rotateY(${nt}deg)` },
              children: [
                jsxRuntimeExports.jsx('img', { src: tt, alt: st }),
                jsxRuntimeExports.jsx(FontAwesomeIcon, {
                  className: classNames('animation', { 'is-animating': it }),
                  icon: faHeart$1,
                }),
              ],
            }),
          }),
          jsxRuntimeExports.jsx('ol', {
            className: 'happiness-boosts-today',
            children: new Array(this.props.cow.happinessBoostsToday)
              .fill(void 0)
              .map((ut, ct) =>
                jsxRuntimeExports.jsx('li', {
                  key: ct,
                  children: jsxRuntimeExports.jsx(FontAwesomeIcon, {
                    icon: faHeart$1,
                  }),
                })
              ),
          }),
        ],
      })
    }
  }
Wr(Dn, 'flipAnimationDuration', 1e3),
  Wr(Dn, 'transitionAnimationDuration', 3e3),
  Wr(Dn, 'hugAnimationDuration', 750)
let Cow = Dn
Cow.propTypes = {
  allowCustomPeerCowNames: propTypesExports.bool.isRequired,
  cow: propTypesExports.object.isRequired,
  cowInventory: propTypesExports.array.isRequired,
  handleCowClick: propTypesExports.func.isRequired,
  id: propTypesExports.string.isRequired,
  isSelected: propTypesExports.bool.isRequired,
}
const ManureManager = ({ cowInventory: o }) => {
  const [a] = reactExports.useState(!1)
  return jsxRuntimeExports.jsxs('div', {
    className: classNames('manure-manager', { 'is-active': a }),
    style: {
      position: 'absolute',
      left: '10%',
      top: '5%',
      width: '100px',
      height: '100px',
      zIndex: 5,
      transform: 'translateX(-50%)',
    },
    children: [
      jsxRuntimeExports.jsx('img', {
        src: manureManagerImage,
        alt: 'Manure Manager',
        style: { width: '100%', height: '100%' },
      }),
      a &&
        jsxRuntimeExports.jsx('div', {
          className: 'water-credit-particles',
          children: [...Array(o.length)].map((s, $) =>
            jsxRuntimeExports.jsx(
              'div',
              { className: 'water-credit-particle' },
              $
            )
          ),
        }),
      jsxRuntimeExports.jsx(Tooltip, {
        arrow: !0,
        placement: 'top',
        title: jsxRuntimeExports.jsxs(Typography, {
          children: [
            'Manure Manager: Generates ',
            o.length,
            ' water credit(s) daily',
          ],
        }),
        children: jsxRuntimeExports.jsx('div', {
          className: 'manure-manager-tooltip-target',
        }),
      }),
    ],
  })
}
ManureManager.propTypes = { cowInventory: propTypesExports.array.isRequired }
const CowPen = ({
  allowCustomPeerCowNames: o,
  cowInventory: a,
  handleCowPenUnmount: s,
  handleCowClick: $,
  id: j,
  selectedCowId: _e,
  inventory: et,
}) => {
  reactExports.useEffect(
    () => () => {
      s()
    },
    [s]
  )
  const tt = et.some(rt => rt.id === MANURE_MANAGER_ID)
  return jsxRuntimeExports.jsxs('div', {
    className: 'CowPen fill',
    children: [
      a.map(rt =>
        jsxRuntimeExports.jsx(Cow, {
          allowCustomPeerCowNames: o,
          cow: rt,
          cowInventory: a,
          key: rt.id,
          handleCowClick: $,
          id: j,
          isSelected: _e === rt.id,
        })
      ),
      tt && jsxRuntimeExports.jsx(ManureManager, { cowInventory: a }),
    ],
  })
}
CowPen.propTypes = {
  allowCustomPeerCowNames: propTypesExports.bool.isRequired,
  cowInventory: propTypesExports.array.isRequired,
  handleCowClick: propTypesExports.func.isRequired,
  handleCowPenUnmount: propTypesExports.func.isRequired,
  id: propTypesExports.string.isRequired,
  selectedCowId: propTypesExports.string.isRequired,
  inventory: propTypesExports.array.isRequired,
}
function Consumer$6(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(CowPen, { ...a, ...s, ...o }),
  })
}
function TierPurchase({
  description: o,
  onBuyClick: a,
  maxedOutPlaceholder: s,
  money: $,
  purchasedTier: j,
  renderTierLabel: _e,
  tiers: et,
  title: tt,
}) {
  const [rt, nt] = reactExports.useState(j),
    it = [...et.entries()],
    ot = Number(rt),
    at = ft => ft <= j,
    st = at(it.slice(-1)[0][0])
  if (at(rt)) {
    const ft = ot + 1,
      mt = et.get(ft)
    mt && $ >= mt.price && nt(`${ft}`)
  }
  const ut = () => {
      const ft = et.get(ot)
      return !!ft && !at(ot) && $ >= ft.price
    },
    ct = () => {
      et.get(ot).price <= $ && a(ot)
    },
    dt = ({ target: { value: ft } }) => {
      nt(ft)
    }
  return jsxRuntimeExports.jsxs(Card, {
    className: 'TierPurchase',
    children: [
      jsxRuntimeExports.jsx(CardHeader, { title: tt }),
      o &&
        jsxRuntimeExports.jsx(CardContent, {
          children: jsxRuntimeExports.jsx(Typography, { children: o }),
        }),
      st && s
        ? jsxRuntimeExports.jsx(CardContent, {
            children: jsxRuntimeExports.jsx(Typography, {
              children: jsxRuntimeExports.jsx('strong', { children: s }),
            }),
          })
        : jsxRuntimeExports.jsxs(CardActions, {
            children: [
              jsxRuntimeExports.jsx(Button, {
                color: 'primary',
                disabled: !ut,
                onClick: ct,
                variant: 'contained',
                children: 'Buy',
              }),
              jsxRuntimeExports.jsx(Select, {
                variant: 'standard',
                sx: { flexGrow: 1, m: 0, ml: '1rem', maxWidth: 300 },
                onChange: dt,
                value: rt > 0 ? rt : '',
                children: it.map(([ft, mt]) =>
                  jsxRuntimeExports.jsx(
                    MenuItem,
                    {
                      value: ft,
                      disabled: $ < mt.price || at(ft),
                      children: _e(mt),
                    },
                    ft
                  )
                ),
              }),
            ],
          }),
    ],
  })
}
TierPurchase.propTypes = {
  description: propTypesExports.string,
  onBuyClick: propTypesExports.func.isRequired,
  maxedOutPlaceholder: propTypesExports.node,
  money: propTypesExports.number.isRequired,
  purchasedTier: propTypesExports.number.isRequired,
  renderTierLabel: propTypesExports.func.isRequired,
  tiers: propTypesExports.instanceOf(Map),
  title: propTypesExports.string.isRequired,
}
function Consumer$5(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(TierPurchase, { ...a, ...s, ...o }),
  })
}
const TabPanel$2 = o => {
  const { children: a, value: s, index: $, ...j } = o
  return jsxRuntimeExports.jsx('section', {
    role: 'tabpanel',
    hidden: s !== $,
    id: `shop-tabpanel-${$}`,
    'aria-labelledby': `shop-tab-${$}`,
    ...j,
    children: s === $ ? a : null,
  })
}
TabPanel$2.propTypes = {
  children: propTypesExports.node,
  index: propTypesExports.number.isRequired,
  value: propTypesExports.number.isRequired,
}
const a11yProps$2 = o => ({
    id: `shop-tab-${o}`,
    'aria-controls': `shop-tabpanel-${o}`,
  }),
  categorizeShopInventory = memoize(o =>
    o.reduce((a, s) => (a.fieldTools.push(s), a), { fieldTools: [] })
  ),
  Shop = ({
    handleCombinePurchase: o,
    handleComposterPurchase: a,
    handleCowPenPurchase: s,
    handleCellarPurchase: $,
    handleFieldPurchase: j,
    handleForestPurchase: _e,
    handleSmelterPurchase: et,
    handleStorageExpansionPurchase: tt,
    inventoryLimit: rt,
    levelEntitlements: nt,
    money: it,
    purchasedCombine: ot,
    purchasedComposter: at,
    purchasedCowPen: st,
    purchasedCellar: ut,
    purchasedField: ct,
    purchasedForest: dt,
    purchasedSmelter: ft,
    shopInventory: mt,
    toolLevels: vt,
    storageUpgradeCost: yt = getCostOfNextStorageExpansion(rt),
  }) => {
    const [pt, ht] = reactExports.useState(0),
      { fieldTools: At } = categorizeShopInventory(mt)
    return (
      nt.stageFocusType[stageFocusType.FOREST],
      jsxRuntimeExports.jsxs('div', {
        className: 'Shop',
        children: [
          jsxRuntimeExports.jsxs(Tabs, {
            value: pt,
            onChange: (wt, Ct) => ht(Ct),
            'aria-label': 'Shop tabs',
            children: [
              jsxRuntimeExports.jsx(Tab, {
                label: 'Supplies',
                ...a11yProps$2(0),
              }),
              jsxRuntimeExports.jsx(Tab, {
                label: 'Upgrades',
                ...a11yProps$2(1),
              }),
            ],
          }),
          jsxRuntimeExports.jsx(TabPanel$2, {
            value: pt,
            index: 0,
            children: jsxRuntimeExports.jsx(Consumer$f, {
              items: At,
              isPurchaseView: !0,
              placeholder: 'Search supplies...',
            }),
          }),
          jsxRuntimeExports.jsx(TabPanel$2, {
            value: pt,
            index: 1,
            children: jsxRuntimeExports.jsxs('ul', {
              className: 'card-list',
              children: [
                rt > INFINITE_STORAGE_LIMIT &&
                  jsxRuntimeExports.jsx('li', {
                    children: jsxRuntimeExports.jsxs(Card, {
                      children: [
                        jsxRuntimeExports.jsx(CardHeader, {
                          avatar: jsxRuntimeExports.jsx('img', {
                            src: items['inventory-box'],
                            alt: 'Inventory box',
                          }),
                          title: 'Storage Unit',
                          subheader: jsxRuntimeExports.jsxs('div', {
                            children: [
                              jsxRuntimeExports.jsxs('p', {
                                children: ['Price: ', moneyString(yt)],
                              }),
                              jsxRuntimeExports.jsxs('p', {
                                children: [
                                  'Current inventory space:',
                                  ' ',
                                  integerString(rt),
                                ],
                              }),
                            ],
                          }),
                        }),
                        jsxRuntimeExports.jsx(CardContent, {
                          children: jsxRuntimeExports.jsxs(Typography, {
                            children: [
                              'Purchase a Storage Unit to increase your inventory capacity for ',
                              STORAGE_EXPANSION_AMOUNT,
                              ' more items.',
                            ],
                          }),
                        }),
                        jsxRuntimeExports.jsx(CardActions, {
                          children: jsxRuntimeExports.jsx(Button, {
                            disabled: it < yt,
                            color: 'primary',
                            onClick: tt,
                            variant: 'contained',
                            children: 'Buy',
                          }),
                        }),
                      ],
                    }),
                  }),
                jsxRuntimeExports.jsx('li', {
                  children: jsxRuntimeExports.jsx(Consumer$5, {
                    onBuyClick: s,
                    maxedOutPlaceholder:
                      "You've purchased the largest cow pen available!",
                    purchasedTier: st,
                    renderTierLabel: ({ cows: wt, price: Ct }) =>
                      `${dollarString(Ct)}: ${wt} cow pen`,
                    tiers: PURCHASEABLE_COW_PENS,
                    title: 'Buy cow pen',
                  }),
                }),
              ],
            }),
          }),
        ],
      })
    )
  }
Shop.propTypes = {
  handleCombinePurchase: propTypesExports.func.isRequired,
  handleCowPenPurchase: propTypesExports.func.isRequired,
  handleCellarPurchase: propTypesExports.func.isRequired,
  handleFieldPurchase: propTypesExports.func.isRequired,
  handleStorageExpansionPurchase: propTypesExports.func.isRequired,
  inventoryLimit: propTypesExports.number.isRequired,
  money: propTypesExports.number.isRequired,
  purchasedCowPen: propTypesExports.number.isRequired,
  purchasedCellar: propTypesExports.number.isRequired,
  purchasedField: propTypesExports.number.isRequired,
  purchasedSmelter: propTypesExports.number.isRequired,
  purchasedCombine: propTypesExports.number.isRequired,
  shopInventory: propTypesExports.array.isRequired,
  toolLevels: propTypesExports.object.isRequired,
  valueAdjustments: propTypesExports.object.isRequired,
}
function Consumer$4(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Shop, { ...a, ...s, ...o }),
  })
}
const TabPanel$1 = o => {
  const { children: a, value: s, index: $, ...j } = o
  return jsxRuntimeExports.jsx('section', {
    role: 'tabpanel',
    hidden: s !== $,
    id: `workshop-tabpanel-${$}`,
    'aria-labelledby': `workshop-tab-${$}`,
    ...j,
    children: s === $ ? a : null,
  })
}
TabPanel$1.propTypes = {
  children: propTypesExports.node,
  index: propTypesExports.number.isRequired,
  value: propTypesExports.number.isRequired,
}
const a11yProps$1 = o => ({
  id: `workshop-tab-${o}`,
  'aria-controls': `workshop-tabpanel-${o}`,
})
function IngredientsList({
  playerInventoryQuantities: o,
  recipe: { ingredients: a, name: s },
}) {
  return jsxRuntimeExports.jsxs('ul', {
    className: 'card-list',
    title: `Ingredients for ${s}`,
    children: [
      jsxRuntimeExports.jsx('li', {
        children: jsxRuntimeExports.jsx('h4', {
          children: 'Ingredients required:',
        }),
      }),
      Object.keys(a).map($ =>
        jsxRuntimeExports.jsx('li', {
          key: $,
          'data-testid': 'ingredient',
          children: jsxRuntimeExports.jsx('p', {
            className: classNames(o[$] >= a[$] ? 'in-stock' : 'out-of-stock'),
            children: INGREDIENTS_LIST_ITEM`${a[$]}${
              itemsMap[$].name
            }${integerString(o[$])}
            `,
          }),
        })
      ),
    ],
  })
}
IngredientsList.propTypes = {
  playerInventoryQuantities: propTypesExports.object.isRequired,
  recipe: propTypesExports.shape({
    ingredients: propTypesExports.object.isRequired,
    name: propTypesExports.string.isRequired,
  }).isRequired,
}
function totalIngredientsInRecipe(o, a = 1) {
  return a * Object.values(o.ingredients).reduce((s, $) => s + $, 0)
}
function UpgradePurchase({
  handleUpgradeTool: o,
  inventory: a,
  inventoryLimit: s,
  playerInventoryQuantities: $,
  upgrade: j,
}) {
  const { id: _e, name: et, description: tt } = j,
    rt = totalIngredientsInRecipe(j),
    nt =
      canMakeRecipe(j, a, 1) &&
      doesInventorySpaceRemain({
        inventory: a,
        inventoryLimit: (s === INFINITE_STORAGE_LIMIT ? 1 / 0 : s) + rt,
      }),
    it = () => o(j)
  return jsxRuntimeExports.jsxs(Card, {
    className: classNames('Recipe', { 'can-be-made': nt }),
    children: [
      jsxRuntimeExports.jsx(CardHeader, {
        avatar: jsxRuntimeExports.jsx('img', {
          src: craftedItems[_e],
          alt: et,
        }),
        title: et,
        subheader: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
          children: [
            jsxRuntimeExports.jsx('p', { children: tt }),
            jsxRuntimeExports.jsx(IngredientsList, {
              playerInventoryQuantities: $,
              recipe: j,
            }),
          ],
        }),
      }),
      jsxRuntimeExports.jsx(CardActions, {
        children: jsxRuntimeExports.jsx(Button, {
          color: 'primary',
          onClick: it,
          variant: 'contained',
          disabled: !nt,
          children: 'Upgrade Tool',
        }),
      }),
    ],
  })
}
UpgradePurchase.propTypes = {
  handleUpgradeTool: propTypesExports.func.isRequired,
  inventory: propTypesExports.array.isRequired,
  inventoryLimit: propTypesExports.number.isRequired,
  playerInventoryQuantities: propTypesExports.object.isRequired,
  toolLevels: propTypesExports.object,
  upgrade: propTypesExports.object,
}
function Consumer$3(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(UpgradePurchase, { ...a, ...s, ...o }),
  })
}
const Recipe = ({
  handleMakeRecipeClick: o,
  inventory: a,
  inventoryLimit: s,
  playerInventoryQuantities: $,
  recipe: j,
  recipe: { id: _e, name: et, description: tt },
}) => {
  const [rt, nt] = reactExports.useState(1)
  reactExports.useEffect(() => {
    nt(Math.min(maxYieldOfRecipe(j, a), Math.max(1, rt)))
  }, [a, j, rt])
  const it = rt * totalIngredientsInRecipe(j),
    ot =
      rt > 0 &&
      canMakeRecipe(j, a, rt) &&
      doesInventorySpaceRemain({
        inventory: a,
        inventoryLimit: (s === INFINITE_STORAGE_LIMIT ? 1 / 0 : s) + it,
      }),
    at = () => {
      ot && o(j, rt)
    },
    st = maxYieldOfRecipe(j, a)
  return jsxRuntimeExports.jsxs(Card, {
    className: classNames('Recipe', { 'can-be-made': ot }),
    children: [
      jsxRuntimeExports.jsx(CardHeader, {
        avatar: jsxRuntimeExports.jsx('img', {
          src: craftedItems[_e],
          alt: et,
        }),
        title: et,
        subheader: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
          children: [
            jsxRuntimeExports.jsxs('p', {
              children: ['Sell price: ', dollarString(itemsMap[_e].value)],
            }),
            jsxRuntimeExports.jsxs('p', {
              children: ['In Inventory: ', integerString($[_e])],
            }),
            jsxRuntimeExports.jsx(IngredientsList, {
              playerInventoryQuantities: $,
              recipe: j,
            }),
          ],
        }),
      }),
      tt &&
        jsxRuntimeExports.jsx(CardContent, {
          children: jsxRuntimeExports.jsx(Typography, { children: tt }),
        }),
      jsxRuntimeExports.jsxs(CardActions, {
        children: [
          jsxRuntimeExports.jsx(Button, {
            className: 'make-recipe',
            color: 'primary',
            disabled: !ot || !rt,
            onClick: at,
            variant: 'contained',
            children: 'Make',
          }),
          jsxRuntimeExports.jsx(QuantityInput, {
            handleSubmit: at,
            handleUpdateNumber: nt,
            maxQuantity: st,
            setQuantity: nt,
            value: rt,
          }),
        ],
      }),
    ],
  })
}
Recipe.propTypes = {
  handleMakeRecipeClick: propTypesExports.func.isRequired,
  inventory: propTypesExports.array.isRequired,
  inventoryLimit: propTypesExports.number.isRequired,
  playerInventoryQuantities: propTypesExports.object.isRequired,
  recipe: propTypesExports.object.isRequired,
}
function Consumer$2(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Recipe, { ...a, ...s, ...o }),
  })
}
function RecipeList({ allRecipes: o, learnedRecipes: a }) {
  const [s, $] = reactExports.useState(''),
    j = s
      ? a.filter(tt => {
          var rt, nt
          return (nt = (rt = o[tt]) == null ? void 0 : rt.name) == null
            ? void 0
            : nt.toLowerCase().includes(s.toLowerCase())
        })
      : a,
    _e = j.length,
    et = Object.keys(o).length
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
    children: [
      jsxRuntimeExports.jsxs('h3', {
        children: ['Learned Recipes (', _e, ' / ', et, ')'],
      }),
      a.length > 0 &&
        jsxRuntimeExports.jsx(SearchBar, {
          placeholder: 'Search recipes...',
          onSearch: $,
        }),
      j.length > 0 &&
        jsxRuntimeExports.jsx('ul', {
          className: 'card-list',
          children: j.map(tt =>
            jsxRuntimeExports.jsx(
              'li',
              {
                children: jsxRuntimeExports.jsx(Consumer$2, { recipe: o[tt] }),
              },
              tt
            )
          ),
        }),
    ],
  })
}
RecipeList.propTypes = {
  allRecipes: PropTypes$1.object.isRequired,
  learnedRecipes: PropTypes$1.array.isRequired,
}
function getUpgradesAvailable({ learnedForgeRecipes: o, toolLevels: a }) {
  let s = []
  for (let $ of Object.keys(upgrades)) {
    const j = upgrades[$][a[$]]
    if (j && !j.isMaxLevel && j.nextLevel) {
      const _e = upgrades[$][j.nextLevel]
      let et = !0
      for (let tt of Object.keys(_e.ingredients))
        et = et && !!(!recipesMap[tt] || o.includes(tt))
      et && s.push(_e)
    }
  }
  return s
}
function ForgeTabPanel({
  currentTab: o,
  index: a,
  learnedForgeRecipes: s,
  toolLevels: $,
}) {
  const j = getUpgradesAvailable({ toolLevels: $, learnedForgeRecipes: s })
  return jsxRuntimeExports.jsxs(TabPanel$1, {
    value: o,
    index: a,
    children: [
      jsxRuntimeExports.jsx(RecipeList, {
        learnedRecipes: s,
        allRecipes: recipeCategories[recipeType.FORGE],
      }),
      j.length
        ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [
              jsxRuntimeExports.jsx(Divider, {}),
              jsxRuntimeExports.jsxs('ul', {
                className: 'card-list',
                children: [
                  jsxRuntimeExports.jsx('li', {
                    children: jsxRuntimeExports.jsx('h4', {
                      children: 'Tool Upgrades',
                    }),
                  }),
                  j.map(_e =>
                    jsxRuntimeExports.jsx(
                      'li',
                      {
                        children: jsxRuntimeExports.jsx(Consumer$3, {
                          upgrade: _e,
                        }),
                      },
                      _e.id
                    )
                  ),
                ],
              }),
            ],
          })
        : null,
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsx('ul', {
        className: 'card-list',
        children: jsxRuntimeExports.jsx('li', {
          children: jsxRuntimeExports.jsx(Card, {
            children: jsxRuntimeExports.jsx(CardContent, {
              children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
                linkTarget: '_blank',
                className: 'markdown',
                source:
                  'Forge recipes are learned by selling resources mined from the field.',
              }),
            }),
          }),
        }),
      }),
    ],
  })
}
ForgeTabPanel.propTypes = {
  currentTab: propTypesExports.number.isRequired,
  index: propTypesExports.number.isRequired,
  learnedForgeRecipes: propTypesExports.array.isRequired,
  toolLevels: propTypesExports.object.isRequired,
}
function KitchenTabPanel({
  currentTab: o,
  index: a,
  learnedKitchenRecipes: s,
}) {
  return jsxRuntimeExports.jsxs(TabPanel$1, {
    value: o,
    index: a,
    children: [
      jsxRuntimeExports.jsx(RecipeList, {
        learnedRecipes: s,
        allRecipes: recipeCategories[recipeType.KITCHEN],
      }),
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsx('ul', {
        className: 'card-list',
        children: jsxRuntimeExports.jsx('li', {
          children: jsxRuntimeExports.jsx(Card, {
            children: jsxRuntimeExports.jsx(CardContent, {
              children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
                linkTarget: '_blank',
                className: 'markdown',
                source:
                  'Kitchen recipes are learned by selling crops and animal products. Sell as much as you can of a wide variety of items!',
              }),
            }),
          }),
        }),
      }),
    ],
  })
}
KitchenTabPanel.propTypes = {
  currentTab: propTypesExports.number.isRequired,
  index: propTypesExports.number.isRequired,
  learnedKitchenRecipes: propTypesExports.array.isRequired,
}
function RecyclingTabPanel({ currentTab: o, index: a, learnedRecipes: s }) {
  return jsxRuntimeExports.jsxs(TabPanel$1, {
    value: o,
    index: a,
    children: [
      jsxRuntimeExports.jsx(RecipeList, {
        learnedRecipes: s,
        allRecipes: recipeCategories[recipeType.RECYCLING],
      }),
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsx('ul', {
        className: 'card-list',
        children: jsxRuntimeExports.jsx('li', {
          children: jsxRuntimeExports.jsx(Card, {
            children: jsxRuntimeExports.jsx(CardContent, {
              children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
                linkTarget: '_blank',
                className: 'markdown',
                source:
                  'Recyling recipes are learned by selling items foraged from the field.',
              }),
            }),
          }),
        }),
      }),
    ],
  })
}
RecyclingTabPanel.propTypes = {
  currentTab: propTypesExports.number.isRequired,
  index: propTypesExports.number.isRequired,
  learnedRecipes: propTypesExports.array.isRequired,
}
const Workshop = ({
  learnedRecipes: o,
  purchasedComposter: a,
  purchasedSmelter: s,
  toolLevels: $,
}) => {
  const [j, _e] = reactExports.useState(0),
    et = Object.keys(o).filter(
      ot => recipesMap[ot].recipeType === recipeType.KITCHEN
    ),
    tt = Object.keys(o).filter(
      ot => recipesMap[ot].recipeType === recipeType.FORGE
    ),
    rt = Object.keys(o).filter(
      ot => recipesMap[ot].recipeType === recipeType.RECYCLING
    ),
    nt = s,
    it = nt ? 2 : 1
  return jsxRuntimeExports.jsxs('div', {
    className: 'Workshop',
    children: [
      jsxRuntimeExports.jsxs(Tabs, {
        value: j,
        onChange: (ot, at) => _e(at),
        'aria-label': 'Workshop tabs',
        children: [
          jsxRuntimeExports.jsx(Tab, { label: 'Kitchen', ...a11yProps$1(0) }),
          nt
            ? jsxRuntimeExports.jsx(Tab, { label: 'Forge', ...a11yProps$1(1) })
            : null,
          a
            ? jsxRuntimeExports.jsx(Tab, {
                label: 'Recycling',
                ...a11yProps$1(it),
              })
            : null,
        ],
      }),
      jsxRuntimeExports.jsx(KitchenTabPanel, {
        currentTab: j,
        index: 0,
        learnedKitchenRecipes: et,
        setCurrentTab: _e,
      }),
      nt
        ? jsxRuntimeExports.jsx(ForgeTabPanel, {
            currentTab: j,
            index: 1,
            learnedForgeRecipes: tt,
            setCurrentTab: _e,
            toolLevels: $,
          })
        : null,
      a
        ? jsxRuntimeExports.jsx(RecyclingTabPanel, {
            currentTab: j,
            index: it,
            learnedRecipes: rt,
            setCurrentTab: _e,
          })
        : null,
    ],
  })
}
Workshop.propTypes = {
  learnedRecipes: propTypesExports.object.isRequired,
  purchasedComposter: propTypesExports.number,
  purchasedSmelter: propTypesExports.number,
  toolLevels: propTypesExports.object.isRequired,
}
function Consumer$1(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Workshop, { ...a, ...s, ...o }),
  })
}
const TabPanel = o => {
  const { children: a, value: s, index: $, ...j } = o
  return jsxRuntimeExports.jsx('section', {
    role: 'tabpanel',
    hidden: s !== $,
    id: `cellar-tabpanel-${$}`,
    'aria-labelledby': `cellar-tab-${$}`,
    ...j,
    children: s === $ ? a : null,
  })
}
TabPanel.propTypes = {
  children: propTypesExports.node,
  index: propTypesExports.number.isRequired,
  value: propTypesExports.number.isRequired,
}
const a11yProps = o => ({
  id: `cellar-tab-${o}`,
  'aria-controls': `cellar-tabpanel-${o}`,
})
function Keg({ keg: o }) {
  const {
      handlers: { handleSellKegClick: a, handleThrowAwayKegClick: s },
      gameState: { completedAchievements: $ },
    } = reactExports.useContext(FarmhandContext),
    j = itemsMap[o.itemId]
  let _e = items[j.id],
    et = FERMENTED_CROP_NAME`${j}`
  const tt = () => {
      a(o)
    },
    rt = () => {
      s(o)
    },
    nt = o.daysUntilMature <= 0,
    it = getKegValue(o) * getSalePriceMultiplier($)
  wineService.isWineRecipe(j) && ((_e = wines[j.variety]), (et = j.name))
  const ot = getKegSpoilageRate(o),
    at = Number((ot * 100).toPrecision(2))
  return jsxRuntimeExports.jsxs(Card, {
    className: 'Keg',
    children: [
      jsxRuntimeExports.jsx(CardHeader, {
        title: et,
        avatar: jsxRuntimeExports.jsx('img', { src: _e, alt: et }),
        subheader: jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
          children: nt
            ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [
                  jsxRuntimeExports.jsxs('p', {
                    children: [
                      'Days since ready: ',
                      Math.abs(o.daysUntilMature),
                    ],
                  }),
                  jsxRuntimeExports.jsxs('p', {
                    children: [
                      'Current value:',
                      ' ',
                      jsxRuntimeExports.jsx(AnimatedNumber, {
                        number: it,
                        formatter: moneyString,
                      }),
                    ],
                  }),
                  cellarService.doesKegSpoil(o) &&
                    jsxRuntimeExports.jsxs('p', {
                      children: ['Potential for spoilage: ', at, '%'],
                    }),
                ],
              })
            : jsxRuntimeExports.jsxs('p', {
                children: ['Days until ready: ', o.daysUntilMature],
              }),
        }),
      }),
      jsxRuntimeExports.jsxs(CardActions, {
        children: [
          jsxRuntimeExports.jsx(Button, {
            className: 'sell-keg',
            color: 'error',
            onClick: tt,
            variant: 'contained',
            disabled: !nt,
            children: 'Sell',
          }),
          nt
            ? null
            : jsxRuntimeExports.jsx(Button, {
                className: 'throw-away-keg',
                color: 'error',
                onClick: rt,
                variant: 'contained',
                children: 'Throw away',
              }),
        ],
      }),
    ],
  })
}
Keg.propTypes = { keg: propTypesExports.object.isRequired }
const CellarInventoryTabPanel = ({ index: o, currentTab: a }) => {
  const [s, $] = reactExports.useState(''),
    {
      gameState: { cellarInventory: j, purchasedCellar: _e },
    } = reactExports.useContext(FarmhandContext),
    et = s
      .toLowerCase()
      .split(' ')
      .filter(nt => nt.length > 0),
    tt = j.filter(nt => {
      const ot = itemsMap[nt.itemId].name.toLowerCase(),
        at = `${FERMENTED_CROP_NAME}${ot}`
      return et.every(st => at.includes(st) || ot.includes(st))
    }),
    rt = PURCHASEABLE_CELLARS.get(_e)
  if (rt === void 0) throw new TypeError(`Invalid purchasedCellar value: ${_e}`)
  return jsxRuntimeExports.jsxs(TabPanel, {
    value: a,
    index: o,
    children: [
      jsxRuntimeExports.jsxs('h3', {
        children: [
          'Capacity: ',
          integerString(j.length),
          ' /',
          ' ',
          integerString(rt.space),
        ],
      }),
      j.length > 0 &&
        jsxRuntimeExports.jsx(SearchBar, {
          placeholder: 'Search kegs...',
          onSearch: $,
        }),
      jsxRuntimeExports.jsx('ul', {
        className: 'card-list',
        children: tt.map(nt =>
          jsxRuntimeExports.jsx(
            'li',
            { children: jsxRuntimeExports.jsx(Keg, { keg: nt }) },
            nt.id
          )
        ),
      }),
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsx('ul', {
        className: 'card-list',
        children: jsxRuntimeExports.jsx('li', {
          children: jsxRuntimeExports.jsx(Card, {
            children: jsxRuntimeExports.jsx(CardContent, {
              children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
                linkTarget: '_blank',
                className: 'markdown',
                source: `This is your inventory of Cellar kegs.

Keg contents take time to reach maturity before they can be sold. After they reach maturity, keg contents become higher in quality over time and their value grows.

Kegs that contain fermented crops compound in value at a rate of ${KEG_INTEREST_RATE}% a day but have an increasing chance of spoiling.

Kegs that contain wine compound in value at a rate of ${WINE_INTEREST_RATE}% for up to ${integerString(
                  WINE_GROWTH_TIMELINE_CAP
                )} days and never spoil.`,
              }),
            }),
          }),
        }),
      }),
    ],
  })
}
CellarInventoryTabPanel.propTypes = {
  currentTab: propTypesExports.number.isRequired,
  index: propTypesExports.number.isRequired,
}
function getCropsAvailableToFerment(o) {
  return Object.keys(o.items)
    .map(s => getFinalCropItemFromSeedItem(itemsMap[s]))
    .filter(s => (s ? 'daysToFerment' in s : !1))
}
const FermentationRecipe = ({ item: o }) => {
  const {
      gameState: { inventory: a, cellarInventory: s, purchasedCellar: $ },
      handlers: { handleMakeFermentationRecipeClick: j },
    } = reactExports.useContext(FarmhandContext),
    [_e, et] = reactExports.useState(1),
    tt = getInventoryQuantityMap(a),
    rt = FERMENTED_CROP_NAME`${o}`,
    { space: nt } = PURCHASEABLE_CELLARS.get($) ?? { space: 0 }
  reactExports.useEffect(() => {
    et(Math.min(getMaxYieldOfFermentationRecipe(o, a, s, nt), Math.max(1, _e)))
  }, [s, nt, a, o, _e])
  const it = _e > 0 && cellarService.doesCellarSpaceRemain(s, $),
    ot = () => {
      it && j(o, _e)
    },
    at = getMaxYieldOfFermentationRecipe(o, a, s, nt),
    st = cellarService.getItemInstancesInCellar(s, o)
  return jsxRuntimeExports.jsxs(Card, {
    className: 'FermentationRecipe',
    children: [
      jsxRuntimeExports.jsx(CardHeader, {
        title: rt,
        avatar: jsxRuntimeExports.jsx('img', { src: items[o.id], alt: rt }),
        subheader: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
          children: [
            jsxRuntimeExports.jsxs('p', {
              children: ['Days to ferment: ', o.daysToFerment],
            }),
            jsxRuntimeExports.jsxs('p', {
              children: [
                'Units of ',
                itemsMap[o.id].name,
                ' in inventory:',
                ' ',
                integerString(tt[o.id] ?? 0),
              ],
            }),
            jsxRuntimeExports.jsxs('p', {
              children: [
                'Units of ',
                itemsMap.salt.name,
                ' required:',
                ' ',
                getSaltRequirementsForFermentationRecipe(o),
                ' (available:',
                ' ',
                jsxRuntimeExports.jsx(AnimatedNumber, {
                  number: tt[itemsMap.salt.id] ?? 0,
                  formatter: integerString,
                }),
                ')',
              ],
            }),
            jsxRuntimeExports.jsxs('p', {
              children: ['In cellar: ', integerString(st ?? 0)],
            }),
          ],
        }),
      }),
      jsxRuntimeExports.jsxs(CardActions, {
        children: [
          jsxRuntimeExports.jsx(Button, {
            className: 'make-recipe',
            color: 'primary',
            disabled: !it || !_e,
            onClick: ot,
            variant: 'contained',
            children: 'Make',
          }),
          jsxRuntimeExports.jsx(QuantityInput, {
            handleSubmit: ot,
            handleUpdateNumber: et,
            maxQuantity: at,
            setQuantity: et,
            value: _e,
          }),
        ],
      }),
    ],
  })
}
FermentationRecipe.propTypes = { item: propTypesExports.object.isRequired }
const totalFermentableItems = Object.keys(fermentableItemsMap).length,
  FermentationRecipeList = () => {
    const {
        gameState: { levelEntitlements: o },
      } = reactExports.useContext(FarmhandContext),
      a = getCropsAvailableToFerment(o),
      [s, $] = reactExports.useState(''),
      j = s
        .toLowerCase()
        .split(' ')
        .filter(tt => tt.length > 0),
      _e = a.filter(tt => {
        const rt = `${FERMENTED_CROP_NAME}${tt.name}`.toLowerCase()
        return j.every(
          nt => rt.includes(nt) || tt.name.toLowerCase().includes(nt)
        )
      }),
      et = _e.length
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsxs('h3', {
          children: [
            'Available Fermentation Recipes (',
            et,
            ' /',
            ' ',
            totalFermentableItems,
            ')',
          ],
        }),
        a.length > 0 &&
          jsxRuntimeExports.jsx(SearchBar, {
            placeholder: 'Search fermentation recipes...',
            onSearch: $,
          }),
        _e.length > 0 &&
          jsxRuntimeExports.jsx('ul', {
            className: 'card-list',
            children: _e.map(tt =>
              jsxRuntimeExports.jsx(
                'li',
                {
                  children: jsxRuntimeExports.jsx(FermentationRecipe, {
                    item: tt,
                  }),
                },
                tt.id
              )
            ),
          }),
      ],
    })
  }
FermentationRecipeList.propTypes = {}
const FermentationTabPanel = ({ index: o, currentTab: a }) =>
  jsxRuntimeExports.jsxs(TabPanel, {
    value: a,
    index: o,
    children: [
      jsxRuntimeExports.jsx(FermentationRecipeList, {}),
      jsxRuntimeExports.jsx(Divider, {}),
      jsxRuntimeExports.jsx('ul', {
        className: 'card-list',
        children: jsxRuntimeExports.jsx('li', {
          children: jsxRuntimeExports.jsx(Card, {
            children: jsxRuntimeExports.jsx(CardContent, {
              children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
                linkTarget: '_blank',
                className: 'markdown',
                source:
                  'Some items can be fermented and become much more valuable over time.',
              }),
            }),
          }),
        }),
      }),
    ],
  })
FermentationTabPanel.propTypes = {
  currentTab: propTypesExports.number.isRequired,
  index: propTypesExports.number.isRequired,
}
const getGrapesSold = o =>
  Object.entries(o).reduce((s, [$, j]) => {
    const _e = itemsMap[$]
    return j > 0 && isGrape(_e) && s.push(_e), s
  }, [])
function getWineVarietiesAvailableToMake(o) {
  return getGrapesSold(o).map(({ variety: $ }) => $)
}
const WineRecipe = ({ wineVariety: o }) => {
  const {
      gameState: { cellarInventory: a, inventory: s, purchasedCellar: $ },
      handlers: { handleMakeWineClick: j },
    } = reactExports.useContext(FarmhandContext),
    [_e, et] = reactExports.useState(1),
    tt = grapeVarietyNameMap[o],
    rt = grapeVarietyToGrapeItemMap[o],
    nt = itemsMap[rt.wineId],
    { space: it } = PURCHASEABLE_CELLARS.get($) ?? { space: 0 },
    ot = getInventoryQuantityMap(s),
    at = ot[rt.id] ?? 0,
    st = ot[yeast$1.id] ?? 0
  reactExports.useEffect(() => {
    et(
      Math.min(
        wineService.getMaxWineYield({
          grape: rt,
          inventory: s,
          cellarInventory: a,
          cellarSize: it,
        }),
        Math.max(1, _e)
      )
    )
  }, [a, it, rt, s, _e, o])
  const ut =
      _e > 0 &&
      at >= GRAPES_REQUIRED_FOR_WINE &&
      cellarService.doesCellarSpaceRemain(a, $),
    ct = !ut || !_e,
    dt = cellarService.getItemInstancesInCellar(a, nt),
    ft = wineService.getMaxWineYield({
      grape: rt,
      inventory: s,
      cellarInventory: a,
      cellarSize: it,
    }),
    mt = () => {
      ut && j(rt, _e)
    }
  return jsxRuntimeExports.jsxs(Card, {
    className: 'WineRecipe',
    sx: { position: 'relative' },
    children: [
      jsxRuntimeExports.jsx(CardHeader, {
        title: tt,
        avatar: jsxRuntimeExports.jsx('img', { src: wines[o], alt: tt }),
        subheader: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
          children: [
            jsxRuntimeExports.jsxs('p', {
              children: [
                'Days to mature:',
                ' ',
                integerString(wineService.getDaysToMature(o)),
              ],
            }),
            jsxRuntimeExports.jsxs('p', {
              children: [
                'Units of ',
                rt.name,
                ' required:',
                ' ',
                integerString(GRAPES_REQUIRED_FOR_WINE),
                ' (available:',
                ' ',
                integerString(at),
                ')',
              ],
            }),
            jsxRuntimeExports.jsxs('p', {
              children: [
                'Units of ',
                yeast$1.name,
                ' required:',
                ' ',
                integerString(getYeastRequiredForWine(o) * _e),
                ' ',
                '(available: ',
                integerString(st),
                ')',
              ],
            }),
            jsxRuntimeExports.jsxs('p', {
              children: ['In cellar: ', integerString(dt ?? 0)],
            }),
          ],
        }),
      }),
      jsxRuntimeExports.jsxs(CardActions, {
        children: [
          jsxRuntimeExports.jsx(Button, {
            color: 'primary',
            variant: 'contained',
            disabled: ct,
            onClick: mt,
            children: 'Make',
          }),
          jsxRuntimeExports.jsx(QuantityInput, {
            handleSubmit: mt,
            handleUpdateNumber: et,
            maxQuantity: ft,
            setQuantity: et,
            value: _e,
          }),
        ],
      }),
    ],
  })
}
WineRecipe.propTypes = {
  wineVariety: propTypesExports.oneOf(Object.keys(grapeVariety)),
}
const totalGrapeVarieties = Object.keys(grapeVariety).length,
  WineRecipeList = () => {
    const {
        gameState: { itemsSold: o },
      } = reactExports.useContext(FarmhandContext),
      a = getWineVarietiesAvailableToMake(o),
      [s, $] = reactExports.useState(''),
      j = a.filter(et => et.toLowerCase().includes(s.toLowerCase())),
      _e = j.length
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsxs('h3', {
          children: [
            'Available Wine Recipes (',
            _e,
            ' /',
            ' ',
            totalGrapeVarieties,
            ')',
          ],
        }),
        a.length > 0 &&
          jsxRuntimeExports.jsx(SearchBar, {
            placeholder: 'Search wine varieties...',
            onSearch: $,
          }),
        jsxRuntimeExports.jsx('ul', {
          className: 'card-list',
          children: j.map(et =>
            jsxRuntimeExports.jsx(
              'li',
              {
                children: jsxRuntimeExports.jsx(WineRecipe, {
                  wineVariety: et,
                }),
              },
              et
            )
          ),
        }),
      ],
    })
  },
  WinemakingTabPanel = ({ index: o, currentTab: a }) =>
    jsxRuntimeExports.jsxs(TabPanel, {
      value: a,
      index: o,
      children: [
        jsxRuntimeExports.jsx(WineRecipeList, {}),
        jsxRuntimeExports.jsx(Divider, {}),
        jsxRuntimeExports.jsx('ul', {
          className: 'card-list',
          children: jsxRuntimeExports.jsx('li', {
            children: jsxRuntimeExports.jsx(Card, {
              children: jsxRuntimeExports.jsx(CardContent, {
                children: jsxRuntimeExports.jsx(ReactMarkdown$1, {
                  linkTarget: '_blank',
                  className: 'markdown',
                  source:
                    'Grapes can be made into wine. Wine becomes very valuable in time and never spoils.',
                }),
              }),
            }),
          }),
        }),
      ],
    })
WinemakingTabPanel.propTypes = {
  currentTab: propTypesExports.number.isRequired,
  index: propTypesExports.number.isRequired,
}
const Cellar = () => {
  const [o, a] = reactExports.useState(0)
  return jsxRuntimeExports.jsxs('div', {
    className: 'Cellar',
    children: [
      jsxRuntimeExports.jsxs(Tabs, {
        value: o,
        onChange: (s, $) => a($),
        'aria-label': 'Cellar tabs',
        children: [
          jsxRuntimeExports.jsx(Tab, {
            label: 'Cellar Inventory',
            ...a11yProps(0),
          }),
          jsxRuntimeExports.jsx(Tab, {
            label: 'Fermentation',
            ...a11yProps(1),
          }),
          jsxRuntimeExports.jsx(Tab, { label: 'Winemaking', ...a11yProps(2) }),
        ],
      }),
      jsxRuntimeExports.jsx(CellarInventoryTabPanel, {
        index: 0,
        currentTab: o,
      }),
      jsxRuntimeExports.jsx(FermentationTabPanel, { index: 1, currentTab: o }),
      jsxRuntimeExports.jsx(WinemakingTabPanel, { index: 2, currentTab: o }),
    ],
  })
}
Cellar.propTypes = {}
const Stage = ({ field: o, stageFocus: a, viewTitle: s }) => {
  const $ = reactExports.useRef(null)
  return (
    reactExports.useEffect(() => {
      const {
        current: j,
        current: { style: _e },
      } = $
      ;(j.scrollTop = 0),
        (_e.overflow = 'hidden'),
        setTimeout(() => (_e.overflow = ''), 0)
    }, [a]),
    jsxRuntimeExports.jsxs('div', {
      className: classNames('Stage', {
        'is-october': isOctober(),
        'is-december': isDecember(),
      }),
      'data-stage-focus': a,
      role: 'main',
      ref: $,
      children: [
        jsxRuntimeExports.jsx('h2', { className: 'view-title', children: s }),
        a === stageFocusType.HOME && jsxRuntimeExports.jsx(Consumer$7, {}),
        a === stageFocusType.FIELD &&
          jsxRuntimeExports.jsx(Consumer$8, {
            columns: o[0].length,
            rows: o.length,
          }),
        a === stageFocusType.FOREST && jsxRuntimeExports.jsx(Forest, {}),
        a === stageFocusType.SHOP && jsxRuntimeExports.jsx(Consumer$4, {}),
        a === stageFocusType.COW_PEN && jsxRuntimeExports.jsx(Consumer$6, {}),
        a === stageFocusType.WORKSHOP && jsxRuntimeExports.jsx(Consumer$1, {}),
        a === stageFocusType.CELLAR && jsxRuntimeExports.jsx(Cellar, {}),
        jsxRuntimeExports.jsx('div', { className: 'spacer' }),
      ],
    })
  )
}
Stage.propTypes = {
  field: propTypesExports.arrayOf(propTypesExports.array).isRequired,
  stageFocus: propTypesExports.string.isRequired,
  viewTitle: propTypesExports.string.isRequired,
}
function Consumer(o) {
  return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
    children: ({ gameState: a, handlers: s }) =>
      jsxRuntimeExports.jsx(Stage, { ...a, ...s, ...o }),
  })
}
const snackbarProviderContentCallback = (
    o,
    { message: a, onClick: s, severity: $ }
  ) =>
    jsxRuntimeExports.jsx(Alert, {
      elevation: 3,
      key: o,
      onClick: s,
      severity: $,
      style: { cursor: s ? 'pointer' : 'default' },
      children: jsxRuntimeExports.jsx(ReactMarkdown$1, { source: a }),
    }),
  NotificationSystem = ({
    closeSnackbar: o,
    enqueueSnackbar: a,
    latestNotification: s,
  }) => (
    reactExports.useEffect(() => {
      s &&
        a(s, {
          autoHideDuration: NOTIFICATION_DURATION,
          onClose: () => o(),
          preventDuplicate: !0,
        })
    }, [o, a, s]),
    null
  )
NotificationSystem.propTypes = {
  latestNotification: propTypesExports.shape({
    message: propTypesExports.string.isRequired,
    onClick: propTypesExports.func,
    severity: propTypesExports.string.isRequired,
  }),
}
const NotificationSystem$1 = withSnackbar(function o(a) {
    return jsxRuntimeExports.jsx(FarmhandContext.Consumer, {
      children: ({ gameState: s, handlers: $ }) =>
        jsxRuntimeExports.jsx(NotificationSystem, { ...s, ...$, ...a }),
    })
  }),
  scriptRel = 'modulepreload',
  assetsURL = function(o) {
    return '/' + o
  },
  seen = {},
  __vitePreload = function o(a, s, $) {
    let j = Promise.resolve()
    if (s && s.length > 0) {
      document.getElementsByTagName('link')
      const et = document.querySelector('meta[property=csp-nonce]'),
        tt =
          (et == null ? void 0 : et.nonce) ||
          (et == null ? void 0 : et.getAttribute('nonce'))
      j = Promise.allSettled(
        s.map(rt => {
          if (((rt = assetsURL(rt)), rt in seen)) return
          seen[rt] = !0
          const nt = rt.endsWith('.css'),
            it = nt ? '[rel="stylesheet"]' : ''
          if (document.querySelector(`link[href="${rt}"]${it}`)) return
          const ot = document.createElement('link')
          if (
            ((ot.rel = nt ? 'stylesheet' : scriptRel),
            nt || (ot.as = 'script'),
            (ot.crossOrigin = ''),
            (ot.href = rt),
            tt && ot.setAttribute('nonce', tt),
            document.head.appendChild(ot),
            nt)
          )
            return new Promise((at, st) => {
              ot.addEventListener('load', at),
                ot.addEventListener('error', () =>
                  st(new Error(`Unable to preload CSS for ${rt}`))
                )
            })
        })
      )
    }
    function _e(et) {
      const tt = new Event('vite:preloadError', { cancelable: !0 })
      if (((tt.payload = et), window.dispatchEvent(tt), !tt.defaultPrevented))
        throw et
    }
    return j.then(et => {
      for (const tt of et || []) tt.status === 'rejected' && _e(tt.reason)
      return a().catch(_e)
    })
  }
function registerSW(o = {}) {
  const {
    immediate: a = !1,
    onNeedRefresh: s,
    onOfflineReady: $,
    onRegistered: j,
    onRegisteredSW: _e,
    onRegisterError: et,
  } = o
  let tt, rt, nt
  const it = async (at = !0) => {
    await rt, await (nt == null ? void 0 : nt())
  }
  async function ot() {
    if ('serviceWorker' in navigator) {
      if (
        ((tt = await __vitePreload(async () => {
          const { Workbox: at } = await import(
            './workbox-window.prod.es5-D5gOYdM7.js'
          )
          return { Workbox: at }
        }, [])
          .then(
            ({ Workbox: at }) =>
              new at('/service-worker.js', { scope: '/', type: 'classic' })
          )
          .catch(at => {
            et == null || et(at)
          })),
        !tt)
      )
        return
      nt = async () => {
        await (tt == null ? void 0 : tt.messageSkipWaiting())
      }
      {
        let at = !1
        const st = () => {
          ;(at = !0),
            tt == null ||
              tt.addEventListener('controlling', ut => {
                ut.isUpdate && window.location.reload()
              }),
            s == null || s()
        }
        tt.addEventListener('installed', ut => {
          typeof ut.isUpdate > 'u'
            ? typeof ut.isExternal < 'u'
              ? ut.isExternal
                ? st()
                : !at && ($ == null || $())
              : ut.isExternal
              ? window.location.reload()
              : !at && ($ == null || $())
            : ut.isUpdate || $ == null || $()
        }),
          tt.addEventListener('waiting', st),
          tt.addEventListener('externalwaiting', st)
      }
      tt.register({ immediate: a })
        .then(at => {
          _e ? _e('/service-worker.js', at) : j == null || j(at)
        })
        .catch(at => {
          et == null || et(at)
        })
    }
  }
  return (rt = ot()), it
}
function useRegisterSW(o = {}) {
  const {
      immediate: a = !0,
      onNeedRefresh: s,
      onOfflineReady: $,
      onRegistered: j,
      onRegisteredSW: _e,
      onRegisterError: et,
    } = o,
    [tt, rt] = reactExports.useState(!1),
    [nt, it] = reactExports.useState(!1),
    [ot] = reactExports.useState(() =>
      registerSW({
        immediate: a,
        onOfflineReady() {
          it(!0), $ == null || $()
        },
        onNeedRefresh() {
          rt(!0), s == null || s()
        },
        onRegistered: j,
        onRegisteredSW: _e,
        onRegisterError: et,
      })
    )
  return {
    needRefresh: [tt, rt],
    offlineReady: [nt, it],
    updateServiceWorker: ot,
  }
}
const UpdateNotifier = () => {
    const {
        handlers: { handleGameUpdateAvailable: o },
      } = reactExports.useContext(FarmhandContext),
      {
        needRefresh: [a],
        updateServiceWorker: s,
      } = useRegisterSW()
    return (
      reactExports.useEffect(() => {
        a &&
          (o(s),
          window.addEventListener('beforeunload', () => {
            s(!0)
          }))
      }, [a, o, s]),
      null
    )
  },
  theme = createTheme({
    palette: { mode: 'light' },
    shape: {},
    components: {
      MuiTabs: {
        styleOverrides: {
          root: ({ theme: o }) => ({
            background: '#ffeec6',
            borderColor: '#9b6d00',
            borderWidth: 2,
            borderStyle: 'solid',
            borderRadius: `${o.shape.borderRadius}px ${o.shape.borderRadius}px 0 0`,
          }),
        },
      },
      MuiInput: { styleOverrides: { root: { margin: '1rem 0' } } },
    },
  }),
  commonFetchConfig = {
    mode: 'cors',
    cache: 'no-cache',
    credentials: 'same-origin',
    headers: { 'Content-Type': 'application/json' },
    redirect: 'follow',
    referrerPolicy: 'no-referrer',
  }
async function getData(o = '', a = {}) {
  const s = new URLSearchParams()
  return (
    Object.keys(a).forEach(j =>
      s.append(encodeURIComponent(j), encodeURIComponent(a[j]))
    ),
    (await fetch(`${o}?${s}`, { ...commonFetchConfig, method: 'GET' })).json()
  )
}
async function postData(o = '', a = {}) {
  return (
    await fetch(o, {
      ...commonFetchConfig,
      method: 'POST',
      body: JSON.stringify(a),
    })
  ).json()
}
function _interopDefault(o) {
  return o && typeof o == 'object' && 'default' in o ? o.default : o
}
var React = reactExports,
  React__default = _interopDefault(React)
function _defineProperty(o, a, s) {
  return (
    a in o
      ? Object.defineProperty(o, a, {
          value: s,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (o[a] = s),
    o
  )
}
function _inheritsLoose(o, a) {
  ;(o.prototype = Object.create(a.prototype)),
    (o.prototype.constructor = o),
    (o.__proto__ = a)
}
var canUseDOM = !!(
  typeof window < 'u' &&
  window.document &&
  window.document.createElement
)
function withSideEffect(o, a, s) {
  if (typeof o != 'function')
    throw new Error('Expected reducePropsToState to be a function.')
  if (typeof a != 'function')
    throw new Error('Expected handleStateChangeOnClient to be a function.')
  if (typeof s < 'u' && typeof s != 'function')
    throw new Error(
      'Expected mapStateOnServer to either be undefined or a function.'
    )
  function $(j) {
    return j.displayName || j.name || 'Component'
  }
  return function(_e) {
    if (typeof _e != 'function')
      throw new Error('Expected WrappedComponent to be a React component.')
    var et = [],
      tt
    function rt() {
      ;(tt = o(
        et.map(function(it) {
          return it.props
        })
      )),
        nt.canUseDOM ? a(tt) : s && (tt = s(tt))
    }
    var nt = (function(it) {
      _inheritsLoose(ot, it)
      function ot() {
        return it.apply(this, arguments) || this
      }
      ;(ot.peek = function() {
        return tt
      }),
        (ot.rewind = function() {
          if (ot.canUseDOM)
            throw new Error(
              'You may only call rewind() on the server. Call peek() to read the current state.'
            )
          var ut = tt
          return (tt = void 0), (et = []), ut
        })
      var at = ot.prototype
      return (
        (at.UNSAFE_componentWillMount = function() {
          et.push(this), rt()
        }),
        (at.componentDidUpdate = function() {
          rt()
        }),
        (at.componentWillUnmount = function() {
          var ut = et.indexOf(this)
          et.splice(ut, 1), rt()
        }),
        (at.render = function() {
          return React__default.createElement(_e, this.props)
        }),
        ot
      )
    })(React.PureComponent)
    return (
      _defineProperty(nt, 'displayName', 'SideEffect(' + $(_e) + ')'),
      _defineProperty(nt, 'canUseDOM', canUseDOM),
      nt
    )
  }
}
var lib = withSideEffect
const withSideEffect$1 = getDefaultExportFromCjs(lib)
var hasElementType = typeof Element < 'u',
  hasMap = typeof Map == 'function',
  hasSet = typeof Set == 'function',
  hasArrayBuffer = typeof ArrayBuffer == 'function' && !!ArrayBuffer.isView
function equal(o, a) {
  if (o === a) return !0
  if (o && a && typeof o == 'object' && typeof a == 'object') {
    if (o.constructor !== a.constructor) return !1
    var s, $, j
    if (Array.isArray(o)) {
      if (((s = o.length), s != a.length)) return !1
      for ($ = s; $-- !== 0; ) if (!equal(o[$], a[$])) return !1
      return !0
    }
    var _e
    if (hasMap && o instanceof Map && a instanceof Map) {
      if (o.size !== a.size) return !1
      for (_e = o.entries(); !($ = _e.next()).done; )
        if (!a.has($.value[0])) return !1
      for (_e = o.entries(); !($ = _e.next()).done; )
        if (!equal($.value[1], a.get($.value[0]))) return !1
      return !0
    }
    if (hasSet && o instanceof Set && a instanceof Set) {
      if (o.size !== a.size) return !1
      for (_e = o.entries(); !($ = _e.next()).done; )
        if (!a.has($.value[0])) return !1
      return !0
    }
    if (hasArrayBuffer && ArrayBuffer.isView(o) && ArrayBuffer.isView(a)) {
      if (((s = o.length), s != a.length)) return !1
      for ($ = s; $-- !== 0; ) if (o[$] !== a[$]) return !1
      return !0
    }
    if (o.constructor === RegExp)
      return o.source === a.source && o.flags === a.flags
    if (
      o.valueOf !== Object.prototype.valueOf &&
      typeof o.valueOf == 'function' &&
      typeof a.valueOf == 'function'
    )
      return o.valueOf() === a.valueOf()
    if (
      o.toString !== Object.prototype.toString &&
      typeof o.toString == 'function' &&
      typeof a.toString == 'function'
    )
      return o.toString() === a.toString()
    if (((j = Object.keys(o)), (s = j.length), s !== Object.keys(a).length))
      return !1
    for ($ = s; $-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(a, j[$])) return !1
    if (hasElementType && o instanceof Element) return !1
    for ($ = s; $-- !== 0; )
      if (
        !(
          (j[$] === '_owner' || j[$] === '__v' || j[$] === '__o') &&
          o.$$typeof
        ) &&
        !equal(o[j[$]], a[j[$]])
      )
        return !1
    return !0
  }
  return o !== o && a !== a
}
var reactFastCompare = function o(a, s) {
  try {
    return equal(a, s)
  } catch ($) {
    if (($.message || '').match(/stack|recursion/i))
      return console.warn('react-fast-compare cannot handle circular refs'), !1
    throw $
  }
}
const isEqual = getDefaultExportFromCjs(reactFastCompare)
var define_global_default = {},
  ATTRIBUTE_NAMES = {
    BODY: 'bodyAttributes',
    HTML: 'htmlAttributes',
    TITLE: 'titleAttributes',
  },
  TAG_NAMES = {
    BASE: 'base',
    BODY: 'body',
    HEAD: 'head',
    HTML: 'html',
    LINK: 'link',
    META: 'meta',
    NOSCRIPT: 'noscript',
    SCRIPT: 'script',
    STYLE: 'style',
    TITLE: 'title',
  }
Object.keys(TAG_NAMES).map(function(o) {
  return TAG_NAMES[o]
})
var TAG_PROPERTIES = {
    CHARSET: 'charset',
    CSS_TEXT: 'cssText',
    HREF: 'href',
    HTTPEQUIV: 'http-equiv',
    INNER_HTML: 'innerHTML',
    ITEM_PROP: 'itemprop',
    NAME: 'name',
    PROPERTY: 'property',
    REL: 'rel',
    SRC: 'src',
    TARGET: 'target',
  },
  REACT_TAG_MAP = {
    accesskey: 'accessKey',
    charset: 'charSet',
    class: 'className',
    contenteditable: 'contentEditable',
    contextmenu: 'contextMenu',
    'http-equiv': 'httpEquiv',
    itemprop: 'itemProp',
    tabindex: 'tabIndex',
  },
  HELMET_PROPS = {
    DEFAULT_TITLE: 'defaultTitle',
    DEFER: 'defer',
    ENCODE_SPECIAL_CHARACTERS: 'encodeSpecialCharacters',
    ON_CHANGE_CLIENT_STATE: 'onChangeClientState',
    TITLE_TEMPLATE: 'titleTemplate',
  },
  HTML_TAG_MAP = Object.keys(REACT_TAG_MAP).reduce(function(o, a) {
    return (o[REACT_TAG_MAP[a]] = a), o
  }, {}),
  SELF_CLOSING_TAGS = [TAG_NAMES.NOSCRIPT, TAG_NAMES.SCRIPT, TAG_NAMES.STYLE],
  HELMET_ATTRIBUTE = 'data-react-helmet',
  _typeof =
    typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
      ? function(o) {
          return typeof o
        }
      : function(o) {
          return o &&
            typeof Symbol == 'function' &&
            o.constructor === Symbol &&
            o !== Symbol.prototype
            ? 'symbol'
            : typeof o
        },
  classCallCheck = function(o, a) {
    if (!(o instanceof a))
      throw new TypeError('Cannot call a class as a function')
  },
  createClass = (function() {
    function o(a, s) {
      for (var $ = 0; $ < s.length; $++) {
        var j = s[$]
        ;(j.enumerable = j.enumerable || !1),
          (j.configurable = !0),
          'value' in j && (j.writable = !0),
          Object.defineProperty(a, j.key, j)
      }
    }
    return function(a, s, $) {
      return s && o(a.prototype, s), $ && o(a, $), a
    }
  })(),
  _extends =
    Object.assign ||
    function(o) {
      for (var a = 1; a < arguments.length; a++) {
        var s = arguments[a]
        for (var $ in s)
          Object.prototype.hasOwnProperty.call(s, $) && (o[$] = s[$])
      }
      return o
    },
  inherits = function(o, a) {
    if (typeof a != 'function' && a !== null)
      throw new TypeError(
        'Super expression must either be null or a function, not ' + typeof a
      )
    ;(o.prototype = Object.create(a && a.prototype, {
      constructor: { value: o, enumerable: !1, writable: !0, configurable: !0 },
    })),
      a &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(o, a)
          : (o.__proto__ = a))
  },
  objectWithoutProperties = function(o, a) {
    var s = {}
    for (var $ in o)
      a.indexOf($) >= 0 ||
        (Object.prototype.hasOwnProperty.call(o, $) && (s[$] = o[$]))
    return s
  },
  possibleConstructorReturn = function(o, a) {
    if (!o)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      )
    return a && (typeof a == 'object' || typeof a == 'function') ? a : o
  },
  encodeSpecialCharacters = function o(a) {
    var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0
    return s === !1
      ? String(a)
      : String(a)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#x27;')
  },
  getTitleFromPropsList = function o(a) {
    var s = getInnermostProperty(a, TAG_NAMES.TITLE),
      $ = getInnermostProperty(a, HELMET_PROPS.TITLE_TEMPLATE)
    if ($ && s)
      return $.replace(/%s/g, function() {
        return Array.isArray(s) ? s.join('') : s
      })
    var j = getInnermostProperty(a, HELMET_PROPS.DEFAULT_TITLE)
    return s || j || void 0
  },
  getOnChangeClientState = function o(a) {
    return (
      getInnermostProperty(a, HELMET_PROPS.ON_CHANGE_CLIENT_STATE) ||
      function() {}
    )
  },
  getAttributesFromPropsList = function o(a, s) {
    return s
      .filter(function($) {
        return typeof $[a] < 'u'
      })
      .map(function($) {
        return $[a]
      })
      .reduce(function($, j) {
        return _extends({}, $, j)
      }, {})
  },
  getBaseTagFromPropsList = function o(a, s) {
    return s
      .filter(function($) {
        return typeof $[TAG_NAMES.BASE] < 'u'
      })
      .map(function($) {
        return $[TAG_NAMES.BASE]
      })
      .reverse()
      .reduce(function($, j) {
        if (!$.length)
          for (var _e = Object.keys(j), et = 0; et < _e.length; et++) {
            var tt = _e[et],
              rt = tt.toLowerCase()
            if (a.indexOf(rt) !== -1 && j[rt]) return $.concat(j)
          }
        return $
      }, [])
  },
  getTagsFromPropsList = function o(a, s, $) {
    var j = {}
    return $.filter(function(_e) {
      return Array.isArray(_e[a])
        ? !0
        : (typeof _e[a] < 'u' &&
            warn(
              'Helmet: ' +
                a +
                ' should be of type "Array". Instead found type "' +
                _typeof(_e[a]) +
                '"'
            ),
          !1)
    })
      .map(function(_e) {
        return _e[a]
      })
      .reverse()
      .reduce(function(_e, et) {
        var tt = {}
        et.filter(function(at) {
          for (
            var st = void 0, ut = Object.keys(at), ct = 0;
            ct < ut.length;
            ct++
          ) {
            var dt = ut[ct],
              ft = dt.toLowerCase()
            s.indexOf(ft) !== -1 &&
              !(
                st === TAG_PROPERTIES.REL &&
                at[st].toLowerCase() === 'canonical'
              ) &&
              !(
                ft === TAG_PROPERTIES.REL &&
                at[ft].toLowerCase() === 'stylesheet'
              ) &&
              (st = ft),
              s.indexOf(dt) !== -1 &&
                (dt === TAG_PROPERTIES.INNER_HTML ||
                  dt === TAG_PROPERTIES.CSS_TEXT ||
                  dt === TAG_PROPERTIES.ITEM_PROP) &&
                (st = dt)
          }
          if (!st || !at[st]) return !1
          var mt = at[st].toLowerCase()
          return (
            j[st] || (j[st] = {}),
            tt[st] || (tt[st] = {}),
            j[st][mt] ? !1 : ((tt[st][mt] = !0), !0)
          )
        })
          .reverse()
          .forEach(function(at) {
            return _e.push(at)
          })
        for (var rt = Object.keys(tt), nt = 0; nt < rt.length; nt++) {
          var it = rt[nt],
            ot = objectAssign$1({}, j[it], tt[it])
          j[it] = ot
        }
        return _e
      }, [])
      .reverse()
  },
  getInnermostProperty = function o(a, s) {
    for (var $ = a.length - 1; $ >= 0; $--) {
      var j = a[$]
      if (j.hasOwnProperty(s)) return j[s]
    }
    return null
  },
  reducePropsToState = function o(a) {
    return {
      baseTag: getBaseTagFromPropsList(
        [TAG_PROPERTIES.HREF, TAG_PROPERTIES.TARGET],
        a
      ),
      bodyAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.BODY, a),
      defer: getInnermostProperty(a, HELMET_PROPS.DEFER),
      encode: getInnermostProperty(a, HELMET_PROPS.ENCODE_SPECIAL_CHARACTERS),
      htmlAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.HTML, a),
      linkTags: getTagsFromPropsList(
        TAG_NAMES.LINK,
        [TAG_PROPERTIES.REL, TAG_PROPERTIES.HREF],
        a
      ),
      metaTags: getTagsFromPropsList(
        TAG_NAMES.META,
        [
          TAG_PROPERTIES.NAME,
          TAG_PROPERTIES.CHARSET,
          TAG_PROPERTIES.HTTPEQUIV,
          TAG_PROPERTIES.PROPERTY,
          TAG_PROPERTIES.ITEM_PROP,
        ],
        a
      ),
      noscriptTags: getTagsFromPropsList(
        TAG_NAMES.NOSCRIPT,
        [TAG_PROPERTIES.INNER_HTML],
        a
      ),
      onChangeClientState: getOnChangeClientState(a),
      scriptTags: getTagsFromPropsList(
        TAG_NAMES.SCRIPT,
        [TAG_PROPERTIES.SRC, TAG_PROPERTIES.INNER_HTML],
        a
      ),
      styleTags: getTagsFromPropsList(
        TAG_NAMES.STYLE,
        [TAG_PROPERTIES.CSS_TEXT],
        a
      ),
      title: getTitleFromPropsList(a),
      titleAttributes: getAttributesFromPropsList(ATTRIBUTE_NAMES.TITLE, a),
    }
  },
  rafPolyfill = (function() {
    var o = Date.now()
    return function(a) {
      var s = Date.now()
      s - o > 16
        ? ((o = s), a(s))
        : setTimeout(function() {
            rafPolyfill(a)
          }, 0)
    }
  })(),
  cafPolyfill = function o(a) {
    return clearTimeout(a)
  },
  requestAnimationFrame$1 =
    typeof window < 'u'
      ? (window.requestAnimationFrame &&
          window.requestAnimationFrame.bind(window)) ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        rafPolyfill
      : define_global_default.requestAnimationFrame || rafPolyfill,
  cancelAnimationFrame$1 =
    typeof window < 'u'
      ? window.cancelAnimationFrame ||
        window.webkitCancelAnimationFrame ||
        window.mozCancelAnimationFrame ||
        cafPolyfill
      : define_global_default.cancelAnimationFrame || cafPolyfill,
  warn = function o(a) {
    return console && typeof console.warn == 'function' && console.warn(a)
  },
  _helmetCallback = null,
  handleClientStateChange = function o(a) {
    _helmetCallback && cancelAnimationFrame$1(_helmetCallback),
      a.defer
        ? (_helmetCallback = requestAnimationFrame$1(function() {
            commitTagChanges(a, function() {
              _helmetCallback = null
            })
          }))
        : (commitTagChanges(a), (_helmetCallback = null))
  },
  commitTagChanges = function o(a, s) {
    var $ = a.baseTag,
      j = a.bodyAttributes,
      _e = a.htmlAttributes,
      et = a.linkTags,
      tt = a.metaTags,
      rt = a.noscriptTags,
      nt = a.onChangeClientState,
      it = a.scriptTags,
      ot = a.styleTags,
      at = a.title,
      st = a.titleAttributes
    updateAttributes(TAG_NAMES.BODY, j),
      updateAttributes(TAG_NAMES.HTML, _e),
      updateTitle(at, st)
    var ut = {
        baseTag: updateTags(TAG_NAMES.BASE, $),
        linkTags: updateTags(TAG_NAMES.LINK, et),
        metaTags: updateTags(TAG_NAMES.META, tt),
        noscriptTags: updateTags(TAG_NAMES.NOSCRIPT, rt),
        scriptTags: updateTags(TAG_NAMES.SCRIPT, it),
        styleTags: updateTags(TAG_NAMES.STYLE, ot),
      },
      ct = {},
      dt = {}
    Object.keys(ut).forEach(function(ft) {
      var mt = ut[ft],
        vt = mt.newTags,
        yt = mt.oldTags
      vt.length && (ct[ft] = vt), yt.length && (dt[ft] = ut[ft].oldTags)
    }),
      s && s(),
      nt(a, ct, dt)
  },
  flattenArray = function o(a) {
    return Array.isArray(a) ? a.join('') : a
  },
  updateTitle = function o(a, s) {
    typeof a < 'u' &&
      document.title !== a &&
      (document.title = flattenArray(a)),
      updateAttributes(TAG_NAMES.TITLE, s)
  },
  updateAttributes = function o(a, s) {
    var $ = document.getElementsByTagName(a)[0]
    if ($) {
      for (
        var j = $.getAttribute(HELMET_ATTRIBUTE),
          _e = j ? j.split(',') : [],
          et = [].concat(_e),
          tt = Object.keys(s),
          rt = 0;
        rt < tt.length;
        rt++
      ) {
        var nt = tt[rt],
          it = s[nt] || ''
        $.getAttribute(nt) !== it && $.setAttribute(nt, it),
          _e.indexOf(nt) === -1 && _e.push(nt)
        var ot = et.indexOf(nt)
        ot !== -1 && et.splice(ot, 1)
      }
      for (var at = et.length - 1; at >= 0; at--) $.removeAttribute(et[at])
      _e.length === et.length
        ? $.removeAttribute(HELMET_ATTRIBUTE)
        : $.getAttribute(HELMET_ATTRIBUTE) !== tt.join(',') &&
          $.setAttribute(HELMET_ATTRIBUTE, tt.join(','))
    }
  },
  updateTags = function o(a, s) {
    var $ = document.head || document.querySelector(TAG_NAMES.HEAD),
      j = $.querySelectorAll(a + '[' + HELMET_ATTRIBUTE + ']'),
      _e = Array.prototype.slice.call(j),
      et = [],
      tt = void 0
    return (
      s &&
        s.length &&
        s.forEach(function(rt) {
          var nt = document.createElement(a)
          for (var it in rt)
            if (rt.hasOwnProperty(it))
              if (it === TAG_PROPERTIES.INNER_HTML) nt.innerHTML = rt.innerHTML
              else if (it === TAG_PROPERTIES.CSS_TEXT)
                nt.styleSheet
                  ? (nt.styleSheet.cssText = rt.cssText)
                  : nt.appendChild(document.createTextNode(rt.cssText))
              else {
                var ot = typeof rt[it] > 'u' ? '' : rt[it]
                nt.setAttribute(it, ot)
              }
          nt.setAttribute(HELMET_ATTRIBUTE, 'true'),
            _e.some(function(at, st) {
              return (tt = st), nt.isEqualNode(at)
            })
              ? _e.splice(tt, 1)
              : et.push(nt)
        }),
      _e.forEach(function(rt) {
        return rt.parentNode.removeChild(rt)
      }),
      et.forEach(function(rt) {
        return $.appendChild(rt)
      }),
      { oldTags: _e, newTags: et }
    )
  },
  generateElementAttributesAsString = function o(a) {
    return Object.keys(a).reduce(function(s, $) {
      var j = typeof a[$] < 'u' ? $ + '="' + a[$] + '"' : '' + $
      return s ? s + ' ' + j : j
    }, '')
  },
  generateTitleAsString = function o(a, s, $, j) {
    var _e = generateElementAttributesAsString($),
      et = flattenArray(s)
    return _e
      ? '<' +
          a +
          ' ' +
          HELMET_ATTRIBUTE +
          '="true" ' +
          _e +
          '>' +
          encodeSpecialCharacters(et, j) +
          '</' +
          a +
          '>'
      : '<' +
          a +
          ' ' +
          HELMET_ATTRIBUTE +
          '="true">' +
          encodeSpecialCharacters(et, j) +
          '</' +
          a +
          '>'
  },
  generateTagsAsString = function o(a, s, $) {
    return s.reduce(function(j, _e) {
      var et = Object.keys(_e)
          .filter(function(nt) {
            return !(
              nt === TAG_PROPERTIES.INNER_HTML || nt === TAG_PROPERTIES.CSS_TEXT
            )
          })
          .reduce(function(nt, it) {
            var ot =
              typeof _e[it] > 'u'
                ? it
                : it + '="' + encodeSpecialCharacters(_e[it], $) + '"'
            return nt ? nt + ' ' + ot : ot
          }, ''),
        tt = _e.innerHTML || _e.cssText || '',
        rt = SELF_CLOSING_TAGS.indexOf(a) === -1
      return (
        j +
        '<' +
        a +
        ' ' +
        HELMET_ATTRIBUTE +
        '="true" ' +
        et +
        (rt ? '/>' : '>' + tt + '</' + a + '>')
      )
    }, '')
  },
  convertElementAttributestoReactProps = function o(a) {
    var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    return Object.keys(a).reduce(function($, j) {
      return ($[REACT_TAG_MAP[j] || j] = a[j]), $
    }, s)
  },
  convertReactPropstoHtmlAttributes = function o(a) {
    var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}
    return Object.keys(a).reduce(function($, j) {
      return ($[HTML_TAG_MAP[j] || j] = a[j]), $
    }, s)
  },
  generateTitleAsReactComponent = function o(a, s, $) {
    var j,
      _e = ((j = { key: s }), (j[HELMET_ATTRIBUTE] = !0), j),
      et = convertElementAttributestoReactProps($, _e)
    return [React$5.createElement(TAG_NAMES.TITLE, et, s)]
  },
  generateTagsAsReactComponent = function o(a, s) {
    return s.map(function($, j) {
      var _e,
        et = ((_e = { key: j }), (_e[HELMET_ATTRIBUTE] = !0), _e)
      return (
        Object.keys($).forEach(function(tt) {
          var rt = REACT_TAG_MAP[tt] || tt
          if (
            rt === TAG_PROPERTIES.INNER_HTML ||
            rt === TAG_PROPERTIES.CSS_TEXT
          ) {
            var nt = $.innerHTML || $.cssText
            et.dangerouslySetInnerHTML = { __html: nt }
          } else et[rt] = $[tt]
        }),
        React$5.createElement(a, et)
      )
    })
  },
  getMethodsForTag = function o(a, s, $) {
    switch (a) {
      case TAG_NAMES.TITLE:
        return {
          toComponent: function() {
            return generateTitleAsReactComponent(a, s.title, s.titleAttributes)
          },
          toString: function() {
            return generateTitleAsString(a, s.title, s.titleAttributes, $)
          },
        }
      case ATTRIBUTE_NAMES.BODY:
      case ATTRIBUTE_NAMES.HTML:
        return {
          toComponent: function() {
            return convertElementAttributestoReactProps(s)
          },
          toString: function() {
            return generateElementAttributesAsString(s)
          },
        }
      default:
        return {
          toComponent: function() {
            return generateTagsAsReactComponent(a, s)
          },
          toString: function() {
            return generateTagsAsString(a, s, $)
          },
        }
    }
  },
  mapStateOnServer = function o(a) {
    var s = a.baseTag,
      $ = a.bodyAttributes,
      j = a.encode,
      _e = a.htmlAttributes,
      et = a.linkTags,
      tt = a.metaTags,
      rt = a.noscriptTags,
      nt = a.scriptTags,
      it = a.styleTags,
      ot = a.title,
      at = ot === void 0 ? '' : ot,
      st = a.titleAttributes
    return {
      base: getMethodsForTag(TAG_NAMES.BASE, s, j),
      bodyAttributes: getMethodsForTag(ATTRIBUTE_NAMES.BODY, $, j),
      htmlAttributes: getMethodsForTag(ATTRIBUTE_NAMES.HTML, _e, j),
      link: getMethodsForTag(TAG_NAMES.LINK, et, j),
      meta: getMethodsForTag(TAG_NAMES.META, tt, j),
      noscript: getMethodsForTag(TAG_NAMES.NOSCRIPT, rt, j),
      script: getMethodsForTag(TAG_NAMES.SCRIPT, nt, j),
      style: getMethodsForTag(TAG_NAMES.STYLE, it, j),
      title: getMethodsForTag(
        TAG_NAMES.TITLE,
        { title: at, titleAttributes: st },
        j
      ),
    }
  },
  Helmet = function o(a) {
    var s, $
    return (
      ($ = s = (function(j) {
        inherits(_e, j)
        function _e() {
          return (
            classCallCheck(this, _e),
            possibleConstructorReturn(this, j.apply(this, arguments))
          )
        }
        return (
          (_e.prototype.shouldComponentUpdate = function(tt) {
            return !isEqual(this.props, tt)
          }),
          (_e.prototype.mapNestedChildrenToProps = function(tt, rt) {
            if (!rt) return null
            switch (tt.type) {
              case TAG_NAMES.SCRIPT:
              case TAG_NAMES.NOSCRIPT:
                return { innerHTML: rt }
              case TAG_NAMES.STYLE:
                return { cssText: rt }
            }
            throw new Error(
              '<' +
                tt.type +
                ' /> elements are self-closing and can not contain children. Refer to our API for more information.'
            )
          }),
          (_e.prototype.flattenArrayTypeChildren = function(tt) {
            var rt,
              nt = tt.child,
              it = tt.arrayTypeChildren,
              ot = tt.newChildProps,
              at = tt.nestedChildren
            return _extends(
              {},
              it,
              ((rt = {}),
              (rt[nt.type] = [].concat(it[nt.type] || [], [
                _extends({}, ot, this.mapNestedChildrenToProps(nt, at)),
              ])),
              rt)
            )
          }),
          (_e.prototype.mapObjectTypeChildren = function(tt) {
            var rt,
              nt,
              it = tt.child,
              ot = tt.newProps,
              at = tt.newChildProps,
              st = tt.nestedChildren
            switch (it.type) {
              case TAG_NAMES.TITLE:
                return _extends(
                  {},
                  ot,
                  ((rt = {}),
                  (rt[it.type] = st),
                  (rt.titleAttributes = _extends({}, at)),
                  rt)
                )
              case TAG_NAMES.BODY:
                return _extends({}, ot, { bodyAttributes: _extends({}, at) })
              case TAG_NAMES.HTML:
                return _extends({}, ot, { htmlAttributes: _extends({}, at) })
            }
            return _extends(
              {},
              ot,
              ((nt = {}), (nt[it.type] = _extends({}, at)), nt)
            )
          }),
          (_e.prototype.mapArrayTypeChildrenToProps = function(tt, rt) {
            var nt = _extends({}, rt)
            return (
              Object.keys(tt).forEach(function(it) {
                var ot
                nt = _extends({}, nt, ((ot = {}), (ot[it] = tt[it]), ot))
              }),
              nt
            )
          }),
          (_e.prototype.warnOnInvalidChildren = function(tt, rt) {
            return !0
          }),
          (_e.prototype.mapChildrenToProps = function(tt, rt) {
            var nt = this,
              it = {}
            return (
              React$5.Children.forEach(tt, function(ot) {
                if (!(!ot || !ot.props)) {
                  var at = ot.props,
                    st = at.children,
                    ut = objectWithoutProperties(at, ['children']),
                    ct = convertReactPropstoHtmlAttributes(ut)
                  switch ((nt.warnOnInvalidChildren(ot, st), ot.type)) {
                    case TAG_NAMES.LINK:
                    case TAG_NAMES.META:
                    case TAG_NAMES.NOSCRIPT:
                    case TAG_NAMES.SCRIPT:
                    case TAG_NAMES.STYLE:
                      it = nt.flattenArrayTypeChildren({
                        child: ot,
                        arrayTypeChildren: it,
                        newChildProps: ct,
                        nestedChildren: st,
                      })
                      break
                    default:
                      rt = nt.mapObjectTypeChildren({
                        child: ot,
                        newProps: rt,
                        newChildProps: ct,
                        nestedChildren: st,
                      })
                      break
                  }
                }
              }),
              (rt = this.mapArrayTypeChildrenToProps(it, rt)),
              rt
            )
          }),
          (_e.prototype.render = function() {
            var tt = this.props,
              rt = tt.children,
              nt = objectWithoutProperties(tt, ['children']),
              it = _extends({}, nt)
            return (
              rt && (it = this.mapChildrenToProps(rt, it)),
              React$5.createElement(a, it)
            )
          }),
          createClass(_e, null, [
            {
              key: 'canUseDOM',
              set: function(tt) {
                a.canUseDOM = tt
              },
            },
          ]),
          _e
        )
      })(React$5.Component)),
      (s.propTypes = {
        base: PropTypes$1.object,
        bodyAttributes: PropTypes$1.object,
        children: PropTypes$1.oneOfType([
          PropTypes$1.arrayOf(PropTypes$1.node),
          PropTypes$1.node,
        ]),
        defaultTitle: PropTypes$1.string,
        defer: PropTypes$1.bool,
        encodeSpecialCharacters: PropTypes$1.bool,
        htmlAttributes: PropTypes$1.object,
        link: PropTypes$1.arrayOf(PropTypes$1.object),
        meta: PropTypes$1.arrayOf(PropTypes$1.object),
        noscript: PropTypes$1.arrayOf(PropTypes$1.object),
        onChangeClientState: PropTypes$1.func,
        script: PropTypes$1.arrayOf(PropTypes$1.object),
        style: PropTypes$1.arrayOf(PropTypes$1.object),
        title: PropTypes$1.string,
        titleAttributes: PropTypes$1.object,
        titleTemplate: PropTypes$1.string,
      }),
      (s.defaultProps = { defer: !0, encodeSpecialCharacters: !0 }),
      (s.peek = a.peek),
      (s.rewind = function() {
        var j = a.rewind()
        return (
          j ||
            (j = mapStateOnServer({
              baseTag: [],
              bodyAttributes: {},
              encodeSpecialCharacters: !0,
              htmlAttributes: {},
              linkTags: [],
              metaTags: [],
              noscriptTags: [],
              scriptTags: [],
              styleTags: [],
              title: '',
              titleAttributes: {},
            })),
          j
        )
      }),
      $
    )
  },
  NullComponent = function o() {
    return null
  },
  HelmetSideEffects = withSideEffect$1(
    reducePropsToState,
    handleClientStateChange,
    mapStateOnServer
  )(NullComponent),
  HelmetExport = Helmet(HelmetSideEffects)
HelmetExport.renderStatic = HelmetExport.rewind
const chitchatterDomain = 'https://chitchatter.im',
  ChatRoom = () => {
    const o = 'chat-title',
      a = 'chat-content',
      {
        handlers: { handleChatRoomOpenStateChange: s },
        gameState: { id: $, isChatOpen: j, room: _e },
      } = reactExports.useContext(FarmhandContext),
      et = () => {
        s(!1)
      },
      tt = jsxRuntimeExports.jsx('chat-room', {
        'root-url': chitchatterDomain,
        room: `__farmhand__${_e}`,
        'user-id': $,
        style: { height: '100%', width: '100%', border: 'none' },
        'color-mode': 'light',
      })
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
      children: [
        jsxRuntimeExports.jsx(HelmetExport, {
          children: jsxRuntimeExports.jsx('script', {
            src: `${chitchatterDomain}/sdk.js`,
          }),
        }),
        jsxRuntimeExports.jsxs(Dialog, {
          className: classNames('Farmhand', 'ChatRoom'),
          fullWidth: !0,
          keepMounted: !0,
          fullScreen: !0,
          open: j,
          onClose: et,
          'aria-describedby': o,
          'aria-labelledby': a,
          children: [
            jsxRuntimeExports.jsx(DialogTitle, {
              id: o,
              children: 'Chat room',
            }),
            jsxRuntimeExports.jsx(DialogContent, { id: a, children: tt }),
            jsxRuntimeExports.jsx(DialogActions, {
              children: jsxRuntimeExports.jsx(Button, {
                onClick: et,
                color: 'primary',
                autoFocus: !0,
                children: 'Close',
              }),
            }),
          ],
        }),
      ],
    })
  },
  itemIds = Object.keys(itemsMap),
  getInventoryQuantities = o => {
    const a = {}
    for (const s of itemIds) a[s] = 0
    for (const { id: s, quantity: $ } of o) a[s] = $
    return a
  }
class FarmhandReducers extends reactExports.Component {
  addCowToInventory() {
    throw new Error('Unimplemented')
  }
  addPeer() {
    throw new Error('Unimplemented')
  }
  adjustLoan() {
    throw new Error('Unimplemented')
  }
  changeCowAutomaticHugState() {
    throw new Error('Unimplemented')
  }
  changeCowBreedingPenResident() {
    throw new Error('Unimplemented')
  }
  changeCowName() {
    throw new Error('Unimplemented')
  }
  clearPlot() {
    throw new Error('Unimplemented')
  }
  computeStateForNextDay() {
    throw new Error('Unimplemented')
  }
  fertilizePlot() {
    throw new Error('Unimplemented')
  }
  forRange() {
    throw new Error('Unimplemented')
  }
  harvestPlot() {
    throw new Error('Unimplemented')
  }
  hugCow() {
    throw new Error('Unimplemented')
  }
  makeRecipe() {
    throw new Error('Unimplemented')
  }
  makeFermentationRecipe() {
    throw new Error('Unimplemented')
  }
  makeWine() {
    throw new Error('Unimplemented')
  }
  modifyCow() {
    throw new Error('Unimplemented')
  }
  offerCow() {
    throw new Error('Unimplemented')
  }
  plantInPlot() {
    throw new Error('Unimplemented')
  }
  prependPendingPeerMessage() {
    throw new Error('Unimplemented')
  }
  purchaseCombine() {
    throw new Error('Unimplemented')
  }
  purchaseComposter() {
    throw new Error('Unimplemented')
  }
  purchaseCow() {
    throw new Error('Unimplemented')
  }
  purchaseCowPen() {
    throw new Error('Unimplemented')
  }
  purchaseCellar() {
    throw new Error('Unimplemented')
  }
  purchaseField() {
    throw new Error('Unimplemented')
  }
  purchaseForest() {
    throw new Error('Unimplemented')
  }
  purchaseItem() {
    throw new Error('Unimplemented')
  }
  purchaseSmelter() {
    throw new Error('Unimplemented')
  }
  purchaseStorageExpansion() {
    throw new Error('Unimplemented')
  }
  removeCowFromInventory() {
    throw new Error('Unimplemented')
  }
  removeKegFromCellar() {
    throw new Error('Unimplemented')
  }
  removePeer() {
    throw new Error('Unimplemented')
  }
  selectCow() {
    throw new Error('Unimplemented')
  }
  sellCow() {
    throw new Error('Unimplemented')
  }
  sellItem() {
    throw new Error('Unimplemented')
  }
  sellKeg() {
    throw new Error('Unimplemented')
  }
  setScarecrow() {
    throw new Error('Unimplemented')
  }
  setSprinkler() {
    throw new Error('Unimplemented')
  }
  showNotification() {
    throw new Error('Unimplemented')
  }
  updatePeer() {
    throw new Error('Unimplemented')
  }
  upgradeTool() {
    throw new Error('Unimplemented')
  }
  waterAllPlots() {
    throw new Error('Unimplemented')
  }
  waterField() {
    throw new Error('Unimplemented')
  }
  waterPlot() {
    throw new Error('Unimplemented')
  }
  withdrawCow() {
    throw new Error('Unimplemented')
  }
  constructor(a) {
    super(a)
    const s = Object.getOwnPropertyNames(FarmhandReducers.prototype).filter(
      $ => $ !== 'constructor'
    )
    for (const $ of s) {
      const j = reducers[$]
      this[$] = (..._e) => {
        this.setState(et => j(et, ..._e))
      }
    }
  }
}
const { CLEANUP, HARVEST, MINE, OBSERVE, WATER, PLANT } = fieldMode,
  emptyObject = Object.freeze({}),
  computePlayerInventory = memoize((o, a) =>
    o.map(({ quantity: s, id: $ }) => ({
      quantity: s,
      ...itemsMap[$],
      value: getItemCurrentValue(itemsMap[$], a),
    }))
  ),
  getFieldToolInventory = memoize(o =>
    o
      .filter(({ id: a }) => {
        const { enablesFieldMode: s } = itemsMap[a]
        return typeof s == 'string' && s !== PLANT
      })
      .map(({ id: a }) => itemsMap[a])
  ),
  getPlantableCropInventory = memoize(o =>
    o
      .filter(({ id: a }) => itemsMap[a].isPlantableCrop)
      .map(({ id: a }) => itemsMap[a])
  ),
  applyPriceEvents = (o, a, s) => {
    const $ = { ...o }
    return (
      Object.keys(a).forEach(j => {
        $[j] = 0.5
      }),
      Object.keys(s).forEach(j => {
        $[j] = 1.5
      }),
      $
    )
  }
class Farmhand extends FarmhandReducers {
  constructor(s) {
    super(s)
    Wr(this, 'state', this.createInitialState())
    Wr(this, 'handlers', { ...eventHandlers, debounced: { ...eventHandlers } })
    Wr(this, 'keyMap', {})
    Wr(this, 'keyHandlers', {})
    Wr(this, 'getData', getData)
    Wr(this, 'postData', postData)
    Wr(this, 'handleCowTradeTimeout', () => {
      typeof this.state.cowTradeTimeoutId == 'number' &&
        (this.showNotification(REQUESTED_COW_TRADE_UNAVAILABLE, 'error'),
        this.setState({
          cowTradeTimeoutId: null,
          isAwaitingCowTradeRequest: !1,
        }),
        console.error('Cow trade request timed out'))
    })
    this.initInputHandlers(), (window$1.farmhand = this)
  }
  get viewTitle() {
    return STAGE_TITLE_MAP[this.state.stageFocus]
  }
  get fieldToolInventory() {
    return getFieldToolInventory(this.state.inventory)
  }
  get playerInventory() {
    const { inventory: s, valueAdjustments: $ } = this.state
    return computePlayerInventory(s, $)
  }
  get plantableCropInventory() {
    return getPlantableCropInventory(this.state.inventory)
  }
  get viewList() {
    const { CELLAR: s, COW_PEN: $, HOME: j, WORKSHOP: _e } = stageFocusType,
      et = [...STANDARD_VIEW_LIST]
    return (
      this.state.showHomeScreen && et.unshift(j),
      this.state.purchasedCowPen && et.push($),
      et.push(_e),
      this.state.purchasedCellar && et.push(s),
      et
    )
  }
  get levelEntitlements() {
    return getLevelEntitlements(levelAchieved(this.state.experience))
  }
  get shopInventory() {
    return getAvailableShopInventory(this.levelEntitlements)
  }
  get peerMetadata() {
    return getPeerMetadata(this.state)
  }
  get isInputBlocked() {
    return (
      this.state.isAwaitingNetworkRequest ||
      this.state.isAwaitingCowTradeRequest ||
      this.state.isWaitingForDayToCompleteIncrementing
    )
  }
  get isChatAvailable() {
    const { isOnline: s, room: $ } = this.state
    return s && $ !== DEFAULT_ROOM
  }
  get isForestUnlocked() {
    return this.levelEntitlements.stageFocusType[stageFocusType.FOREST]
  }
  createInitialState() {
    return {
      activePlayers: null,
      allowCustomPeerCowNames: !1,
      cellarInventory: [],
      currentDialogView: dialogView.NONE,
      completedAchievements: {},
      cowForSale: generateCow(),
      cowBreedingPen: { cowId1: null, cowId2: null, daysUntilBirth: -1 },
      cowColorsPurchased: {},
      cowIdOfferedForTrade: '',
      cowInventory: [],
      cowsSold: {},
      cowsTraded: 0,
      cowTradeTimeoutId: -1,
      cropsHarvested: {},
      dayCount: 0,
      experience: 0,
      farmName: 'Unnamed',
      field: createNewField(),
      fieldMode: OBSERVE,
      forest: createNewForest(),
      getCowAccept: noop$2,
      getCowReject: noop$2,
      getCowTradeRequest: noop$2,
      getPeerMetadata: noop$2,
      hasBooted: !1,
      heartbeatTimeoutId: null,
      historicalDailyLosses: [],
      historicalDailyRevenue: [],
      historicalValueAdjustments: [],
      hoveredPlotRangeSize: 0,
      id: uuid_1.v4(),
      inventory: [{ id: scarecrow$1.id, quantity: 0 }],
      inventoryLimit: INITIAL_STORAGE_LIMIT,
      isAwaitingCowTradeRequest: !1,
      isAwaitingNetworkRequest: !1,
      isCombineEnabled: !1,
      isMenuOpen: !doesMenuObstructStage(),
      itemsSold: {},
      cellarItemsSold: {},
      isChatOpen: !1,
      isDialogViewOpen: !1,
      isOnline: this.props.match.path.startsWith('/online'),
      isWaitingForDayToCompleteIncrementing: !1,
      learnedRecipes: {},
      loanBalance: STANDARD_LOAN_AMOUNT,
      loansTakenOut: 1,
      money: STANDARD_LOAN_AMOUNT,
      latestNotification: null,
      newDayNotifications: [],
      notificationLog: [],
      peers: {},
      peerRoom: null,
      pendingPeerMessages: [],
      latestPeerMessages: [],
      sendPeerMetadata: null,
      selectedCowId: '',
      selectedItemId: '',
      priceCrashes: {},
      priceSurges: {},
      profitabilityStreak: 0,
      record7dayProfitAverage: 0,
      recordProfitabilityStreak: 0,
      recordSingleDayProfit: 0,
      revenue: 0,
      redirect: '',
      room: decodeURIComponent(this.props.match.params.room || DEFAULT_ROOM),
      sendCowAccept: noop$2,
      sendCowReject: noop$2,
      purchasedCombine: 0,
      purchasedComposter: 0,
      purchasedCowPen: 1,
      purchasedCellar: 0,
      purchasedField: 0,
      purchasedForest: 0,
      purchasedSmelter: 0,
      sendCowTradeRequest: noop$2,
      showHomeScreen: !0,
      showNotifications: !0,
      stageFocus: stageFocusType.HOME,
      todaysNotifications: [],
      todaysLosses: 0,
      todaysPurchases: {},
      todaysRevenue: 0,
      todaysStartingInventory: {},
      toolLevels: {
        [toolType.HOE]: toolLevel.DEFAULT,
        [toolType.SCYTHE]: toolLevel.DEFAULT,
        [toolType.SHOVEL]: toolLevel.UNAVAILABLE,
        [toolType.WATERING_CAN]: toolLevel.DEFAULT,
      },
      useAlternateEndDayButtonPosition: !1,
      valueAdjustments: {},
      version: '1.18.26',
    }
  }
  async initializeNewGame() {
    await this.incrementDay(!0),
      this.setState(() => ({ historicalValueAdjustments: [] })),
      this.showNotification(LOAN_INCREASED`${STANDARD_LOAN_AMOUNT}`, 'info')
  }
  initInputHandlers() {
    Object.keys(eventHandlers).forEach($ => {
      ;(this.handlers[$] = eventHandlers[$].bind(this)),
        (this.handlers.debounced[$] = debounce$2(this.handlers[$], 50))
    }),
      (this.keyMap = {
        incrementDay: 'shift+c',
        nextView: 'right',
        openAccounting: 'b',
        openAchievements: 'a',
        openLog: 'l',
        openPriceEvents: 'e',
        openStats: 's',
        openSettings: ',',
        openKeybindings: 'shift+?',
        previousView: 'left',
        toggleMenu: 'm',
      }),
      (this.keyHandlers = {
        incrementDay: () => this.incrementDay(),
        nextView: this.focusNextView.bind(this),
        openAccounting: () => this.openDialogView(dialogView.ACCOUNTING),
        openAchievements: () => this.openDialogView(dialogView.ACHIEVEMENTS),
        openLog: () => this.openDialogView(dialogView.FARMERS_LOG),
        openPriceEvents: () => this.openDialogView(dialogView.PRICE_EVENTS),
        openStats: () => this.openDialogView(dialogView.STATS),
        openSettings: () => this.openDialogView(dialogView.SETTINGS),
        openKeybindings: () => this.openDialogView(dialogView.KEYBINDINGS),
        previousView: this.focusPreviousView.bind(this),
        selectHoe: () => this.handlers.handleFieldModeSelect(CLEANUP),
        selectScythe: () => this.handlers.handleFieldModeSelect(HARVEST),
        selectWateringCan: () => this.handlers.handleFieldModeSelect(WATER),
        selectShovel: () => {
          this.state.toolLevels[toolType.SHOVEL] !== toolLevel.UNAVAILABLE &&
            this.handlers.handleFieldModeSelect(MINE)
        },
        toggleMenu: () => this.handlers.handleMenuToggle(),
      }),
      nullArray(9).forEach(($, j) => {
        const _e = j + 1,
          et = `numberKey${_e}`
        ;(this.keyMap[et] = String(_e)),
          (this.keyHandlers[et] = () => {
            const tt = this.viewList[j]
            typeof tt == 'string' &&
              this.setState({ stageFocus: stageFocusType[tt] })
          })
      }),
      Object.assign(this.keyHandlers, {
        clearPersistedData: () => this.clearPersistedData(),
        waterAllPlots: () => this.waterAllPlots(),
      })
  }
  async componentDidMount() {
    const s = await this.props.localforage.getItem('state')
    if (s) {
      const $ = transformStateDataForImport({
          ...this.createInitialState(),
          ...s,
        }),
        { isCombineEnabled: j, newDayNotifications: _e } = $
      this.setState({ ...$, newDayNotifications: [] }, () => {
        _e.forEach(({ message: et, severity: tt }) => {
          setTimeout(() => this.showNotification(et, tt), 0),
            j && this.forRange(harvestPlot, 1 / 0, 0, 0)
        })
      })
    } else await this.initializeNewGame()
    this.syncToRoom(), this.setState({ hasBooted: !0 })
  }
  componentDidUpdate(s, $) {
    var ft, mt
    const {
      hasBooted: j,
      heartbeatTimeoutId: _e,
      isMenuOpen: et,
      isOnline: tt,
      money: rt,
      peerRoom: nt,
      room: it,
      stageFocus: ot,
    } = this.state
    if (!j) return
    const {
        match: {
          path: at,
          params: { room: st = it },
        },
      } = this.props,
      ut = decodeURIComponent(st),
      ct = at.startsWith('/online')
    ;(ct !== this.state.isOnline || ut !== it) &&
      this.setState(() => ({ isOnline: ct, redirect: '', room: ut })),
      (tt !== $.isOnline || it !== $.room) &&
        (ct && this.syncToRoom(),
        !tt &&
          typeof _e == 'number' &&
          (clearTimeout(_e),
          this.setState({
            activePlayers: null,
            heartbeatTimeoutId: null,
            peerRoom: null,
          }))),
      tt === !1 &&
        $.isOnline === !0 &&
        this.showNotification(DISCONNECTED_FROM_SERVER, 'info')
    const dt = updateAchievements(this.state, $)
    if (
      (dt !== this.state && this.setState(() => dt),
      this.state.stageFocus === stageFocusType.COW_PEN &&
        $.stageFocus !== stageFocusType.COW_PEN &&
        this.setState(() => ({ selectedCowId: '' })),
      ot !== $.stageFocus &&
        et &&
        this.setState(() => ({ isMenuOpen: !doesMenuObstructStage() })),
      rt < $.money &&
        this.setState(({ todaysLosses: vt }) => ({
          todaysLosses: moneyTotal(vt, rt - $.money),
        })),
      nt !== $.peerRoom)
    )
      if (nt) {
        nt.onPeerJoin(jt => {
          this.addPeer(jt)
        }),
          nt.onPeerLeave(jt => {
            this.removePeer(jt)
          })
        const [vt, yt] = nt.makeAction('peerMetadata')
        yt((...jt) => handlePeerMetadataRequest(this, ...jt))
        const [pt, ht] = nt.makeAction('cowTrade')
        ht((...jt) => handleCowTradeRequest(this, ...jt))
        const [At, wt] = nt.makeAction('cowAccept')
        wt((...jt) => handleCowTradeRequestAccept(this, ...jt))
        const [Ct, Dt] = nt.makeAction('cowReject')
        Dt((...jt) => handleCowTradeRequestReject(this, ...jt)),
          this.setState({
            getCowAccept: wt,
            getCowReject: Dt,
            getCowTradeRequest: ht,
            getPeerMetadata: yt,
            pendingPeerMessages: [],
            sendCowAccept: At,
            sendCowReject: Ct,
            sendCowTradeRequest: pt,
            sendPeerMetadata: this.wrapSendPeerMetadata(vt),
          }),
          vt(this.peerMetadata)
      } else
        $.peerRoom.leave(), this.setState({ peers: {}, sendPeerMetadata: null })
    ;[
      'showInventoryFullNotifications',
      'showRecipeLearnedNotifications',
    ].forEach(vt => this[vt]($)),
      (mt = (ft = this.state).sendPeerMetadata) == null ||
        mt.call(ft, this.peerMetadata)
  }
  wrapSendPeerMetadata(s) {
    return throttle$1(
      (...$) => {
        s(...$), this.setState(() => ({ pendingPeerMessages: [] }))
      },
      5e3,
      { trailing: !0 }
    )
  }
  tradeForPeerCow(s) {
    this.setState($ => {
      const {
        cowIdOfferedForTrade: j,
        cowInventory: _e,
        peers: et,
        sendCowTradeRequest: tt,
      } = $
      if (!tt) return null
      const { ownerId: rt } = s,
        [nt] =
          Object.entries(et).find(
            ([, st]) => (st == null ? void 0 : st.id) === rt
          ) ?? []
      if (!nt)
        return (
          console.error(`Owner not found for cow ${JSON.stringify(s)}`), null
        )
      if (_e.find(({ id: st }) => st === s.id))
        return (
          console.error(`Cow ID ${s.id} is already in inventory`),
          showNotification($, COW_ALREADY_OWNED, 'error')
        )
      const ot = _e.find(({ id: st }) => st === j)
      if (!ot) return console.error(`Cow ID ${j} not found`), null
      const at = setTimeout(this.handleCowTradeTimeout, COW_TRADE_TIMEOUT)
      return (
        tt(
          { cowOffered: { ...ot, isUsingHuggingMachine: !1 }, cowRequested: s },
          nt
        ),
        { cowTradeTimeoutId: at, isAwaitingCowTradeRequest: !0 }
      )
    }, noop$2)
  }
  async clearPersistedData() {
    await this.props.localforage.clear(), this.showNotification(DATA_DELETED)
  }
  async syncToRoom() {
    var et
    const {
      isOnline: s,
      priceCrashes: $,
      priceSurges: j,
      room: _e,
    } = this.state
    if (s) {
      this.showNotification(CONNECTING_TO_SERVER, 'info')
      try {
        this.setState({ isAwaitingNetworkRequest: !0, peers: {} }),
          (et = this.state.peerRoom) == null || et.leave()
        const { valueAdjustments: tt } = await getData(
          endpoints.getMarketData,
          { farmId: this.state.id, room: _e }
        )
        this.scheduleHeartbeat(),
          this.setState({
            activePlayers: 1,
            peerRoom: joinRoom(
              {
                appId: '@jeremyckahn/farmhand',
                relayUrls,
                relayRedundancy: 4,
                rtcConfig,
              },
              _e
            ),
            valueAdjustments: applyPriceEvents(tt, $, j),
          }),
          this.showNotification(CONNECTED_TO_ROOM`${_e}`, 'success')
      } catch (tt) {
        this.showNotification(SERVER_ERROR, 'error'),
          console.error(tt),
          this.setState(() => ({ redirect: '/', cowIdOfferedForTrade: '' }))
      }
      this.setState({
        isAwaitingNetworkRequest: !1,
        isAwaitingCowTradeRequest: !1,
      })
    }
  }
  scheduleHeartbeat() {
    const { heartbeatTimeoutId: s } = this.state
    clearTimeout(s ?? -1),
      this.setState(() => ({
        heartbeatTimeoutId: setTimeout(async () => {
          this.setState(({ money: $, activePlayers: j }) => ({
            activePlayers: j,
            money: moneyTotal($, j),
          })),
            this.scheduleHeartbeat()
        }, HEARTBEAT_INTERVAL_PERIOD),
      }))
  }
  showInventoryFullNotifications(s) {
    inventorySpaceRemaining(s) > 0 &&
      inventorySpaceRemaining(this.state) <= 0 &&
      this.showNotification(INVENTORY_FULL_NOTIFICATION, 'warning')
  }
  showRecipeLearnedNotifications({ learnedRecipes: s }) {
    let $ = []
    Object.keys(this.state.learnedRecipes).forEach(j => {
      s.hasOwnProperty(j) || $.push(recipesMap[j])
    }),
      $.length > 1
        ? this.showNotification(RECIPES_LEARNED`${$}`)
        : $.length === 1 && this.showNotification(RECIPE_LEARNED`${$[0]}`)
  }
  persistState(s = {}) {
    return this.props.localforage.setItem(
      'state',
      reduceByPersistedKeys({ ...this.state, ...s })
    )
  }
  async incrementDay(s = !1) {
    const {
        inventory: $,
        isCombineEnabled: j,
        isOnline: _e,
        room: et,
        stageFocus: tt,
        todaysPurchases: rt,
        todaysStartingInventory: nt,
      } = this.state,
      it = computeStateForNextDay(this.state, s),
      ot = []
    let at
    if (_e) {
      try {
        this.setState({ isAwaitingNetworkRequest: !0 })
        const ut = computeMarketPositions(nt, rt, $),
          { valueAdjustments: ct } = await postData(endpoints.postDayResults, {
            positions: ut,
            room: et,
          })
        Object.keys(ut).length &&
          (ot.push({
            message: POSITIONS_POSTED_NOTIFICATION`${'You'}${ut}`,
            severity: 'info',
          }),
          (at = POSITIONS_POSTED_NOTIFICATION`${''}${ut}`)),
          (it.valueAdjustments = applyPriceEvents(
            ct,
            it.priceCrashes,
            it.priceSurges
          ))
      } catch (ut) {
        ot.push({ message: SERVER_ERROR, severity: 'error' }),
          this.setState({ redirect: '/', cowIdOfferedForTrade: '' }),
          console.error(ut)
      }
      this.setState({ isAwaitingNetworkRequest: !1 })
    }
    const st = [...ot, ...it.newDayNotifications]
    this.setState(
      {
        ...it,
        isWaitingForDayToCompleteIncrementing: !0,
        newDayNotifications: [],
        todaysNotifications: [],
      },
      async () => {
        try {
          await this.persistState({ newDayNotifications: st }),
            [...st]
              .concat(
                s ? [] : [{ message: PROGRESS_SAVED_MESSAGE, severity: 'info' }]
              )
              .forEach(({ message: ct, severity: dt }) =>
                this.showNotification(ct, dt)
              ),
            j &&
              (tt === stageFocusType.FIELD && (await sleep(1e3)),
              this.forRange(harvestPlot, 1 / 0, 0, 0))
        } catch (ut) {
          console.error(ut), this.showNotification(JSON.stringify(ut), 'error')
        } finally {
          this.setState(() => ({ isWaitingForDayToCompleteIncrementing: !1 })),
            at && this.messagePeers(at)
        }
      }
    )
  }
  openDialogView(s) {
    this.setState({ currentDialogView: s, isDialogViewOpen: !0 })
  }
  closeDialogView() {
    this.setState({ isDialogViewOpen: !1 })
  }
  focusNextView() {
    var $
    if (
      (($ = document.activeElement) == null
        ? void 0
        : $.getAttribute('role')) === 'tab'
    )
      return
    const { viewList: s } = this
    this.setState(({ stageFocus: j }) => {
      const _e = s.indexOf(j)
      return { stageFocus: s[(_e + 1) % s.length] }
    })
  }
  focusPreviousView() {
    var $
    if (
      (($ = document.activeElement) == null
        ? void 0
        : $.getAttribute('role')) === 'tab'
    )
      return
    const { viewList: s } = this
    this.setState(({ stageFocus: j }) => {
      const _e = s.indexOf(j)
      return { stageFocus: s[_e === 0 ? s.length - 1 : (_e - 1) % s.length] }
    })
  }
  messagePeers(s, $) {
    this.prependPendingPeerMessage(s, $)
  }
  render() {
    const {
        props: { features: s },
        state: { redirect: $ },
        fieldToolInventory: j,
        handlers: _e,
        isChatAvailable: et,
        keyHandlers: tt,
        keyMap: rt,
        levelEntitlements: nt,
        plantableCropInventory: it,
        playerInventory: ot,
        shopInventory: at,
        viewList: st,
        viewTitle: ut,
      } = this,
      ct = this.isInputBlocked,
      dt = {
        ...this.state,
        blockInput: ct,
        features: s,
        fieldToolInventory: j,
        isChatAvailable: et,
        levelEntitlements: nt,
        plantableCropInventory: it,
        playerInventory: ot,
        playerInventoryQuantities: getInventoryQuantities(this.state.inventory),
        shopInventory: at,
        viewList: st,
        viewTitle: ut,
      }
    return jsxRuntimeExports.jsx(index_esExports.GlobalHotKeys, {
      allowChanges: !0,
      keyMap: ct ? emptyObject : rt,
      handlers: ct ? emptyObject : tt,
      children: jsxRuntimeExports.jsx(StyledEngineProvider, {
        injectFirst: !0,
        children: jsxRuntimeExports.jsx(ThemeProvider, {
          theme,
          children: jsxRuntimeExports.jsxs(SnackbarProvider, {
            anchorOrigin: { vertical: 'top', horizontal: 'right' },
            classes: { containerRoot: 'Farmhand notification-container' },
            content: snackbarProviderContentCallback,
            maxSnack: 4,
            children: [
              $ && jsxRuntimeExports.jsx(Redirect, { to: $ }),
              jsxRuntimeExports.jsxs(FarmhandContext.Provider, {
                value: { gameState: dt, handlers: _e },
                children: [
                  jsxRuntimeExports.jsxs('div', {
                    className: classNames(
                      'Farmhand farmhand-root fill',
                      this.state.isMenuOpen ? 'menu-open' : 'menu-closed',
                      {
                        'use-alternate-end-day-button-position': this.state
                          .useAlternateEndDayButtonPosition,
                        'block-input': ct,
                        'has-booted': this.state.hasBooted,
                      }
                    ),
                    children: [
                      jsxRuntimeExports.jsx(UpdateNotifier, {}),
                      jsxRuntimeExports.jsx(Consumer$n, {}),
                      jsxRuntimeExports.jsxs(Drawer, {
                        className: 'sidebar-wrapper',
                        open: dt.isMenuOpen,
                        variant: 'persistent',
                        role: 'complementary',
                        PaperProps: { className: 'sidebar' },
                        children: [
                          jsxRuntimeExports.jsx(Consumer$h, {}),
                          jsxRuntimeExports.jsx(Consumer$c, {}),
                          jsxRuntimeExports.jsx('div', { className: 'spacer' }),
                        ],
                      }),
                      jsxRuntimeExports.jsx(Consumer, {}),
                      jsxRuntimeExports.jsxs('div', {
                        className: 'bottom-controls',
                        children: [
                          jsxRuntimeExports.jsx(MobileStepper, {
                            variant: 'dots',
                            steps: st.length,
                            position: 'static',
                            activeStep: st.indexOf(this.state.stageFocus),
                            className: '',
                            backButton: null,
                            nextButton: null,
                          }),
                          jsxRuntimeExports.jsxs('div', {
                            className: 'fab-buttons buttons',
                            children: [
                              jsxRuntimeExports.jsx(Fab, {
                                'aria-label': 'Previous view',
                                color: 'primary',
                                onClick: () => this.focusPreviousView(),
                                children: jsxRuntimeExports.jsx(
                                  default_1$d,
                                  {}
                                ),
                              }),
                              jsxRuntimeExports.jsx(Fab, {
                                className: classNames('menu-button', {
                                  'is-open': this.state.isMenuOpen,
                                }),
                                color: 'primary',
                                'aria-label': 'Open drawer',
                                onClick: () => _e.handleMenuToggle(),
                                children: jsxRuntimeExports.jsx(
                                  default_1$f,
                                  {}
                                ),
                              }),
                              jsxRuntimeExports.jsx(Fab, {
                                'aria-label': 'Next view',
                                color: 'primary',
                                onClick: () => this.focusNextView(),
                                children: jsxRuntimeExports.jsx(
                                  default_1$c,
                                  {}
                                ),
                              }),
                            ],
                          }),
                        ],
                      }),
                      jsxRuntimeExports.jsx(Tooltip, {
                        placement: 'left',
                        title: jsxRuntimeExports.jsxs(
                          jsxRuntimeExports.Fragment,
                          {
                            children: [
                              jsxRuntimeExports.jsx('p', {
                                children:
                                  'End the day to save your progress and advance the game.',
                              }),
                              jsxRuntimeExports.jsx('p', {
                                children: '(shift + c)',
                              }),
                            ],
                          }
                        ),
                        children: jsxRuntimeExports.jsx(Fab, {
                          'aria-label':
                            'End the day to save your progress and advance the game.',
                          className: 'end-day',
                          color: 'error',
                          onClick: _e.handleClickEndDayButton,
                          sx: { zIndex: Z_INDEX.END_DAY_BUTTON },
                          children: jsxRuntimeExports.jsx(default_1$e, {}),
                        }),
                      }),
                    ],
                  }),
                  et ? jsxRuntimeExports.jsx(ChatRoom, {}) : null,
                  jsxRuntimeExports.jsx(NotificationSystem$1, {}),
                ],
              }),
            ],
          }),
        }),
      }),
    })
  }
}
Wr(Farmhand, 'defaultProps', {
  localforage: localforage.createInstance({
    name: 'farmhand',
    description: 'Persisted game data for Farmhand',
  }),
  features: {},
  match: { path: '', params: {} },
})
Farmhand.propTypes = {
  features: propTypesExports.object,
  history: propTypesExports.object,
  location: propTypesExports.object,
  match: propTypesExports.object.isRequired,
}
const FarmhandRoute = o => jsxRuntimeExports.jsx(Farmhand, { ...o, features })
ReactDOM.render(
  jsxRuntimeExports.jsx(HashRouter, {
    hashType: 'noslash',
    children: jsxRuntimeExports.jsx(Route, {
      path: ['/online/:room', '/online', '/'],
      component: FarmhandRoute,
    }),
  }),
  document.getElementById('root')
)
//# sourceMappingURL=index-BKwLzXBm.js.map
